<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>ğŸ‡§ğŸ‡· Implementando um padrÃ£o de projeto orientado a objetos - </title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme;
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            document.querySelector('html').classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="ch01-00-introduction.html"><strong aria-hidden="true">1.</strong> ğŸ‡§ğŸ‡· IntroduÃ§Ã£o</a></li><li><ol class="section"><li><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> ğŸ‡§ğŸ‡· InstalaÃ§Ã£o</a></li><li><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> ğŸ‡§ğŸ‡· OlÃ¡, Mundo!</a></li></ol></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> ğŸ‡§ğŸ‡· Jogo de AdivinhaÃ§Ã£o</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> ğŸ‡§ğŸ‡· Conceitos Comuns de ProgramaÃ§Ã£o</a></li><li><ol class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> ğŸ‡§ğŸ‡· VariÃ¡veis e Mutabilidade</a></li><li><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> ğŸ‡§ğŸ‡· Tipos de dados</a></li><li><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> ğŸ‡§ğŸ‡· FunÃ§Ãµes</a></li><li><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> ğŸ‡§ğŸ‡· ComentÃ¡rios</a></li><li><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> ğŸ‡§ğŸ‡· Controle de fluxo</a></li></ol></li><li><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> ğŸ‡§ğŸ‡· Entendendo Ownership</a></li><li><ol class="section"><li><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> ğŸ‡§ğŸ‡· O Que Ã‰ Ownership?</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> ğŸ‡§ğŸ‡· ReferÃªncias e Borrowing</a></li><li><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> ğŸ‡§ğŸ‡· Slices</a></li></ol></li><li><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> ğŸ‡§ğŸ‡· Structs</a></li><li><ol class="section"><li><a href="ch05-01-method-syntax.html"><strong aria-hidden="true">5.1.</strong> Method Syntax</a></li></ol></li><li><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> ğŸ‡§ğŸ‡· Enums e Casamento de PadrÃµes</a></li><li><ol class="section"><li><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> ğŸ‡§ğŸ‡· Definindo uma Enum</a></li><li><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> ğŸ‡§ğŸ‡· Operador match</a></li><li><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> ğŸ‡§ğŸ‡· Controle de Fluxo Conciso com if let</a></li></ol></li><li><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> ğŸ‡§ğŸ‡· MÃ³dulos</a></li><li><ol class="section"><li><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> ğŸ‡§ğŸ‡· mod e o Sistema de Arquivos</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> ğŸ‡§ğŸ‡· Controlando a Visibilidade com pub</a></li><li><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> ğŸ‡§ğŸ‡· Importando nomes com use</a></li></ol></li><li><a href="ch08-00-fundamental-collections.html"><strong aria-hidden="true">8.</strong> Fundamental Collections</a></li><li><ol class="section"><li><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> ğŸ‡§ğŸ‡· Vetores</a></li><li><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> ğŸ‡§ğŸ‡· Strings</a></li><li><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> ğŸ‡§ğŸ‡· Hash Maps</a></li></ol></li><li><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> ğŸ‡§ğŸ‡· Tratamento de Erros</a></li><li><ol class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> ğŸ‡§ğŸ‡· Erros IrrecuperÃ¡veis com panic!</a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> ğŸ‡§ğŸ‡· Erros recuperÃ¡veis com Result</a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> ğŸ‡§ğŸ‡· Entrar em panic! ou NÃ£o Entrar em panic!</a></li></ol></li><li><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> ğŸ‡§ğŸ‡· Tipos GenÃ©ricos, Traits, e Tempos de vida (Lifetimes)</a></li><li><ol class="section"><li><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> ğŸ‡§ğŸ‡· Tipos GenÃ©ricos de Dados</a></li><li><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> ğŸ‡§ğŸ‡· Traits: Definindo Comportamento Compartilhado</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> ğŸ‡§ğŸ‡· Validating References with Lifetimes</a></li></ol></li><li><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Writing tests</a></li><li><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Running tests</a></li><li><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project</a></li><li><ol class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Improving Error Handling and Modularity</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Testing the Library's Functionality</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing to stderr instead of stdout</a></li></ol></li><li><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features in Rust</a></li><li><ol class="section"><li><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures</a></li><li><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Iterators</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving our I/O Project</a></li><li><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performance</a></li></ol></li><li><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Release Profiles</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> ğŸ‡§ğŸ‡· Ponteiros Inteligentes (Smart Pointers)</a></li><li><ol class="section"><li><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> ğŸ‡§ğŸ‡· Box<T> Aponta para Dados no Heap e Tem Tamanho Conhecido</a></li><li><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> ğŸ‡§ğŸ‡· Tratando Ponteiros Inteligentes como ReferÃªncias Normais com a Trait Deref</a></li><li><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> ğŸ‡§ğŸ‡· A Trait Drop Roda CÃ³digo durante a Limpeza</a></li><li><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> ğŸ‡§ğŸ‡· Rc<T>, o Ponteiro Inteligente com Contagem de ReferÃªncias</a></li><li><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> ğŸ‡§ğŸ‡· RefCell<T> e a Pattern de Mutabilidade Interior</a></li><li><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> ğŸ‡§ğŸ‡· Ciclos de ReferÃªncias Podem Vazar MemÃ³ria</a></li></ol></li><li><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrency</a></li><li><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> ğŸ‡§ğŸ‡· Rust Ã© uma linguagem orientada a objetos?</a></li><li><ol class="section"><li><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> ğŸ‡§ğŸ‡· O que significa orientado a objetos?</a></li><li><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> ğŸ‡§ğŸ‡· Usando objetos trait que permitem valores de tipos diferentes</a></li><li><a href="ch17-03-oo-design-patterns.html" class="active"><strong aria-hidden="true">17.3.</strong> ğŸ‡§ğŸ‡· Implementando um padrÃ£o de projeto orientado a objetos</a></li></ol></li><li><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns</a></li><li><a href="ch19-00-more-lifetimes.html"><strong aria-hidden="true">19.</strong> More Lifetimes</a></li><li><a href="ch20-00-advanced-types.html"><strong aria-hidden="true">20.</strong> Advanced Type System Features</a></li><li><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> Keywords</a></li><li><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> Operators</a></li><li><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> Derivable Traits</a></li><li><a href="appendix-04-nightly-rust.html"><strong aria-hidden="true">21.4.</strong> Nightly Rust</a></li><li><a href="appendix-05-macros.html"><strong aria-hidden="true">21.5.</strong> Macros</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="submenu">
                                <li><button class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li><button class="theme" id="rust">Rust</button></li>
                                <li><button class="theme" id="coal">Coal</button></li>
                                <li><button class="theme" id="navy">Navy</button></li>
                                <li><button class="theme" id="ayu">Ayu</button></li>
                            </ul>
                        </div>

                        <h1 class="menu-title"></h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="ch17-03-oo-design-patterns.html#implementando-um-padrÃ£o-de-projeto-orientado-a-objetos" id="implementando-um-padrÃ£o-de-projeto-orientado-a-objetos"><h2>Implementando um padrÃ£o de projeto orientado a objetos</h2></a>
<p>O <em>padrÃ£o de estado</em> Ã© um padrÃ£o de projeto orientado a objetos. O ponto crucial do padrÃ£o
Ã© que um valor tem algun estado interno, que Ã© representado por um conjunto
de <em>objetos de estado</em> e o comportamento do valor Ã© alterado com base no estado
interno. Os objetos de estado compartilham funcionalidade: em Rust, Ã© claro, usamos
estruturas e traits em vez de de objetos e heranÃ§a. Cada objeto de estado Ã©
responsÃ¡vel por seu prÃ³prio comportamento e por administrar quando dev mudar para outro
estado. O valor que contÃ©m um objeto de estado nÃ£o sabe nada sobre o
comportamento diferente dos estados ou quando fazer transiÃ§Ã£o entre os estados.</p>
<p>Usando o padrÃ£o de estados significa que quando os requisitos do negÃ³cio do programa
mudam, nÃ£o precisamos mudar o cÃ³digo do valor que detÃ©m o estado ou o
cÃ³digo que usa o valor. Precisamos apenas atualizar o cÃ³digo dentro de um dos
objetos de estados para mudar suas regras ou talvez adicionar mais objetos de estados. Vamos ver
um exemplo de padrÃ£o de projeto de estados e como usÃ¡-lo no Rust.</p>
<p>Implementaremos um fluxo de trabalho de postagens de maneira incremental. A funcionalidade
final do blog serÃ¡ assim:</p>
<ol>
<li>Uma postagem no blog comeÃ§a como um rascunho vazio.</li>
<li>Quando o rascunho Ã© concluÃ­do, Ã© necessÃ¡ria uma revisÃ£o da postagem.</li>
<li>Quando a postagem Ã© aprovada, ela Ã© aprovada.</li>
<li>Apenas postagens de blog publicadas retornam conteÃºdo para impressÃ£o, portanto, postagens nÃ£o aprovadas nÃ£o podem ser
publicadas por acidente.</li>
</ol>
<p>Quaisquer outras tentativas de mudanÃ§a em uma postagem nÃ£o deve ter efeito. Por exemplo, se
tentarmos aprovar um rascunho de postagem no blog antes de solicitarmos uma revisÃ£o, a postagem
a postagem deve permanecer em rascunho nÃ£o publicado.</p>
<p>Listagem 17-11 mostra esse fluxo de trabalho em forma de cÃ³digo: este Ã© um exemplo de uso de
API que implementaremos em um biblioteca crate chamada <code>blog</code>. Isso ainda nÃ£o foi compilado,
porque nÃ£o tempos implementado o crate <code>blog</code>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate blog;
use blog::Postagem;

fn main() {
    let mut post = Postagem::new();

    post.add_texto(&quot;Eu comi uma salada no almoÃ§o de hoje&quot;);
    assert_eq!(&quot;&quot;, post.conteudo());

    post.solicitar_revisao();
    assert_eq!(&quot;&quot;, post.conteudo());

    post.aprovar();
    assert_eq!(&quot;Eu comi uma salada no almoÃ§o de hoje&quot;, post.conteudo());
}
</code></pre>
<p><span class="caption">Listagem 17-11: CÃ³digo que demonstra o desejado
comportamento que queremos que o nosso crate<code>blog</code> tenha</span></p>
<p>Queremos permitir que o usuÃ¡rio crie uma nova postagem de blog com <code>Postagem :: new</code>.
EntÃ£o, queremos permitir que o texto seja adicionado Ã  postagem do blog enquanto ela estiver no estado de
rascunho. Se tentarmos obter o conteÃºdo da postagem imediatamente, antes da aprovaÃ§Ã£o,
nada deve acontecer porque a postagem ainda Ã© um rascunho. Adicionamos
<code>assert_eq!</code> no cÃ³digo para fins de demonstraÃ§Ã£o. Um excelente teste unitÃ¡rio para
isso seria afirmar que uma postagem do blog em rascunho retorna uma string vazia do mÃ©todo
<code>conteudo</code>, mas nÃ£o vamos escrever testes para este exemplo.</p>
<p>Em seguida, queremos possibilitar uma solicitaÃ§Ã£o de revisÃ£o para a postagem e queremos que o
<code>conteudo</code> retorne uma string vazia enquanto aguarda a revisÃ£o. Quand a postagem
for aprovada, deve ser publicada, significa que o texto da postagem
serÃ¡ retornada quando o <code>conteudo</code> for chamado.</p>
<p>Observe que o Ãºnico tipo com o qual estamos interagindo, do crate, Ã© o
tipo <code>Postagem</code>. Esse tipo usarÃ¡ padrÃ£o de estados e terÃ¡ um valor que serÃ¡
um dos trÃªs estados de objeto, representam os vÃ¡rios estados em que uma postagem pode estar
em - rascunho, esperando por revisÃ£o ou publicada. Mudar de um estado para outro serÃ¡
gerenciado internamente com o tipo <code>Postagem</code>. Os estados mudam em
resposta aos mÃ©todos chamados pelos usuÃ¡rios da bibliotÃ©ca sobre a instÃ¢ncia <code>Postagem</code>,
mas eles nÃ£o precisam gerenciar as alteraÃ§Ãµes de estados diretamente. AlÃ©m disso, usuÃ¡rios nÃ£o podem
cometer erros nos estados, como publicar uma postagem antes de revisÃ¡-la.</p>
<a class="header" href="ch17-03-oo-design-patterns.html#definindo-postagem-e-criando-uma-nova-instÃ¢ncia-no-estado-de-rascunho" id="definindo-postagem-e-criando-uma-nova-instÃ¢ncia-no-estado-de-rascunho"><h3>Definindo <code>Postagem</code> e criando uma nova instÃ¢ncia no estado de rascunho</h3></a>
<p>Vamos comeÃ§ar a implementaÃ§Ã£o da biblioteca! Sabemos que precisamos da
estrutura pÃºblica <code>Postagem</code> que contenha algum conteÃºdo, por isso comeÃ§aremos com a
definiÃ§Ã£o da estrutura e a funÃ§Ã£o pÃºblica <code>new</code> associada para criar uma
instÃ¢ncia de <code>Postagem</code>, como mostra a Listageá¸¿ 17-12. TambÃ©m faremos um trait privado
<code>Estado</code>. EntÃ£o o <code>Postagem</code> conterÃ¡ um objeto trait <code>Box&lt;Estado&gt;</code> dentro de um
<code>Opcao</code> em um campo privado, chamado <code>estado</code>. VocÃª verÃ¡ porquÃª o <code>Opcao</code>
Ã© necessÃ¡rio.</p>
<p>O trait <code>Estado</code> define o comportamento compartilhado por diferentes estados de postagem e os
estados <code>Rascunho</code>, <code>RevisaoPendente</code> e <code>Publicado</code> implementarÃ£o todos os
trait <code>Estado</code>. Por equanto, o trait nÃ£o tem nenhum mÃ©todo; e comeÃ§aremos definindo
apenas o estado <code>Rascunho</code>, porque esse Ã© o estado em que queremos uma postagem inicialmente:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Postagem {
    estado: Opcao&lt;Box&lt;Estado&gt;&gt;,
    conteudo: String,
}

impl Postagem {
    pub fn new() -&gt; Postagem {
        Postagem {
            estado: Some(Box::new(Rascunho {})),
            conteudo: String::new(),
        }
    }
}

trait Estado {}

struct Rascunho {}

impl Estado for Rascunho {}
#}</code></pre></pre>
<p><span class="caption">Listagem 17-12: DefiniÃ§Ã£o da estrutura <code>Postagem</code> e a funÃ§Ã£o <code>new</code>,
que cria uma nova instÃ¢ncia de <code>Postagem</code>, um trait <code>Estado</code> e uma
estrutura <code>Rascunho</code></span></p>
<p>Quando criamos um novo <code>Postagem</code>, definimos seu campo <code>estado</code> como um valor <code>Some</code>, que
conterÃ¡ um <code>Box</code>. Este <code>Box</code> aponta para uma nova instÃ¢ncia da estrutura <code>Rascunho</code>. Isso
garante que sempre criamos uma nova instÃ¢ncia de <code>Postagem</code>, ela comeÃ§arÃ¡ como um
rascunho. Como o campo <code>estado</code> do <code>Postagem</code> Ã© privado, nÃ£o hÃ¡ como
criar um <code>Postagem</code> em qualquer outro estado!</p>
<a class="header" href="ch17-03-oo-design-patterns.html#armazenando-o-texto-do-conteÃºdo-do-post" id="armazenando-o-texto-do-conteÃºdo-do-post"><h3>Armazenando o texto do conteÃºdo do post</h3></a>
<p>Na funÃ§Ã£o <code>Postagem::new</code>, definimos o campo <code>conteudo</code> como uma novo
<code>String</code> vazia. Listagem 17-11 mostrou que queremos poder chamar o mÃ©todo chamado
<code>add_texto</code> e passar um <code>&amp;str</code> que Ã© entÃ£o adicionado ao conteÃºdo do texto da
postagem do blog. Implementamos isso como uma mÃ©todo, em vez de expor o campo <code>conteudo</code>
como <code>pub</code>. Isso significa que podemos implementar um mÃ©todo posteriormente que controlarÃ¡
como os dados do campo <code>conteudo</code> sÃ£o lidos. O mÃ©todo <code>add_texto</code> Ã© bastante direto,
entÃ£o vamos adicionar a implementaÃ§Ã£o na Listagem 17-13 ao bloco
<code>impl Postagem</code>:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Postagem {
#     conteudo: String,
# }
#
impl Postagem {
    // --recorte--
    pub fn add_texto(&amp;mut self, text: &amp;str) {
        self.conteudo.push_str(text);
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 17-13: Implementando o mÃ©todo <code>add_texto</code> para adicionar o
texto ao <code>conteudo</code> da postagem</span></p>
<p>O mÃ©todo <code>add_texto</code> usa uma referÃªncia mutÃ¡vel ao <code>self</code>, porque estamos
mudando a instÃ¢ncia <code>Postagem</code> que estamos chamando a partir de<code>add_texto</code>. EntÃ£o chamamos
<code>push_str</code> na <code>String</code> em <code>conteudo</code> e passamos o argumento <code>text</code> para adicionar ao <code>conteudo</code>
salvo. Esse comportamento nÃ£o depende do estado em que a postagem estÃ¡,
portanto, nÃ£o faz parte do padrÃ£o de estados. O mÃ©todo <code>add_texto</code> nÃ£o interage
com o campo <code>estado</code>, mas faz parte do comportamento que queremos
suportar.</p>
<a class="header" href="ch17-03-oo-design-patterns.html#garantindo-que-o-conteÃºdo-de-um-rascunho-de-postagem-esteja-vazio" id="garantindo-que-o-conteÃºdo-de-um-rascunho-de-postagem-esteja-vazio"><h3>Garantindo que o conteÃºdo de um rascunho de postagem esteja vazio</h3></a>
<p>Mesmo depois que chamamos <code>add_texto</code> e adicionamos algum conteÃºdo para nossa postagem, ainda
queremos que o mÃ©todo <code>conteudo</code> retorne um pedaÃ§o de string vazia, porque a postagem ainda
estÃ¡ no estÃ¡ de rascunho, como mostrado na linha 8 da Listagem 17-11. Por hora, vamos
implementar o mÃ©todo <code>conteudo</code> com a coisa mais simples que atenderÃ¡ a esse
requisito: sempre retornando um pedaÃ§o de string vazia. Mudaremos isso mais tarde,
quando implementaremos a possibilidade de mudar o estado de uma postagem para que ela possa ser publicada.
AtÃ© agora, postagens apenas podem estar no estado de rascunho, portanto, o conteÃºdo da publicaÃ§Ã£o deve estar
vazio. Listagem 17-14 mostra essa implementaÃ§Ã£o substituta:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Postagem {
#     conteudo: String,
# }
#
impl Postagem {
    // --recorte--
    pub fn conteudo(&amp;self) -&gt; &amp;str {
        &quot;&quot;
    }
}
#}</code></pre></pre>
<p><span class="caption">LIstagem 17-14: Adicionando temporÃ¡ria para
o mÃ©todo <code>conteudo</code> do <code>Postagem</code> que sempre retorna uma string vazia</span></p>
<p>Como o mÃ©todo <code>conteudo</code> adicionado, tudo na Listagem 17-11 atÃ© a linha 8
funciona como prentendido.</p>
<a class="header" href="ch17-03-oo-design-patterns.html#solicitando-uma-revisÃ£o-da-postagem-que-altera-seu-estado" id="solicitando-uma-revisÃ£o-da-postagem-que-altera-seu-estado"><h3>Solicitando uma revisÃ£o da postagem que altera seu estado</h3></a>
<p>Em seguida, nÃ³s precisamos adicionar funcionalidade para solicitar uma revisÃ£o da postagem, que deve
mudar seu estado de <code>Rascunho</code> para <code>RevisaoPendente</code>. Listagem 17-15 mostra este cÃ³digo:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Postagem {
#     estado: Opcao&lt;Box&lt;Estado&gt;&gt;,
#     conteudo: String,
# }
#
impl Postagem {
    // --recorte--
    pub fn solicitar_revisao(&amp;mut self) {
        if let Some(s) = self.estado.take() {
            self.estado = Some(s.solicitar_revisao())
        }
    }
}

trait Estado {
    fn solicitar_revisao(self: Box&lt;Self&gt;) -&gt; Box&lt;Estado&gt;;
}

struct Rascunho {}

impl Estado for Rascunho {
    fn solicitar_revisao(self: Box&lt;Self&gt;) -&gt; Box&lt;Estado&gt; {
        Box::new(RevisaoPendente {})
    }
}

struct RevisaoPendente {}

impl Estado for RevisaoPendente {
    fn solicitar_revisao(self: Box&lt;Self&gt;) -&gt; Box&lt;Estado&gt; {
        self
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 17-15: Implementando mÃ©todo <code>solicitar_revisao</code> no
<code>Postagem</code> e no trait <code>Estado</code></span></p>
<p>NÃ³s fornecemos ao <code>Postagem</code> um mÃ©todo pÃºblico chamado <code>solicitar_revisao</code> que irÃ¡ tormar uma referÃªncia
mutÃ¡vel para <code>self</code>. Em seguida, chamamos internamente o mÃ©todo <code>solicitar_revisao</code>
do estado atual do <code>Postagem</code> e esse segundo mÃ©todo <code>solicitar_revisao</code> consome o
estado atual e retorna um novo estado.</p>
<p>Adicionamos o mÃ©todo <code>solicitar_revisao</code> para o trait <code>Estado</code>; todos os tipos
que implementam o trait, agora precisarÃ£o implementar o mÃ©todo <code>solicitar_revisao</code>.
Note que em vez de ter <code>self</code>, <code>&amp;self</code> ou <code>&amp;mut self</code> como
primeiro parÃ¢metro do mÃ©todo, temos <code>self: Box&lt;Self&gt;</code>. Essa sintaxe significa que
o mÃ©todo Ã© apenas vÃ¡lido quando chamado em um <code>Box</code> contendo o tipo. Essa sintaxe apropria-se
do <code>Box&lt;Self&gt;</code>, invalidando o antigo estado para que o valor de estado do
<code>Postagem</code> possa se transfor em um novo estado.</p>
<p>Para consumir o antigo estado, o mÃ©todo <code>solicitar_revisao</code> precisa apropriar-se
do valor do estado. Este Ã© o lugar onde o <code>Opcao</code> no campo <code>estado</code> do <code>Postagem</code>:
chamamos o mÃ©todo <code>take</code> para tirar o valor de <code>Some</code> do campo <code>estado</code>
e deixar um <code>None</code> no lugar, porque Rust nÃ£o nos permite ter
campos nÃ£o preenchidos nas estruturas. Isso nos permite mover o valor do <code>estado</code> para fora
do <code>Postagem</code> em vez de pedir emprestado. Em seguida, definiremos o valor do <code>estado</code> da postagem como
resultado da operaÃ§Ã£o.</p>
<p>Precisamos definir o <code>estado</code> como <code>None</code> temporariamente em vez de configurÃ¡-la diretamente
com o cÃ³digo <code>self.estado = self.estado.solicitar_revisao();</code> para obter a posse do
valor de <code>estado</code>. Isso garante que o <code>Postagem</code> nÃ£o pode usar o antigo valor do <code>estado</code> depois
de transformÃ¡-lo em um novo estado.</p>
<p>O mÃ©todo <code>solicitar_revisao</code> no <code>Rascunho</code> precisa retornar uma nova instÃ¢ncia em caixa de
uma nova estrutura <code>RevisaoPendente</code>, que representa o estado quando uma postagem estÃ¡ aguardando
uma revisÃ£o. A estrutura <code>RevisaoPendente</code> tambÃ©m implementa o mÃ©todo <code>solicitar_revisao</code>,
mas nÃ£o faz nenhuma transformaÃ§Ã£o. Em vez disso, ele retorna a si mesmo, porque
quando solicitamos uma revisÃ£o em uma publicaÃ§Ã£o jÃ¡ no estado <code>RevisaoPendente</code>, ele deve
permanecer no estado <code>RevisaoPendente</code>.</p>
<p>Agora podemos comeÃ§ar a ver as vantagens do padrÃ§ao de estados: o mÃ©todo
<code>solicitar_revisao</code> no <code>Postagem</code> Ã© o mesmo, nÃ£o importa seu valor <code>estado</code>. Cada
estado Ã© responsÃ¡vel por suas prÃ³prias regras.</p>
<p>Deixaremos o mÃ©todo <code>conteudo</code> do <code>Postagem</code> como estÃ¡, retornando uma string
vazia. Agora podemos ter um <code>Postagem</code> no estado <code>RevisaoPendente</code>, bem como no estado
<code>Rascunho</code>, mas queremos o mesmo comportamento no estado <code>RevisaoPendente</code>.
Listagem 17-11 agora funciona atÃ© a linha 11!</p>
<a class="header" href="ch17-03-oo-design-patterns.html#adicionando-o-mÃ©todo-aprovar-que-muda-o-coportamento-do-conteudo" id="adicionando-o-mÃ©todo-aprovar-que-muda-o-coportamento-do-conteudo"><h3>Adicionando o mÃ©todo <code>aprovar</code> que muda o coportamento do <code>conteudo</code></h3></a>
<p>O mÃ©todo <code>aprovar</code> serÃ¡ semelhante ao mÃ©todo <code>solicitar_revisao</code>: ele
definirÃ¡ <code>estado</code> com um valor que o estado atual diz que deve ter quando esse
estado Ã© aprovado, como mostra a Listagem 17-16:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Postagem {
#     estado: Opcao&lt;Box&lt;Estado&gt;&gt;,
#     conteudo: String,
# }
#
impl Postagem {
    // --recorte--
    pub fn aprovar(&amp;mut self) {
        if let Some(s) = self.estado.take() {
            self.estado = Some(s.aprovar())
        }
    }
}

trait Estado {
    fn solicitar_revisao(self: Box&lt;Self&gt;) -&gt; Box&lt;Estado&gt;;
    fn aprovar(self: Box&lt;Self&gt;) -&gt; Box&lt;Estado&gt;;
}

struct Rascunho {}

impl Estado for Rascunho {
#     fn solicitar_revisao(self: Box&lt;Self&gt;) -&gt; Box&lt;Estado&gt; {
#         Box::new(RevisaoPendente {})
#     }
#
    // --recorte--
    fn aprovar(self: Box&lt;Self&gt;) -&gt; Box&lt;Estado&gt; {
        self
    }
}

struct RevisaoPendente {}

impl Estado for RevisaoPendente {
#     fn solicitar_revisao(self: Box&lt;Self&gt;) -&gt; Box&lt;Estado&gt; {
#         self
#     }
#
    // --recorte--
    fn aprovar(self: Box&lt;Self&gt;) -&gt; Box&lt;Estado&gt; {
        Box::new(Publicado {})
    }
}

struct Publicado {}

impl Estado for Publicado {
    fn solicitar_revisao(self: Box&lt;Self&gt;) -&gt; Box&lt;Estado&gt; {
        self
    }

    fn aprovar(self: Box&lt;Self&gt;) -&gt; Box&lt;Estado&gt; {
        self
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 17-16: Implementando o mÃ©todo <code>aprovar</code> no
<code>Postagem</code> e o trait <code>Estado</code></span></p>
<p>Adicionamos o mÃ©todo <code>aprovar</code> para o trait <code>Estado</code> e adicionamos uma nova estrutura que
implementa <code>Estado</code>, o estado <code>Publicado</code>.</p>
<p>Semelhante ao <code>solicitar_revisao</code>, se chamarmos o mÃ©todo <code>aprovar</code> no <code>Rascunho</code>, ele
nÃ£o terÃ¡ efeito, porque ele retornarÃ¡ <code>self</code>. Quando chamamos <code>aprovar</code> do
<code>RevisaoPendente</code>, ele retorna uma nova instÃ¢ncia em caixa da estrutura <code>Publicado</code>.
A estrutura <code>Publicado</code> implementa o trait <code>Estado</code> e, tanto para
o mÃ©todo <code>solicitar_revisao</code> quanto para o <code>aprovar</code>, ele retorna si prÃ³prio., porque
a postagem deve permanecer no estado <code>Publicado</code> nesses casos.</p>
<p>Agora, precisamos atualizar o mÃ©todo <code>conteudo</code> do <code>Postagem</code>: se o estado for
<code>Publicado</code>, queremos que retorne o valor do campo <code>conteudo</code> da publicaÃ§Ã£o;
caso contrÃ¡rio, queremos que retorne uma string vazia, como mostra a Listagem 17-17:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# trait Estado {
#     fn conteudo&lt;'a&gt;(&amp;self, post: &amp;'a Postagem) -&gt; &amp;'a str;
# }
# pub struct Postagem {
#     estado: Opcao&lt;Box&lt;Estado&gt;&gt;,
#     conteudo: String,
# }
#
impl Postagem {
    // --recorte--
    pub fn conteudo(&amp;self) -&gt; &amp;str {
        self.estado.as_ref().unwrap().conteudo(&amp;self)
    }
    // --recorte--
}
#}</code></pre></pre>
<p><span class="caption">Listagem 17-17: Atualizando o mÃ©todo <code>conteudo</code> do <code>Postagem</code> para
encarregar o mÃ©todo <code>conteudo</code> em <code>Estado</code></span></p>
<p>Porque o objetivo Ã© manter todos essas regras dentro das estruturas que implementam
<code>Estado</code>, chamamos o mÃ©todo <code>conteudo</code>no valor em <code>estado</code> e passamos a instÃ¢ncia
da postagem (que Ã©, <code>self</code>) como um argumento. EntÃ£o retornamos o valor que Ã©
retornado usando o mÃ©todo <code>conteudo</code> do valor do <code>estado</code>.</p>
<p>NÃ³s chamamos o mÃ©todo <code>as__ref</code> do <code>Opcao</code> porque queremos uma referÃªncia ao valor
do <code>Opcao</code> em vez da propriedade do valor. Como <code>estado</code>
Ã© um <code>Opcao&lt;Box&lt;Estado&gt;&gt;</code>, quando chamamos <code>as_ref</code>, um <code>Opcao&lt;Box&lt;Estado&gt;&gt;</code> Ã©
retornado. Se nÃ£o chamarmos <code>as__ref</code>, receberÃ­amos um erro,
porque nÃ£o podemos obter <code>estado</code> emprestado do <code>&amp;self</code> do parÃ¢metro da funÃ§Ã£o.</p>
<p>EntÃ£o chamamos o mÃ©todo <code>unwrap</code>, que sabemos que nunca vai entrar em pÃ¢nico, porque sabemos
que os mÃ©todos em <code>Postagem</code>garantem que o <code>estado</code> sempre conterÃ¡ um valor <code>Some</code>
quando esses mÃ©todos forem realizados. Esse Ã© um dos casos sobre os quais falamos na
seÃ§Ã£o &quot;Casos em que VocÃª Tem Mais InformaÃ§Ã£o Que o Compilador&quot; do CapÃ­tulo
9, quando sabemos que um valor <code>None</code> nunca Ã© possÃ­vel, mesmo que o compilador nÃ£o
consiga ententer isso.</p>
<p>Nesse momento, quando chamamos <code>conteudo</code> no <code>&amp;Box&lt;Estado&gt;</code>, a coerÃ§Ã£o deref terÃ¡
efeito no <code>&amp;</code> e no <code>Nox</code>, entÃ£o finalmente o mÃ©todo
<code>conteudo</code> Ã© chamado no tipo que implementa o trait <code>Estado</code>. Isso significa que precisamos adicionar
<code>conteudo</code> Ã  definiÃ§Ã£o do trait <code>Estado</code> e que Ã© onde colocaremos
a lÃ³gica de qual conteÃºdo retornar, dependendo do estado que temos, como mostra
a Listagem 17-18:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Postagem {
#     conteudo: String
# }
trait Estado {
    // --recorte--
    fn conteudo&lt;'a&gt;(&amp;self, post: &amp;'a Postagem) -&gt; &amp;'a str {
        &quot;&quot;
    }
}

// --recorte--
struct Publicado {}

impl Estado for Publicado {
    // --recorte--
    fn conteudo&lt;'a&gt;(&amp;self, post: &amp;'a Postagem) -&gt; &amp;'a str {
        &amp;post.conteudo
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 17-18: Adicionando o mÃ©todo <code>conteudo</code> ao trait
<code>Estado</code></span></p>
<p>Adicionamos uma implementaÃ§Ã£o padrÃ£o para o mÃ©todo <code>conteudo</code>, que retorna uma
string vazia. Isso significa que nÃ£o preciamos implementar <code>conteudo</code> nas estruturas <code>Rascunho</code> e
<code>RevisaoPendente</code>. A estrutura <code>Publicado</code> irÃ¡ sobrepor o mÃ©todo <code>conteudo</code>
e retornar o valor do <code>post.conteudo</code>.</p>
<p>Observe que precisamos anotaÃ§Ãµes de vida Ãºtil nesse mÃ©todo, como discutimos no
CapÃ­tulo 10. Estamos fazendo uma referÃªncia a um <code>post</code> como argumento e retornando uma
referÃªncia a parte desse <code>post</code>, entÃ£o o tempo de vida Ãºtil da referÃªncia retornada Ã©
relacionada ao tempo de vida Ãºtil do argumento <code>post</code>.</p>
<p>E estamos prontos - tudo da Listagem 17-11 agora funcionam! NÃ³s implementamos o padrÃ£o de estados
com as regras do fluxo de trabalho da postagem no blog. A lÃ³gica relacionada
Ã s regras vive nos objetos de estados, em vez de estar espalhada por todo o <code>Postagem</code>.</p>
<a class="header" href="ch17-03-oo-design-patterns.html#vantagens-e-desvantagens-do-padrÃ£o-de-estados" id="vantagens-e-desvantagens-do-padrÃ£o-de-estados"><h3>Vantagens e desvantagens do padrÃ£o de estados</h3></a>
<p>Mostramos que o Rust Ã© capaz de implementar o padrÃ£o de estado orientaÃ§Ã£o a objetos
para encapsular os diferentes tipos de comportamentos que um post deve ter em
cada estado. Os mÃ©todos do <code>Postagem</code> nÃ£o sabem nada sobre os vÃ¡rios comportamentos. A
maneira como organizamos o cÃ³digo, nÃ³s sÃ³ temos de procurar num sÃ³ lugar pra conhecer as
diferentes formas como uma postagem pode comportar-se: a implementaÃ§Ã£o do trait <code>Estado</code>
na estrutura <code>Publicado</code>.</p>
<p>Se fÃ´ssemos criar uma implementaÃ§Ã£o alternativa que nÃ£o usasse o padrÃ£o
de estados, poderÃ­amos usar instruÃ§Ãµes <code>match</code> nos mÃ©todos do <code>Postagem</code> ou
mesmo no cÃ³digo <code>main</code>, que verifica o estado da postagem e muda o comportamento
nesses locais. Isso significaria que terÃ­amos que procurar em vÃ¡rios lugares para
entender todas as implicaÃ§Ãµes de uma postagem estar no estado publicado! Isso sÃ³
aumentaria o nÃºmero de estados que adicionamos: cada uma dessas instruÃ§Ãµes <code>match</code>
precisaria de outra ramificaÃ§Ã£o.</p>
<p>Com o padrÃ£o de de estados, os mÃ©todos de <code>Postagem</code> e os locais que usam <code>Postagem</code> nÃ£o
precisam da instruÃ§Ã£o <code>match</code> e para adicionar um novo estado, apenas precisamos adicionar uma nova estrutura e
implementar os mÃ©todos trait nessa estrutura.</p>
<p>A implementaÃ§Ã£o usando o padrÃ£o de estados Ã© fÃ¡cil de estender para adicionar mais
funcionalidades. Para ver a simplicidade de manter o cÃ³digo que usa padrÃ£o de
estados, tente usar essas sugestÃµes:</p>
<ul>
<li>Adicionar um mÃ©todo <code>reject</code> que altere o estado de postagem de <code>RevisaoPendente</code> de volta
para <code>Rascunho</code>.</li>
<li>Requer duas chamadas para <code>aprovar</code> antes que o estado possa ser alterado para <code>Publicado</code>.</li>
<li>Permitir que os usuÃ¡rios adicinem conteÃºdo de texto somente quando uma postagem estiver no estado <code>Rascunho</code>.
Dica: Ter o objeto de estado responsÃ¡vel pelo que pode mudar sobre o
conteÃºdo, mas nÃ£o responsÃ¡vel por modificar o <code>Postagem</code>.</li>
</ul>
<p>Uma desvantagem do padrÃ£o de estados Ã© que como os estados implementam as
transiÃ§Ãµes entre estados, alguns dos estados estÃ£o acoplados uns aos outros. Se adicionarmos
outros estados entre <code>RevisaoPendente</code> e <code>Publicado</code>, como um <code>Scheduled</code>,
terÃ­amos que mudar o cÃ³digo de <code>RevisaoPendente</code> para fazer a transiÃ§Ã£o para
<code>Scheduled</code>. Seria menos trabalhoso se <code>RevisaoPendente</code> nÃ£o precisasse de
mudanÃ§as com a adiÃ§Ã£o de um novo estado, mas isso significaria mudar para
outro padrÃ£o de projetos.</p>
<p>Outra desvantagem Ã© que nÃ³s duplicamos algumas lÃ³gicas. Para eleminar parte da
duplicaÃ§Ã£o, podemos tentar fazer a implementaÃ§Ã£o padrÃ£o dos mÃ©todos
<code>solicitar_revisao</code> e <code>aprovar</code> no trait <code>Estado</code>, que retorna <code>self</code>;
no entanto, isso violaria a seguranÃ§a dos objetos, porque o trait nÃ£o sabe
exatamente o que Ã© o <code>self</code> concreto. Queremos que seja possÃ­vel usar <code>Estado</code> como um
objeto trait, entao precisamos que seus mÃ©todos sejam objetos seguros.</p>
<p>Outra duplicaÃ§Ã£o inclui a implementaÃ§Ã£o semelhante dos mÃ©todos <code>solicitar_revisao</code>
e <code>aprovar</code> do <code>Postagem</code>. Ambos os mÃ©todos delegam a implementaÃ§Ã£o do
mesmo mÃ©todo sobre o valor do campo <code>estado</code> do <code>Opcao</code> e definem  o novo
valor do campo <code>estado</code> para o resultado. Se tivÃ©ssemos muitos mÃ©todos no <code>Postagem</code>
que seguissem  esse padrÃ£o, poderÃ­amos considerar a definiÃ§Ã£o de uma macro para eliminar
a repetiÃ§Ã£o (veja o ApÃªndice D, Macros).</p>
<p>Ao implementar o padrÃ£o de estados exatamente como ele Ã© definido para linguagens orientada a objetos,
nÃ£o estamos aproveitando ao mÃ¡ximo os pontos fortes do Rust como
poderÃ­amos. Vamos ver algumas mudanÃ§as que podemos fazer no o crate <code>blog</code>, que pode tornar
estados e transiÃ§Ãµes invÃ¡lidas em erros em tempo de compilaÃ§Ã£o.</p>
<a class="header" href="ch17-03-oo-design-patterns.html#codificando-estados-e-comportamento-como-tipo" id="codificando-estados-e-comportamento-como-tipo"><h3>Codificando estados e comportamento como tipo</h3></a>
<p>Mostraremos como repensar o padrÃ£o de estados para obter um conjunto diferente de
compensaÃ§Ãµes. Em vez de encapsular completamente os estados e transiÃ§Ãµes para que o
cÃ³digo externo nÃ£o tenha conhecimento dele, codificaremos os estados em diferentes
tipos. Consequentemente, o sistema de verificaÃ§Ã£o de tipo do Rust impedirÃ¡ que as tentativas de usar
mensagens de rascunho, em que apenas as postagens publicadas sejam permitidas, emitem um erro do compilador.</p>
<p>Vamos considerar a primeira parte do <code>main</code> na Listagem 17-11:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let mut post = Postagem::new();

    post.add_texto(&quot;Eu comi uma salada no almoÃ§o de hoje&quot;);
    assert_eq!(&quot;&quot;, post.conteudo());
}
</code></pre>
<p>Ainda permitimos a criaÃ§Ã£o de novas postagens no estado de rascunho, usando <code>Postagem::new</code>
e a capacidade de adicionar texto ao conteÃºdo da postagem. Mas em vez de ter um
mÃ©todo <code>conteudo</code> em um rascunho, que retorna uma string vazia, vamos fazer com que as
mensagens de rascunho nÃ£o tenham o mÃ©todo <code>conteudo</code>. Dessa forma, se tentarmos pegar o
conteÃºdo de uma postagem de rascunho, receberemos um erro do compilador informando que o mÃ©todo
nÃ£o existe. Como resultado, serÃ¡ possÃ­vel exibir , acidentalmente,
o conteÃºdo do rascunho em produÃ§Ã£o, porque esse cÃ³digo nem serÃ¡ compilado.
Listagem 17-19 mostra a definiÃ§Ã£o de uma estrutura <code>Postagem</code>, uma estrutura <code>RascunhoPostagem</code> e
mÃ©todos em cada um deles:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Postagem {
    conteudo: String,
}

pub struct RascunhoPostagem {
    conteudo: String,
}

impl Postagem {
    pub fn new() -&gt; RascunhoPostagem {
        RascunhoPostagem {
            conteudo: String::new(),
        }
    }

    pub fn conteudo(&amp;self) -&gt; &amp;str {
        &amp;self.conteudo
    }
}

impl RascunhoPostagem {
    pub fn add_texto(&amp;mut self, text: &amp;str) {
        self.conteudo.push_str(text);
    }
}
#}</code></pre></pre>
<p><span class="caption">Arquivo 17-19: Uma <code>Postagem</code> com um mÃ©todo <code>conteudo</code>e um
<code>RascunhoPostagem</code> sem um mÃ©todo <code>conteudo</code></span></p>
<p>Ambas as estruturas <code>Postagem</code> e <code>RascunhoPostagem</code> tÃªm um campo <code>conteudo</code> privado, que
armazena o texto da postagem do blog. As estruturas nÃ£o tÃªm mais o campo <code>estado</code> porque
estamos movendo a codificaÃ§Ã£o do estado para os tipos de cada estrutura. A estrutura <code>Postagem</code>
representarÃ¡ uma postagem publicada e tem um mÃ©todo <code>conteudo</code> que
retorna o <code>conteudo</code>.</p>
<p>NÃ³s ainta temos uma funÃ§Ã£o <code>Postagem::new</code>, mas ao invÃ©s de retornar uma instÃ¢ncia de
<code>Postagem</code>, ela retorna uma instÃ¢ncia de <code>RascunhoPostagem</code>. Como <code>conteudo</code> Ã© privado
e nÃ£o hÃ¡ nenhuma funÃ§Ã£o que retorne <code>Postagem</code>, nÃ£o Ã© possÃ­vel criar uma
instÃ¢ncia de <code>Postagem</code> agora.</p>
<p>A estrutura <code>RascunhoPostagem</code> tem um mÃ©todo <code>add_texto</code> para que possamos adicionar texto ao <code>conteudo</code>
como antes, mas note que <code>RascunhoPostagem</code> nÃ£o possui um mÃ©todo <code>conteudo</code> definido!
EntÃ£o, agora, o programa garante que todas as postagens iniciem como rascunhos e, rascunho
nÃ£o tÃªm seu conteÃºdo disponÃ­vel para exibiÃ§Ã£o. Qualquer tentativa de contornar essas
restriÃ§Ãµes resultarÃ¡ em um erro de compilador.</p>
<a class="header" href="ch17-03-oo-design-patterns.html#implementando-transaÃ§Ãµes-como-transformaÃ§Ãµes-em-diferentes-tipos" id="implementando-transaÃ§Ãµes-como-transformaÃ§Ãµes-em-diferentes-tipos"><h4>Implementando transaÃ§Ãµes como transformaÃ§Ãµes em diferentes tipos</h4></a>
<p>EntÃ£o, como conseguimos uma publicar uma postagem? Queremos impor a regra de que um
rascunho tenha de ser revisada e aprovada antes dela poder ser publicada. Uma postagem no estado de
revisÃ£o pendente ainda nÃ£o deve exibir nenhum conteÃºdo. Vamos implementar essas restriÃ§Ãµes
adicionando outra estrutura, <code>RevisaoPendentePostagem</code>, definindo o mÃ©todo
<code>solicitar_revisao</code> no <code>RascunhoPostagem</code> para retornar um <code>RevisaoPendentePostagem</code> e
definindo um mÃ©todo <code>aprovar</code> no <code>RevisaoPendentePostagem</code> para retornar um <code>Postagem</code>, como
mostra a Listagem 17-20:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Postagem {
#     conteudo: String,
# }
#
# pub struct RascunhoPostagem {
#     conteudo: String,
# }
#
impl RascunhoPostagem {
    // --recorte--

    pub fn solicitar_revisao(self) -&gt; RevisaoPendentePostagem {
        RevisaoPendentePostagem {
            conteudo: self.conteudo,
        }
    }
}

pub struct RevisaoPendentePostagem {
    conteudo: String,
}

impl RevisaoPendentePostagem {
    pub fn aprovar(self) -&gt; Postagem {
        Postagem {
            conteudo: self.conteudo,
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 17-20: Uma <code>RevisaoPendentePostagem</code> que Ã© criado
chamando <code>solicitar_revisao</code> no <code>RascunhoPostagem</code> e um mÃ©todo <code>aprovar</code> que transforma um
<code>RevisaoPendentePostagem</code> em um <code>Postagem</code> publicado</span></p>
<p>Os mÃ©todos <code>solicitar_revisao</code> e <code>aprovar</code> tomam posso do <code>self</code>, consumindo
as instÃ¢ncias <code>RascunhoPostagem</code> e <code>RevisaoPendentePostagem</code> e transformando-os
em <code>RevisaoPendentePostagem</code> e <code>Postagem</code> publicado respectivamente. Dessa forma,
nÃ£o teremos instÃ¢ncias <code>RascunhoPostagem</code> remanecentes apÃ³s chamarmos
<code>solicitar_revisao</code> e, assim por diante. A estrutura <code>RevisaoPendentePostagem</code> nÃ£o tem um mÃ©todo
<code>conteudo</code> definido dele, portanto, tentar ler seu conteÃºdo
resulta em um erro do compilador. como em <code>RascunhoPostagem</code>. Porque o Ãºnico modo de ter uma
instÃ¢ncia pÃºblica de <code>Postagem</code> que tenha um mÃ©todo <code>conteudo</code> definico Ã© chamar o
mÃ©todo <code>aprovar</code> em <code>RevisaoPendentePostagem</code> e a Ãºnica maneura de obter
<code>RevisaoPendentePostagem</code> Ã© chamar o mÃ©todo <code>solicitar_revisao</code> em <code>RascunhoPostagem</code>,
agora codificamos o fluxo de trabalho da postagem do blog em um sistema de tipos.</p>
<p>Mas tambÃ©m temos que fazer algumas pequenas mudanÃ§as no<code>main</code>. Os mÃ©todos <code>solicitar_revisao</code> e
<code>aprovar</code> retornam novas instÃ¢ncias em vez de modificar a estrutura para qual sÃ£o chamadas,
entÃ£o precisamos adicionar mais <code>let post</code> shadowing para salvar
as instÃ¢ncias retornadas. TambÃ©m nÃ£o temos certeza se o conteÃºdo do rascunho e da
postagem em revisÃ£o Ã© uma string vazia, nem precisamos delas: nÃ£o podemos
compilar cÃ³digo que tente usar o conteÃºdo da postagem nesses estados.
O cÃ³digo atualizado na <code>main</code> Ã© mostradp na Listagem 17-21:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate blog;
use blog::Postagem;

fn main() {
    let mut post = Postagem::new();

    post.add_texto(&quot;Eu comi uma salada no almoÃ§o de hoje&quot;);

    let post = post.solicitar_revisao();

    let post = post.aprovar();

    assert_eq!(&quot;Eu comi uma salada no almoÃ§o de hoje&quot;, post.conteudo());
}
</code></pre>
<p><span class="caption">Listagem 17-21: ModificaÃ§Ãµes na <code>main</code> para usar a nova
implementaÃ§Ã£o do fluxo de trabalho da psotagem no blog</span></p>
<p>As mudanÃ§as que precisamos fazer na <code>main</code>reatribuir <code>post</code>, o que significa que essa
implementaÃ§Ã£o nÃ£o segue mais o padrÃ£o de estados orientado a objetos:
as transformaÃ§Ãµes entre os estados nÃ£o sÃ£o mais encapsuladas inteiramente
dentro da implementaÃ§Ã£o do <code>Postagem</code>. No entanto, nosso ganho Ã© que estados invÃ¡lidos agora
sÃ£o impossÃ­veis por causa do sistema de tipos e a verificaÃ§Ã£o de tipos que acontecem em
tempo de compilaÃ§Ã£o! Isso garante que certos bugs, como o conteÃºdo de uma postagem
nÃ£o publicada sendo exibida, serÃ¡ descoberta antes de chegar em
produÃ§Ã£o.</p>
<p>Experimente as tarefas sugeridas como requisitos adicionais que mencionamos no
inÃ­cion dessa seÃ§Ã£o sobre o crate <code>blog</code> como estÃ¡ apÃ³s a Listagem 17-20 para ver
o que vocÃª acha sobre o design desta versÃ£o do cÃ³digo. Observe que algumas tarefas
podem ser concluÃ­das jÃ¡ neste design!</p>
<p>Vimos que, embora o Rust seja capas de implementar o padrÃ£o de projetos orientado a objetos,
outros padrÃµes, como codificar estados em sistema de tipos,
tambÃ©m estÃ£o disponÃ­veis. Esses padrÃµes tÃªm diferentes vantagens e desvantagens. Apesar
de vocÃª poder estar bastante familiarizado com o padrÃ£o orientado a objetos, repensar
o problema para aproveitar os recursos do Rust pode fornecer benefÃ­cios, como evitar
alguns bugs em tempo de compilaÃ§Ã£o. PadrÃµes orientados a objetos nem sempre serÃ£o a
melhor soluÃ§Ã£o em Rust devido certos recursos, como propriedade, que
as linguagens orientadas a objetos nÃ£o tÃªm.</p>
<a class="header" href="ch17-03-oo-design-patterns.html#resumo" id="resumo"><h2>Resumo</h2></a>
<p>NÃ£o importa se vocÃª acha que Rust Ã© uma linguagem orientada a objetos depois
de ler este capÃ­tulo, vocÃª agora sabe que pode usar objetos trait para obter alguns
recursos orientado a objetos em Rust. O despacho dinÃ¢mico pode dar ao seu cÃ³digo alguma
flexibilidade em troca de um pouco de desempenho em tempo de execuÃ§Ã£o. VocÃª pode usar essa
flexibilidade para implementar padrÃ£o orientado a objetos que podem ajudar na manutenÃ§Ã£o
de seu cÃ³digo. Rust tambÃ©m tem outros recursos, como propriedade, que
linguagens orientadas aobjetos nÃ£o tÃªm. Um padrÃ£o orientado a objetos nem sempre
Ã© a melhor maneira de aproveitar os pontos fortes do Rust, mas Ã© uma opÃ§Ã£o disponÃ­vel.</p>
<p>Em seguida, veremos os padrÃµes, que sÃ£o outros dos recursos que permitem
muita flexibilidade. Veremos brevemente eles ao longo do livro, mas ainda nÃ£o vimos a capacidade total deles. Vamos lÃ¡!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch17-02-trait-objects.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch18-00-patterns.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="ch17-02-trait-objects.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="ch18-00-patterns.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if (getComputedStyle(document.querySelector(".fa")).fontFamily !== "FontAwesome") {
                var link = document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = '_FontAwesome/css/font-awesome.css';
                document.head.insertBefore(link, document.head.firstChild)
            }
        </script>

        

        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
