<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>ğŸ‡§ğŸ‡· Jogo de AdivinhaÃ§Ã£o - </title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme;
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            document.querySelector('html').classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="ch01-00-introduction.html"><strong aria-hidden="true">1.</strong> ğŸ‡§ğŸ‡· IntroduÃ§Ã£o</a></li><li><ol class="section"><li><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> ğŸ‡§ğŸ‡· InstalaÃ§Ã£o</a></li><li><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> ğŸ‡§ğŸ‡· OlÃ¡, Mundo!</a></li></ol></li><li><a href="ch02-00-guessing-game-tutorial.html" class="active"><strong aria-hidden="true">2.</strong> ğŸ‡§ğŸ‡· Jogo de AdivinhaÃ§Ã£o</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> ğŸ‡§ğŸ‡· Conceitos Comuns de ProgramaÃ§Ã£o</a></li><li><ol class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> ğŸ‡§ğŸ‡· VariÃ¡veis e Mutabilidade</a></li><li><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> ğŸ‡§ğŸ‡· Tipos de dados</a></li><li><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> ğŸ‡§ğŸ‡· FunÃ§Ãµes</a></li><li><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> ğŸ‡§ğŸ‡· ComentÃ¡rios</a></li><li><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> ğŸ‡§ğŸ‡· Controle de fluxo</a></li></ol></li><li><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> ğŸ‡§ğŸ‡· Entendendo Ownership</a></li><li><ol class="section"><li><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> ğŸ‡§ğŸ‡· O Que Ã‰ Ownership?</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> ğŸ‡§ğŸ‡· ReferÃªncias e Borrowing</a></li><li><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> ğŸ‡§ğŸ‡· Slices</a></li></ol></li><li><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> ğŸ‡§ğŸ‡· Structs</a></li><li><ol class="section"><li><a href="ch05-01-method-syntax.html"><strong aria-hidden="true">5.1.</strong> Method Syntax</a></li></ol></li><li><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> ğŸ‡§ğŸ‡· Enums e Casamento de PadrÃµes</a></li><li><ol class="section"><li><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> ğŸ‡§ğŸ‡· Definindo uma Enum</a></li><li><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> ğŸ‡§ğŸ‡· Operador match</a></li><li><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> ğŸ‡§ğŸ‡· Controle de Fluxo Conciso com if let</a></li></ol></li><li><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> ğŸ‡§ğŸ‡· MÃ³dulos</a></li><li><ol class="section"><li><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> ğŸ‡§ğŸ‡· mod e o Sistema de Arquivos</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> ğŸ‡§ğŸ‡· Controlando a Visibilidade com pub</a></li><li><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> ğŸ‡§ğŸ‡· Importando nomes com use</a></li></ol></li><li><a href="ch08-00-fundamental-collections.html"><strong aria-hidden="true">8.</strong> Fundamental Collections</a></li><li><ol class="section"><li><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> ğŸ‡§ğŸ‡· Vetores</a></li><li><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> ğŸ‡§ğŸ‡· Strings</a></li><li><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> ğŸ‡§ğŸ‡· Hash Maps</a></li></ol></li><li><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> ğŸ‡§ğŸ‡· Tratamento de Erros</a></li><li><ol class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> ğŸ‡§ğŸ‡· Erros IrrecuperÃ¡veis com panic!</a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> ğŸ‡§ğŸ‡· Erros recuperÃ¡veis com Result</a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> ğŸ‡§ğŸ‡· Entrar em panic! ou NÃ£o Entrar em panic!</a></li></ol></li><li><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> ğŸ‡§ğŸ‡· Tipos GenÃ©ricos, Traits, e Tempos de vida (Lifetimes)</a></li><li><ol class="section"><li><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> ğŸ‡§ğŸ‡· Tipos GenÃ©ricos de Dados</a></li><li><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> ğŸ‡§ğŸ‡· Traits: Definindo Comportamento Compartilhado</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> ğŸ‡§ğŸ‡· Validating References with Lifetimes</a></li></ol></li><li><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Writing tests</a></li><li><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Running tests</a></li><li><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project</a></li><li><ol class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Improving Error Handling and Modularity</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Testing the Library's Functionality</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing to stderr instead of stdout</a></li></ol></li><li><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features in Rust</a></li><li><ol class="section"><li><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures</a></li><li><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Iterators</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving our I/O Project</a></li><li><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performance</a></li></ol></li><li><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Release Profiles</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> ğŸ‡§ğŸ‡· Ponteiros Inteligentes (Smart Pointers)</a></li><li><ol class="section"><li><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> ğŸ‡§ğŸ‡· Box<T> Aponta para Dados no Heap e Tem Tamanho Conhecido</a></li><li><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> ğŸ‡§ğŸ‡· Tratando Ponteiros Inteligentes como ReferÃªncias Normais com a Trait Deref</a></li><li><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> ğŸ‡§ğŸ‡· A Trait Drop Roda CÃ³digo durante a Limpeza</a></li><li><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> ğŸ‡§ğŸ‡· Rc<T>, o Ponteiro Inteligente com Contagem de ReferÃªncias</a></li><li><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> ğŸ‡§ğŸ‡· RefCell<T> e a Pattern de Mutabilidade Interior</a></li><li><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> ğŸ‡§ğŸ‡· Ciclos de ReferÃªncias Podem Vazar MemÃ³ria</a></li></ol></li><li><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrency</a></li><li><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> ğŸ‡§ğŸ‡· Rust Ã© uma linguagem orientada a objetos?</a></li><li><ol class="section"><li><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> ğŸ‡§ğŸ‡· O que significa orientado a objetos?</a></li><li><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> ğŸ‡§ğŸ‡· Usando objetos trait que permitem valores de tipos diferentes</a></li><li><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> ğŸ‡§ğŸ‡· Implementando um padrÃ£o de projeto orientado a objetos</a></li></ol></li><li><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns</a></li><li><a href="ch19-00-more-lifetimes.html"><strong aria-hidden="true">19.</strong> More Lifetimes</a></li><li><a href="ch20-00-advanced-types.html"><strong aria-hidden="true">20.</strong> Advanced Type System Features</a></li><li><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> Keywords</a></li><li><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> Operators</a></li><li><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> Derivable Traits</a></li><li><a href="appendix-04-nightly-rust.html"><strong aria-hidden="true">21.4.</strong> Nightly Rust</a></li><li><a href="appendix-05-macros.html"><strong aria-hidden="true">21.5.</strong> Macros</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="submenu">
                                <li><button class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li><button class="theme" id="rust">Rust</button></li>
                                <li><button class="theme" id="coal">Coal</button></li>
                                <li><button class="theme" id="navy">Navy</button></li>
                                <li><button class="theme" id="ayu">Ayu</button></li>
                            </ul>
                        </div>

                        <h1 class="menu-title"></h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="ch02-00-guessing-game-tutorial.html#jogo-de-adivinhaÃ§Ã£o" id="jogo-de-adivinhaÃ§Ã£o"><h1>Jogo de AdivinhaÃ§Ã£o</h1></a>
<p>Vamos entrar de cabeÃ§a no Rust e colocar a mÃ£o na massa! Este capÃ­tulo vai lhe
apresentar alguns conceitos bem comuns no Rust, mostrando como usÃ¡-los em um
programa de verdade. VocÃª vai aprender sobre <code>let</code>, <code>match</code>, mÃ©todos, funÃ§Ãµes
associadas, crates externos, e mais! Os capÃ­tulos seguintes vÃ£o explorar essas
ideias em mais detalhes. Neste capÃ­tulo, vocÃª vai praticar o bÃ¡sico.</p>
<p>Vamos implementar um clÃ¡ssico problema de programaÃ§Ã£o para iniciantes: um jogo
de adivinhaÃ§Ã£o. Eis como ele funciona: o programa vai gerar um nÃºmero inteiro
aleatÃ³rio entre 1 e 100. EntÃ£o, ele vai pedir ao jogador que digite um palpite.
ApÃ³s darmos nosso palpite, ele vai nos indicar se o palpite Ã© muito baixo ou
muito alto. Uma vez que o palpite estiver correto, ele vai nos dar os parabÃ©ns e
sair.</p>
<a class="header" href="ch02-00-guessing-game-tutorial.html#preparando-um-novo-projeto" id="preparando-um-novo-projeto"><h2>Preparando um Novo Projeto</h2></a>
<p>Para iniciar um novo projeto, vÃ¡ ao seu diretÃ³rio de projetos que vocÃª criou no
CapÃ­tulo 1, e execute os comandos do Cargo a seguir:</p>
<pre><code class="language-text">$ cargo new jogo_de_advinhacao --bin
$ cd jogo_de_advinhacao
</code></pre>
<p>O primeiro comando, <code>cargo new</code>, recebe o nome do projeto (<code>jogo_de_advinhacao</code>)
como primeiro argumento. A flag <code>--bin</code> diz ao Cargo que faÃ§a um projeto
binÃ¡rio, similar ao do CapÃ­tulo 1. O segundo comando muda a pasta atual para o
diretÃ³rio do projeto.</p>
<p>Confira o arquivo <em>Cargo.toml</em> gerado:</p>
<p><span class="filename">Arquivo: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;jogo_de_advinhacao&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Seu Nome &lt;voce@exemplo.com&gt;&quot;]

[dependencies]
</code></pre>
<p>Se as informaÃ§Ãµes sobre o autor, que o Cargo obtÃ©m do seu ambiente, nÃ£o
estiverem corretas, faÃ§a os reparos necessÃ¡rios e salve o arquivo.</p>
<p>Assim como no CapÃ­tulo 1, <code>cargo new</code> gera um programa &quot;Hello, world!&quot; para nÃ³s.
Confira em <em>src/main.rs</em>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Agora vamos compilar esse programa &quot;Hello, world!&quot; e executÃ¡-lo de uma vez sÃ³
usando o comando <code>cargo run</code>:</p>
<pre><code class="language-text">$ cargo run
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50 secs
     Running `target/debug/jogo_de_advinhacao`
Hello, world!
</code></pre>
<p>O comando <code>run</code> Ã© uma boa opÃ§Ã£o quando precisamos iterar rapidamente em um
projeto, que Ã© o caso neste jogo: nÃ³s queremos testar rapidamente cada iteraÃ§Ã£o
antes de movermos para a prÃ³xima.</p>
<p>Abra novamente o arquivo <em>src/main.rs</em>. Escreveremos todo nosso cÃ³digo nele.</p>
<a class="header" href="ch02-00-guessing-game-tutorial.html#processando-um-palpite" id="processando-um-palpite"><h2>Processando um Palpite</h2></a>
<p>A primeira parte do programa vai pedir uma entrada ao usuÃ¡rio, processar essa
entrada, e conferir se ela estÃ¡ no formato esperado. Pra comeÃ§ar, vamos permitir
que o jogador entre com um palpite. Coloque este cÃ³digo no arquivo
<em>src/main.rs</em>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;

fn main() {
    println!(&quot;Advinhe o nÃºmero!&quot;);

    println!(&quot;Digite o seu palpite.&quot;);

    let mut palpite = String::new();

    io::stdin().read_line(&amp;mut palpite)
        .expect(&quot;Falha ao ler entrada&quot;);

    println!(&quot;VocÃª disse: {}&quot;, palpite);
}
</code></pre>
<p><span class="caption">Listagem 2-1: CÃ³digo para ler um palpite do usuÃ¡rio e
imprimÃ­-lo na tela.</span></p>
<p>Esse cÃ³digo tem muita informaÃ§Ã£o, vamos ver uma parte de cada vez. Para obter a
entrada do usuÃ¡rio, e entÃ£o imprimir o resultado como saÃ­da, precisaremos trazer
ao escopo a biblioteca <code>io</code> (de entrada/saÃ­da). A biblioteca <code>io</code> provÃ©m da
biblioteca padrÃ£o (chamada de <code>std</code>):</p>
<pre><code class="language-rust ignore">use std::io;
</code></pre>
<p>Por padrÃ£o, o Rust traz apenas alguns tipos para o escopo de todos os programas
no <a href="../../std/prelude/index.html"><em>prelÃºdio</em></a><!-- ignore -->. Se um tipo que vocÃª quiser usar nÃ£o
estiver no prelÃºdio, vocÃª terÃ¡ que importÃ¡-lo explicitamente atravÃ©s do <code>use</code>.
A biblioteca <code>std::io</code> oferece vÃ¡rias ferramentas de entrada/saÃ­da, incluindo a
funcionalidade de ler dados de entrada do usuÃ¡rio.</p>
<p>Como visto no CapÃ­tulo 1, a funÃ§Ã£o <code>main</code> Ã© o ponto de entrada do programa:</p>
<pre><code class="language-rust ignore">fn main() {
</code></pre>
<p>A sintaxe <code>fn</code> declara uma nova funÃ§Ã£o, o <code>()</code> indica que nÃ£o hÃ¡ parÃ¢metros, e
o <code>{</code> inicia o corpo da funÃ§Ã£o.</p>
<p>Como vocÃª tambÃ©m jÃ¡ aprendeu no CapÃ­tulo 1, <code>println!</code> Ã© uma macro que imprime
uma string na tela:</p>
<pre><code class="language-rust ignore">println!(&quot;Advinhe o nÃºmero!&quot;);

println!(&quot;Digite o seu palpite.&quot;);
</code></pre>
<p>Este cÃ³digo estÃ¡ exibindo uma mensagem que diz de que se trata o jogo e solicita
uma entrada do usuÃ¡rio.</p>
<a class="header" href="ch02-00-guessing-game-tutorial.html#armazenando-valores-em-variÃ¡veis" id="armazenando-valores-em-variÃ¡veis"><h3>Armazenando Valores em VariÃ¡veis</h3></a>
<p>PrÃ³ximo passo, vamos criar um local para armazenar a entrada do usuÃ¡rio:</p>
<pre><code class="language-rust ignore">let mut palpite = String::new();
</code></pre>
<p>Agora o programa estÃ¡ ficando interessante! Tem muita coisa acontecendo nesta
pequena linha. Repare que esta Ã© uma declaraÃ§Ã£o <code>let</code>, que Ã© usada para criar
<em>variÃ¡veis</em>. Segue outro exemplo:</p>
<pre><code class="language-rust ignore">let foo = bar;
</code></pre>
<p>Essa linha cria uma nova variÃ¡vel chamada <code>foo</code>, e a vincula ao valor <code>bar</code>. Em
Rust, variÃ¡veis sÃ£o imutÃ¡veis por padrÃ£o. O exemplo a seguir mostra como usar
<code>mut</code> antes do nome da variÃ¡vel para tornÃ¡-la mutÃ¡vel:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let foo = 5; // imutÃ¡vel
let mut bar = 5; // mutÃ¡vel
#}</code></pre></pre>
<blockquote>
<p>Nota: A sintaxe <code>//</code> inicia um comentÃ¡rio, que continua atÃ© o fim da linha.
Rust ignora tudo o que estiver nos comentÃ¡rios.</p>
</blockquote>
<p>Agora vocÃª sabe que <code>let mut palpite</code> vai introduzir uma variÃ¡vel mutÃ¡vel de
nome <code>palpite</code>. No outro lado do sÃ­mbolo <code>=</code> estÃ¡ o valor ao qual <code>palpite</code> estÃ¡
vinculado, que Ã© o resultado da chamada <code>String::new</code>, uma funÃ§Ã£o que retorna
uma nova instÃ¢ncia de <code>String</code>. <a href="../../std/string/struct.String.html"><code>String</code></a><!-- ignore --> Ã© um tipo
fornecido pela biblioteca padrÃ£o que representa uma cadeia expansÃ­vel de
caracteres codificados em UTF-8.</p>
<p>A sintaxe <code>::</code> na linha <code>::new</code> indica que <code>new</code> Ã© uma <em>funÃ§Ã£o associada</em> do
tipo <code>String</code>. Uma funÃ§Ã£o associada Ã© implementada sobre um tipo, neste caso
<code>String</code>, em vez de uma instÃ¢ncia particular de <code>String</code>. Algumas linguagens
dÃ£o a isso o nome <em>mÃ©todo estÃ¡tico</em>.</p>
<p>Esta funÃ§Ã£o <code>new()</code> cria uma nova <code>String</code> vazia. VocÃª encontrarÃ¡ uma funÃ§Ã£o
<code>new()</code> em muitos tipos, jÃ¡ que Ã© um nome comum para uma funÃ§Ã£o que produz um
novo valor de algum tipo.</p>
<p>Para resumir, a linha <code>let mut palpite = String::new();</code> criou uma variÃ¡vel
mutÃ¡vel que estÃ¡ atualmente vinculada a uma nova instÃ¢ncia vazia de uma
<code>String</code>. Ufa!</p>
<p>Lembre-se de que incluÃ­mos a funcionalidade de entrada/saÃ­da da biblioteca
padrÃ£o por meio do <code>use std::io;</code> na primeira linha do programa. Agora vamos
chamar uma funÃ§Ã£o associada, <code>stdin</code>, em <code>io</code>:</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut palpite)
    .expect(&quot;Falha ao ler entrada&quot;);
</code></pre>
<p>Se nÃ£o tivÃ©ssemos a linha <code>use std::io</code> no inÃ­cio do programa, poderÃ­amos ter
escrito esta chamada como <code>std::io::stdin</code>. A funÃ§Ã£o <code>stdin</code> retorna uma
instÃ¢ncia de <a href="../../std/io/struct.Stdin.html"><code>std::io::Stdin</code></a><!-- ignore -->, um tipo que representa
um manipulador (<em>handle</em>) da entrada padrÃ£o do seu terminal.</p>
<p>A prÃ³xima parte do cÃ³digo, <code>.read_line(&amp;mut palpite)</code>, chama o mÃ©todo
<a href="../../std/io/struct.Stdin.html#method.read_line"><code>read_line</code></a><!-- ignore --> do <em>handle</em> da entrada padrÃ£o para obter
entrada do usuÃ¡rio. TambÃ©m estamos passando um argumento para <code>read_line</code>:
<code>&amp;mut palpite</code>.</p>
<p>O trabalho da funÃ§Ã£o <code>read_line</code> Ã© receber o que o usuÃ¡rio digita na entrada
padrÃ£o e colocar isso numa string, por isso ela recebe essa string como
argumento. A string do argumento deve ser mutÃ¡vel para que o mÃ©todo consiga
alterar o seu conteÃºdo, adicionando a entrada do usuÃ¡rio.</p>
<p>O sÃ­mbolo <code>&amp;</code> indica que o argumento Ã© uma <em>referÃªncia</em>, o que permite mÃºltiplas
partes do seu cÃ³digo acessar um certo dado sem precisar criar vÃ¡rias cÃ³pias dele
na memÃ³ria. ReferÃªncias sÃ£o uma caracterÃ­stica complexa, e uma das maiores
vantagens do Rust Ã© o quÃ£o fÃ¡cil e seguro Ã© usar referÃªncias. VocÃª nÃ£o precisa
conhecer muitos desses detalhes para finalizar esse programa. O CapÃ­tulo 4 vai
explicar sobre referÃªncias de forma mais aprofundada. Por enquanto, tudo que
vocÃª precisa saber Ã© que, assim como as variÃ¡veis, referÃªncias sÃ£o imutÃ¡veis por
padrÃ£o. Por isso, precisamos escrever <code>&amp;mut palpite</code>, em vez de apenas
<code>&amp;palpite</code>, para fazer com que o palpite seja mutÃ¡vel.</p>
<p>Ainda nÃ£o finalizamos completamente esta linha de cÃ³digo. Embora esta seja uma
Ãºnica linha de texto, Ã© apenas a primeira parte de uma linha lÃ³gica de cÃ³digo. A
segunda parte Ã© a chamada para este mÃ©todo:</p>
<pre><code class="language-rust ignore">.expect(&quot;Falha ao ler entrada&quot;);
</code></pre>
<p>Quando vocÃª chama um mÃ©todo com a sintaxe <code>.foo()</code>, geralmente Ã© bom introduzir
uma nova linha e outro espaÃ§o para ajudar a dividir linhas muito compridas.
PoderÃ­amos ter feito assim:</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut palpite).expect(&quot;Falha ao ler entrada&quot;);
</code></pre>
<p>PorÃ©m, uma linha muito comprida fica difÃ­cil de ler. EntÃ£o Ã© melhor dividirmos a
linha em duas, uma para cada mÃ©todo chamado. Agora vamos falar sobre o que essa
linha faz.</p>
<a class="header" href="ch02-00-guessing-game-tutorial.html#tratando-potenciais-falhas-com-o-tipo-result" id="tratando-potenciais-falhas-com-o-tipo-result"><h3>Tratando Potenciais Falhas com o Tipo <code>Result</code></h3></a>
<p>Como mencionado anteriormente, <code>read_line</code> coloca o que o usuÃ¡rio escreve dentro
da string que passamos como argumento, mas tambÃ©m retorna um valor - neste
caso, um <a href="../../std/io/type.Result.html"><code>io::Result</code></a><!-- ignore -->. Rust tem uma variedade de
tipos com o nome <code>Result</code> em sua biblioteca padrÃ£o: um <a href="../../std/result/enum.Result.html"><code>Result</code></a>
genÃ©rico e as versÃµes especÃ­ficas dos submÃ³dulos, como <code>io::Result</code>.</p>
<p>Os tipos <code>Result</code> sÃ£o <a href="ch06-00-enums.html"><em>enumeraÃ§Ãµes</em></a><!-- ignore -->, comumente chamadas
de <em>enums</em>. Uma enumeraÃ§Ã£o Ã© um tipo que pode ter um conjunto fixo de valores,
os quais sÃ£o chamados de <em>variantes</em> da enum. O CapÃ­tulo 6 vai abordar enums em
mais detalhes.</p>
<p>Para <code>Result</code>, as variantes sÃ£o <code>Ok</code> ou <code>Err</code>. <code>Ok</code> indica que a operaÃ§Ã£o teve
sucesso, e dentro da variante <code>Ok</code> estÃ¡ o valor resultante. <code>Err</code> significa que
a operaÃ§Ã£o falhou, e contÃ©m informaÃ§Ãµes sobre como ou por que isso ocorreu.</p>
<p>O propÃ³sito destes tipos <code>Result</code> Ã© codificar informaÃ§Ãµes de manipulaÃ§Ã£o de
erros. Valores do tipo <code>Result</code>, assim como qualquer tipo, possuem mÃ©todos
definidos. Uma instÃ¢ncia de <code>io::Result</code> tem um <a href="../../std/result/enum.Result.html#method.expect">mÃ©todo <code>expect</code></a><!-- ignore -->
que vocÃª pode chamar. Se esta instÃ¢ncia de <code>io::Result</code> Ã© um <code>Err</code>, <code>expect</code> vai
terminar o programa com erro e mostrar a mensagem que vocÃª passou como argumento
ao <code>expect</code>. Se o mÃ©todo <code>read_line</code> retornar um <code>Err</code>, provavelmente seria o
resultado de um erro vindo do sistema operacional que estÃ¡ por trÃ¡s. Se esta
instÃ¢ncia de <code>io::Result</code> Ã© um <code>Ok</code>, <code>expect</code> vai obter o valor contido no <code>Ok</code>
e retornÃ¡-lo para que vocÃª possa usÃ¡-lo. Neste caso, o valor Ã© o nÃºmero de bytes
dos dados que o usuÃ¡rio inseriu atravÃ©s da entrada padrÃ£o.</p>
<p>Se nÃ£o chamarmos <code>expect</code>, nosso programa vai compilar, mas vamos ter um aviso:</p>
<pre><code class="language-text">$ cargo build
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
warning: unused `std::result::Result` which must be used
  --&gt; src/main.rs:10:5
   |
10 |     io::stdin().read_line(&amp;mut palpite);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: #[warn(unused_must_use)] on by default
</code></pre>
<p>Rust avisa que nÃ£o usamos o valor <code>Result</code>, retornado por <code>read_line</code>, indicando
que o programa deixou de tratar um possÃ­vel erro. A maneira correta de suprimir
o aviso Ã© realmente escrevendo um tratador de erro, mas como queremos que o
programa seja encerrado caso ocorra um problema, podemos usar <code>expect</code>. VocÃª
aprenderÃ¡ sobre recuperaÃ§Ã£o de erros no CapÃ­tulo 9.</p>
<a class="header" href="ch02-00-guessing-game-tutorial.html#exibindo-valores-com-curingas-do-println" id="exibindo-valores-com-curingas-do-println"><h3>Exibindo Valores com Curingas do <code>println!</code></h3></a>
<p>Tirando a chave que delimita a funÃ§Ã£o <code>main</code>, hÃ¡ apenas uma linha mais a ser
discutida no cÃ³digo que fizemos atÃ© agora, que Ã© a seguinte:</p>
<pre><code class="language-rust ignore">println!(&quot;VocÃª disse: {}&quot;, guess);
</code></pre>
<p>Esta linha imprime a string na qual salvamos os dados inseridos pelo usuÃ¡rio. O
<code>{}</code> Ã© um curinga que reserva o lugar de um valor. VocÃª pode imprimir mais de um
valor usando <code>{}</code>: o primeiro conjunto de <code>{}</code> guarda o primeiro valor listado
apÃ³s a string de formataÃ§Ã£o, o segundo conjunto guarda o segundo valor, e
assim por diante. Imprimir mÃºltiplos valores em uma sÃ³ chamada a <code>println!</code>
seria assim:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
let y = 10;

println!(&quot;x = {} e y = {}&quot;, x, y);
#}</code></pre></pre>
<p>Esse cÃ³digo imprime <code>x = 5 e y = 10</code>.</p>
<a class="header" href="ch02-00-guessing-game-tutorial.html#testando-a-primeira-parte" id="testando-a-primeira-parte"><h3>Testando a Primeira Parte</h3></a>
<p>Vamos testar a primeira parte do jogo de advinhaÃ§Ã£o. VocÃª pode executÃ¡-lo usando
<code>cargo run</code>:</p>
<pre><code class="language-text">$ cargo run
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
     Running `target/debug/jogo_de_advinhacao`
Advinhe o nÃºmero!
Digite o seu palpite.
6
VocÃª disse: 6
</code></pre>
<p>Nesse ponto, a primeira parte do jogo estÃ¡ feita: podemos coletar entrada do
teclado e mostrÃ¡-la na tela.</p>
<a class="header" href="ch02-00-guessing-game-tutorial.html#gerando-um-nÃºmero-secreto" id="gerando-um-nÃºmero-secreto"><h2>Gerando um NÃºmero Secreto</h2></a>
<p>A seguir, precisamos gerar um nÃºmero secreto que o usuÃ¡rio vai tentar advinhar.
O nÃºmero secreto deve ser diferente a cada execuÃ§Ã£o, para que o jogo tenha graÃ§a
em ser jogado mais de uma vez. Vamos usar um nÃºmero aleatÃ³rio entre 1 e 100,
para que o jogo nÃ£o seja tÃ£o difÃ­cil. Rust ainda nÃ£o inclui uma funcionalidade
de geraÃ§Ã£o de nÃºmeros aleatÃ³rios em sua biblioteca padrÃ£o. PorÃ©m, a equipe Rust
fornece um <a href="https://crates.io/crates/rand">crate <code>rand</code></a>.</p>
<a class="header" href="ch02-00-guessing-game-tutorial.html#usando-um-crate-para-ter-mais-funcionalidades" id="usando-um-crate-para-ter-mais-funcionalidades"><h3>Usando um Crate para Ter Mais Funcionalidades</h3></a>
<p>Lembre-se que um <em>crate</em> Ã© um pacote de cÃ³digo Rust. O projeto que estamos
construindo Ã© um <em>crate binÃ¡rio</em>, que Ã© um executÃ¡vel. JÃ¡ o <code>rand</code> Ã© um
<em>crate de biblioteca</em>, que contÃ©m cÃ³digo cujo objetivo Ã© ser usado por outros
programas.</p>
<p>Ã‰ no uso de crates externos que Cargo realmente brilha. Antes que possamos
escrever o cÃ³digo usando <code>rand</code>, precisamos modificar o arquivo <em>Cargo.toml</em>
para incluir o crate <code>rand</code> como uma dependÃªncia. Abra o arquivo e adicione
esta linha no final, abaixo do cabeÃ§alho da seÃ§Ã£o <code>[dependencies]</code> que o Cargo
criou para vocÃª:</p>
<p><span class="filename">Arquivo: Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]

rand = &quot;0.3.14&quot;
</code></pre>
<p>No arquivo <em>Cargo.toml</em>, tudo que vem depois de um cabeÃ§alho Ã© parte de uma
seÃ§Ã£o que segue atÃ© o inÃ­cio de outra. A seÃ§Ã£o <code>[dependencies]</code> Ã© onde vocÃª diz
ao Cargo de quais crates externos o seu projeto depende, e quais versÃµes desses
crates vocÃª exige. Neste caso, especificamos o crate <code>rand</code> com a versÃ£o
semÃ¢ntica <code>0.3.14</code>. Cargo compreende <a href="https://semver.org/lang/pt-BR/">Versionamento SemÃ¢ntico</a><!-- ignore -->
(Ã s vezes chamado <em>SemVer</em>), um padrÃ£o para escrever nÃºmeros de versÃµes. O
nÃºmero <code>0.3.14</code> Ã©, na verdade, uma forma curta de escrever <code>^0.3.14</code>, que
significa &quot;qualquer versÃ£o que tenha uma API pÃºblica compatÃ­vel com a versÃ£o
0.3.14&quot;.</p>
<p>Agora, sem mudar cÃ³digo algum, vamos compilar nosso projeto, conforme mostrado
na Listagem 2-2:</p>
<pre><code class="language-text">$ cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading rand v0.3.14
 Downloading libc v0.2.14
   Compiling libc v0.2.14
   Compiling rand v0.3.14
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
</code></pre>
<p><span class="caption">Listagem 2-2: Resultado da execuÃ§Ã£o de <code>cargo build</code>
depois de adicionar o crate <code>rand</code> como dependÃªncia.</span></p>
<p>Talvez pra vocÃª apareÃ§am versÃµes diferentes (mas elas sÃ£o todas compatÃ­veis com
o cÃ³digo, graÃ§as ao Versionamento SemÃ¢ntico!), e as linhas talvez apareÃ§am em
ordem diferente.</p>
<p>Agora que temos uma dependÃªncia externa, Cargo busca as versÃµes mais recentes de
tudo no <em>registro</em>, que Ã© uma cÃ³pia dos dados do <a href="https://crates.io">Crates.io</a>.
Crates.io Ã© onde as pessoas do ecossistema Rust postam seus projetos
<em>open source</em> para que os outros possam usar.</p>
<p>ApÃ³s atualizar o registro, Cargo verifica a seÃ§Ã£o <code>[dependencies]</code> e baixa todas
as que vocÃª nÃ£o tem ainda. Neste caso, embora tenhamos listado apenas <code>rand</code>
como dependÃªncia, o Cargo tambÃ©m puxou uma cÃ³pia da <code>libc</code>, porque <code>rand</code>
depende da <code>libc</code> para funcionar. Depois de baixÃ¡-las, o Cargo as compila e
entÃ£o compila nosso projeto.</p>
<p>Se, logo em seguida, vocÃª executar <code>cargo build</code> novamente sem fazer mudanÃ§as,
nÃ£o vai aparecer nenhuma mensagem de saÃ­da. O Cargo sabe que jÃ¡ baixou e
compilou as dependÃªncias, e vocÃª nÃ£o alterou mais nada sobre elas no seu arquivo
<em>Cargo.toml</em>. Cargo tambÃ©m sabe que vocÃª nÃ£o mudou mais nada no seu cÃ³digo, e
por isso nÃ£o o recompila. Sem nada a fazer, ele simplesmente sai. Se vocÃª abrir
<em>src/main.rs</em>, fizer uma modificaÃ§Ã£o trivial, salvar e compilar de novo, vai
aparecer uma mensagem de apenas duas linhas:</p>
<pre><code class="language-text">$ cargo build
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
</code></pre>
<p>Essas linhas mostram que o Cargo sÃ³ atualiza o <em>build</em> com a sua pequena mudanÃ§a
no arquivo <em>src/main.rs</em>. Suas dependÃªncias nÃ£o mudaram, entÃ£o o Cargo sabe que
pode reutilizar o que jÃ¡ tiver sido baixado e compilado para elas. Ele apenas
recompila a sua parte do cÃ³digo.</p>
<a class="header" href="ch02-00-guessing-game-tutorial.html#o-arquivo-cargolock-garante-builds-reproduzÃ­veis" id="o-arquivo-cargolock-garante-builds-reproduzÃ­veis"><h4>O Arquivo <em>Cargo.lock</em> Garante <em>Builds</em> ReproduzÃ­veis</h4></a>
<p>O Cargo tem um mecanismo que assegura que vocÃª pode reconstruir o mesmo artefato
toda vez que vocÃª ou outra pessoa compilar o seu cÃ³digo. O Cargo vai usar apenas
as versÃµes das dependÃªncias que vocÃª especificou, atÃ© que vocÃª indique o
contrÃ¡rio. Por exemplo, o que acontece se, na semana que vem, sair a versÃ£o
<code>v0.3.15</code> contendo uma correÃ§Ã£o de bug, mas tambÃ©m uma regressÃ£o que nÃ£o
funciona com o seu cÃ³digo?</p>
<p>A resposta para isso estÃ¡ no arquivo <em>Cargo.lock</em>, que foi criado na primeira
vez que vocÃª executou <code>cargo build</code>, e agora estÃ¡ no seu diretÃ³rio
<em>jogo_de_advinhacao</em>. Quando vocÃª compila o seu projeto pela primeira vez, o
Cargo descobre as versÃµes de todas as dependÃªncias que preenchem os critÃ©rios
e entÃ£o as escreve no arquivo <em>Cargo.lock</em>. Quando vocÃª compilar o seu projeto
futuramente, o Cargo verÃ¡ que o arquivo <em>Cargo.lock</em> existe e usarÃ¡ as versÃµes
especificadas lÃ¡, em vez de refazer todo o trabalho descobrir as versÃµes
novamente. Isto lhe permite ter um <em>build</em> reproduzÃ­vel automaticamente. Em
outras palavras, seu projeto vai continuar com a versÃ£o <code>0.3.14</code> atÃ© que vocÃª
faÃ§a uma atualizaÃ§Ã£o explÃ­cita, graÃ§as ao arquivo <em>Cargo.lock</em>.</p>
<a class="header" href="ch02-00-guessing-game-tutorial.html#atualizando-um-crate-para-obter-uma-nova-versÃ£o" id="atualizando-um-crate-para-obter-uma-nova-versÃ£o"><h4>Atualizando um Crate para Obter uma Nova VersÃ£o</h4></a>
<p>Quando vocÃª <em>quiser</em> atualizar um crate, o Cargo tem outro comando, <code>update</code>,
que faz o seguinte:</p>
<ol>
<li>Ignora o arquivo <em>Cargo.lock</em> e descobre todas as versÃµes mais recentes que
atendem as suas especificaÃ§Ãµes no <em>Cargo.toml</em>.</li>
<li>Se funcionar, o Cargo escreve essas versÃµes no arquivo <em>Cargo.lock</em>.</li>
</ol>
<p>Mas, por padrÃ£o, o Cargo vai procurar as versÃµes maiores que <code>0.3.0</code> e menores
que <code>0.4.0</code>. Se o crate <code>rand</code> jÃ¡ tiver lanÃ§ado duas novas versÃµes, <code>0.3.15</code> e
<code>0.4.0</code>, vocÃª verÃ¡ a seguinte mensagem ao executar <code>cargo update</code>:</p>
<pre><code class="language-text">$ cargo update
    Updating registry `https://github.com/rust-lang/crates.io-index`
    Updating rand v0.3.14 -&gt; v0.3.15
</code></pre>
<p>Nesse ponto, vocÃª vai notar tambÃ©m uma mudanÃ§a no seu arquivo <em>Cargo.lock</em>
dizendo que a versÃ£o do crate <code>rand</code> que vocÃª estÃ¡ usando agora Ã© a <code>0.3.15</code>.</p>
<p>Se vocÃª quisesse usar a versÃ£o <code>0.4.0</code>, ou qualquer versÃ£o da sÃ©rie <code>0.4.x</code> do
<code>rand</code>, vocÃª teria que atualizar o seu <em>Cargo.toml</em> dessa forma:</p>
<pre><code class="language-toml">[dependencies]

rand = &quot;0.4.0&quot;
</code></pre>
<p>Na prÃ³xima vez que vocÃª executar <code>cargo build</code>, o Cargo vai atualizar o registro
de crates disponÃ­veis e reavaliar os seus requisitos sobre o <code>rand</code> de acordo
com a nova versÃ£o que vocÃª especificou.</p>
<p>HÃ¡ muito mais a ser dito sobre <a href="http://doc.crates.io">Cargo</a><!-- ignore --> e o <a href="http://doc.crates.io/crates-io.html">seu
ecossistema</a><!-- ignore --> que vai ser discutido no CapÃ­tulo 14,
mas por ora isto Ã© tudo que vocÃª precisa saber. Cargo facilita muito reutilizar
bibliotecas, de forma que os <em>rustÃ¡ceos</em> consigam escrever projetos menores que
sÃ£o montados a partir de diversos pacotes.</p>
<a class="header" href="ch02-00-guessing-game-tutorial.html#gerando-um-nÃºmero-aleatÃ³rio" id="gerando-um-nÃºmero-aleatÃ³rio"><h3>Gerando um NÃºmero AleatÃ³rio</h3></a>
<p>Agora vamos <em>usar</em>, de fato, o <code>rand</code>. O prÃ³ximo passo Ã© atualizar o
<em>src/main.rs</em> conforme mostrado na Listagem 2-3:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use rand::Rng;

fn main() {
    println!(&quot;Advinhe o nÃºmero!&quot;);

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    println!(&quot;O nÃºmero secreto Ã©: {}&quot;, numero_secreto);

    println!(&quot;Digite o seu palpite.&quot;);

    let mut palpite = String::new();

    io::stdin().read_line(&amp;mut palpite)
        .expect(&quot;Falha ao ler entrada&quot;);

    println!(&quot;VocÃª disse: {}&quot;, palpite);
}
</code></pre>
<p><span class="caption">Listagem 2-3: MudanÃ§as necessÃ¡rias do cÃ³digo para gerar um
nÃºmero aleatÃ³rio.</span></p>
<p>Estamos adicionando a linha <code>extern crate rand</code> ao topo do arquivo para indicar
ao Rust que estamos usando uma dependÃªncia externa. Isto tambÃ©m Ã© equivalente a
um <code>use rand;</code>, assim podemos chamar qualquer coisa que esteja no crate <code>rand</code>
prefixando-a com <code>rand::</code>.</p>
<p>Em seguida, adicionamos outra linha <code>use</code>: <code>use rand::Rng</code>. <code>Rng</code> Ã© um trait
que define mÃ©todos a serem implementados pelos geradores de nÃºmeros aleatÃ³rios,
e esse trait deve estar dentro do escopo para que possamos usar esses mÃ©todos. O
CapÃ­tulo 10 vai abordar traits em mais detalhes.</p>
<p>Tem outras duas linhas que adicionamos no meio. A funÃ§Ã£o <code>rand::thread_rng</code> nos
dÃ¡ o gerador de nÃºmeros aleatÃ³rios que vamos usar, um que Ã© local Ã  <em>thread</em>
corrente e que Ã© inicializado pelo sistema operacional. Depois, vamos chamar o
mÃ©todo <code>gen_range</code> no gerador de nÃºmeros aleatÃ³rios. Esse mÃ©todo estÃ¡ definido
pelo trait <code>Rng</code> que trouxemos ao escopo por meio do <code>use rand::Rng</code>. Este
mÃ©todo recebe dois argumentos e gera um nÃºmero aleatÃ³rio entre eles. Ele inclui
o limite inferior mas exclui o superior, entÃ£o precisamos passar <code>1</code> e <code>101</code>
para obter um nÃºmero de 1 a 100.</p>
<p>Saber quais traits devem ser usadas e quais funÃ§Ãµes e mÃ©todos de um crate
devem ser chamados nÃ£o Ã© nada trivial. As instruÃ§Ãµes de como usar um crate
estÃ£o na documentaÃ§Ã£o de cada um. Outra coisa boa do Cargo Ã© que vocÃª pode rodar
o comando <code>cargo doc --open</code> que vai construir localmente a documentaÃ§Ã£o
fornecida por todas as suas dependÃªncias e abrÃ­-las no seu navegador. Se vocÃª
estiver interessado em outras funcionalidades do crate <code>rand</code>, por exemplo,
execute <code>cargo doc --open</code> e clique em <code>rand</code>, no menu ao lado esquerdo.</p>
<p>A segunda linha que adicionamos imprime o nÃºmero secreto. Isto Ã© Ãºtil enquanto
estamos desenvolvendo o programa para podermos testÃ¡-lo, mas vamos retirÃ¡-la da
versÃ£o final. Um jogo nÃ£o Ã© muito interessante se ele mostra a resposta logo no
inÃ­cio!</p>
<p>Tente rodar o programa algumas vezes:</p>
<pre><code class="language-text">$ cargo run
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
     Running `target/debug/jogo_de_advinhacao`
Advinhe o nÃºmero!
O nÃºmero secreto Ã©: 7
Digite o seu palpite.
4
VocÃª disse: 4
$ cargo run
     Running `target/debug/jogo_de_advinhacao`
Advinhe o nÃºmero!
O nÃºmero secreto Ã©: 83
Digite o seu palpite.
5
VocÃª disse: 5
</code></pre>
<p>VocÃª jÃ¡ deve obter nÃºmeros aleatÃ³rios diferentes, e eles devem ser todos entre 1
e 100. Bom trabalho!</p>
<a class="header" href="ch02-00-guessing-game-tutorial.html#comparando-o-palpite-com-o-nÃºmero-secreto" id="comparando-o-palpite-com-o-nÃºmero-secreto"><h2>Comparando o Palpite com o NÃºmero Secreto</h2></a>
<p>Agora que nÃ³s temos a entrada do usuÃ¡rio e o nÃºmero secreto, vamos comparÃ¡-los.
Esta estapa Ã© mostrada na Listagem 2-4:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Advinhe o nÃºmero!&quot;);

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    println!(&quot;O nÃºmero secreto Ã©: {}&quot;, numero_secreto);

    println!(&quot;Digite o seu palpite.&quot;);

    let mut palpite = String::new();

    io::stdin().read_line(&amp;mut palpite)
        .expect(&quot;Falha ao ler entrada&quot;);

    println!(&quot;VocÃª disse: {}&quot;, palpite);

    match palpite.cmp(&amp;numero_secreto) {
        Ordering::Less =&gt; println!(&quot;Muito baixo!&quot;),
        Ordering::Greater =&gt; println!(&quot;Muito alto!&quot;),
        Ordering::Equal =&gt; println!(&quot;VocÃª acertou!&quot;),
    }
}
</code></pre>
<p><span class="caption">Listagem 2-4: Tratando os possÃ­veis resultados da
comparaÃ§Ã£o de dois nÃºmeros.</span></p>
<p>A primeira novidade aqui Ã© outro <code>use</code>, que traz ao escopo um tipo da biblioteca
padrÃ£o chamado <code>std::cmp::Ordering</code>. <code>Ordering</code> Ã© outra enum, igual a <code>Result</code>,
mas as suas variantes sÃ£o <code>Less</code>, <code>Greater</code> e <code>Equal</code> (elas significam menor,
maior e igual, respectivamente). Estes sÃ£o os trÃªs possÃ­veis resultados quando
vocÃª compara dois valores.</p>
<p>Depois, adicionamos cinco novas linhas no final que usam o tipo <code>Ordering</code>:</p>
<pre><code class="language-rust ignore">match palpite.cmp(&amp;numero_secreto) {
    Ordering::Less =&gt; println!(&quot;Muito baixo!&quot;),
    Ordering::Greater =&gt; println!(&quot;Muito alto!&quot;),
    Ordering::Equal =&gt; println!(&quot;VocÃª acertou!&quot;),
}
</code></pre>
<p>O mÃ©todo <code>cmp</code> compara dois valores, e pode ser chamado a partir de qualquer
coisa que possa ser comparada. Ele recebe uma referÃªncia de qualquer coisa que
vocÃª queira comparar. Neste caso, estÃ¡ comparando o <code>palpite</code> com o
<code>numero_secreto</code>. <code>cmp</code> retorna uma variante do tipo <code>Ordering</code>, que trouxemos
ao escopo com <code>use</code>. NÃ³s usamos uma expressÃ£o <a href="ch06-02-match.html"><code>match</code></a><!-- ignore -->
para decidir o que fazer em seguida, com base em qual variante de <code>Ordering</code> foi
retornada pelo mÃ©todo <code>cmp</code>, que foi chamado com os valores <code>palpite</code> e
<code>numero_secreto</code>.</p>
<p>Uma expressÃ£o <code>match</code> Ã© composta de <em>braÃ§os</em>. Um braÃ§o consiste em um <em>padrÃ£o</em>
mais o cÃ³digo que deve ser executado se o valor colocado no inÃ­cio do <code>match</code> se
encaixar no padrÃ£o deste braÃ§o. O Rust pega o valor passado ao <code>match</code> e o
compara com o padrÃ£o de cada braÃ§o na sequÃªncia. A expressÃ£o <code>match</code> e os
padrÃµes sÃ£o ferramentas poderosas do Rust que lhe permitem expressar uma
variedade de situaÃ§Ãµes que seu cÃ³digo pode encontrar, e ajuda a assegurar que
vocÃª tenha tratado todas elas. Essas ferramentas serÃ£o abordadas em detalhes nos
capÃ­tulos 6 e 18, respectivamente.</p>
<p>Vamos acompanhar um exemplo do que aconteceria na expressÃ£o <code>match</code> usada aqui.
Digamos que o usuÃ¡rio tenha colocado 50 como palpite, e o nÃºmero secreto
aleatÃ³rio desta vez Ã© 38. Quando o cÃ³digo compara 50 com 38, o mÃ©todo <code>cmp</code> vai
retornar <code>Ordering::Greater</code>, porque 50 Ã© maior que 38. <code>Ordering::Greater</code> Ã© o
valor passado ao <code>match</code>. Ele olha para o padrÃ£o <code>Ordering::Less</code> do primeiro
braÃ§o, mas o valor <code>Ordering::Greater</code> nÃ£o casa com <code>Ordering::Less</code>, entÃ£o ele
ignora o cÃ³digo desse braÃ§o e avanÃ§a para o prÃ³ximo. JÃ¡ o padrÃ£o do prÃ³ximo
braÃ§o, <code>Ordering::Greater</code>, <em>casa</em> com <code>Ordering::Greater</code>! O cÃ³digo associado a
este braÃ§o vai ser executado e mostrar <code>Muito alto!</code> na tela. A expressÃ£o
<code>match</code> termina porque jÃ¡ nÃ£o tem mais necessidade de verificar o Ãºltimo braÃ§o
nesse caso particular.</p>
<p>PorÃ©m, o cÃ³digo da Listagem 2-4 ainda nÃ£o vai compilar. Vamos tentar:</p>
<pre><code class="language-text">$ cargo build
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
error[E0308]: mismatched types
  --&gt; src/main.rs:23:21
   |
23 |     match palpite.cmp(&amp;numero_secreto) {
   |                       ^^^^^^^^^^^^^^^ expected struct `std::string::String`, found integral variable
   |
   = note: expected type `&amp;std::string::String`
   = note:    found type `&amp;{integer}`

error: aborting due to previous error
Could not compile `jogo_de_advinhacao`.
</code></pre>
<p>O que este erro estÃ¡ dizendo Ã© que temos <em>tipos incompatÃ­veis</em>. Rust tem um
sistema de tipos forte e estÃ¡tico. PorÃ©m, Rust tambÃ©m tem inferÃªncia de tipos.
Quando escrevemos <code>let palpite = String::new()</code>, Rust foi capaz de inferir que
<code>palpite</code> deveria ser uma <code>String</code>, entÃ£o ele nÃ£o nos faz escrever o tipo. O
<code>numero_secreto</code>, por outro lado, Ã© de um tipo numÃ©rico. Existem alguns tipos
numÃ©ricos capazes de guardar um valor entre 1 e 100: <code>i32</code>, que Ã© um nÃºmero de
32 bits; <code>u32</code>, um nÃºmero de 32 bits sem sinal; <code>i64</code>, um nÃºmero de 64 bits; e
mais alguns outros. O tipo numÃ©rico padrÃ£o do Rust Ã© <code>i32</code>, que Ã© o tipo do
<code>numero_secreto</code>, a nÃ£o ser que adicionemos, em algum lugar, uma informaÃ§Ã£o de
tipo que faÃ§a o Rust inferir outro tipo numÃ©rico. A razÃ£o do erro Ã© que o Rust
nÃ£o pode comparar uma string e um tipo numÃ©rico.</p>
<p>Em Ãºltima anÃ¡lise, queremos converter a <code>String</code> que lemos como entrada em um
tipo numÃ©rico de verdade, de forma que possamos comparÃ¡-lo numericamente com o
palpite. Podemos fazer isso com mais duas linhas no corpo da funÃ§Ã£o <code>main</code>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Advinhe o nÃºmero!&quot;);

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    println!(&quot;O nÃºmero secreto Ã©: {}&quot;, numero_secreto);

    println!(&quot;Digite o seu palpite.&quot;);

    let mut palpite = String::new();

    io::stdin().read_line(&amp;mut palpite)
        .expect(&quot;Falha ao ler entrada&quot;);

    let palpite: u32 = palpite.trim().parse()
        .expect(&quot;Por favor, digite um nÃºmero!&quot;);

    println!(&quot;VocÃª disse: {}&quot;, palpite);

    match palpite.cmp(&amp;numero_secreto) {
        Ordering::Less =&gt; println!(&quot;Muito baixo!&quot;),
        Ordering::Greater =&gt; println!(&quot;Muito alto!&quot;),
        Ordering::Equal =&gt; println!(&quot;VocÃª acertou!&quot;),
    }
}
</code></pre>
<p>As duas linhas novas sÃ£o:</p>
<pre><code class="language-rust ignore">let palpite: u32 = palpite.trim().parse()
    .expect(&quot;Por favor, digite um nÃºmero!&quot;);
</code></pre>
<p>NÃ³s criamos uma variÃ¡vel chamada <code>palpite</code>. Mas espera, o programa jÃ¡ nÃ£o tinha
uma variÃ¡vel chamada <code>palpite</code>? Sim, mas o Rust nos permite <em>sombrear</em> o
<code>palpite</code> anterior com um novo. Isto Ã© geralmente usado em situaÃ§Ãµes em que vocÃª
quer converter um valor de um tipo em outro. O sombreamento nos permite
reutilizar o nome <code>palpite</code>, em vez de nos forÃ§ar a criar dois nomes Ãºnicos como
<code>palpite_str</code> e <code>palpite</code>, por exemplo. (O CapÃ­tulo 3 vai cobrir sombreamento em
mais detalhes).</p>
<p>NÃ³s vinculamos <code>palpite</code> Ã  expressÃ£o <code>palpite.trim().parse()</code>. O <code>palpite</code>, na
expressÃ£o, refere-se ao <code>palpite</code> original contendo a <code>String</code> de entrada do
usuÃ¡rio. O mÃ©todo <code>trim</code>, em uma instÃ¢ncia de <code>String</code>, vai eliminar quaisquer
espaÃ§os em branco no inÃ­cio e no fim. <code>u32</code> pode conter apenas caracteres
numÃ©ricos, mas o usuÃ¡rio precisa pressionar <span class="keystroke">Enter</span>
para satisfazer o <code>read_line</code>. Quando o usuÃ¡rio pressiona
<span class="keystroke">Enter</span>, um caractere de nova linha Ã© inserido na
string. Por exemplo, se o usuÃ¡rio digitar <span class="keystroke">5</span> e
depois <span class="keystroke">Enter</span>, <code>palpite</code> ficaria assim: <code>5\n</code>. O
<code>\n</code> representa uma linha nova, a tecla <span class="keystroke">Enter</span>.
O mÃ©todo <code>trim</code> elimina o <code>\n</code>, deixando apenas <code>5</code>.</p>
<p>O <a href="../../std/primitive.str.html#method.parse">mÃ©todo <code>parse</code> em strings</a><!-- ignore --> converte uma string para
algum tipo de nÃºmero. Dado que ele pode interpretar uma variedade de tipos
numÃ©ricos, precisamos dizer ao Rust qual o tipo exato de nÃºmero nÃ³s queremos, e
para isso usamos <code>let palpite: u32</code>. Os dois pontos (<code>:</code>) depois de <code>palpite</code>
informam ao Rust que estamos anotando seu tipo. O Rust tem alguns tipos
numÃ©ricos embutidos, o <code>u32</code> visto aqui Ã© um inteiro de 32 bits sem sinal. Ã‰ uma
boa escolha padrÃ£o para um nÃºmero positivo pequeno. VocÃª vai aprender sobre
outros tipos numÃ©ricos no CapÃ­tulo 3. AlÃ©m disso, a anotaÃ§Ã£o <code>u32</code> neste
programa de exemplo e a comparaÃ§Ã£o com <code>numero_secreto</code> significam que o Rust
vai inferir que <code>numero_secreto</code> tambÃ©m deve ser um <code>u32</code>. EntÃ£o agora a
comparaÃ§Ã£o vai ser feita entre valores do mesmo tipo!</p>
<p>A chamada para <code>parse</code> poderia facilmente causar um erro. Por exemplo, se a
string contiver <code>AğŸ‘%</code>, nÃ£o haveria como converter isto em um nÃºmero. Como ele
pode falhar, o mÃ©todo <code>parse</code> retorna um <code>Result</code>, assim como o mÃ©todo
<code>read_line</code>, conforme discutido anteriormente na seÃ§Ã£o &quot;Tratando Potenciais
Falhas com o Tipo <code>Result</code>. Vamos tratar este <code>Result</code> da mesma forma usando o
mÃ©todo <code>expect</code> de novo. Se o <code>parse</code> retornar uma variante <code>Err</code> da enum
<code>Result</code>, por nÃ£o conseguir criar um nÃºmero a partir da string, a chamada ao
<code>expect</code> vai causar um <em>crash</em> no jogo e exibir a mensagem que passamos a ele.
Se o <code>parse</code> conseguir converter uma string em um nÃºmero, ele vai retornar a
variante <code>Ok</code> da enum <code>Result</code> e <code>expect</code> vai retornar o nÃºmero que queremos
extrair do valor <code>Ok</code>.</p>
<p>Agora vamos executar o programa!</p>
<pre><code class="language-text">$ cargo run
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43 secs
     Running `target/jogo_de_advinhacao`
Advinhe o nÃºmero!
O nÃºmero secreto Ã©: 58
Digite o seu palpite.
  76
VocÃª disse: 76
Muito alto!
</code></pre>
<p>Boa! AtÃ© mesmo colocando alguns espaÃ§os antes de digitar o palpite, o programa
ainda descobriu que o palpite do usuÃ¡rio Ã© 76. Execute o programa mais algumas
vezes para verificar os diferentes comportamentos com diferentes tipos de
entrada: advinhe o nÃºmero corretamente, digite um nÃºmero muito alto, e digite um
nÃºmero muito baixo.</p>
<p>Agora jÃ¡ temos a maior parte do jogo funcionando, mas o usuÃ¡rio sÃ³ consegue dar
um palpite uma vez. Vamos mudar isso adicionando laÃ§os!</p>
<a class="header" href="ch02-00-guessing-game-tutorial.html#permitindo-mÃºltiplos-palpites-usando-looping" id="permitindo-mÃºltiplos-palpites-usando-looping"><h2>Permitindo MÃºltiplos Palpites Usando <em>Looping</em></h2></a>
<p>A palavra-chave <code>loop</code> nos dÃ¡ um laÃ§o (<em>loop</em>) infinito. Use-a para dar aos
usuÃ¡rios mais chances de advinhar o nÃºmero:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Advinhe o nÃºmero!&quot;);

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    println!(&quot;O nÃºmero secreto Ã©: {}&quot;, numero_secreto);

    loop {
        println!(&quot;Digite o seu palpite.&quot;);

        let mut palpite = String::new();

        io::stdin().read_line(&amp;mut palpite)
            .expect(&quot;Falha ao ler entrada&quot;);

        let palpite: u32 = palpite.trim().parse()
            .expect(&quot;Por favor, digite um nÃºmero!&quot;);

        println!(&quot;VocÃª disse: {}&quot;, palpite);

        match palpite.cmp(&amp;numero_secreto) {
            Ordering::Less =&gt; println!(&quot;Muito baixo!&quot;),
            Ordering::Greater =&gt; println!(&quot;Muito alto!&quot;),
            Ordering::Equal =&gt; println!(&quot;VocÃª acertou!&quot;),
        }
    }
}
</code></pre>
<p>Como vocÃª pode ver, movemos tudo para dentro do laÃ§o a partir da mensagem
pedindo o palpite do usuÃ¡rio. Certifique-se de indentar essas linhas mais quatro
espaÃ§os cada uma, e execute o programa novamente. Repare que hÃ¡ um novo
problema, porque o programa estÃ¡ fazendo exatamente o que dissemos para ele
fazer: pedir sempre outro palpite! Parece que o usuÃ¡rio nÃ£o consegue sair!</p>
<p>O usuÃ¡rio pode sempre interromper o programa usando as teclas
<span class="keystroke">ctrl-c</span>. Mas hÃ¡ uma outra forma de escapar deste
monstro insaciÃ¡vel que mencionamos na discussÃ£o do mÃ©todo <code>parse</code>, na seÃ§Ã£o
&quot;Comparando o Palpite com o NÃºmero Secreto&quot;: se o usuÃ¡rio fornece uma resposta
nÃ£o-numÃ©rica, o programa vai sofrer um <em>crash</em>. O usuÃ¡rio pode levar vantagem
disso para conseguir sair, como mostrado abaixo:</p>
<pre><code class="language-text">$ cargo run
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
     Running `target/jogo_de_advinhacao`
Advinhe o nÃºmero!
O nÃºmero secreto Ã©: 59
Digite o seu palpite.
45
VocÃª disse: 45
Muito baixo!
Digite o seu palpite.
60
VocÃª disse: 60
Muito alto!
Digite o seu palpite.
59
VocÃª disse: 59
VocÃª acertou!
Digite o seu palpite.
sair
thread 'main' panicked at 'Por favor, digite um nÃºmero!: ParseIntError { kind: InvalidDigit }', src/libcore/result.rs:785
note: Run with `RUST_BACKTRACE=1` for a backtrace.
error: Process didn't exit successfully: `target/debug/jogo_de_advinhacao` (exit code: 101)
</code></pre>
<p>Digitar <code>sair</code>, na verdade, sai do jogo, mas isso tambÃ©m acontece com qualquer
outra entrada nÃ£o numÃ©rica. PorÃ©m, isto nÃ£o Ã© o ideal. Queremos que o jogo
termine automaticamente quando o nÃºmero Ã© advinhado corretamente.</p>
<a class="header" href="ch02-00-guessing-game-tutorial.html#saindo-apÃ³s-um-palpite-correto" id="saindo-apÃ³s-um-palpite-correto"><h3>Saindo ApÃ³s um Palpite Correto</h3></a>
<p>Vamos programar o jogo para sair quando o usuÃ¡rio vencer, colocando um <code>break</code>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Advinhe o nÃºmero!&quot;);

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    println!(&quot;O nÃºmero secreto Ã©: {}&quot;, numero_secreto);

    loop {
        println!(&quot;Digite o seu palpite.&quot;);

        let mut palpite = String::new();

        io::stdin().read_line(&amp;mut palpite)
            .expect(&quot;Falha ao ler entrada&quot;);

        let palpite: u32 = palpite.trim().parse()
            .expect(&quot;Por favor, digite um nÃºmero!&quot;);

        println!(&quot;VocÃª disse: {}&quot;, palpite);

        match palpite.cmp(&amp;numero_secreto) {
            Ordering::Less =&gt; println!(&quot;Muito baixo&quot;),
            Ordering::Greater =&gt; println!(&quot;Muito alto!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;VocÃª acertou!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p>Adicionando a linha <code>break</code> apÃ³s o <code>VocÃª acertou!</code>, o programa vai sair do laÃ§o
quando o usuÃ¡rio advinhar corretamente o nÃºmero secreto. Sair do laÃ§o tambÃ©m
significa sair do programa, pois o laÃ§o Ã© a Ãºltima parte da <code>main</code>.</p>
<a class="header" href="ch02-00-guessing-game-tutorial.html#tratando-entradas-invÃ¡lidas" id="tratando-entradas-invÃ¡lidas"><h3>Tratando Entradas InvÃ¡lidas</h3></a>
<p>Para refinar ainda mais o comportamento do jogo, em vez de causar um <em>crash</em> no
programa quando o usuÃ¡rio insere uma entrada nÃ£o numÃ©rica, vamos fazer o jogo
ignorÃ¡-la para que o usuÃ¡rio possa continuar tentando. Podemos fazer isso
alterando a linha em que o <code>palpite</code> Ã© convertido de <code>String</code> para <code>u32</code>:</p>
<pre><code class="language-rust ignore">let palpite: u32 = match palpite.trim().parse() {
    Ok(num) =&gt; num,
    Err(_) =&gt; continue,
};
</code></pre>
<p>Trocando uma chamada a <code>expect</code> por uma expressÃ£o <code>match</code> Ã© a forma como vocÃª
geralmente deixa de causar um <em>crash</em> em um erro e passa a tratÃ¡-lo, de fato.
Lembre-se que o mÃ©todo <code>parse</code> retorna um valor do tipo <code>Result</code>, uma enum que
contÃ©m a variante <code>Ok</code> ou <code>Err</code>. Estamos usando um <code>match</code> aqui, assim como
fizemos com o <code>Ordering</code> resultante do mÃ©todo <code>cmp</code>.</p>
<p>Se o <code>parse</code> consegue converter a string em um nÃºmero, ele vai retornar um <code>Ok</code>
contendo o nÃºmero resultante. Esse valor <code>Ok</code> vai casar com o padrÃ£o do primeiro
braÃ§o, e o <code>match</code> vai apenas retornar o valor <code>num</code> produzido pelo <code>parse</code> e
colocado dentro do <code>Ok</code>. Esse nÃºmero vai acabar ficando exatamente onde
queremos, na variÃ¡vel <code>palpite</code> que estamos criando.</p>
<p>Se o <code>parse</code> <em>nÃ£o</em> conseguir converter a string em um nÃºmero, ele vai retornar
um <code>Err</code> que contÃ©m mais informaÃ§Ãµes sobre o erro. O valor <code>Err</code> nÃ£o casa com o
padrÃ£o <code>Ok(num)</code> do primeiro braÃ§o do <code>match</code>, mas casa com o padrÃ£o <code>Err(_)</code> do
segundo braÃ§o. O <code>_</code> Ã© um valor &quot;pega tudo&quot;. Neste exemplo, estamos dizendo que
queremos casar todos os valores <code>Err</code>, nÃ£o importa qual informaÃ§Ã£o hÃ¡ dentro
deles. EntÃ£o o programa vai executar o cÃ³digo do segundo braÃ§o, <code>continue</code>, que
significa ir para a prÃ³xima iteraÃ§Ã£o do <code>loop</code> e pedir outro palpite.
Efetivamente, o programa ignora todos os erros que o <code>parse</code> vier a encontrar!</p>
<p>Agora, tudo no programa deve funcionar como esperado. Vamos tentar executÃ¡-lo
usando o comando <code>cargo run</code>:</p>
<pre><code class="language-text">$ cargo run
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
     Running `target/jogo_de_advinhacao`
Advinhe o nÃºmero!
O nÃºmero secreto Ã©: 61
Digite o seu palpite.
10
VocÃª disse: 10
Muito baixo!
Digite o seu palpite.
99
VocÃª disse: 99
Muito alto!
Digite o seu palpite.
foo
Digite o seu palpite.
61
VocÃª disse: 61
VocÃª acertou!
</code></pre>
<p>Demais! Com apenas um Ãºltimo ajuste, vamos finalizar o jogo de adivinhaÃ§Ã£o:
lembre-se que o programa ainda estÃ¡ mostrando o nÃºmero secreto. Isto foi bom
para testar, mas estraga o jogo. Vamos apagar o <code>println!</code> que revela o nÃºmero
secreto. A Listagem 2-5 mostra o cÃ³digo final:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Advinhe o nÃºmero!&quot;);

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    loop {
        println!(&quot;Digite o seu palpite.&quot;);

        let mut palpite = String::new();

        io::stdin().read_line(&amp;mut palpite)
            .expect(&quot;Falha ao ler entrada&quot;);

        let palpite: u32 = match palpite.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;VocÃª disse: {}&quot;, palpite);

        match palpite.cmp(&amp;numero_secreto) {
            Ordering::Less =&gt; println!(&quot;Muito baixo!&quot;),
            Ordering::Greater =&gt; println!(&quot;Muito alto!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;VocÃª acertou!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p><span class="caption">Listagem 2-5: CÃ³digo completo do jogo de advinhaÃ§Ã£o.
</span></p>
<a class="header" href="ch02-00-guessing-game-tutorial.html#resumo" id="resumo"><h2>Resumo</h2></a>
<p>Neste ponto, vocÃª construiu com sucesso o jogo de adivinhaÃ§Ã£o! ParabÃ©ns!</p>
<p>Este projeto foi uma forma prÃ¡tica de apresentar vÃ¡rios conceitos novos de Rust:
<code>let</code>, <code>match</code>, mÃ©todos, funÃ§Ãµes associadas, uso de crates externos, e outros.
Nos prÃ³ximos capÃ­tulos, vocÃª vai aprender sobre esses conceitos em mais
detalhes. O CapÃ­tulo 3 aborda conceitos que a maioria das linguagens de
programaÃ§Ã£o tem, como variÃ¡veis, tipos de dados e funÃ§Ãµes, e mostra como usÃ¡-los
em Rust. O CapÃ­tulo 4 explora posse (<em>ownership</em>), que Ã© a caracterÃ­stica do
Rust mais diferente das outras linguagens. O CapÃ­tulo 5 discute structs e a
sintaxe de mÃ©todos, e o CapÃ­tulo 6 se dedica a explicar enums.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch01-02-hello-world.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch03-00-common-programming-concepts.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="ch01-02-hello-world.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="ch03-00-common-programming-concepts.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if (getComputedStyle(document.querySelector(".fa")).fontFamily !== "FontAwesome") {
                var link = document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = '_FontAwesome/css/font-awesome.css';
                document.head.insertBefore(link, document.head.firstChild)
            }
        </script>

        

        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
