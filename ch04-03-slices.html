<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>ğŸ‡§ğŸ‡· Slices - </title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme;
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            document.querySelector('html').classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="ch01-00-introduction.html"><strong aria-hidden="true">1.</strong> ğŸ‡§ğŸ‡· IntroduÃ§Ã£o</a></li><li><ol class="section"><li><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> ğŸ‡§ğŸ‡· InstalaÃ§Ã£o</a></li><li><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> ğŸ‡§ğŸ‡· OlÃ¡, Mundo!</a></li></ol></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> ğŸ‡§ğŸ‡· Jogo de AdivinhaÃ§Ã£o</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> ğŸ‡§ğŸ‡· Conceitos Comuns de ProgramaÃ§Ã£o</a></li><li><ol class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> ğŸ‡§ğŸ‡· VariÃ¡veis e Mutabilidade</a></li><li><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> ğŸ‡§ğŸ‡· Tipos de dados</a></li><li><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> ğŸ‡§ğŸ‡· FunÃ§Ãµes</a></li><li><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> ğŸ‡§ğŸ‡· ComentÃ¡rios</a></li><li><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> ğŸ‡§ğŸ‡· Controle de fluxo</a></li></ol></li><li><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> ğŸ‡§ğŸ‡· Entendendo Ownership</a></li><li><ol class="section"><li><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> ğŸ‡§ğŸ‡· O Que Ã‰ Ownership?</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> ğŸ‡§ğŸ‡· ReferÃªncias e Borrowing</a></li><li><a href="ch04-03-slices.html" class="active"><strong aria-hidden="true">4.3.</strong> ğŸ‡§ğŸ‡· Slices</a></li></ol></li><li><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> ğŸ‡§ğŸ‡· Structs</a></li><li><ol class="section"><li><a href="ch05-01-method-syntax.html"><strong aria-hidden="true">5.1.</strong> Method Syntax</a></li></ol></li><li><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> ğŸ‡§ğŸ‡· Enums e Casamento de PadrÃµes</a></li><li><ol class="section"><li><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> ğŸ‡§ğŸ‡· Definindo uma Enum</a></li><li><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> ğŸ‡§ğŸ‡· Operador match</a></li><li><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> ğŸ‡§ğŸ‡· Controle de Fluxo Conciso com if let</a></li></ol></li><li><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> ğŸ‡§ğŸ‡· MÃ³dulos</a></li><li><ol class="section"><li><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> ğŸ‡§ğŸ‡· mod e o Sistema de Arquivos</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> ğŸ‡§ğŸ‡· Controlando a Visibilidade com pub</a></li><li><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> ğŸ‡§ğŸ‡· Importando nomes com use</a></li></ol></li><li><a href="ch08-00-fundamental-collections.html"><strong aria-hidden="true">8.</strong> Fundamental Collections</a></li><li><ol class="section"><li><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> ğŸ‡§ğŸ‡· Vetores</a></li><li><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> ğŸ‡§ğŸ‡· Strings</a></li><li><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> ğŸ‡§ğŸ‡· Hash Maps</a></li></ol></li><li><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> ğŸ‡§ğŸ‡· Tratamento de Erros</a></li><li><ol class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> ğŸ‡§ğŸ‡· Erros IrrecuperÃ¡veis com panic!</a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> ğŸ‡§ğŸ‡· Erros recuperÃ¡veis com Result</a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> ğŸ‡§ğŸ‡· Entrar em panic! ou NÃ£o Entrar em panic!</a></li></ol></li><li><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> ğŸ‡§ğŸ‡· Tipos GenÃ©ricos, Traits, e Tempos de vida (Lifetimes)</a></li><li><ol class="section"><li><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> ğŸ‡§ğŸ‡· Tipos GenÃ©ricos de Dados</a></li><li><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> ğŸ‡§ğŸ‡· Traits: Definindo Comportamento Compartilhado</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> ğŸ‡§ğŸ‡· Validating References with Lifetimes</a></li></ol></li><li><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Writing tests</a></li><li><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Running tests</a></li><li><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project</a></li><li><ol class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Improving Error Handling and Modularity</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Testing the Library's Functionality</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing to stderr instead of stdout</a></li></ol></li><li><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features in Rust</a></li><li><ol class="section"><li><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures</a></li><li><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Iterators</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving our I/O Project</a></li><li><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performance</a></li></ol></li><li><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Release Profiles</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> ğŸ‡§ğŸ‡· Ponteiros Inteligentes (Smart Pointers)</a></li><li><ol class="section"><li><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> ğŸ‡§ğŸ‡· Box<T> Aponta para Dados no Heap e Tem Tamanho Conhecido</a></li><li><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> ğŸ‡§ğŸ‡· Tratando Ponteiros Inteligentes como ReferÃªncias Normais com a Trait Deref</a></li><li><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> ğŸ‡§ğŸ‡· A Trait Drop Roda CÃ³digo durante a Limpeza</a></li><li><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> ğŸ‡§ğŸ‡· Rc<T>, o Ponteiro Inteligente com Contagem de ReferÃªncias</a></li><li><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> ğŸ‡§ğŸ‡· RefCell<T> e a Pattern de Mutabilidade Interior</a></li><li><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> ğŸ‡§ğŸ‡· Ciclos de ReferÃªncias Podem Vazar MemÃ³ria</a></li></ol></li><li><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrency</a></li><li><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> ğŸ‡§ğŸ‡· Rust Ã© uma linguagem orientada a objetos?</a></li><li><ol class="section"><li><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> ğŸ‡§ğŸ‡· O que significa orientado a objetos?</a></li><li><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> ğŸ‡§ğŸ‡· Usando objetos trait que permitem valores de tipos diferentes</a></li><li><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> ğŸ‡§ğŸ‡· Implementando um padrÃ£o de projeto orientado a objetos</a></li></ol></li><li><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns</a></li><li><a href="ch19-00-more-lifetimes.html"><strong aria-hidden="true">19.</strong> More Lifetimes</a></li><li><a href="ch20-00-advanced-types.html"><strong aria-hidden="true">20.</strong> Advanced Type System Features</a></li><li><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> Keywords</a></li><li><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> Operators</a></li><li><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> Derivable Traits</a></li><li><a href="appendix-04-nightly-rust.html"><strong aria-hidden="true">21.4.</strong> Nightly Rust</a></li><li><a href="appendix-05-macros.html"><strong aria-hidden="true">21.5.</strong> Macros</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="submenu">
                                <li><button class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li><button class="theme" id="rust">Rust</button></li>
                                <li><button class="theme" id="coal">Coal</button></li>
                                <li><button class="theme" id="navy">Navy</button></li>
                                <li><button class="theme" id="ayu">Ayu</button></li>
                            </ul>
                        </div>

                        <h1 class="menu-title"></h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="ch04-03-slices.html#slices" id="slices"><h2><em>Slices</em></h2></a>
<p>Outro tipo de dados em que nÃ£o hÃ¡ ownership Ã© a <em>slice</em> (do inglÃªs, fatia).
Slices lhe permitem referenciar uma sequÃªncia contÃ­gua de elementos em uma
coleÃ§Ã£o em vez de referenciar a coleÃ§Ã£o inteira.</p>
<p>Aqui estÃ¡ um pequeno problema de programaÃ§Ã£o: escrever uma funÃ§Ã£o que pega uma
string e retorna a primeira palavra que encontrar dentro dela. Se a funÃ§Ã£o nÃ£o
encontrar um espaÃ§o na string, significa que a string inteira Ã© uma palavra sÃ³,
entÃ£o a string toda deve ser retornada.</p>
<p>Vamos pensar sobre a assinatura desta funÃ§Ã£o:</p>
<pre><code class="language-rust ignore">fn primeira_palavra(s: &amp;String) -&gt; ?
</code></pre>
<p>Esta funÃ§Ã£o, <code>primeira_palavra</code>, tem uma <code>&amp;String</code> como parÃ¢metro. NÃ³s nÃ£o
queremos tomar posse dela, entÃ£o tudo bem. Mas o que nÃ³s deverÃ­amos retornar?
NÃ£o temos uma forma de falar sobre <em>parte</em> de uma string. No entanto, poderÃ­amos
retornar o Ã­ndice do final de uma palavra. Vamos tentar fazer isso, conforme
mostrado na Listagem 4-5:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn primeira_palavra(s: &amp;String) -&gt; usize {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
#}</code></pre></pre>
<p><span class="caption">Listagem 4-5: A funÃ§Ã£o <code>primeira_palavra</code>, que retorna um
Ã­ndice para um byte da <code>String</code> passada como parÃ¢metro.</span></p>
<p>Vamos dividir este cÃ³digo em algumas partes. Como precisamos varrer a <code>String</code>
elemento por elemento, e verificar se algum valor Ã© um espaÃ§o, vamos converter
nossa <code>String</code> em um array de bytes usando o mÃ©todo <code>as_bytes</code>:</p>
<pre><code class="language-rust ignore">let bytes = s.as_bytes();
</code></pre>
<p>Depois, criamos um iterador sobre o array de bytes usando o mÃ©todo <code>iter</code>:</p>
<pre><code class="language-rust ignore">for (i, &amp;item) in bytes.iter().enumerate() {
</code></pre>
<p>Vamos discutir sobre iteradores em mais detalhes no CapÃ­tulo 13. Por enquanto,
saiba que <code>iter</code> Ã© um mÃ©todo que retorna cada elemento em uma coleÃ§Ã£o, e
<code>enumerate</code> encapsula o resultado do <code>iter</code> e retorna cada elemento como parte
de uma tupla. O primeiro elemento da tupla Ã© o Ã­ndice, e o segundo elemento Ã©
uma referÃªncia ao valor. Isto Ã© um pouco mais conveniente do que calcular o
Ã­ndice nÃ³s mesmos.</p>
<p>Como o mÃ©todo <code>enumerate</code> retorna uma tupla, podemos usar padrÃµes para
desestruturar esta tupla, assim como qualquer outra coisa em Rust. EntÃ£o, no
<code>for</code>, especificamos um padrÃ£o que tem <code>i</code> para o Ã­ndice na tupla e <code>&amp;item</code> para
o byte. Como pegamos uma referÃªncia ao elemento atravÃ©s do
<code>.iter().enumerate()</code>, usamos um <code>&amp;</code> neste padrÃ£o.</p>
<p>NÃ³s procuramos o byte que representa um espaÃ§o usando a sintaxe de byte literal.
Se encontrarmos um espaÃ§o, retornamos a posiÃ§Ã£o dele. Caso contrÃ¡rio, retornamos
o tamanho da string usando <code>s.len()</code>:</p>
<pre><code class="language-rust ignore">    if item == b' ' {
        return i;
    }
}
s.len()
</code></pre>
<p>Agora temos uma forma de descobrir o Ã­ndice do fim da primeira palavra na
string, mas tem um problema. Estamos retornando um <code>usize</code> por si sÃ³, mas ele sÃ³
possui um significado no contexto da <code>&amp;String</code>. Em outras palavras, como Ã© um
valor separado da <code>String</code>, nÃ£o hÃ¡ garantia de que ele ainda serÃ¡ vÃ¡lido no
futuro. Considere o programa na Listagem 4-6, que usa a funÃ§Ã£o da Listagem 4-5:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn primeira_palavra(s: &amp;String) -&gt; usize {
#     let bytes = s.as_bytes();
#
#     for (i, &amp;item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return i;
#         }
#     }
#
#     s.len()
# }
#
fn main() {
    let mut s = String::from(&quot;texto longo&quot;);

    let palavra = primeira_palavra(&amp;s); // palavra vai ter o valor 5.

    s.clear(); // Isso esvazia a String, deixando ela igual a &quot;&quot;.

    // palavra ainda tem o valor 5 aqui, mas jÃ¡ nÃ£o hÃ¡ mais uma string para a
    // qual o valor 5 faÃ§a algum sentido. palavra agora Ã© totalmente invÃ¡lida!
}
</code></pre></pre>
<p><span class="caption">Listagem 4-6: Armazenando o resultado de uma chamada Ã 
funÃ§Ã£o <code>primeira_palavra</code>, e depois, mudando o conteÃºdo da <code>String</code>.</span></p>
<p>Este programa compila sem erros, e tambÃ©m o faria se usÃ¡ssemos a variÃ¡vel
<code>palavra</code> depois de chamar <code>s.clear()</code>. <code>palavra</code> nÃ£o estÃ¡ conectada ao estado
de <code>s</code> de nenhuma forma, entÃ£o, <code>palavra</code> ainda contÃ©m o valor <code>5</code>. PoderÃ­amos
usar esse valor <code>5</code> com a variÃ¡vel <code>s</code> para tentar extrair a primeira palavra da
string, mas isso seria um bug, pois o conteÃºdo de <code>s</code> jÃ¡ mudou apÃ³s termos salvo
o valor <code>5</code> na variÃ¡vel <code>word</code>.</p>
<p>Ter que se preocupar sobre o Ã­ndice da <code>palavra</code> ficar fora de sincronia com os
dados em <code>s</code> Ã© tedioso e propenso a erros! Gerenciar esses Ã­ndices Ã© ainda mais
delicado se escrevermos uma funÃ§Ã£o <code>segunda_palavra</code>. Sua assinatura teria que
ser algo do tipo:</p>
<pre><code class="language-rust ignore">fn segunda_palavra(s: &amp;String) -&gt; (usize, usize) {
</code></pre>
<p>Agora estamos rastreando os Ã­ndices do inÃ­cio <em>e</em> do final, e temos ainda mais
valores que sÃ£o calculados a partir dos dados em um estado particular, mas que
nÃ£o estÃ£o vinculados a este estado de nenhuma forma. Agora temos trÃªs variÃ¡veis
nÃ£o relacionadas flutuando que precisam ser mantidas em sincronia.</p>
<p>Felizmente, Rust possui uma soluÃ§Ã£o para este problema: slices de string.</p>
<a class="header" href="ch04-03-slices.html#slices-de-string" id="slices-de-string"><h3>Slices de String</h3></a>
<p>Uma <em>slice de string</em> Ã© uma referÃªncia para uma parte de uma <code>String</code>, e tem a
seguinte forma:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;texto longo&quot;);

let texto = &amp;s[0..5];
let longo = &amp;s[6..11];
#}</code></pre></pre>
<p>Isto Ã© similar a pegar uma referÃªncia Ã  <code>String</code> inteira, mas com um <code>[0..5]</code> a
mais. Em vez de uma referÃªncia Ã  <code>String</code> inteira, trata-se de uma referÃªncia a
uma porÃ§Ã£o da <code>String</code>. A sintaxe <code>inÃ­cio..fim</code> representa um <em>range</em>
(uma faixa) que comeÃ§a em <code>inÃ­cio</code> e continua atÃ©, mas nÃ£o incluindo, <code>fim</code>.</p>
<p>Podemos criar slices usando um range entre colchetes especificando
<code>[Ã­ndice_inicial..Ã­ndice_final]</code>, em que <code>Ã­ndice_inicial</code> Ã© a primeira posiÃ§Ã£o
inclusa na slice, e <code>Ã­ndice_final</code> Ã© um a mais que a Ãºltima posiÃ§Ã£o inclusa na
slice. Internamente, a estrutura de dados de uma slice armazena a posiÃ§Ã£o
inicial e o tamanho da slice, que corresponde a <code>Ã­ndice_final</code> menos
<code>Ã­ndice_inicial</code>. EntÃ£o, no caso do <code>let longo = &amp;s[6..11];</code>, <code>longo</code> seria uma
slice que contÃ©m um ponteiro para o sÃ©timo byte de <code>s</code> (Ã­ndice 6) e um tamanho
igual a 5.</p>
<p>A Figura 4-6 mostra isto em um diagrama.</p>
<p><img alt="mundo contendo um ponteiro para o 7o byte da String s e um tamanho 5" src="img/trpl04-06.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Figura 4-6: Slice referente a uma parte de uma
<code>String</code></span></p>
<p>Com a sintaxe de range do Rust (<code>..</code>), se vocÃª quiser comeÃ§ar com o primeiro
elemento (Ã­ndice zero), vocÃª pode omitir o valor antes dos dois pontos. Em
outras palavras, estas formas sÃ£o equivalentes:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;texto&quot;);

let slice = &amp;s[0..2];
let slice = &amp;s[..2];
#}</code></pre></pre>
<p>Da mesma forma, se a sua slice inclui o Ãºltimo byte da <code>String</code>, vocÃª pode
omitir o Ãºltimo nÃºmero. Isso significa que as seguintes formas sÃ£o equivalentes:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;texto&quot;);

let tamanho = s.len();

let slice = &amp;s[3..tamanho];
let slice = &amp;s[3..];
#}</code></pre></pre>
<p>VocÃª tambÃ©m pode omitir ambos os valores para pegar uma slice da string inteira.
Logo, essas duas formas sÃ£o equivalentes:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;texto&quot;);

let tamanho = s.len();

let slice = &amp;s[0..tamanho];
let slice = &amp;s[..];
#}</code></pre></pre>
<blockquote>
<p>Nota: Os Ã­ndices do range de uma slice de string devem coincidir com os
limites entre caracteres UTF-8 vÃ¡lidos. Se vocÃª tentar criar uma slice de
string no meio de um caractere que tenha mais de um byte, seu programa vai
terminar com erro. Para introduzir slices de string, estamos utilizando
apenas caracteres ASCII nesta seÃ§Ã£o; uma discussÃ£o mais detalhada sobre
manipulaÃ§Ã£o de caracteres UTF-8 serÃ¡ feita na seÃ§Ã£o &quot;Strings&quot; do CapÃ­tulo 8.</p>
</blockquote>
<p>Com toda essa informaÃ§Ã£o em mente, vamos reescrever a funÃ§Ã£o <code>primeira_palavra</code>
para retornar uma slice. O tipo que representa &quot;slice de string&quot; Ã© escrito como
<code>&amp;str</code>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn primeira_palavra(s: &amp;String) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
#}</code></pre></pre>
<p>Pegamos o Ã­ndice para o fim da palavra da mesma forma como fizemos na Listagem
4-5, buscando a primeira ocorrÃªncia de um espaÃ§o. Quando o encontramos,
retornamos uma slice de string usando o inÃ­cio da string e o Ã­ndice do espaÃ§o
como Ã­ndices inicial e final, respectivamente.</p>
<p>Agora, quando chamamos <code>primeira_palavra</code>, pegamos de volta um Ãºnico valor que
estÃ¡ vinculado Ã  string. O valor Ã© composto de uma referÃªncia para o ponto
inicial da slice e o nÃºmero de elementos que ela contÃ©m.</p>
<p>Retornar uma slice tambÃ©m funcionaria para uma funÃ§Ã£o <code>segunda_palavra</code>:</p>
<pre><code class="language-rust ignore">fn segunda_palavra(s: &amp;String) -&gt; &amp;str {
</code></pre>
<p>Agora, temos uma API bem direta que Ã© bem mais difÃ­cil de bagunÃ§ar, uma vez que
o compilador vai se certificar que as referÃªncias dentro da <code>String</code>
permanecerÃ£o vÃ¡lidas. Lembra do bug do programa na Listagem 4-6, quando
obtivemos o Ã­ndice para o fim da primeira palavra mas depois limpamos a string,
invalidando o Ã­ndice obtido? Aquele cÃ³digo era logicamente incorreto, mas nÃ£o
mostrava nenhum erro imediato. Os problemas apareceriam mais tarde quando
tentÃ¡ssemos usar o Ã­ndice da primeira palavra com uma string que foi esvaziada.
Slices tornam esse bug impossÃ­vel de acontecer e nos permitem saber que temos um
problema no cÃ³digo muito mais cedo. Na versÃ£o usando slice, a funÃ§Ã£o
<code>primeira_palavra</code> vai lanÃ§ar um erro em tempo de compilaÃ§Ã£o:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let mut s = String::from(&quot;texto longo&quot;);

    let palavra = first_word(&amp;s);

    s.clear(); // Erro!
}
</code></pre>
<p>Aqui estÃ¡ o erro:</p>
<pre><code class="language-text">error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:5
  |
4 |     let word = primeira_palavra(&amp;s);
  |                                  - immutable borrow occurs here
5 |
6 |     s.clear(); // Erro!
  |     ^ mutable borrow occurs here
7 | }
  | - immutable borrow ends here
</code></pre>
<p>Voltando Ã s regras de borrowing, lembre-se que, se temos uma referÃªncia imutÃ¡vel
para algum valor, nÃ£o podemos tambÃ©m obter uma referÃªncia mutÃ¡vel do mesmo. Como
<code>clear</code> precisa truncar a <code>String</code>, esse mÃ©todo tenta obter uma referÃªncia
mutÃ¡vel, e acaba falhando. O Rust nÃ£o sÃ³ tornou nossa API mais fÃ¡cil de usar,
como tambÃ©m eliminou uma classe inteira de erros em tempo de compilaÃ§Ã£o!</p>
<a class="header" href="ch04-03-slices.html#strings-literais-sÃ£o-slices" id="strings-literais-sÃ£o-slices"><h4>Strings Literais SÃ£o Slices</h4></a>
<p>Lembre-se de que falamos sobre strings literais serem armazenadas dentro do
binÃ¡rio. Agora que conhecemos slices, podemos entender strings literais
adequadamente:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = &quot;OlÃ¡, mundo!&quot;;
#}</code></pre></pre>
<p>O tipo de <code>s</code> aqui Ã© <code>&amp;str</code>: Ã© uma slice apontando para aquele ponto especÃ­fico
do binÃ¡rio. TambÃ©m Ã© por isso que strings literais sÃ£o imutÃ¡veis; <code>&amp;str</code> Ã© uma
referÃªncia imutÃ¡vel.</p>
<a class="header" href="ch04-03-slices.html#slices-de-strings-como-parÃ¢metros" id="slices-de-strings-como-parÃ¢metros"><h4>Slices de Strings como ParÃ¢metros</h4></a>
<p>Saber que vocÃª pode obter slices de literais e <code>String</code>s nos levam a mais um
aprimoramento da funÃ§Ã£o <code>primeira_palavra</code>, e aqui estÃ¡ sua assinatura:</p>
<pre><code class="language-rust ignore">fn primeira_palavra(s: &amp;String) -&gt; &amp;str {
</code></pre>
<p>Um RustÃ¡ceo mais experiente escreveria esta funÃ§Ã£o conforme a seguir, permitindo
utilizar a mesma funÃ§Ã£o com <code>String</code>s e <code>&amp;str</code>s:</p>
<pre><code class="language-rust ignore">fn primeira_palavra(s: &amp;str) -&gt; &amp;str {
</code></pre>
<p>Se temos uma slice de string, podemos passÃ¡-la diretamente. Se temos uma
<code>String</code>, podemos passar uma slice da <code>String</code> inteira. Definir uma funÃ§Ã£o que
recebe uma slice em vez de uma referÃªncia para uma String deixa nossa API mais
genÃ©rica e Ãºtil sem perder nenhuma funcionalidade:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn primeira_palavra(s: &amp;str) -&gt; &amp;str {
#     let bytes = s.as_bytes();
#
#     for (i, &amp;item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return &amp;s[0..i];
#         }
#     }
#
#     &amp;s[..]
# }
fn main() {
    let minha_string = String::from(&quot;texto longo&quot;);

    // primeira_palavra funciona com slices de `String`s
    let palavra = primeira_palavra(&amp;minha_string[..]);

    let minha_string_literal = &quot;texto longo&quot;;

    // primeira_palavra funciona com strings literais
    let palavra = primeira_palavra(&amp;minha_string_literal[..]);
    
    // uma vez que strings literais *sÃ£o* slices de strings,
    // isso tambÃ©m funciona, sem nem usar sintaxe de slice!
    let palavra = primeira_palavra(minha_string_literal);
}
</code></pre></pre>
<a class="header" href="ch04-03-slices.html#outras-slices" id="outras-slices"><h3>Outras Slices</h3></a>
<p>Slices de string, como vocÃª pode imaginar, sÃ£o especÃ­ficas de strings. Mas hÃ¡
tambÃ©m um tipo de slice mais genÃ©rico. Considere esta array:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a = [1, 2, 3, 4, 5];
#}</code></pre></pre>
<p>Assim como Ã s vezes queremos nos referir a uma parte de uma string, podemos
tambÃ©m querer nos referir a uma parte de uma array, e farÃ­amos isso da seguinte
forma:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];
#}</code></pre></pre>
<p>Essa slice tem o tipo <code>&amp;[i32]</code>. Ela funciona da mesma forma que as slices de
string, armazenando uma referÃªncia para o primeiro elemento e um tamanho. VocÃª
vai usar esse tipo de slice para todos os tipos de coleÃ§Ãµes. Vamos discutir
essas coleÃ§Ãµes em mais detalhe quando falarmos sobre vetores no CapÃ­tulo 8.</p>
<a class="header" href="ch04-03-slices.html#resumo" id="resumo"><h2>Resumo</h2></a>
<p>Os conceitos de ownership, borrowing, e slices sÃ£o o que garante a seguranÃ§a de
memÃ³ria dos programas em Rust em tempo de compilaÃ§Ã£o. A linguagem Rust lhe dÃ¡
controle sobre o uso da memÃ³ria, assim como outras linguagens de programaÃ§Ã£o de
sistemas, mas como o dono dos dados limpa automaticamente a memÃ³ria quando ele
sai de escopo, vocÃª nÃ£o tem que escrever e debugar cÃ³digo extra para ter esse
controle.</p>
<p>O ownership afeta o funcionamento de vÃ¡rias outras partes do Rust, por isso
vamos falar um pouco mais sobre esses conceitos neste livro daqui para a frente.
Vamos seguir para o prÃ³ximo capÃ­tulo e ver como agrupar dados em uma <code>struct</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch04-02-references-and-borrowing.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch05-00-structs.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="ch04-02-references-and-borrowing.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="ch05-00-structs.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if (getComputedStyle(document.querySelector(".fa")).fontFamily !== "FontAwesome") {
                var link = document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = '_FontAwesome/css/font-awesome.css';
                document.head.insertBefore(link, document.head.firstChild)
            }
        </script>

        

        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
