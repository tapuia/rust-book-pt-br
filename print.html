<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title></title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme;
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            document.querySelector('html').classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="ch01-00-introduction.html"><strong aria-hidden="true">1.</strong> ğŸ‡§ğŸ‡· IntroduÃ§Ã£o</a></li><li><ol class="section"><li><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> ğŸ‡§ğŸ‡· InstalaÃ§Ã£o</a></li><li><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> ğŸ‡§ğŸ‡· OlÃ¡, Mundo!</a></li></ol></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> ğŸ‡§ğŸ‡· Jogo de AdivinhaÃ§Ã£o</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> ğŸ‡§ğŸ‡· Conceitos Comuns de ProgramaÃ§Ã£o</a></li><li><ol class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> ğŸ‡§ğŸ‡· VariÃ¡veis e Mutabilidade</a></li><li><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> ğŸ‡§ğŸ‡· Tipos de dados</a></li><li><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> ğŸ‡§ğŸ‡· FunÃ§Ãµes</a></li><li><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> ğŸ‡§ğŸ‡· ComentÃ¡rios</a></li><li><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> ğŸ‡§ğŸ‡· Controle de fluxo</a></li></ol></li><li><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> ğŸ‡§ğŸ‡· Entendendo Ownership</a></li><li><ol class="section"><li><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> ğŸ‡§ğŸ‡· O Que Ã‰ Ownership?</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> ğŸ‡§ğŸ‡· ReferÃªncias e Borrowing</a></li><li><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> ğŸ‡§ğŸ‡· Slices</a></li></ol></li><li><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> ğŸ‡§ğŸ‡· Structs</a></li><li><ol class="section"><li><a href="ch05-01-method-syntax.html"><strong aria-hidden="true">5.1.</strong> Method Syntax</a></li></ol></li><li><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> ğŸ‡§ğŸ‡· Enums e Casamento de PadrÃµes</a></li><li><ol class="section"><li><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> ğŸ‡§ğŸ‡· Definindo uma Enum</a></li><li><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> ğŸ‡§ğŸ‡· Operador match</a></li><li><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> ğŸ‡§ğŸ‡· Controle de Fluxo Conciso com if let</a></li></ol></li><li><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> ğŸ‡§ğŸ‡· MÃ³dulos</a></li><li><ol class="section"><li><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> ğŸ‡§ğŸ‡· mod e o Sistema de Arquivos</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> ğŸ‡§ğŸ‡· Controlando a Visibilidade com pub</a></li><li><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> ğŸ‡§ğŸ‡· Importando nomes com use</a></li></ol></li><li><a href="ch08-00-fundamental-collections.html"><strong aria-hidden="true">8.</strong> Fundamental Collections</a></li><li><ol class="section"><li><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> ğŸ‡§ğŸ‡· Vetores</a></li><li><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> ğŸ‡§ğŸ‡· Strings</a></li><li><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> ğŸ‡§ğŸ‡· Hash Maps</a></li></ol></li><li><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> ğŸ‡§ğŸ‡· Tratamento de Erros</a></li><li><ol class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> ğŸ‡§ğŸ‡· Erros IrrecuperÃ¡veis com panic!</a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> ğŸ‡§ğŸ‡· Erros recuperÃ¡veis com Result</a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> ğŸ‡§ğŸ‡· Entrar em panic! ou NÃ£o Entrar em panic!</a></li></ol></li><li><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> ğŸ‡§ğŸ‡· Tipos GenÃ©ricos, Traits, e Tempos de vida (Lifetimes)</a></li><li><ol class="section"><li><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> ğŸ‡§ğŸ‡· Tipos GenÃ©ricos de Dados</a></li><li><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> ğŸ‡§ğŸ‡· Traits: Definindo Comportamento Compartilhado</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> ğŸ‡§ğŸ‡· Validating References with Lifetimes</a></li></ol></li><li><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Writing tests</a></li><li><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Running tests</a></li><li><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project</a></li><li><ol class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Improving Error Handling and Modularity</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Testing the Library's Functionality</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing to stderr instead of stdout</a></li></ol></li><li><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features in Rust</a></li><li><ol class="section"><li><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures</a></li><li><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Iterators</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving our I/O Project</a></li><li><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performance</a></li></ol></li><li><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Release Profiles</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> ğŸ‡§ğŸ‡· Ponteiros Inteligentes (Smart Pointers)</a></li><li><ol class="section"><li><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> ğŸ‡§ğŸ‡· Box<T> Aponta para Dados no Heap e Tem Tamanho Conhecido</a></li><li><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> ğŸ‡§ğŸ‡· Tratando Ponteiros Inteligentes como ReferÃªncias Normais com a Trait Deref</a></li><li><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> ğŸ‡§ğŸ‡· A Trait Drop Roda CÃ³digo durante a Limpeza</a></li><li><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> ğŸ‡§ğŸ‡· Rc<T>, o Ponteiro Inteligente com Contagem de ReferÃªncias</a></li><li><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> ğŸ‡§ğŸ‡· RefCell<T> e a Pattern de Mutabilidade Interior</a></li><li><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> ğŸ‡§ğŸ‡· Ciclos de ReferÃªncias Podem Vazar MemÃ³ria</a></li></ol></li><li><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrency</a></li><li><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> ğŸ‡§ğŸ‡· Rust Ã© uma linguagem orientada a objetos?</a></li><li><ol class="section"><li><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> ğŸ‡§ğŸ‡· O que significa orientado a objetos?</a></li><li><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> ğŸ‡§ğŸ‡· Usando objetos trait que permitem valores de tipos diferentes</a></li><li><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> ğŸ‡§ğŸ‡· Implementando um padrÃ£o de projeto orientado a objetos</a></li></ol></li><li><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns</a></li><li><a href="ch19-00-more-lifetimes.html"><strong aria-hidden="true">19.</strong> More Lifetimes</a></li><li><a href="ch20-00-advanced-types.html"><strong aria-hidden="true">20.</strong> Advanced Type System Features</a></li><li><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> Keywords</a></li><li><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> Operators</a></li><li><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> Derivable Traits</a></li><li><a href="appendix-04-nightly-rust.html"><strong aria-hidden="true">21.4.</strong> Nightly Rust</a></li><li><a href="appendix-05-macros.html"><strong aria-hidden="true">21.5.</strong> Macros</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="submenu">
                                <li><button class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li><button class="theme" id="rust">Rust</button></li>
                                <li><button class="theme" id="coal">Coal</button></li>
                                <li><button class="theme" id="navy">Navy</button></li>
                                <li><button class="theme" id="ayu">Ayu</button></li>
                            </ul>
                        </div>

                        <h1 class="menu-title"></h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="print.html#comeÃ§ando" id="comeÃ§ando"><h1>ComeÃ§ando</h1></a>
<p>Vamos comeÃ§ar a sua jornada Rust! Neste capÃ­tulo, nÃ³s iremos discutir:</p>
<ul>
<li>A instalaÃ§Ã£o de Rust no Linux, Mac ou Windows</li>
<li>A escrita de um programa que imprime &quot;Hello, world!&quot; na tela</li>
<li>O uso do <code>cargo</code>, o gerenciador de pacote e sistema de compilaÃ§Ã£o</li>
</ul>
<a class="header" href="print.html#instalaÃ§Ã£o" id="instalaÃ§Ã£o"><h2>InstalaÃ§Ã£o</h2></a>
<p>O primeiro passo Ã© instalar Rust. NÃ³s vamos baixar Rust atravÃ©s do <code>rustup</code>,
uma ferramenta de linha de comando para gerenciar versÃµes de Rust e ferramentas
associadas. VocÃª vai precisar de uma conexÃ£o com a internet para executar o
download.</p>
<blockquote>
<p>Nota: se vocÃª prefere nÃ£o usar o <code>rustup</code> por algum motivo, por favor veja o
<a href="https://www.rust-lang.org/tools/install">a pÃ¡gina de instalaÃ§Ã£o de Rust</a>
para outras opÃ§Ãµes.</p>
</blockquote>
<p>Os prÃ³ximos passos irÃ£o instalar a Ãºltima versÃ£o estÃ¡vel do compilador de Rust.
A garantias de estabilidade de Rust certificam-se de que todos os exemplos
neste livro que compilam vao continuar a compilar com novas versÃµes de Rust.
As saÃ­das podem variar um pouco de versÃ£o a versÃ£o, porque Rust frequentemente
melhora mensagens de erro e alertas. Em outras palavras, qualquer versÃ£o nova,
estÃ¡vel, de Rust qu vocÃª instalar usando esses passos devem funcionar como o
esperado com o conteÃºdo deste livro.</p>
<blockquote>
<a class="header" href="print.html#notaÃ§Ã£o-de-linha-de-comando" id="notaÃ§Ã£o-de-linha-de-comando"><h3>NotaÃ§Ã£o de Linha de Comando</h3></a>
<p>Neste capÃ­tulo e ao longo do livro, nÃ³s iremos mostrar alguns comandos usados
no terminal. Linhas que vocÃª deve digitar num terminal todas comeÃ§am com <code>$</code>.
VocÃª nÃ£o precisa digitar o carÃ¡ctere <code>$</code>. Ele indica o inÃ­cio de cada comando.
Linhas que nÃ£o comecem com <code>$</code> tipicamente mostram a saÃ­da do comando anterior.
Adicionalmente, exemplos especÃ­ficos de PowerShell irÃ£o utilizar <code>&gt;</code> ao invÃ©s
de <code>$</code>.</p>
</blockquote>
<a class="header" href="print.html#instalando-rustup-em-linux-ou-mac" id="instalando-rustup-em-linux-ou-mac"><h3>Instalando <code>rustup</code> em Linux ou Mac</h3></a>
<p>Se vocÃª utiliza Linux ou Mac, abra um terminal e digite o seguinte comando:</p>
<pre><code class="language-text">$ curl https://sh.rustup.rs -sSf | sh
</code></pre>
<p>Este comando baixa um script e inicia a instalaÃ§Ã£o da ferramenta <code>rustup</code>, a
qual instala a Ãºltima versÃ£o estÃ¡vel de Rust. Talvez seja solicitado que vocÃª
digite sua senha. Se a instalaÃ§Ã£o for bem-sucedida, a seguinte linha irÃ¡
aparecer:</p>
<pre><code class="language-text">Rust is installed now. Great!
</code></pre>
<p>Se preferir, sinta-se livre para baixar o script e inspecionÃ¡-lo antes de
executar.</p>
<p>O script de instalaÃ§Ã£o adiciona automaticamente Rust Ã  variÃ¡vel PATH do
seu ambiente apÃ³s o seu prÃ³ximo login. Se vocÃª quiser usar Rust imediatamente
ao invÃ©s de reiniciar o seu terminal, execute o seguinte comando no seu shell
para adicionar Rust Ã  PATH do seu sistema manualmente:</p>
<pre><code class="language-text">$ source $HOME/.cargo/env
</code></pre>
<p>Outra opÃ§Ã£o Ã© adicionar a linha abaixo ao seu <code>~/.bash_profile</code>:</p>
<pre><code class="language-text">$ export PATH=&quot;$HOME/.cargo/bin:$PATH&quot;
</code></pre>
<a class="header" href="print.html#instalando-no-windows" id="instalando-no-windows"><h3>Instalando no Windows</h3></a>
<p>No Windows, vÃ¡ atÃ© <a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a> e siga
as instruÃ§Ãµes para instalar Rust. Em algum ponto da instalaÃ§Ã£o, vocÃª receberÃ¡
uma mensagem explicando que vocÃª tambÃ©m irÃ¡ precisar de ferramentas de
compilaÃ§Ã£o de C++ para o Visual Studio 2013 ou superior. A forma mais fÃ¡cil de
adquiri-las Ã© instalando as <a href="https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2019">Ferramentas de CompilaÃ§Ã£o para o Visual
Studio 2019</a>. As ferramentas estÃ£o na seÃ§Ã£o Other Tools and
Frameworks.</p>
<p>O restante deste livro utiliza comandos que funcionam tanto no <em>cmd.exe</em> quanto
no PowerShell. Se existirem diferenÃ§as especÃ­ficas, nÃ³s iremos apontar qual
utilizar.</p>
<a class="header" href="print.html#atualizando-e-desinstalando" id="atualizando-e-desinstalando"><h3>Atualizando e desinstalando</h3></a>
<p>ApÃ³s instalar Rust pelo <code>rustup</code>, atualizar para a Ãºltima versÃ£o Ã© fÃ¡cil.
Do seu seu shell, rode o seguinte script de atualizaÃ§Ã£o:</p>
<pre><code class="language-text">$ rustup update
</code></pre>
<p>Para desinstalar Rust e o <code>rustup</code>, rode o seguinte script de desinstalaÃ§Ã£o do
seu shell:</p>
<pre><code class="language-text">$ rustup self uninstall
</code></pre>
<a class="header" href="print.html#soluÃ§Ã£o-de-problemas" id="soluÃ§Ã£o-de-problemas"><h3>SoluÃ§Ã£o de Problemas</h3></a>
<p>Para checar se vocÃª tem Rust instalado corretamente, abra um terminal e digite
esta linha:</p>
<pre><code class="language-text">$ rustc --version
</code></pre>
<p>VocÃª deverÃ¡ ver o nÃºmero, o hash e a data do commit da Ãºltima versÃ£o estÃ¡vel
lanÃ§ada no seguinte formato:</p>
<pre><code class="language-text">rustc x.y.z (abcabcabc yyyy-mm-dd)
</code></pre>
<p>Se aparecer a mensagem acima, vocÃª instalou Rust com sucesso! Se vocÃª nÃ£o ver
esta informaÃ§Ã£o e vocÃª estiver no Windows, cheque que Rust estÃ¡ na sua variÃ¡vel
de ambiente <code>%PATH%</code>. Se tudo isso estiver correto e Rust ainda nÃ£o funcionar,
existem vÃ¡rios locais em que vocÃª pode pedir ajuda. O mais fÃ¡cil Ã© o canal
#beginners no <a href="https://discord.gg/rust-lang">Discord oficial de Rust</a>. LÃ¡, vocÃª pode falar com
outros RustÃ¡ceos (um apelido bobo que damos a nÃ³s mesmos) que podem te ajudar.
Outros Ã³timos recursos incluem <a href="https://users.rust-lang.org/">o fÃ³rum de usÃ¡rios</a> e o <a href="http://stackoverflow.com/questions/tagged/rust">Stack
Overflow</a>.</p>
<a class="header" href="print.html#documentaÃ§Ã£o-local" id="documentaÃ§Ã£o-local"><h3>DocumentaÃ§Ã£o local</h3></a>
<p>O instalador tambÃ©m inclui uma cÃ³pia local da documentaÃ§Ã£o para que vocÃª possa
acessÃ¡-la offline. Execute o comando <code>rustup doc</code> para abrir a documentaÃ§Ã£o no
seu navegador.</p>
<p>Sempre que um tipo ou for fornecido pela biblioteca padrÃ£o e vocÃª nÃ£o tiver
certeza do que ele faz ou de como usÃ¡-lo, use a documentaÃ§Ã£o da API para
descobrir!</p>
<!-- ## Hello, World!
<p>Now that youâ€™ve installed Rust, letâ€™s write your first Rust program. Itâ€™s
traditional when learning a new language to write a little program that prints
the text <code>Hello, world!</code> to the screen, so weâ€™ll do the same here!</p>
<blockquote>
<p>Note: This book assumes basic familiarity with the command line. Rust makes
no specific demands about your editing or tooling or where your code lives, so
if you prefer to use an integrated development environment (IDE) instead of
the command line, feel free to use your favorite IDE. Many IDEs now have some
degree of Rust support; check the IDEâ€™s documentation for details. Recently,
the Rust team has been focusing on enabling great IDE support, and progress
has been made rapidly on that front! --&gt;</p>
</blockquote>
<a class="header" href="print.html#olÃ¡-mundo" id="olÃ¡-mundo"><h2>OlÃ¡, Mundo!</h2></a>
<p>Agora que Rust jÃ¡ estÃ¡ instalado, vamos escrever seu primeiro programa Rust.
Quando aprendemos uma nova linguagem de programaÃ§Ã£o, Ã© tradicional escrever um
pequeno programa que imprime &quot;OlÃ¡, mundo!&quot; (<em>â€œHello, world!â€</em>) na tela, e vamos
fazer o mesmo aqui.</p>
<blockquote>
<p>Nota: Este livro assume que o leitor tem um pouco de familiaridade com a
linha de comando. Rust nÃ£o faz nenhuma demanda a respeito do seu editor ou
ferramentas ou sobre onde seu cÃ³digo mora, entÃ£o se vocÃª preferir usar uma
IDE ao invÃ©s da linha de comando, sinta-se livre para usar sua IDE favorita.
Muitas IDEs tÃªm agora algum nÃ­vel de suporte a Rust. Cheque  a documentaÃ§Ã£o
da IDE para detalhes. Recentemente o time Rust tem focado em habilitar um
Ã³timo suporte a IDEs, e progresso tem sido rapidamente feito nesse front!</p>
</blockquote>
<!-- ### Creating a Project Directory
<p>Youâ€™ll start by making a directory to store your Rust code. It doesnâ€™t matter
to Rust where your code lives, but for the exercises and projects in this book,
we suggest making a <em>projects</em> directory in your home directory and keeping all
your projects there.</p>
<p>Open a terminal and enter the following commands to make a <em>projects</em> directory
and a directory for the Hello, world! project within the <em>projects</em> directory.</p>
<p>For Linux, macOS, and PowerShell on Windows, enter this:</p>
<pre><code class="language-text">$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
</code></pre>
<p>For Windows CMD, enter this:</p>
<pre><code class="language-cmd">&gt; mkdir &quot;%USERPROFILE%\projects&quot;
&gt; cd /d &quot;%USERPROFILE%\projects&quot;
&gt; mkdir hello_world
&gt; cd hello_world
</code></pre>
<p>--&gt;</p>
<a class="header" href="print.html#criando-um-diretÃ³rio-de-projeto" id="criando-um-diretÃ³rio-de-projeto"><h3>Criando um DiretÃ³rio de Projeto</h3></a>
<p>VocÃª irÃ¡ comeÃ§ar criando um diretÃ³rio para guardar seu cÃ³digo Rust. NÃ£o importa
para Rust onde seu cÃ³digo vive, mas para os exercÃ­cios e projetos neste livro,
nÃ³s sugerimos criar um diretÃ³rio <em>projects</em> no seu diretÃ³rio principal e manter
todo o seus projetos lÃ¡.</p>
<p>Abra um terminal e digite os seguintes comandos para criar um diretÃ³rio
<em>projects</em> e um diretÃ³rio para o projeto &quot;Hello, world!&quot; dentro do diretÃ³rio
<em>projects</em>.</p>
<p>Para Linux, macOS, e PowerShell no Windows, digite o seguinte:</p>
<pre><code class="language-text">$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
</code></pre>
<p>No CMD do Windows, digite o seguinte:</p>
<pre><code class="language-cmd">&gt; mkdir &quot;%USERPROFILE%\projects&quot;
&gt; cd /d &quot;%USERPROFILE%\projects&quot;
&gt; mkdir hello_world
&gt; cd hello_world
</code></pre>
<!-- ### Writing and Running a Rust Program
<p>Next, make a new source file and call it <em>main.rs</em>. Rust files always end with
the <em>.rs</em> extension. If youâ€™re using more than one word in your filename, use
an underscore to separate them. For example, use <em>hello_world.rs</em> rather than
<em>helloworld.rs</em>.</p>
<p>Now open the <em>main.rs</em> file you just created and enter the code in Listing 1-1.</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p><span class="caption">Listing 1-1: A program that prints <code>Hello, world!</code></span></p>
<p>Save the file and go back to your terminal window. On Linux or macOS, enter
the following commands to compile and run the file:</p>
<pre><code class="language-text">$ rustc main.rs
$ ./main
Hello, world!
</code></pre>
<p>On Windows, enter the command <code>.\main.exe</code> instead of <code>./main</code>:</p>
<pre><code class="language-powershell">&gt; rustc main.rs
&gt; .\main.exe
Hello, world!
</code></pre>
<p>Regardless of your operating system, the string <code>Hello, world!</code> should print to
the terminal. If you donâ€™t see this output, refer back to the
<a href="ch01-01-installation.html#troubleshooting">â€œTroubleshootingâ€</a> part of the Installation
section for ways to get help.</p>
<p>If <code>Hello, world!</code> did print, congratulations! Youâ€™ve officially written a Rust
program. That makes you a Rust programmerâ€”welcome! --&gt;</p>
<a class="header" href="print.html#escrevendo-e-executando-um-programa-rust" id="escrevendo-e-executando-um-programa-rust"><h3>Escrevendo e Executando um Programa Rust</h3></a>
<p>Crie um novo arquivo <em>main.rs</em>. Arquivos Rust sempre terminam com a extensÃ£o
<em>.rs</em>. Se o nome do seu arquivo tem mais de uma palavra, use um <em>underscore</em>
para separÃ¡-los. Por exemplo, vocÃª deve nomear o seu arquivo <em>hello_world.rs</em>
em vez de <em>helloworld.rs</em>.</p>
<p>Agora abra o arquivo <em>main.rs</em> que vocÃª acabou de criar e digite o cÃ³digo na
Listagem 1-1:</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p><span class="caption">Listagem 1-1: Um programa que imprime <code>Hello, world!</code></span></p>
<p>Salve o arquivo e volte ao seu terminal. No Linux ou macOS, digite os seguintes
comandos para compilar e rodar o arquivo:</p>
<pre><code class="language-text">$ rustc main.rs
$ ./main
Hello, world!
</code></pre>
<p>No Windows, digite o comando <code>.\main.exe</code> ao invÃ©s de <code>./main</code>:</p>
<pre><code class="language-powershell">&gt; rustc main.rs
&gt; .\main.exe
Hello, world!
</code></pre>
<p>Independente do seu sistema operacional, vocÃª deverÃ¡ ver a mensagem
<code>Hello, world!</code> no seu terminal. Se vocÃª nÃ£o ver essa mensagem, volte Ã  parte
<a href="ch01-01-installation.html#troubleshooting">â€œTroubleshootingâ€</a> da seÃ§Ã£o &quot;InstalaÃ§Ã£o&quot; sobre formas de
obter ajuda.</p>
<p>Se <code>Hello, world!</code> apareceu, parabÃ©ns! VocÃª oficialmente escreveu um programa
Rust. Isso faz de vocÃª um programador Rust! Seja bem-vindo!</p>
<!-- ### Anatomy of a Rust Program
<p>Letâ€™s review in detail what just happened in your Hello, world! program.
Hereâ€™s the first piece of the puzzle:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {

}
</code></pre></pre>
<p>These lines define a function in Rust. The <code>main</code> function is special: it is
always the first code that runs in every executable Rust program. The first
line declares a function named <code>main</code> that has no parameters and returns
nothing. If there were parameters, they would go inside the parentheses, <code>()</code>. --&gt;</p>
<a class="header" href="print.html#anatomia-de-um-programa-em-rust" id="anatomia-de-um-programa-em-rust"><h3>Anatomia de um Programa em Rust</h3></a>
<p>Agora vamos ver o que aconteceu com o seu programa &quot;Hello, world!&quot; em detalhes.
Aqui estÃ¡ a primeira peÃ§a do quebra-cabeÃ§a:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {

}
</code></pre></pre>
<p>Estas linhas definem uma funÃ§Ã£o em Rust. A funÃ§Ã£o <code>main</code> Ã© especial: ela Ã©
sempre o primeiro cÃ³digo a ser executado em todo programa executÃ¡vel Rust.
A primeira linha declara uma funÃ§Ã£o chamada <code>main</code> que nÃ£o tem nenhum parÃ¢metro
e nÃ£o retorna nada. Se houvessem parÃ¢metros, eles seriam inseridos dentro dos
parÃªnteses, <code>()</code>.</p>
<!-- 
Also, note that the function body is wrapped in curly brackets, `{}`. Rust
requires these around all function bodies. Itâ€™s good style to place the opening
curly bracket on the same line as the function declaration, adding one space in
between.
<p>At the time of this writing, an automatic formatter tool called <code>rustfmt</code> is
under development. If you want to stick to a standard style across Rust
projects, <code>rustfmt</code> will format your code in a particular style. The Rust team
plans to eventually include this tool with the standard Rust distribution, like
<code>rustc</code>. So depending on when you read this book, it might already be installed
on your computer! Check the online documentation for more details.</p>
<p>Inside the <code>main</code> function is the following code:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    println!(&quot;Hello, world!&quot;);
``` --&gt;

TambÃ©m, note que o corpo da funÃ§Ã£o Ã© envolvido em chaves, `{}`. Rust as requer
ao redor de todos os corpos de funÃ§Ã£o. Ã‰ boa prÃ¡tica colocar a chave de
abertura na mesma linha que a declaraÃ§Ã£o da funÃ§Ã£o, adicionando um espaÃ§o entre
elas.

No momento desta escrita, uma ferramenta de formataÃ§Ã£o automÃ¡tica chamada
`rustfmt` estÃ¡ sendo desenvolvida. Se vocÃª quiser se ater a um estilo padrÃ£o
atravÃ©s de projetos Rust, `rustfmt` irÃ¡ formatar seu cÃ³digo num estilo
particular. O time Rust planeja eventualmente incluir esta ferramenta com a
distribuiÃ§Ã£o padrÃ£o de Rust, assim como o `rustc`. EntÃ£o dependendo de quando
vocÃª ler este livro, ela pode jÃ¡ estar instalada no seu computador! Cheque a
documentaÃ§Ã£o online para mais detalhes.

Dentro da funÃ§Ã£o `main` estÃ¡ o seguinte cÃ³digo:

```rust
    println!(&quot;Hello, world!&quot;);
#}</code></pre></pre>
<!-- This line does all the work in this little program: it prints text to the
screen. There are four important details to notice here. First, Rust style is
to indent with four spaces, not a tab.
<p>Second, <code>println!</code> calls a Rust macro. If it called a function instead, it
would be entered as <code>println</code> (without the <code>!</code>). Weâ€™ll discuss Rust macros in
more detail in Chapter 19. For now, you just need to know that using a <code>!</code>
means that youâ€™re calling a macro instead of a normal function.</p>
<p>Third, you see the <code>&quot;Hello, world!&quot;</code> string. We pass this string as an argument
to <code>println!</code>, and the string is printed to the screen.</p>
<p>Fourth, we end the line with a semicolon (<code>;</code>), which indicates that this
expression is over and the next one is ready to begin. Most lines of Rust code
end with a semicolon. --&gt;</p>
<p>Esta linha faz todo o trabalho neste pequeno programa: ela imprime texto na
tela. HÃ¡ quatro detalhes importantes a se notar aqui. Primeiro, o estilo Rust
Ã© indentar com quatro espaÃ§os, nÃ£o com uma tabulaÃ§Ã£o (tab).</p>
<p>Em segundo, <code>println!</code> chama uma macro Rust. Se ele chamasse uma funÃ§Ã£o ao
invÃ©s disso, ele seria escrito como <code>println</code> (sem a <code>!</code>). NÃ³s iremos discutir
macros Rust em mais detalhes no capÃ­tulo 19. Por agora, vocÃª sÃ³ precisa saber
que usar uma <code>!</code> significa que vocÃª estÃ¡ chamando uma macro ao invÃ©s de uma
funÃ§Ã£o normal.</p>
<p>Em terceiro, vocÃª vÃª a string <code>&quot;Hello, world!&quot;</code>. NÃ³s passamos essa string como
um argumento para o <code>println!</code>, e a string Ã© impressa na tela.</p>
<p>Em quarto, nÃ³s terminamos a linha com um ponto e vÃ­rgula (<code>;</code>), que indica que
essa expressÃ£o terminou e a prÃ³xima estÃ¡ pronta para comeÃ§ar. A maioria das
linhas de Rust terminam com um ponto e vÃ­rgula.</p>
<!-- ### Compiling and Running Are Separate Steps
<p>Youâ€™ve just run a newly created program, so letâ€™s examine each step in the
process.</p>
<p>Before running a Rust program, you must compile it using the Rust compiler by
entering the <code>rustc</code> command and passing it the name of your source file, like
this:</p>
<pre><code class="language-text">$ rustc main.rs
</code></pre>
<p>If you have a C or C++ background, youâ€™ll notice that this is similar to <code>gcc</code>
or <code>clang</code>. After compiling successfully, Rust outputs a binary executable.</p>
<p>On Linux, macOS, and PowerShell on Windows, you can see the executable by
entering the <code>ls</code> command in your shell. On Linux and macOS, youâ€™ll see two
files. With PowerShell on Windows, youâ€™ll see the same three files that you
would see using CMD.</p>
<pre><code class="language-text">$ ls
main  main.rs
``` --&gt;

### CompilaÃ§Ã£o e ExecuÃ§Ã£o SÃ£o Etapas Diferentes

VocÃª acabou de rodar um programa rÃ©cem-criado, entÃ£o vamos analisar cada etapa
no processo.

Antes de rodar um programa Rust, vocÃª deve compilÃ¡-lo usando o compilador Rust
ao digitar o comando `rustc` e passar a ele o nome do arquivo fonte, desta
forma:

```text
$ rustc main.rs
</code></pre>
<p>Se vocÃª tem experiÃªncia em C ou C++, vocáº½ irÃ¡ notar que isso Ã© similar ao <code>gcc</code>
ou ao <code>clang</code>. Depois de compilar com sucesso, Rust produz um executÃ¡vel
binÃ¡rio.</p>
<p>Em Linux, macOS, e PowerShell no Windows, vocÃª pode ver o executÃ¡vel ao entrar
o comando <code>ls</code> no seu shell. Em Linux e macOS, vocÃª irÃ¡ ver dois arquivos. No
PowerShell no Windows, vocÃª irÃ¡ ver os mesmos trÃªs arquivos que vocÃª veria
usando CMD.</p>
<pre><code class="language-text">$ ls
main  main.rs
</code></pre>
<p>No CMD no Windows, vocÃª digitaria o seguinte:</p>
<pre><code class="language-cmd">&gt; dir /B %= the /B option says to only show the file names =%
main.exe
main.pdb
main.rs
</code></pre>
<p>Isto mostra o cÃ³digo fonte com a extensÃ£o <em>.rs</em>, o arquivo executÃ¡vel (
<em>main.exe</em> no Windows, mas <em>main</em> em todas as outras plataformas), e, usando
Windows, um arquivo contendo informaÃ§Ã£o de debugging com a extensÃ£o <em>.pdb</em>.
Daqui, vocÃª roda os arquivos <em>main</em> ou <em>main.exe</em>, da seguinte forma:</p>
<pre><code class="language-text">$ ./main # or .\main.exe on Windows
</code></pre>
<p>Se <em>main.rs</em> era o seu programa &quot;Hello, world!&quot;, esta linha irÃ¡ imprimir
<code>Hello, world!</code> no seu terminal.</p>
<!-- 
If youâ€™re more familiar with a dynamic language, such as Ruby, Python, or
JavaScript, you might not be used to compiling and running a program as
separate steps. Rust is an *ahead-of-time compiled* language, meaning you can
compile a program and give the executable to someone else, and they can run it
even without having Rust installed. If you give someone a *.rb*, *.py*, or
*.js* file, they need to have a Ruby, Python, or JavaScript implementation
installed (respectively). But in those languages, you only need one command to
compile and run your program. Everything is a trade-off in language design.
<p>Just compiling with <code>rustc</code> is fine for simple programs, but as your project
grows, youâ€™ll want to manage all the options and make it easy to share your
code. Next, weâ€™ll introduce you to the Cargo tool, which will help you write
real-world Rust programs.</p>
<p><a href="ch01-01-installation.html#troubleshooting">troubleshooting</a>: ch01-01-installation.html#troubleshooting --&gt;</p>
<p>Se vocÃª Ã© mais familiar com uma linguagem dinÃ¢mica, como Ruby, Python, ou
Javascript, vocÃª pode nÃ£o estar acostumado a compilar e rodar um programa como
etapas separadas. Rust Ã© uma linguagem compilada <em>ahead of time</em>
(antecipadamente), o que significa que vocÃª pode compilar um programa e dar o
executÃ¡vel para outra pessoa, e ela pode rodar o programa mesmos sem ter Rust
instalada. Se vocÃª der a alguÃ©m um arquivo <em>.rb</em>, <em>.py</em>, ou <em>.js</em>, ela irÃ¡
precisar ter uma implementaÃ§Ã£o de Ruvy, Python, ou Javascript instaladas
respectivamente. Mas nessas linguagens, vocÃª apenas precisa de um comando
para compilar e rodar seu programa. Tudo Ã© um trade-off no projeto de
linguagens.</p>
<p>Apenas compilando com <code>rustc</code> Ã© ok para programas simples, mas quando seu
projeto crescer, vocÃª pode querer gerenciar todas as opÃ§Ãµes e tornar fÃ¡cil
compartilhar seu cÃ³digo. Em seguida, nÃ³s iremos introduzir Ã  ferramenta Cargo,
que irÃ¡ ajudÃ¡-lo a escrever programas Rust reais.</p>
<a class="header" href="print.html#jogo-de-adivinhaÃ§Ã£o" id="jogo-de-adivinhaÃ§Ã£o"><h1>Jogo de AdivinhaÃ§Ã£o</h1></a>
<p>Vamos entrar de cabeÃ§a no Rust e colocar a mÃ£o na massa! Este capÃ­tulo vai lhe
apresentar alguns conceitos bem comuns no Rust, mostrando como usÃ¡-los em um
programa de verdade. VocÃª vai aprender sobre <code>let</code>, <code>match</code>, mÃ©todos, funÃ§Ãµes
associadas, crates externos, e mais! Os capÃ­tulos seguintes vÃ£o explorar essas
ideias em mais detalhes. Neste capÃ­tulo, vocÃª vai praticar o bÃ¡sico.</p>
<p>Vamos implementar um clÃ¡ssico problema de programaÃ§Ã£o para iniciantes: um jogo
de adivinhaÃ§Ã£o. Eis como ele funciona: o programa vai gerar um nÃºmero inteiro
aleatÃ³rio entre 1 e 100. EntÃ£o, ele vai pedir ao jogador que digite um palpite.
ApÃ³s darmos nosso palpite, ele vai nos indicar se o palpite Ã© muito baixo ou
muito alto. Uma vez que o palpite estiver correto, ele vai nos dar os parabÃ©ns e
sair.</p>
<a class="header" href="print.html#preparando-um-novo-projeto" id="preparando-um-novo-projeto"><h2>Preparando um Novo Projeto</h2></a>
<p>Para iniciar um novo projeto, vÃ¡ ao seu diretÃ³rio de projetos que vocÃª criou no
CapÃ­tulo 1, e execute os comandos do Cargo a seguir:</p>
<pre><code class="language-text">$ cargo new jogo_de_advinhacao --bin
$ cd jogo_de_advinhacao
</code></pre>
<p>O primeiro comando, <code>cargo new</code>, recebe o nome do projeto (<code>jogo_de_advinhacao</code>)
como primeiro argumento. A flag <code>--bin</code> diz ao Cargo que faÃ§a um projeto
binÃ¡rio, similar ao do CapÃ­tulo 1. O segundo comando muda a pasta atual para o
diretÃ³rio do projeto.</p>
<p>Confira o arquivo <em>Cargo.toml</em> gerado:</p>
<p><span class="filename">Arquivo: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;jogo_de_advinhacao&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Seu Nome &lt;voce@exemplo.com&gt;&quot;]

[dependencies]
</code></pre>
<p>Se as informaÃ§Ãµes sobre o autor, que o Cargo obtÃ©m do seu ambiente, nÃ£o
estiverem corretas, faÃ§a os reparos necessÃ¡rios e salve o arquivo.</p>
<p>Assim como no CapÃ­tulo 1, <code>cargo new</code> gera um programa &quot;Hello, world!&quot; para nÃ³s.
Confira em <em>src/main.rs</em>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Agora vamos compilar esse programa &quot;Hello, world!&quot; e executÃ¡-lo de uma vez sÃ³
usando o comando <code>cargo run</code>:</p>
<pre><code class="language-text">$ cargo run
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50 secs
     Running `target/debug/jogo_de_advinhacao`
Hello, world!
</code></pre>
<p>O comando <code>run</code> Ã© uma boa opÃ§Ã£o quando precisamos iterar rapidamente em um
projeto, que Ã© o caso neste jogo: nÃ³s queremos testar rapidamente cada iteraÃ§Ã£o
antes de movermos para a prÃ³xima.</p>
<p>Abra novamente o arquivo <em>src/main.rs</em>. Escreveremos todo nosso cÃ³digo nele.</p>
<a class="header" href="print.html#processando-um-palpite" id="processando-um-palpite"><h2>Processando um Palpite</h2></a>
<p>A primeira parte do programa vai pedir uma entrada ao usuÃ¡rio, processar essa
entrada, e conferir se ela estÃ¡ no formato esperado. Pra comeÃ§ar, vamos permitir
que o jogador entre com um palpite. Coloque este cÃ³digo no arquivo
<em>src/main.rs</em>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;

fn main() {
    println!(&quot;Advinhe o nÃºmero!&quot;);

    println!(&quot;Digite o seu palpite.&quot;);

    let mut palpite = String::new();

    io::stdin().read_line(&amp;mut palpite)
        .expect(&quot;Falha ao ler entrada&quot;);

    println!(&quot;VocÃª disse: {}&quot;, palpite);
}
</code></pre>
<p><span class="caption">Listagem 2-1: CÃ³digo para ler um palpite do usuÃ¡rio e
imprimÃ­-lo na tela.</span></p>
<p>Esse cÃ³digo tem muita informaÃ§Ã£o, vamos ver uma parte de cada vez. Para obter a
entrada do usuÃ¡rio, e entÃ£o imprimir o resultado como saÃ­da, precisaremos trazer
ao escopo a biblioteca <code>io</code> (de entrada/saÃ­da). A biblioteca <code>io</code> provÃ©m da
biblioteca padrÃ£o (chamada de <code>std</code>):</p>
<pre><code class="language-rust ignore">use std::io;
</code></pre>
<p>Por padrÃ£o, o Rust traz apenas alguns tipos para o escopo de todos os programas
no <a href="../../std/prelude/index.html"><em>prelÃºdio</em></a><!-- ignore -->. Se um tipo que vocÃª quiser usar nÃ£o
estiver no prelÃºdio, vocÃª terÃ¡ que importÃ¡-lo explicitamente atravÃ©s do <code>use</code>.
A biblioteca <code>std::io</code> oferece vÃ¡rias ferramentas de entrada/saÃ­da, incluindo a
funcionalidade de ler dados de entrada do usuÃ¡rio.</p>
<p>Como visto no CapÃ­tulo 1, a funÃ§Ã£o <code>main</code> Ã© o ponto de entrada do programa:</p>
<pre><code class="language-rust ignore">fn main() {
</code></pre>
<p>A sintaxe <code>fn</code> declara uma nova funÃ§Ã£o, o <code>()</code> indica que nÃ£o hÃ¡ parÃ¢metros, e
o <code>{</code> inicia o corpo da funÃ§Ã£o.</p>
<p>Como vocÃª tambÃ©m jÃ¡ aprendeu no CapÃ­tulo 1, <code>println!</code> Ã© uma macro que imprime
uma string na tela:</p>
<pre><code class="language-rust ignore">println!(&quot;Advinhe o nÃºmero!&quot;);

println!(&quot;Digite o seu palpite.&quot;);
</code></pre>
<p>Este cÃ³digo estÃ¡ exibindo uma mensagem que diz de que se trata o jogo e solicita
uma entrada do usuÃ¡rio.</p>
<a class="header" href="print.html#armazenando-valores-em-variÃ¡veis" id="armazenando-valores-em-variÃ¡veis"><h3>Armazenando Valores em VariÃ¡veis</h3></a>
<p>PrÃ³ximo passo, vamos criar um local para armazenar a entrada do usuÃ¡rio:</p>
<pre><code class="language-rust ignore">let mut palpite = String::new();
</code></pre>
<p>Agora o programa estÃ¡ ficando interessante! Tem muita coisa acontecendo nesta
pequena linha. Repare que esta Ã© uma declaraÃ§Ã£o <code>let</code>, que Ã© usada para criar
<em>variÃ¡veis</em>. Segue outro exemplo:</p>
<pre><code class="language-rust ignore">let foo = bar;
</code></pre>
<p>Essa linha cria uma nova variÃ¡vel chamada <code>foo</code>, e a vincula ao valor <code>bar</code>. Em
Rust, variÃ¡veis sÃ£o imutÃ¡veis por padrÃ£o. O exemplo a seguir mostra como usar
<code>mut</code> antes do nome da variÃ¡vel para tornÃ¡-la mutÃ¡vel:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let foo = 5; // imutÃ¡vel
let mut bar = 5; // mutÃ¡vel
#}</code></pre></pre>
<blockquote>
<p>Nota: A sintaxe <code>//</code> inicia um comentÃ¡rio, que continua atÃ© o fim da linha.
Rust ignora tudo o que estiver nos comentÃ¡rios.</p>
</blockquote>
<p>Agora vocÃª sabe que <code>let mut palpite</code> vai introduzir uma variÃ¡vel mutÃ¡vel de
nome <code>palpite</code>. No outro lado do sÃ­mbolo <code>=</code> estÃ¡ o valor ao qual <code>palpite</code> estÃ¡
vinculado, que Ã© o resultado da chamada <code>String::new</code>, uma funÃ§Ã£o que retorna
uma nova instÃ¢ncia de <code>String</code>. <a href="../../std/string/struct.String.html"><code>String</code></a><!-- ignore --> Ã© um tipo
fornecido pela biblioteca padrÃ£o que representa uma cadeia expansÃ­vel de
caracteres codificados em UTF-8.</p>
<p>A sintaxe <code>::</code> na linha <code>::new</code> indica que <code>new</code> Ã© uma <em>funÃ§Ã£o associada</em> do
tipo <code>String</code>. Uma funÃ§Ã£o associada Ã© implementada sobre um tipo, neste caso
<code>String</code>, em vez de uma instÃ¢ncia particular de <code>String</code>. Algumas linguagens
dÃ£o a isso o nome <em>mÃ©todo estÃ¡tico</em>.</p>
<p>Esta funÃ§Ã£o <code>new()</code> cria uma nova <code>String</code> vazia. VocÃª encontrarÃ¡ uma funÃ§Ã£o
<code>new()</code> em muitos tipos, jÃ¡ que Ã© um nome comum para uma funÃ§Ã£o que produz um
novo valor de algum tipo.</p>
<p>Para resumir, a linha <code>let mut palpite = String::new();</code> criou uma variÃ¡vel
mutÃ¡vel que estÃ¡ atualmente vinculada a uma nova instÃ¢ncia vazia de uma
<code>String</code>. Ufa!</p>
<p>Lembre-se de que incluÃ­mos a funcionalidade de entrada/saÃ­da da biblioteca
padrÃ£o por meio do <code>use std::io;</code> na primeira linha do programa. Agora vamos
chamar uma funÃ§Ã£o associada, <code>stdin</code>, em <code>io</code>:</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut palpite)
    .expect(&quot;Falha ao ler entrada&quot;);
</code></pre>
<p>Se nÃ£o tivÃ©ssemos a linha <code>use std::io</code> no inÃ­cio do programa, poderÃ­amos ter
escrito esta chamada como <code>std::io::stdin</code>. A funÃ§Ã£o <code>stdin</code> retorna uma
instÃ¢ncia de <a href="../../std/io/struct.Stdin.html"><code>std::io::Stdin</code></a><!-- ignore -->, um tipo que representa
um manipulador (<em>handle</em>) da entrada padrÃ£o do seu terminal.</p>
<p>A prÃ³xima parte do cÃ³digo, <code>.read_line(&amp;mut palpite)</code>, chama o mÃ©todo
<a href="../../std/io/struct.Stdin.html#method.read_line"><code>read_line</code></a><!-- ignore --> do <em>handle</em> da entrada padrÃ£o para obter
entrada do usuÃ¡rio. TambÃ©m estamos passando um argumento para <code>read_line</code>:
<code>&amp;mut palpite</code>.</p>
<p>O trabalho da funÃ§Ã£o <code>read_line</code> Ã© receber o que o usuÃ¡rio digita na entrada
padrÃ£o e colocar isso numa string, por isso ela recebe essa string como
argumento. A string do argumento deve ser mutÃ¡vel para que o mÃ©todo consiga
alterar o seu conteÃºdo, adicionando a entrada do usuÃ¡rio.</p>
<p>O sÃ­mbolo <code>&amp;</code> indica que o argumento Ã© uma <em>referÃªncia</em>, o que permite mÃºltiplas
partes do seu cÃ³digo acessar um certo dado sem precisar criar vÃ¡rias cÃ³pias dele
na memÃ³ria. ReferÃªncias sÃ£o uma caracterÃ­stica complexa, e uma das maiores
vantagens do Rust Ã© o quÃ£o fÃ¡cil e seguro Ã© usar referÃªncias. VocÃª nÃ£o precisa
conhecer muitos desses detalhes para finalizar esse programa. O CapÃ­tulo 4 vai
explicar sobre referÃªncias de forma mais aprofundada. Por enquanto, tudo que
vocÃª precisa saber Ã© que, assim como as variÃ¡veis, referÃªncias sÃ£o imutÃ¡veis por
padrÃ£o. Por isso, precisamos escrever <code>&amp;mut palpite</code>, em vez de apenas
<code>&amp;palpite</code>, para fazer com que o palpite seja mutÃ¡vel.</p>
<p>Ainda nÃ£o finalizamos completamente esta linha de cÃ³digo. Embora esta seja uma
Ãºnica linha de texto, Ã© apenas a primeira parte de uma linha lÃ³gica de cÃ³digo. A
segunda parte Ã© a chamada para este mÃ©todo:</p>
<pre><code class="language-rust ignore">.expect(&quot;Falha ao ler entrada&quot;);
</code></pre>
<p>Quando vocÃª chama um mÃ©todo com a sintaxe <code>.foo()</code>, geralmente Ã© bom introduzir
uma nova linha e outro espaÃ§o para ajudar a dividir linhas muito compridas.
PoderÃ­amos ter feito assim:</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut palpite).expect(&quot;Falha ao ler entrada&quot;);
</code></pre>
<p>PorÃ©m, uma linha muito comprida fica difÃ­cil de ler. EntÃ£o Ã© melhor dividirmos a
linha em duas, uma para cada mÃ©todo chamado. Agora vamos falar sobre o que essa
linha faz.</p>
<a class="header" href="print.html#tratando-potenciais-falhas-com-o-tipo-result" id="tratando-potenciais-falhas-com-o-tipo-result"><h3>Tratando Potenciais Falhas com o Tipo <code>Result</code></h3></a>
<p>Como mencionado anteriormente, <code>read_line</code> coloca o que o usuÃ¡rio escreve dentro
da string que passamos como argumento, mas tambÃ©m retorna um valor - neste
caso, um <a href="../../std/io/type.Result.html"><code>io::Result</code></a><!-- ignore -->. Rust tem uma variedade de
tipos com o nome <code>Result</code> em sua biblioteca padrÃ£o: um <a href="../../std/result/enum.Result.html"><code>Result</code></a>
genÃ©rico e as versÃµes especÃ­ficas dos submÃ³dulos, como <code>io::Result</code>.</p>
<p>Os tipos <code>Result</code> sÃ£o <a href="ch06-00-enums.html"><em>enumeraÃ§Ãµes</em></a><!-- ignore -->, comumente chamadas
de <em>enums</em>. Uma enumeraÃ§Ã£o Ã© um tipo que pode ter um conjunto fixo de valores,
os quais sÃ£o chamados de <em>variantes</em> da enum. O CapÃ­tulo 6 vai abordar enums em
mais detalhes.</p>
<p>Para <code>Result</code>, as variantes sÃ£o <code>Ok</code> ou <code>Err</code>. <code>Ok</code> indica que a operaÃ§Ã£o teve
sucesso, e dentro da variante <code>Ok</code> estÃ¡ o valor resultante. <code>Err</code> significa que
a operaÃ§Ã£o falhou, e contÃ©m informaÃ§Ãµes sobre como ou por que isso ocorreu.</p>
<p>O propÃ³sito destes tipos <code>Result</code> Ã© codificar informaÃ§Ãµes de manipulaÃ§Ã£o de
erros. Valores do tipo <code>Result</code>, assim como qualquer tipo, possuem mÃ©todos
definidos. Uma instÃ¢ncia de <code>io::Result</code> tem um <a href="../../std/result/enum.Result.html#method.expect">mÃ©todo <code>expect</code></a><!-- ignore -->
que vocÃª pode chamar. Se esta instÃ¢ncia de <code>io::Result</code> Ã© um <code>Err</code>, <code>expect</code> vai
terminar o programa com erro e mostrar a mensagem que vocÃª passou como argumento
ao <code>expect</code>. Se o mÃ©todo <code>read_line</code> retornar um <code>Err</code>, provavelmente seria o
resultado de um erro vindo do sistema operacional que estÃ¡ por trÃ¡s. Se esta
instÃ¢ncia de <code>io::Result</code> Ã© um <code>Ok</code>, <code>expect</code> vai obter o valor contido no <code>Ok</code>
e retornÃ¡-lo para que vocÃª possa usÃ¡-lo. Neste caso, o valor Ã© o nÃºmero de bytes
dos dados que o usuÃ¡rio inseriu atravÃ©s da entrada padrÃ£o.</p>
<p>Se nÃ£o chamarmos <code>expect</code>, nosso programa vai compilar, mas vamos ter um aviso:</p>
<pre><code class="language-text">$ cargo build
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
warning: unused `std::result::Result` which must be used
  --&gt; src/main.rs:10:5
   |
10 |     io::stdin().read_line(&amp;mut palpite);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: #[warn(unused_must_use)] on by default
</code></pre>
<p>Rust avisa que nÃ£o usamos o valor <code>Result</code>, retornado por <code>read_line</code>, indicando
que o programa deixou de tratar um possÃ­vel erro. A maneira correta de suprimir
o aviso Ã© realmente escrevendo um tratador de erro, mas como queremos que o
programa seja encerrado caso ocorra um problema, podemos usar <code>expect</code>. VocÃª
aprenderÃ¡ sobre recuperaÃ§Ã£o de erros no CapÃ­tulo 9.</p>
<a class="header" href="print.html#exibindo-valores-com-curingas-do-println" id="exibindo-valores-com-curingas-do-println"><h3>Exibindo Valores com Curingas do <code>println!</code></h3></a>
<p>Tirando a chave que delimita a funÃ§Ã£o <code>main</code>, hÃ¡ apenas uma linha mais a ser
discutida no cÃ³digo que fizemos atÃ© agora, que Ã© a seguinte:</p>
<pre><code class="language-rust ignore">println!(&quot;VocÃª disse: {}&quot;, guess);
</code></pre>
<p>Esta linha imprime a string na qual salvamos os dados inseridos pelo usuÃ¡rio. O
<code>{}</code> Ã© um curinga que reserva o lugar de um valor. VocÃª pode imprimir mais de um
valor usando <code>{}</code>: o primeiro conjunto de <code>{}</code> guarda o primeiro valor listado
apÃ³s a string de formataÃ§Ã£o, o segundo conjunto guarda o segundo valor, e
assim por diante. Imprimir mÃºltiplos valores em uma sÃ³ chamada a <code>println!</code>
seria assim:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
let y = 10;

println!(&quot;x = {} e y = {}&quot;, x, y);
#}</code></pre></pre>
<p>Esse cÃ³digo imprime <code>x = 5 e y = 10</code>.</p>
<a class="header" href="print.html#testando-a-primeira-parte" id="testando-a-primeira-parte"><h3>Testando a Primeira Parte</h3></a>
<p>Vamos testar a primeira parte do jogo de advinhaÃ§Ã£o. VocÃª pode executÃ¡-lo usando
<code>cargo run</code>:</p>
<pre><code class="language-text">$ cargo run
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
     Running `target/debug/jogo_de_advinhacao`
Advinhe o nÃºmero!
Digite o seu palpite.
6
VocÃª disse: 6
</code></pre>
<p>Nesse ponto, a primeira parte do jogo estÃ¡ feita: podemos coletar entrada do
teclado e mostrÃ¡-la na tela.</p>
<a class="header" href="print.html#gerando-um-nÃºmero-secreto" id="gerando-um-nÃºmero-secreto"><h2>Gerando um NÃºmero Secreto</h2></a>
<p>A seguir, precisamos gerar um nÃºmero secreto que o usuÃ¡rio vai tentar advinhar.
O nÃºmero secreto deve ser diferente a cada execuÃ§Ã£o, para que o jogo tenha graÃ§a
em ser jogado mais de uma vez. Vamos usar um nÃºmero aleatÃ³rio entre 1 e 100,
para que o jogo nÃ£o seja tÃ£o difÃ­cil. Rust ainda nÃ£o inclui uma funcionalidade
de geraÃ§Ã£o de nÃºmeros aleatÃ³rios em sua biblioteca padrÃ£o. PorÃ©m, a equipe Rust
fornece um <a href="https://crates.io/crates/rand">crate <code>rand</code></a>.</p>
<a class="header" href="print.html#usando-um-crate-para-ter-mais-funcionalidades" id="usando-um-crate-para-ter-mais-funcionalidades"><h3>Usando um Crate para Ter Mais Funcionalidades</h3></a>
<p>Lembre-se que um <em>crate</em> Ã© um pacote de cÃ³digo Rust. O projeto que estamos
construindo Ã© um <em>crate binÃ¡rio</em>, que Ã© um executÃ¡vel. JÃ¡ o <code>rand</code> Ã© um
<em>crate de biblioteca</em>, que contÃ©m cÃ³digo cujo objetivo Ã© ser usado por outros
programas.</p>
<p>Ã‰ no uso de crates externos que Cargo realmente brilha. Antes que possamos
escrever o cÃ³digo usando <code>rand</code>, precisamos modificar o arquivo <em>Cargo.toml</em>
para incluir o crate <code>rand</code> como uma dependÃªncia. Abra o arquivo e adicione
esta linha no final, abaixo do cabeÃ§alho da seÃ§Ã£o <code>[dependencies]</code> que o Cargo
criou para vocÃª:</p>
<p><span class="filename">Arquivo: Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]

rand = &quot;0.3.14&quot;
</code></pre>
<p>No arquivo <em>Cargo.toml</em>, tudo que vem depois de um cabeÃ§alho Ã© parte de uma
seÃ§Ã£o que segue atÃ© o inÃ­cio de outra. A seÃ§Ã£o <code>[dependencies]</code> Ã© onde vocÃª diz
ao Cargo de quais crates externos o seu projeto depende, e quais versÃµes desses
crates vocÃª exige. Neste caso, especificamos o crate <code>rand</code> com a versÃ£o
semÃ¢ntica <code>0.3.14</code>. Cargo compreende <a href="https://semver.org/lang/pt-BR/">Versionamento SemÃ¢ntico</a><!-- ignore -->
(Ã s vezes chamado <em>SemVer</em>), um padrÃ£o para escrever nÃºmeros de versÃµes. O
nÃºmero <code>0.3.14</code> Ã©, na verdade, uma forma curta de escrever <code>^0.3.14</code>, que
significa &quot;qualquer versÃ£o que tenha uma API pÃºblica compatÃ­vel com a versÃ£o
0.3.14&quot;.</p>
<p>Agora, sem mudar cÃ³digo algum, vamos compilar nosso projeto, conforme mostrado
na Listagem 2-2:</p>
<pre><code class="language-text">$ cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading rand v0.3.14
 Downloading libc v0.2.14
   Compiling libc v0.2.14
   Compiling rand v0.3.14
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
</code></pre>
<p><span class="caption">Listagem 2-2: Resultado da execuÃ§Ã£o de <code>cargo build</code>
depois de adicionar o crate <code>rand</code> como dependÃªncia.</span></p>
<p>Talvez pra vocÃª apareÃ§am versÃµes diferentes (mas elas sÃ£o todas compatÃ­veis com
o cÃ³digo, graÃ§as ao Versionamento SemÃ¢ntico!), e as linhas talvez apareÃ§am em
ordem diferente.</p>
<p>Agora que temos uma dependÃªncia externa, Cargo busca as versÃµes mais recentes de
tudo no <em>registro</em>, que Ã© uma cÃ³pia dos dados do <a href="https://crates.io">Crates.io</a>.
Crates.io Ã© onde as pessoas do ecossistema Rust postam seus projetos
<em>open source</em> para que os outros possam usar.</p>
<p>ApÃ³s atualizar o registro, Cargo verifica a seÃ§Ã£o <code>[dependencies]</code> e baixa todas
as que vocÃª nÃ£o tem ainda. Neste caso, embora tenhamos listado apenas <code>rand</code>
como dependÃªncia, o Cargo tambÃ©m puxou uma cÃ³pia da <code>libc</code>, porque <code>rand</code>
depende da <code>libc</code> para funcionar. Depois de baixÃ¡-las, o Cargo as compila e
entÃ£o compila nosso projeto.</p>
<p>Se, logo em seguida, vocÃª executar <code>cargo build</code> novamente sem fazer mudanÃ§as,
nÃ£o vai aparecer nenhuma mensagem de saÃ­da. O Cargo sabe que jÃ¡ baixou e
compilou as dependÃªncias, e vocÃª nÃ£o alterou mais nada sobre elas no seu arquivo
<em>Cargo.toml</em>. Cargo tambÃ©m sabe que vocÃª nÃ£o mudou mais nada no seu cÃ³digo, e
por isso nÃ£o o recompila. Sem nada a fazer, ele simplesmente sai. Se vocÃª abrir
<em>src/main.rs</em>, fizer uma modificaÃ§Ã£o trivial, salvar e compilar de novo, vai
aparecer uma mensagem de apenas duas linhas:</p>
<pre><code class="language-text">$ cargo build
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
</code></pre>
<p>Essas linhas mostram que o Cargo sÃ³ atualiza o <em>build</em> com a sua pequena mudanÃ§a
no arquivo <em>src/main.rs</em>. Suas dependÃªncias nÃ£o mudaram, entÃ£o o Cargo sabe que
pode reutilizar o que jÃ¡ tiver sido baixado e compilado para elas. Ele apenas
recompila a sua parte do cÃ³digo.</p>
<a class="header" href="print.html#o-arquivo-cargolock-garante-builds-reproduzÃ­veis" id="o-arquivo-cargolock-garante-builds-reproduzÃ­veis"><h4>O Arquivo <em>Cargo.lock</em> Garante <em>Builds</em> ReproduzÃ­veis</h4></a>
<p>O Cargo tem um mecanismo que assegura que vocÃª pode reconstruir o mesmo artefato
toda vez que vocÃª ou outra pessoa compilar o seu cÃ³digo. O Cargo vai usar apenas
as versÃµes das dependÃªncias que vocÃª especificou, atÃ© que vocÃª indique o
contrÃ¡rio. Por exemplo, o que acontece se, na semana que vem, sair a versÃ£o
<code>v0.3.15</code> contendo uma correÃ§Ã£o de bug, mas tambÃ©m uma regressÃ£o que nÃ£o
funciona com o seu cÃ³digo?</p>
<p>A resposta para isso estÃ¡ no arquivo <em>Cargo.lock</em>, que foi criado na primeira
vez que vocÃª executou <code>cargo build</code>, e agora estÃ¡ no seu diretÃ³rio
<em>jogo_de_advinhacao</em>. Quando vocÃª compila o seu projeto pela primeira vez, o
Cargo descobre as versÃµes de todas as dependÃªncias que preenchem os critÃ©rios
e entÃ£o as escreve no arquivo <em>Cargo.lock</em>. Quando vocÃª compilar o seu projeto
futuramente, o Cargo verÃ¡ que o arquivo <em>Cargo.lock</em> existe e usarÃ¡ as versÃµes
especificadas lÃ¡, em vez de refazer todo o trabalho descobrir as versÃµes
novamente. Isto lhe permite ter um <em>build</em> reproduzÃ­vel automaticamente. Em
outras palavras, seu projeto vai continuar com a versÃ£o <code>0.3.14</code> atÃ© que vocÃª
faÃ§a uma atualizaÃ§Ã£o explÃ­cita, graÃ§as ao arquivo <em>Cargo.lock</em>.</p>
<a class="header" href="print.html#atualizando-um-crate-para-obter-uma-nova-versÃ£o" id="atualizando-um-crate-para-obter-uma-nova-versÃ£o"><h4>Atualizando um Crate para Obter uma Nova VersÃ£o</h4></a>
<p>Quando vocÃª <em>quiser</em> atualizar um crate, o Cargo tem outro comando, <code>update</code>,
que faz o seguinte:</p>
<ol>
<li>Ignora o arquivo <em>Cargo.lock</em> e descobre todas as versÃµes mais recentes que
atendem as suas especificaÃ§Ãµes no <em>Cargo.toml</em>.</li>
<li>Se funcionar, o Cargo escreve essas versÃµes no arquivo <em>Cargo.lock</em>.</li>
</ol>
<p>Mas, por padrÃ£o, o Cargo vai procurar as versÃµes maiores que <code>0.3.0</code> e menores
que <code>0.4.0</code>. Se o crate <code>rand</code> jÃ¡ tiver lanÃ§ado duas novas versÃµes, <code>0.3.15</code> e
<code>0.4.0</code>, vocÃª verÃ¡ a seguinte mensagem ao executar <code>cargo update</code>:</p>
<pre><code class="language-text">$ cargo update
    Updating registry `https://github.com/rust-lang/crates.io-index`
    Updating rand v0.3.14 -&gt; v0.3.15
</code></pre>
<p>Nesse ponto, vocÃª vai notar tambÃ©m uma mudanÃ§a no seu arquivo <em>Cargo.lock</em>
dizendo que a versÃ£o do crate <code>rand</code> que vocÃª estÃ¡ usando agora Ã© a <code>0.3.15</code>.</p>
<p>Se vocÃª quisesse usar a versÃ£o <code>0.4.0</code>, ou qualquer versÃ£o da sÃ©rie <code>0.4.x</code> do
<code>rand</code>, vocÃª teria que atualizar o seu <em>Cargo.toml</em> dessa forma:</p>
<pre><code class="language-toml">[dependencies]

rand = &quot;0.4.0&quot;
</code></pre>
<p>Na prÃ³xima vez que vocÃª executar <code>cargo build</code>, o Cargo vai atualizar o registro
de crates disponÃ­veis e reavaliar os seus requisitos sobre o <code>rand</code> de acordo
com a nova versÃ£o que vocÃª especificou.</p>
<p>HÃ¡ muito mais a ser dito sobre <a href="http://doc.crates.io">Cargo</a><!-- ignore --> e o <a href="http://doc.crates.io/crates-io.html">seu
ecossistema</a><!-- ignore --> que vai ser discutido no CapÃ­tulo 14,
mas por ora isto Ã© tudo que vocÃª precisa saber. Cargo facilita muito reutilizar
bibliotecas, de forma que os <em>rustÃ¡ceos</em> consigam escrever projetos menores que
sÃ£o montados a partir de diversos pacotes.</p>
<a class="header" href="print.html#gerando-um-nÃºmero-aleatÃ³rio" id="gerando-um-nÃºmero-aleatÃ³rio"><h3>Gerando um NÃºmero AleatÃ³rio</h3></a>
<p>Agora vamos <em>usar</em>, de fato, o <code>rand</code>. O prÃ³ximo passo Ã© atualizar o
<em>src/main.rs</em> conforme mostrado na Listagem 2-3:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use rand::Rng;

fn main() {
    println!(&quot;Advinhe o nÃºmero!&quot;);

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    println!(&quot;O nÃºmero secreto Ã©: {}&quot;, numero_secreto);

    println!(&quot;Digite o seu palpite.&quot;);

    let mut palpite = String::new();

    io::stdin().read_line(&amp;mut palpite)
        .expect(&quot;Falha ao ler entrada&quot;);

    println!(&quot;VocÃª disse: {}&quot;, palpite);
}
</code></pre>
<p><span class="caption">Listagem 2-3: MudanÃ§as necessÃ¡rias do cÃ³digo para gerar um
nÃºmero aleatÃ³rio.</span></p>
<p>Estamos adicionando a linha <code>extern crate rand</code> ao topo do arquivo para indicar
ao Rust que estamos usando uma dependÃªncia externa. Isto tambÃ©m Ã© equivalente a
um <code>use rand;</code>, assim podemos chamar qualquer coisa que esteja no crate <code>rand</code>
prefixando-a com <code>rand::</code>.</p>
<p>Em seguida, adicionamos outra linha <code>use</code>: <code>use rand::Rng</code>. <code>Rng</code> Ã© um trait
que define mÃ©todos a serem implementados pelos geradores de nÃºmeros aleatÃ³rios,
e esse trait deve estar dentro do escopo para que possamos usar esses mÃ©todos. O
CapÃ­tulo 10 vai abordar traits em mais detalhes.</p>
<p>Tem outras duas linhas que adicionamos no meio. A funÃ§Ã£o <code>rand::thread_rng</code> nos
dÃ¡ o gerador de nÃºmeros aleatÃ³rios que vamos usar, um que Ã© local Ã  <em>thread</em>
corrente e que Ã© inicializado pelo sistema operacional. Depois, vamos chamar o
mÃ©todo <code>gen_range</code> no gerador de nÃºmeros aleatÃ³rios. Esse mÃ©todo estÃ¡ definido
pelo trait <code>Rng</code> que trouxemos ao escopo por meio do <code>use rand::Rng</code>. Este
mÃ©todo recebe dois argumentos e gera um nÃºmero aleatÃ³rio entre eles. Ele inclui
o limite inferior mas exclui o superior, entÃ£o precisamos passar <code>1</code> e <code>101</code>
para obter um nÃºmero de 1 a 100.</p>
<p>Saber quais traits devem ser usadas e quais funÃ§Ãµes e mÃ©todos de um crate
devem ser chamados nÃ£o Ã© nada trivial. As instruÃ§Ãµes de como usar um crate
estÃ£o na documentaÃ§Ã£o de cada um. Outra coisa boa do Cargo Ã© que vocÃª pode rodar
o comando <code>cargo doc --open</code> que vai construir localmente a documentaÃ§Ã£o
fornecida por todas as suas dependÃªncias e abrÃ­-las no seu navegador. Se vocÃª
estiver interessado em outras funcionalidades do crate <code>rand</code>, por exemplo,
execute <code>cargo doc --open</code> e clique em <code>rand</code>, no menu ao lado esquerdo.</p>
<p>A segunda linha que adicionamos imprime o nÃºmero secreto. Isto Ã© Ãºtil enquanto
estamos desenvolvendo o programa para podermos testÃ¡-lo, mas vamos retirÃ¡-la da
versÃ£o final. Um jogo nÃ£o Ã© muito interessante se ele mostra a resposta logo no
inÃ­cio!</p>
<p>Tente rodar o programa algumas vezes:</p>
<pre><code class="language-text">$ cargo run
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
     Running `target/debug/jogo_de_advinhacao`
Advinhe o nÃºmero!
O nÃºmero secreto Ã©: 7
Digite o seu palpite.
4
VocÃª disse: 4
$ cargo run
     Running `target/debug/jogo_de_advinhacao`
Advinhe o nÃºmero!
O nÃºmero secreto Ã©: 83
Digite o seu palpite.
5
VocÃª disse: 5
</code></pre>
<p>VocÃª jÃ¡ deve obter nÃºmeros aleatÃ³rios diferentes, e eles devem ser todos entre 1
e 100. Bom trabalho!</p>
<a class="header" href="print.html#comparando-o-palpite-com-o-nÃºmero-secreto" id="comparando-o-palpite-com-o-nÃºmero-secreto"><h2>Comparando o Palpite com o NÃºmero Secreto</h2></a>
<p>Agora que nÃ³s temos a entrada do usuÃ¡rio e o nÃºmero secreto, vamos comparÃ¡-los.
Esta estapa Ã© mostrada na Listagem 2-4:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Advinhe o nÃºmero!&quot;);

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    println!(&quot;O nÃºmero secreto Ã©: {}&quot;, numero_secreto);

    println!(&quot;Digite o seu palpite.&quot;);

    let mut palpite = String::new();

    io::stdin().read_line(&amp;mut palpite)
        .expect(&quot;Falha ao ler entrada&quot;);

    println!(&quot;VocÃª disse: {}&quot;, palpite);

    match palpite.cmp(&amp;numero_secreto) {
        Ordering::Less =&gt; println!(&quot;Muito baixo!&quot;),
        Ordering::Greater =&gt; println!(&quot;Muito alto!&quot;),
        Ordering::Equal =&gt; println!(&quot;VocÃª acertou!&quot;),
    }
}
</code></pre>
<p><span class="caption">Listagem 2-4: Tratando os possÃ­veis resultados da
comparaÃ§Ã£o de dois nÃºmeros.</span></p>
<p>A primeira novidade aqui Ã© outro <code>use</code>, que traz ao escopo um tipo da biblioteca
padrÃ£o chamado <code>std::cmp::Ordering</code>. <code>Ordering</code> Ã© outra enum, igual a <code>Result</code>,
mas as suas variantes sÃ£o <code>Less</code>, <code>Greater</code> e <code>Equal</code> (elas significam menor,
maior e igual, respectivamente). Estes sÃ£o os trÃªs possÃ­veis resultados quando
vocÃª compara dois valores.</p>
<p>Depois, adicionamos cinco novas linhas no final que usam o tipo <code>Ordering</code>:</p>
<pre><code class="language-rust ignore">match palpite.cmp(&amp;numero_secreto) {
    Ordering::Less =&gt; println!(&quot;Muito baixo!&quot;),
    Ordering::Greater =&gt; println!(&quot;Muito alto!&quot;),
    Ordering::Equal =&gt; println!(&quot;VocÃª acertou!&quot;),
}
</code></pre>
<p>O mÃ©todo <code>cmp</code> compara dois valores, e pode ser chamado a partir de qualquer
coisa que possa ser comparada. Ele recebe uma referÃªncia de qualquer coisa que
vocÃª queira comparar. Neste caso, estÃ¡ comparando o <code>palpite</code> com o
<code>numero_secreto</code>. <code>cmp</code> retorna uma variante do tipo <code>Ordering</code>, que trouxemos
ao escopo com <code>use</code>. NÃ³s usamos uma expressÃ£o <a href="ch06-02-match.html"><code>match</code></a><!-- ignore -->
para decidir o que fazer em seguida, com base em qual variante de <code>Ordering</code> foi
retornada pelo mÃ©todo <code>cmp</code>, que foi chamado com os valores <code>palpite</code> e
<code>numero_secreto</code>.</p>
<p>Uma expressÃ£o <code>match</code> Ã© composta de <em>braÃ§os</em>. Um braÃ§o consiste em um <em>padrÃ£o</em>
mais o cÃ³digo que deve ser executado se o valor colocado no inÃ­cio do <code>match</code> se
encaixar no padrÃ£o deste braÃ§o. O Rust pega o valor passado ao <code>match</code> e o
compara com o padrÃ£o de cada braÃ§o na sequÃªncia. A expressÃ£o <code>match</code> e os
padrÃµes sÃ£o ferramentas poderosas do Rust que lhe permitem expressar uma
variedade de situaÃ§Ãµes que seu cÃ³digo pode encontrar, e ajuda a assegurar que
vocÃª tenha tratado todas elas. Essas ferramentas serÃ£o abordadas em detalhes nos
capÃ­tulos 6 e 18, respectivamente.</p>
<p>Vamos acompanhar um exemplo do que aconteceria na expressÃ£o <code>match</code> usada aqui.
Digamos que o usuÃ¡rio tenha colocado 50 como palpite, e o nÃºmero secreto
aleatÃ³rio desta vez Ã© 38. Quando o cÃ³digo compara 50 com 38, o mÃ©todo <code>cmp</code> vai
retornar <code>Ordering::Greater</code>, porque 50 Ã© maior que 38. <code>Ordering::Greater</code> Ã© o
valor passado ao <code>match</code>. Ele olha para o padrÃ£o <code>Ordering::Less</code> do primeiro
braÃ§o, mas o valor <code>Ordering::Greater</code> nÃ£o casa com <code>Ordering::Less</code>, entÃ£o ele
ignora o cÃ³digo desse braÃ§o e avanÃ§a para o prÃ³ximo. JÃ¡ o padrÃ£o do prÃ³ximo
braÃ§o, <code>Ordering::Greater</code>, <em>casa</em> com <code>Ordering::Greater</code>! O cÃ³digo associado a
este braÃ§o vai ser executado e mostrar <code>Muito alto!</code> na tela. A expressÃ£o
<code>match</code> termina porque jÃ¡ nÃ£o tem mais necessidade de verificar o Ãºltimo braÃ§o
nesse caso particular.</p>
<p>PorÃ©m, o cÃ³digo da Listagem 2-4 ainda nÃ£o vai compilar. Vamos tentar:</p>
<pre><code class="language-text">$ cargo build
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
error[E0308]: mismatched types
  --&gt; src/main.rs:23:21
   |
23 |     match palpite.cmp(&amp;numero_secreto) {
   |                       ^^^^^^^^^^^^^^^ expected struct `std::string::String`, found integral variable
   |
   = note: expected type `&amp;std::string::String`
   = note:    found type `&amp;{integer}`

error: aborting due to previous error
Could not compile `jogo_de_advinhacao`.
</code></pre>
<p>O que este erro estÃ¡ dizendo Ã© que temos <em>tipos incompatÃ­veis</em>. Rust tem um
sistema de tipos forte e estÃ¡tico. PorÃ©m, Rust tambÃ©m tem inferÃªncia de tipos.
Quando escrevemos <code>let palpite = String::new()</code>, Rust foi capaz de inferir que
<code>palpite</code> deveria ser uma <code>String</code>, entÃ£o ele nÃ£o nos faz escrever o tipo. O
<code>numero_secreto</code>, por outro lado, Ã© de um tipo numÃ©rico. Existem alguns tipos
numÃ©ricos capazes de guardar um valor entre 1 e 100: <code>i32</code>, que Ã© um nÃºmero de
32 bits; <code>u32</code>, um nÃºmero de 32 bits sem sinal; <code>i64</code>, um nÃºmero de 64 bits; e
mais alguns outros. O tipo numÃ©rico padrÃ£o do Rust Ã© <code>i32</code>, que Ã© o tipo do
<code>numero_secreto</code>, a nÃ£o ser que adicionemos, em algum lugar, uma informaÃ§Ã£o de
tipo que faÃ§a o Rust inferir outro tipo numÃ©rico. A razÃ£o do erro Ã© que o Rust
nÃ£o pode comparar uma string e um tipo numÃ©rico.</p>
<p>Em Ãºltima anÃ¡lise, queremos converter a <code>String</code> que lemos como entrada em um
tipo numÃ©rico de verdade, de forma que possamos comparÃ¡-lo numericamente com o
palpite. Podemos fazer isso com mais duas linhas no corpo da funÃ§Ã£o <code>main</code>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Advinhe o nÃºmero!&quot;);

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    println!(&quot;O nÃºmero secreto Ã©: {}&quot;, numero_secreto);

    println!(&quot;Digite o seu palpite.&quot;);

    let mut palpite = String::new();

    io::stdin().read_line(&amp;mut palpite)
        .expect(&quot;Falha ao ler entrada&quot;);

    let palpite: u32 = palpite.trim().parse()
        .expect(&quot;Por favor, digite um nÃºmero!&quot;);

    println!(&quot;VocÃª disse: {}&quot;, palpite);

    match palpite.cmp(&amp;numero_secreto) {
        Ordering::Less =&gt; println!(&quot;Muito baixo!&quot;),
        Ordering::Greater =&gt; println!(&quot;Muito alto!&quot;),
        Ordering::Equal =&gt; println!(&quot;VocÃª acertou!&quot;),
    }
}
</code></pre>
<p>As duas linhas novas sÃ£o:</p>
<pre><code class="language-rust ignore">let palpite: u32 = palpite.trim().parse()
    .expect(&quot;Por favor, digite um nÃºmero!&quot;);
</code></pre>
<p>NÃ³s criamos uma variÃ¡vel chamada <code>palpite</code>. Mas espera, o programa jÃ¡ nÃ£o tinha
uma variÃ¡vel chamada <code>palpite</code>? Sim, mas o Rust nos permite <em>sombrear</em> o
<code>palpite</code> anterior com um novo. Isto Ã© geralmente usado em situaÃ§Ãµes em que vocÃª
quer converter um valor de um tipo em outro. O sombreamento nos permite
reutilizar o nome <code>palpite</code>, em vez de nos forÃ§ar a criar dois nomes Ãºnicos como
<code>palpite_str</code> e <code>palpite</code>, por exemplo. (O CapÃ­tulo 3 vai cobrir sombreamento em
mais detalhes).</p>
<p>NÃ³s vinculamos <code>palpite</code> Ã  expressÃ£o <code>palpite.trim().parse()</code>. O <code>palpite</code>, na
expressÃ£o, refere-se ao <code>palpite</code> original contendo a <code>String</code> de entrada do
usuÃ¡rio. O mÃ©todo <code>trim</code>, em uma instÃ¢ncia de <code>String</code>, vai eliminar quaisquer
espaÃ§os em branco no inÃ­cio e no fim. <code>u32</code> pode conter apenas caracteres
numÃ©ricos, mas o usuÃ¡rio precisa pressionar <span class="keystroke">Enter</span>
para satisfazer o <code>read_line</code>. Quando o usuÃ¡rio pressiona
<span class="keystroke">Enter</span>, um caractere de nova linha Ã© inserido na
string. Por exemplo, se o usuÃ¡rio digitar <span class="keystroke">5</span> e
depois <span class="keystroke">Enter</span>, <code>palpite</code> ficaria assim: <code>5\n</code>. O
<code>\n</code> representa uma linha nova, a tecla <span class="keystroke">Enter</span>.
O mÃ©todo <code>trim</code> elimina o <code>\n</code>, deixando apenas <code>5</code>.</p>
<p>O <a href="../../std/primitive.str.html#method.parse">mÃ©todo <code>parse</code> em strings</a><!-- ignore --> converte uma string para
algum tipo de nÃºmero. Dado que ele pode interpretar uma variedade de tipos
numÃ©ricos, precisamos dizer ao Rust qual o tipo exato de nÃºmero nÃ³s queremos, e
para isso usamos <code>let palpite: u32</code>. Os dois pontos (<code>:</code>) depois de <code>palpite</code>
informam ao Rust que estamos anotando seu tipo. O Rust tem alguns tipos
numÃ©ricos embutidos, o <code>u32</code> visto aqui Ã© um inteiro de 32 bits sem sinal. Ã‰ uma
boa escolha padrÃ£o para um nÃºmero positivo pequeno. VocÃª vai aprender sobre
outros tipos numÃ©ricos no CapÃ­tulo 3. AlÃ©m disso, a anotaÃ§Ã£o <code>u32</code> neste
programa de exemplo e a comparaÃ§Ã£o com <code>numero_secreto</code> significam que o Rust
vai inferir que <code>numero_secreto</code> tambÃ©m deve ser um <code>u32</code>. EntÃ£o agora a
comparaÃ§Ã£o vai ser feita entre valores do mesmo tipo!</p>
<p>A chamada para <code>parse</code> poderia facilmente causar um erro. Por exemplo, se a
string contiver <code>AğŸ‘%</code>, nÃ£o haveria como converter isto em um nÃºmero. Como ele
pode falhar, o mÃ©todo <code>parse</code> retorna um <code>Result</code>, assim como o mÃ©todo
<code>read_line</code>, conforme discutido anteriormente na seÃ§Ã£o &quot;Tratando Potenciais
Falhas com o Tipo <code>Result</code>. Vamos tratar este <code>Result</code> da mesma forma usando o
mÃ©todo <code>expect</code> de novo. Se o <code>parse</code> retornar uma variante <code>Err</code> da enum
<code>Result</code>, por nÃ£o conseguir criar um nÃºmero a partir da string, a chamada ao
<code>expect</code> vai causar um <em>crash</em> no jogo e exibir a mensagem que passamos a ele.
Se o <code>parse</code> conseguir converter uma string em um nÃºmero, ele vai retornar a
variante <code>Ok</code> da enum <code>Result</code> e <code>expect</code> vai retornar o nÃºmero que queremos
extrair do valor <code>Ok</code>.</p>
<p>Agora vamos executar o programa!</p>
<pre><code class="language-text">$ cargo run
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43 secs
     Running `target/jogo_de_advinhacao`
Advinhe o nÃºmero!
O nÃºmero secreto Ã©: 58
Digite o seu palpite.
  76
VocÃª disse: 76
Muito alto!
</code></pre>
<p>Boa! AtÃ© mesmo colocando alguns espaÃ§os antes de digitar o palpite, o programa
ainda descobriu que o palpite do usuÃ¡rio Ã© 76. Execute o programa mais algumas
vezes para verificar os diferentes comportamentos com diferentes tipos de
entrada: advinhe o nÃºmero corretamente, digite um nÃºmero muito alto, e digite um
nÃºmero muito baixo.</p>
<p>Agora jÃ¡ temos a maior parte do jogo funcionando, mas o usuÃ¡rio sÃ³ consegue dar
um palpite uma vez. Vamos mudar isso adicionando laÃ§os!</p>
<a class="header" href="print.html#permitindo-mÃºltiplos-palpites-usando-looping" id="permitindo-mÃºltiplos-palpites-usando-looping"><h2>Permitindo MÃºltiplos Palpites Usando <em>Looping</em></h2></a>
<p>A palavra-chave <code>loop</code> nos dÃ¡ um laÃ§o (<em>loop</em>) infinito. Use-a para dar aos
usuÃ¡rios mais chances de advinhar o nÃºmero:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Advinhe o nÃºmero!&quot;);

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    println!(&quot;O nÃºmero secreto Ã©: {}&quot;, numero_secreto);

    loop {
        println!(&quot;Digite o seu palpite.&quot;);

        let mut palpite = String::new();

        io::stdin().read_line(&amp;mut palpite)
            .expect(&quot;Falha ao ler entrada&quot;);

        let palpite: u32 = palpite.trim().parse()
            .expect(&quot;Por favor, digite um nÃºmero!&quot;);

        println!(&quot;VocÃª disse: {}&quot;, palpite);

        match palpite.cmp(&amp;numero_secreto) {
            Ordering::Less =&gt; println!(&quot;Muito baixo!&quot;),
            Ordering::Greater =&gt; println!(&quot;Muito alto!&quot;),
            Ordering::Equal =&gt; println!(&quot;VocÃª acertou!&quot;),
        }
    }
}
</code></pre>
<p>Como vocÃª pode ver, movemos tudo para dentro do laÃ§o a partir da mensagem
pedindo o palpite do usuÃ¡rio. Certifique-se de indentar essas linhas mais quatro
espaÃ§os cada uma, e execute o programa novamente. Repare que hÃ¡ um novo
problema, porque o programa estÃ¡ fazendo exatamente o que dissemos para ele
fazer: pedir sempre outro palpite! Parece que o usuÃ¡rio nÃ£o consegue sair!</p>
<p>O usuÃ¡rio pode sempre interromper o programa usando as teclas
<span class="keystroke">ctrl-c</span>. Mas hÃ¡ uma outra forma de escapar deste
monstro insaciÃ¡vel que mencionamos na discussÃ£o do mÃ©todo <code>parse</code>, na seÃ§Ã£o
&quot;Comparando o Palpite com o NÃºmero Secreto&quot;: se o usuÃ¡rio fornece uma resposta
nÃ£o-numÃ©rica, o programa vai sofrer um <em>crash</em>. O usuÃ¡rio pode levar vantagem
disso para conseguir sair, como mostrado abaixo:</p>
<pre><code class="language-text">$ cargo run
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
     Running `target/jogo_de_advinhacao`
Advinhe o nÃºmero!
O nÃºmero secreto Ã©: 59
Digite o seu palpite.
45
VocÃª disse: 45
Muito baixo!
Digite o seu palpite.
60
VocÃª disse: 60
Muito alto!
Digite o seu palpite.
59
VocÃª disse: 59
VocÃª acertou!
Digite o seu palpite.
sair
thread 'main' panicked at 'Por favor, digite um nÃºmero!: ParseIntError { kind: InvalidDigit }', src/libcore/result.rs:785
note: Run with `RUST_BACKTRACE=1` for a backtrace.
error: Process didn't exit successfully: `target/debug/jogo_de_advinhacao` (exit code: 101)
</code></pre>
<p>Digitar <code>sair</code>, na verdade, sai do jogo, mas isso tambÃ©m acontece com qualquer
outra entrada nÃ£o numÃ©rica. PorÃ©m, isto nÃ£o Ã© o ideal. Queremos que o jogo
termine automaticamente quando o nÃºmero Ã© advinhado corretamente.</p>
<a class="header" href="print.html#saindo-apÃ³s-um-palpite-correto" id="saindo-apÃ³s-um-palpite-correto"><h3>Saindo ApÃ³s um Palpite Correto</h3></a>
<p>Vamos programar o jogo para sair quando o usuÃ¡rio vencer, colocando um <code>break</code>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Advinhe o nÃºmero!&quot;);

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    println!(&quot;O nÃºmero secreto Ã©: {}&quot;, numero_secreto);

    loop {
        println!(&quot;Digite o seu palpite.&quot;);

        let mut palpite = String::new();

        io::stdin().read_line(&amp;mut palpite)
            .expect(&quot;Falha ao ler entrada&quot;);

        let palpite: u32 = palpite.trim().parse()
            .expect(&quot;Por favor, digite um nÃºmero!&quot;);

        println!(&quot;VocÃª disse: {}&quot;, palpite);

        match palpite.cmp(&amp;numero_secreto) {
            Ordering::Less =&gt; println!(&quot;Muito baixo&quot;),
            Ordering::Greater =&gt; println!(&quot;Muito alto!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;VocÃª acertou!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p>Adicionando a linha <code>break</code> apÃ³s o <code>VocÃª acertou!</code>, o programa vai sair do laÃ§o
quando o usuÃ¡rio advinhar corretamente o nÃºmero secreto. Sair do laÃ§o tambÃ©m
significa sair do programa, pois o laÃ§o Ã© a Ãºltima parte da <code>main</code>.</p>
<a class="header" href="print.html#tratando-entradas-invÃ¡lidas" id="tratando-entradas-invÃ¡lidas"><h3>Tratando Entradas InvÃ¡lidas</h3></a>
<p>Para refinar ainda mais o comportamento do jogo, em vez de causar um <em>crash</em> no
programa quando o usuÃ¡rio insere uma entrada nÃ£o numÃ©rica, vamos fazer o jogo
ignorÃ¡-la para que o usuÃ¡rio possa continuar tentando. Podemos fazer isso
alterando a linha em que o <code>palpite</code> Ã© convertido de <code>String</code> para <code>u32</code>:</p>
<pre><code class="language-rust ignore">let palpite: u32 = match palpite.trim().parse() {
    Ok(num) =&gt; num,
    Err(_) =&gt; continue,
};
</code></pre>
<p>Trocando uma chamada a <code>expect</code> por uma expressÃ£o <code>match</code> Ã© a forma como vocÃª
geralmente deixa de causar um <em>crash</em> em um erro e passa a tratÃ¡-lo, de fato.
Lembre-se que o mÃ©todo <code>parse</code> retorna um valor do tipo <code>Result</code>, uma enum que
contÃ©m a variante <code>Ok</code> ou <code>Err</code>. Estamos usando um <code>match</code> aqui, assim como
fizemos com o <code>Ordering</code> resultante do mÃ©todo <code>cmp</code>.</p>
<p>Se o <code>parse</code> consegue converter a string em um nÃºmero, ele vai retornar um <code>Ok</code>
contendo o nÃºmero resultante. Esse valor <code>Ok</code> vai casar com o padrÃ£o do primeiro
braÃ§o, e o <code>match</code> vai apenas retornar o valor <code>num</code> produzido pelo <code>parse</code> e
colocado dentro do <code>Ok</code>. Esse nÃºmero vai acabar ficando exatamente onde
queremos, na variÃ¡vel <code>palpite</code> que estamos criando.</p>
<p>Se o <code>parse</code> <em>nÃ£o</em> conseguir converter a string em um nÃºmero, ele vai retornar
um <code>Err</code> que contÃ©m mais informaÃ§Ãµes sobre o erro. O valor <code>Err</code> nÃ£o casa com o
padrÃ£o <code>Ok(num)</code> do primeiro braÃ§o do <code>match</code>, mas casa com o padrÃ£o <code>Err(_)</code> do
segundo braÃ§o. O <code>_</code> Ã© um valor &quot;pega tudo&quot;. Neste exemplo, estamos dizendo que
queremos casar todos os valores <code>Err</code>, nÃ£o importa qual informaÃ§Ã£o hÃ¡ dentro
deles. EntÃ£o o programa vai executar o cÃ³digo do segundo braÃ§o, <code>continue</code>, que
significa ir para a prÃ³xima iteraÃ§Ã£o do <code>loop</code> e pedir outro palpite.
Efetivamente, o programa ignora todos os erros que o <code>parse</code> vier a encontrar!</p>
<p>Agora, tudo no programa deve funcionar como esperado. Vamos tentar executÃ¡-lo
usando o comando <code>cargo run</code>:</p>
<pre><code class="language-text">$ cargo run
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
     Running `target/jogo_de_advinhacao`
Advinhe o nÃºmero!
O nÃºmero secreto Ã©: 61
Digite o seu palpite.
10
VocÃª disse: 10
Muito baixo!
Digite o seu palpite.
99
VocÃª disse: 99
Muito alto!
Digite o seu palpite.
foo
Digite o seu palpite.
61
VocÃª disse: 61
VocÃª acertou!
</code></pre>
<p>Demais! Com apenas um Ãºltimo ajuste, vamos finalizar o jogo de adivinhaÃ§Ã£o:
lembre-se que o programa ainda estÃ¡ mostrando o nÃºmero secreto. Isto foi bom
para testar, mas estraga o jogo. Vamos apagar o <code>println!</code> que revela o nÃºmero
secreto. A Listagem 2-5 mostra o cÃ³digo final:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Advinhe o nÃºmero!&quot;);

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    loop {
        println!(&quot;Digite o seu palpite.&quot;);

        let mut palpite = String::new();

        io::stdin().read_line(&amp;mut palpite)
            .expect(&quot;Falha ao ler entrada&quot;);

        let palpite: u32 = match palpite.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;VocÃª disse: {}&quot;, palpite);

        match palpite.cmp(&amp;numero_secreto) {
            Ordering::Less =&gt; println!(&quot;Muito baixo!&quot;),
            Ordering::Greater =&gt; println!(&quot;Muito alto!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;VocÃª acertou!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p><span class="caption">Listagem 2-5: CÃ³digo completo do jogo de advinhaÃ§Ã£o.
</span></p>
<a class="header" href="print.html#resumo" id="resumo"><h2>Resumo</h2></a>
<p>Neste ponto, vocÃª construiu com sucesso o jogo de adivinhaÃ§Ã£o! ParabÃ©ns!</p>
<p>Este projeto foi uma forma prÃ¡tica de apresentar vÃ¡rios conceitos novos de Rust:
<code>let</code>, <code>match</code>, mÃ©todos, funÃ§Ãµes associadas, uso de crates externos, e outros.
Nos prÃ³ximos capÃ­tulos, vocÃª vai aprender sobre esses conceitos em mais
detalhes. O CapÃ­tulo 3 aborda conceitos que a maioria das linguagens de
programaÃ§Ã£o tem, como variÃ¡veis, tipos de dados e funÃ§Ãµes, e mostra como usÃ¡-los
em Rust. O CapÃ­tulo 4 explora posse (<em>ownership</em>), que Ã© a caracterÃ­stica do
Rust mais diferente das outras linguagens. O CapÃ­tulo 5 discute structs e a
sintaxe de mÃ©todos, e o CapÃ­tulo 6 se dedica a explicar enums.</p>
<a class="header" href="print.html#conceitos-comuns-de-programaÃ§Ã£o" id="conceitos-comuns-de-programaÃ§Ã£o"><h1>Conceitos Comuns de ProgramaÃ§Ã£o</h1></a>
<p>Este capÃ­tulo aborda conceitos que aparecem em quase todas as linguagens de programaÃ§Ã£o e como eles funcionam no Rust. Muitas linguagens de programaÃ§Ã£o tÃªm muito em comum em seu cerne. Nenhum dos conceitos apresentados neste capÃ­tulo Ã© exclusivo de Rust, mas vamos discuti-los no contexto do Rust e explicar as convenÃ§Ãµes em torno do uso desses conceitos.</p>
<p>Especificamente, vocÃª aprenderÃ¡ sobre variÃ¡veis, tipos bÃ¡sicos, funÃ§Ãµes, comentÃ¡rios e fluxo de controle. Esses princÃ­pios estarÃ£o em todos os programas em Rust, e aprendÃª-los cedo lhe darÃ¡ uma boa base para comeÃ§ar.</p>
<blockquote>
<a class="header" href="print.html#palavras-chaves" id="palavras-chaves"><h3>Palavras chaves</h3></a>
<p>A linguagem Rust tem uma sÃ©rie de <em>palavras-chaves</em> que sÃ£o reservadas para uso exclusivo
da linguagem, como ocorre em outras linguagens. Tenha em mente que vocÃª nÃ£o
pode usar essas palavras como nome de variÃ¡veis ou funÃ§Ãµes. A maioria das palavras-chaves tem
um significado especÃ­fico, e vocÃª estarÃ¡ usando-as para vÃ¡rias tarefas em programas em Rust;
algumas ainda nÃ£o possuem funcionalidades associadas a elas, mas
foram reservadas para funcionalidades que podem ser adicionadas ao Rust futuramente. VocÃª
encontrarÃ¡ uma lista de palavras-chaves no ApÃªndice A.</p>
</blockquote>
<a class="header" href="print.html#variÃ¡veis-e-mutabilidade" id="variÃ¡veis-e-mutabilidade"><h1>VariÃ¡veis e Mutabilidade</h1></a>
<p>Como mencionado no CapÃ­tulo 2, por padrÃ£o, as variÃ¡veis sÃ£o imutÃ¡veis. Essa Ã© uma das
maneiras que o Rust lhe dÃ¡ para escrever o seu cÃ³digo de
modo seguro e a fÃ¡cil concorrÃªncia que Rust oferece. No entanto, vocÃª ainda tem
a opÃ§Ã£o de tornar a sua variÃ¡vel mutÃ¡vel. Vamos explorar como e por que Rust
incentiva vocÃª a usar variÃ¡veis imutÃ¡veis e por que Ã s vezes pode
nÃ£o optar por utilizÃ¡-las.</p>
<p>Quando uma variÃ¡vel Ã© imutÃ¡vel, logo que um valor Ã© associado a uma variÃ¡vel, vocÃª nÃ£o pode mudar este valor.
Para ilustrar isso, vamos criar um projeto chamado <em>variaveis</em>
no seu diretÃ³rio <em>projetos</em> usando <code>cargo new --bin variables</code>.</p>
<p>EntÃ£o dentro do novo diretÃ³rio chamado <em>variaveis</em>, abra <em>src/main.rs</em> e substitua o
cÃ³digo com o cÃ³digo abaixo, que nÃ£o irÃ¡ compilar:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let x = 5;
    println!(&quot;O valor de x Ã©: {}&quot;, x);
    x = 6;
    println!(&quot;O valor de x Ã©: {}&quot;, x);
}
</code></pre>
<p>Salve e execute o programa usando <code>cargo run</code>. VocÃª deve receber uma mensagem de erro,
conforme mostrado nesta saÃ­da:</p>
<pre><code class="language-text">error[E0384]: cannot assign twice to immutable variable `x`
 --&gt; src/main.rs:4:5
  |
2 |     let x = 5;
  |         - first assignment to `x`
3 |     println!(&quot;O valor de x Ã©: {}&quot;, x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable
</code></pre>
<p>Esse exemplo mostra como o compilador ajuda vocÃª a encontrar erros no seus programas.
Mesmo que erros de compilaÃ§Ã£o sejam frustrantes, eles apenas significam que seu programa
nÃ£o estÃ¡ fazendo de modo seguro o que vocÃª espera fazer; eles <em>nÃ£o</em> siginificam que vocÃª
nÃ£o Ã© um bom programador! Programadores experientes tambÃ©m recebem erros de compilaÃ§Ã£o.</p>
<p>A mensagem indica que a causa do erro Ã© que vocÃª
<code>nÃ£o pode atribuir mais de uma vez Ã  variÃ¡vel imutÃ¡vel x</code>, porque vocÃª tentou atribuir um segundo valor Ã  variÃ¡vel <code>x</code>.</p>
<p>Ã‰ importante que nos recebamos erros em tempo de compilaÃ§Ã£o quando tentamos
alterar um valor que anteriormente foi indicado como imutÃ¡vel, porque
esta situaÃ§Ã£o pode ocasionar erros. Se uma parte do seu cÃ³digo funciona assumindo
que o valor nunca serÃ¡ alterado e outra parte do seu cÃ³digo muda este valor, Ã©
possÃ­vel que a primeira parte do cÃ³digo nÃ£o faÃ§a o que foi projetada para fazer.
A causa desse tipo de falha pode ser difÃ­cil de rastrear,
especialmente quando o segundo trecho de cÃ³digo muda o valor apenas <em>algumas vezes</em>.</p>
<p>Em Rust, o compilador garante que quando vocÃª afirma que um valor nÃ£o pode mudar,
ele nÃ£o mude. Isso significa que quando vocÃª estÃ¡ lendo e ecrevendo cÃ³digo,
vocÃª nÃ£o tenha de acompanhar como e onde um valor pode mudar. E assim seu cÃ³digo
fica mais fÃ¡cil de entender.</p>
<p>Mas mutabilidade pode ser muito Ãºtil. VariÃ¡veis sÃ£o imutÃ¡veis por padrÃ£o; como
vocÃª fez no CapÃ­tulo 2, vocÃª pode tornÃ¡-las mutÃ¡veis adicionando <code>mut</code> na frente do
nome da variÃ¡vel. AlÃ©m de permitir que este valor mude, <code>mut</code> transmite
a intenÃ§Ã£o aos futuros leitores do cÃ³digo, indicando que naquela
parte do cÃ³digo estarÃ£o mudando o valor da variÃ¡vel.</p>
<p>Por exemplo, vamos mudar <em>src/main.rs</em> para o seguinte:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut x = 5;
    println!(&quot;O valor de x Ã©: {}&quot;, x);
    x = 6;
    println!(&quot;O valor de x Ã©: {}&quot;, x);
}
</code></pre></pre>
<p>Quando executamos o programa, recebemos isso:</p>
<pre><code class="language-text">$ cargo run
   Compiling variaveis v0.1.0 (file:///projects/variaveis)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30 secs
     Running `target/debug/variaveis`
O valor de x Ã©: 5
O valor de x Ã©: 6
</code></pre>
<p>Estamos autorizados a mudar o valor <code>5</code> contido  em <code>x</code> para <code>6</code>
quando <code>mut</code> Ã© usado. Em alguns casos, vocÃª precisarÃ¡ criar uma variÃ¡vel mutÃ¡vel porque ela
serÃ¡ mais conveniente para escrever do que se fosse imutÃ¡vel.</p>
<p>Tem vÃ¡rios compromissos a serem considerados alÃ©m de prevenÃ§Ã£o de
falhas. Por exemplo, nos casos em que vocÃª usa estruturas de dados grandes,
a alteraÃ§Ã£o em uma instÃ¢ncia pode ser mais rÃ¡pida do que copiar e retornar a nova instÃ¢ncia
alocada. Com estruturas de dados menores, criar novas instÃ¢ncias e escrever
em um estilo de programaÃ§Ã£o funcional pode ser mais fÃ¡cil de entender, portanto,
um desempenho menor pode ser uma penalidade que vale a pena para obter mais clareza.</p>
<a class="header" href="print.html#diferenÃ§as-entre-variÃ¡veis-e-constantes" id="diferenÃ§as-entre-variÃ¡veis-e-constantes"><h3>DiferenÃ§as entre variÃ¡veis e constantes</h3></a>
<p>Ser incapaz de mudar o valor de uma variÃ¡vel, pode ter feito vocÃª lembrar de
outro conceito de programaÃ§Ã£o, que a maioria das outras linguagens possui, chamado: <em>constantes</em>. Como
variÃ¡veis imutÃ¡veis, constantes sÃ£o valores que estÃ£o vinculados ao nome e nÃ£o
podem serem alterados, mas hÃ¡ algumas diferenÃ§as entre constantes e
variÃ¡veis.</p>
<p>Primeiro, vocÃª nÃ£o pode usar <code>mut</code> com constantes. Constante nÃ£o sÃ£o apenas
imutÃ¡veis por padrÃ£o, constante sÃ£o sempre imutÃ¡veis.</p>
<p>VocÃª declara constante usando a palavra-chave <code>const</code> em vez de <code>let</code>,
e o tipo do valor <em>necessita</em> ser especÃ­ficado. Falaremos sobre tipos de dados
na prÃ³xima seÃ§Ã£o, &quot;Data Type&quot;, entÃ£o
nÃ£o se preocupe com os detalhes por agora. Apenas saiba que vocÃª precisa especificar o tipo.</p>
<p>Constantes podem ser declaradas em qualquer escopo, incluindo o escopo global, o que os tornam
Ãºteis para valores que vÃ¡rias partes do cÃ³digo precisa conhecer.</p>
<p>A Ãºltima diferenÃ§a Ã© que as constantes podem ser definidas apenas para uma expressÃ£o constante,
ou seja, nÃ£o pode ser o resultado de uma chamada de funÃ§Ã£o ou qualquer outro valor que sÃ³ poderia ser
calculado em tempo de execuÃ§Ã£o.</p>
<p>Aqui estÃ¡ um exemplo de uma declaraÃ§Ã£o constante, em que o nome da constante Ã©
<code>PONTOS_MAXIMOS</code> e o valor definido Ã© 100,000 (por
convenÃ§Ã£o, contantes em Rust sÃ£o nomeadas usando maiÃºsculas e sublinhado entre as palavras):</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
const PONTOS_MAXIMOS: u32 = 100_000;
#}</code></pre></pre>
<p>Constante sÃ£o vÃ¡lidas durante todo o tempo de execuÃ§Ã£o de um programa, dentro do escopo em que
foram declaradas, tornando-as uma Ã³tima escolha para valores no domÃ­nio da aplicaÃ§Ã£o,
que vÃ¡rias partes do programa necessitam conhecer, como por exemplo,
o nÃºmero mÃ¡ximo de pontos um jogador pode ter ou a
velocidade da luz.</p>
<p>A nomeaÃ§Ã£o de valores codificados permanentemente usados em todo o programa como constantes Ã© Ãºtil
para transmitir o significado desse valor para futuros mantenedores do cÃ³digo. TambÃ©m
ajuda ter apenas um lugar em seu cÃ³digo que vocÃª precisaria mudar se o
valor codificado precisasse ser atualizado no futuro.</p>
<a class="header" href="print.html#shadowing" id="shadowing"><h3>Shadowing</h3></a>
<p>Como vocÃª viu na seÃ§Ã£o â€œComparando o Adivinha ao NÃºmero Secretoâ€ no CapÃ­tulo
2, vocÃª pode declarar uma nova variÃ¡vel com o mesmo nome de uma variÃ¡vel anterior,
e a nova variÃ¡vel sombreia a variÃ¡vel anterior. Rustaceans dizem que a
primeira variÃ¡vel Ã© <em>sombreada</em> pela segunda, o que significa que o segundo
valor da variÃ¡vel Ã© o que aparece quando a variÃ¡vel Ã© usada. Podemos sombrear uma
variÃ¡vel usando o mesmo nome da variÃ¡vel e repetindo o uso da palavra-chave <code>let</code>
da seguinte forma:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 5;

    let x = x + 1;

    let x = x * 2;

    println!(&quot;O valor de x Ã©: {}&quot;, x);
}
</code></pre></pre>
<p>Esse programa primeiro vincula <code>x</code> ao valor <code>5</code>. Em seguida <code>x</code> Ã© sombreado por
<code>let x =</code>, pegando o valor original e adicionando <code>1</code>, entÃ£o o valor de
<code>x</code> Ã© <code>6</code>. O terceiro <code>let</code> tambÃ©m sombrea <code>x</code>, multiplicando o
valor anterior por <code>2</code> para entÃ£o <code>x</code> ficar com o valor final de <code>12</code>. Quando nÃ³s executamos esse programa, Ã©
produzida a seguinte saÃ­da:</p>
<pre><code class="language-text">$ cargo run
   Compiling variaveis v0.1.0 (file:///projects/variaveis)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/variaveis`
O valor de x Ã©: 12
</code></pre>
<p>Shadowing Ã© diferente do que dizer que uma variÃ¡vel Ã© <code>mut</code>, porque teremos um
erro em tempo de compilaÃ§Ã£o se, acidentalmente, tentarmos reatribuir essa variÃ¡vel sem
utilizar <code>let</code>. Usando <code>let</code>, nÃ³s podemos realizar algumas transformaÃ§Ãµes,
mas sem ter uma variÃ¡vel imutÃ¡vel apÃ³s estas transformaÃ§Ãµes terem
sido concluÃ­das.</p>
<p>Uma outra diferenÃ§a entre <code>mut</code> e shadowing Ã© que,
como estamos efetivamente criando uma nova vÃ¡rivel, quando usamos novamente a palavra-chave <code>let</code>, nÃ³s
podemos mudar o tipo do valor, mas reutilizando o mesmo nome. Por exemplo, digamos que nosso programa
solicite ao usuÃ¡rio que mostre quantos espaÃ§os deseja entre um texto, inserindo
caracteres de espaÃ§o, mas queremos armazenar essa entrada como um nÃºmero:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let espacos = &quot;   &quot;;
let espacos = espacos.len();
#}</code></pre></pre>
<p>Essa construÃ§Ã£o Ã© permitida, porque a primeira variÃ¡vel <code>espacos</code> Ã© do tipo string
e a segunda variÃ¡vel, que Ã© uma nova variÃ¡vel que tem o
mesmo nome que a primeira, Ã© do tipo numÃ©rico. Shadowing nos poupa de
ter de criar nomes diferentes, como <code>str_espacos</code> e
<code>num_espacos</code>; em vez disso, podemos simplesmente reutilizar o nome <code>espacos</code>. No entanto, se
tentassemos usar <code>mut</code> para isso, como mostramos aqui, teremos um erro em tempo de compilaÃ§Ã£o:</p>
<pre><code class="language-rust ignore">let mut espacos = &quot;   &quot;;
espacos = espacos.len();
</code></pre>
<p>O erro diz que nÃ£o podemos alterar o tipo de variÃ¡vel:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:3:14
  |
3 |     espacos = espacos.len();
  |              ^^^^^^^^^^^^ expected &amp;str, found usize
  |
  = note: expected type `&amp;str`
             found type `usize`
</code></pre>
<p>Agora que exploramos como as variÃ¡veis funcionam, vamos ver mais tipos de dados.</p>
<a class="header" href="print.html#tipos-de-dados" id="tipos-de-dados"><h1>Tipos de dados</h1></a>
<p>Todo valor em Rust Ã© um <em>tipo de dado</em>, que informa ao Rust que tipos de
dados estÃ£o sendo especificados para que saiba como trabalhar com esses dados. Vamos olhar para
dois subconjuntos de tipos de dados: escalar e composto.</p>
<p>Tenha em mente que Rust Ã© uma linguagem de <em>tipagem estÃ¡tica</em>, o que significa
que deve conhecer os tipos de todas as variÃ¡veis em tempo de compilaÃ§Ã£o. O compilador
geralmente pode inferir que tipo queremos com base no valor e como o usamos. Nos casos
em que sÃ£o Ã© possÃ­vel vÃ¡rios tipos de dados, como quando convertemos uma <code>String</code> em um tipo numÃ©rico
usando <code>parse</code> na seÃ§Ã£o &quot;Comparando o Adivinha ao NÃºmero Secreto&quot; no
CapÃ­tulo 2, devemos adicionar uma anotaÃ§Ã£o de tipo, como a seguinte:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let guess: u32 = &quot;42&quot;.parse().expect(&quot;NÃ£o Ã© um nÃºmero!&quot;);
#}</code></pre></pre>
<p>Se nÃ£o adicionarmos uma anotaÃ§Ã£o de tipo, Rust irÃ¡ mostrar o seguinte erro,
que significa que o compilador precisa de mais informaÃ§oes para saber qual tipo de dados
queremos usar:</p>
<pre><code class="language-text">error[E0282]: type annotations needed
 --&gt; src/main.rs:2:9
  |
2 |     let guess = &quot;42&quot;.parse().expect(&quot;NÃ£o Ã© um nÃºmero!&quot;);
  |         ^^^^^
  |         |
  |         cannot infer type for `_`
  |         consider giving `guess` a type
</code></pre>
<p>VocÃª verÃ¡ anotaÃ§Ãµes de tipos diferentes para outros tipos de dados.</p>
<a class="header" href="print.html#tipos-escalares" id="tipos-escalares"><h3>Tipos escalares</h3></a>
<p>Um tipo <em>escalar</em> representa um valor Ãºnico. Rust tem quatro tipos escalares primÃ¡rios:
inteiros, nÃºmeros de ponto flutuante, booleanos e caracteres. VocÃª pode reconhecer
esses tipos de outras linguagens de programaÃ§Ã£o. Vamos pular para como eles funcionam no Rust.</p>
<a class="header" href="print.html#tipos-inteiros" id="tipos-inteiros"><h3>Tipos inteiros</h3></a>
<p>Um <em>inteiro</em> Ã© um nÃºmero sem a parte fracionÃ¡ria. Usamos
um tipo inteiro no CapÃ­tulo 2, o tipo <code>u32</code>. Esse tipo de
declaraÃ§Ã£o indica que
o valor associado deve ser um inteiro sem sinal (tipos inteiros com sinal comeÃ§am com <code>i</code>, em vez de <code>u</code>) que ocupa 32 bits de espaÃ§o. Tabela 3-1 mostra
os tipos inteiros internos ao Rust. Cada variante estÃ¡ na
coluna com sinal e sem sinal (por exemplo, <code>i16</code>) pode ser usada para declarar um valor do tipo
inteiro.</p>
<p><span class="caption">Tabela 3-1: Tipos inteiros no Rust</span></p>
<table><thead><tr><th> Tamanho </th><th> Signed  </th><th> Unsigned </th></tr></thead><tbody>
<tr><td> 8-bit   </td><td> <code>i8</code>    </td><td> <code>u8</code>     </td></tr>
<tr><td> 16-bit  </td><td> <code>i16</code>   </td><td> <code>u16</code>    </td></tr>
<tr><td> 32-bit  </td><td> <code>i32</code>   </td><td> <code>u32</code>    </td></tr>
<tr><td> 64-bit  </td><td> <code>i64</code>   </td><td> <code>u64</code>    </td></tr>
<tr><td> arch    </td><td> <code>isize</code> </td><td> <code>usize</code>  </td></tr>
</tbody></table>
<p>Cada variante pode ser com ou sem sinal e ter tamanho explÃ­cito.
<em>Signed</em> e <em>unsigned</em> refere-se Ã  possibilidade do nÃºmero ser
negativo ou positivo - em outras palavras, se o nÃºmero precisa de um sinal
com ele (signed) ou se sempre for
positivo pode ser representado sem um sinal (unsigned). Ã‰ como escrevemos nÃºmeros no papel: Quando
o sinal importa, o nÃºmero Ã© mostrado com um sinal de mais ou menos; contudo,
quando Ã© seguro assumir que o nÃºmero Ã© positivo, Ã© mostrado sem sinal.
NÃºmeros com sinais sÃ£o armazenados usando a representaÃ§Ã£o complemento de dois (se vocÃª nÃ£o tiver
certeza do que Ã© isso, vocÃª pode procurar sobre isso na internet; uma explicaÃ§Ã£o estÃ¡ fora do escopo
deste livro).</p>
<p>Cada variante com sinal pode armazenar nÃºmeros de -(2<sup>n - 1</sup>) atÃ© 2<sup>n -
1</sup> - 1 incluso, sendo <em>n</em> o nÃºmero de bits que varia de acordo com o uso. EntÃ£o, um
<code>i8</code> pode armazenar nÃºmeros de -(2<sup>7</sup>) atÃ© 2<sup>7</sup> - 1, que Ã©  igual
a -128 atÃ© 127. Variantes sem sinal pode armazenar nÃºmeros de 0 atÃ© 2<sup>n</sup> - 1,
entao um <code>u8</code> pode armazenar nÃºmeros de 0 atÃ© 2<sup>8</sup> - 1, que Ã© de 0 atÃ© 255.</p>
<p>AlÃ©m disso, os tipos <code>isize</code> e <code>usize</code> dependem do computador em que seu programa
estÃ¡ rodando: 64 bits se estiver em uma arquitetura de 64-bit e 32 bits
se sua arquitetura for 32-bit.</p>
<p>VocÃª pode criar inteiros literais em qualquer uma das formas mostrada na Tabela 3-2. Observe
que todos os literais de nÃºmeros, exceto o byte literal, permitem um sufixo de tipo,
como por exemplo, <code>57u8</code> e <code>_</code> sÃ£o separadores visuais, tal como <code>1_000</code>.</p>
<p><span class="caption">Tabela 3-2: Inteiros Literais no Rust</span></p>
<table><thead><tr><th> NÃºmeros literais    </th><th> Exemplo       </th></tr></thead><tbody>
<tr><td> Decimal             </td><td> <code>98_222</code>      </td></tr>
<tr><td> Hexadecimal         </td><td> <code>0xff</code>        </td></tr>
<tr><td> Octal               </td><td> <code>0o77</code>        </td></tr>
<tr><td> BinÃ¡rio             </td><td> <code>0b1111_0000</code> </td></tr>
<tr><td> Byte (<code>u8</code> apenas)  </td><td> <code>b'A'</code>        </td></tr>
</tbody></table>
<p>EntÃ£o como vocÃª pode saber qual tipo de inteiro usar? Se sentir-se inseguro, as
escolhas padrÃµes do Rust geralmente sÃ£o boas, e por padrÃ£o os inteiros sÃ£o do tipo <code>i32</code>: Esse
tipo geralmente Ã© o mais rÃ¡pido, atÃ© em sistemas de 64-bit. A
principal situaÃ§Ã£o em que vocÃª usuaria <code>isize</code> ou <code>usize</code> Ã© indexar algum tipo de coleÃ§Ã£o.</p>
<a class="header" href="print.html#tipos-de-ponto-flutuante" id="tipos-de-ponto-flutuante"><h4>Tipos de ponto flutuante</h4></a>
<p>Rust tambÃ©m tem dois tipos primitivos para <em>nÃºmeros de ponto flutuante</em>, que sÃ£o
nÃºmeros com casas decimais. Os pontos flutuantes do Rust sÃ£o
<code>f32</code> e <code>f64</code>, que tÃªm respectivamente os tamanhos de 32 e 64 bits. O tipo padrÃ£o Ã© <code>f64</code>
porque nos processadores modernos, a velocidade Ã© quase a mesma que em um <code>f32</code>, mas possui
maior precisÃ£o.</p>
<p>Esse exemplo mostra nÃºmeros de ponto flutuante em aÃ§Ã£o:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
</code></pre></pre>
<p>NÃºmeros em ponto flutuante sÃ£o representados de acordo com o padrÃ£o IEEE-754. O tipo
<code>f32</code> Ã© de precisÃ£o simples e <code>f64</code> tem precisÃ£o dupla.</p>
<a class="header" href="print.html#operaÃ§Ãµes-numÃ©ricas" id="operaÃ§Ãµes-numÃ©ricas"><h4>OperaÃ§Ãµes numÃ©ricas</h4></a>
<p>Rust suporta operaÃ§Ãµes matemÃ¡ticas bÃ¡sicas, vocÃª pode esperar
todas as seguintes operaÃ§Ãµes para todos os tipos numÃ©ricos: adiÃ§Ã£o, subtraÃ§Ã£o, multiplicaÃ§Ã£o, divisÃ£o e resto.
O cÃ³digo a seguir mostra como usar cada declaraÃ§Ã£o <code>let</code>:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // adiÃ§Ã£o
    let soma = 5 + 10;

    // subtraÃ§Ã£o
    let diferenca = 95.5 - 4.3;

    // multiplicaÃ§Ã£o
    let produto = 4 * 30;

    // divisÃ£o
    let quociente = 56.7 / 32.2;

    // resto
    let resto = 43 % 5;
}
</code></pre></pre>
<p>Cada expressÃ£o nessas declaraÃ§Ãµes, usa um operador matemÃ¡tico e computa um Ãºnico valor,
que entÃ£o Ã© atribuÃ­do Ã  uma variÃ¡vel.
ApÃªndice B contÃ©m uma lista de todos os operadores que o Rust suporta.</p>
<a class="header" href="print.html#o-tipo-booleano" id="o-tipo-booleano"><h4>O tipo booleano</h4></a>
<p>Como em diversas linguagens de programaÃ§Ã£o, o tipo Booleano em Rust possue dois valores
possÃ­veis: <code>true</code> e <code>false</code>. O tipo Booleano no Rust Ã© especificado usando <code>bool</code>.
Por exemplo:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let t = true;

    let f: bool = false; // com tipo explÃ­cito
}
</code></pre></pre>
<p>A principal utilizaÃ§Ã£o de valores Booleanos Ã© atravÃ©s dos condicionais, como um <code>if</code>.
Veremos como a expressÃ£o <code>if</code> funciona em Rust na seÃ§Ã£o
&quot;Controle de fluxo&quot;.</p>
<a class="header" href="print.html#o-tipo-de-caractere" id="o-tipo-de-caractere"><h4>O tipo de caractere</h4></a>
<p>AtÃ© agora trabalhamos apenas com nÃºmeros, mas Rust tambÃ©m suporta letras. O <code>char</code>
Ã© o tipo mais primitivo da linguaguem e o seguinte cÃ³digo
mostra uma forma de utilizÃ¡-lo. (Observe que o <code>char</code> Ã©
especÃ­ficado com aspas simples, Ã© o oposto de strings, que usa aspas duplas.)</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let c = 'z';
    let z = 'â„¤';
    let heart_eyed_cat = 'ğŸ˜»';
}
</code></pre></pre>
<p>O tipo <code>char</code> representa um valor unicode, o que quer dizer que vocÃª pode
armazenar muito mais que apenas ASCII. Letras com acentuaÃ§Ã£o; ideogramas chinÃªs, japonÃªs e
coreano; emoji; e caracteres nÃ£o visÃ­veis sÃ£o vÃ¡lidos.
Valores Unicode vÃ£o de <code>U+0000</code> atÃ© <code>U+D7FF</code> e <code>U+E000</code> atÃ©
<code>U+10FFFF</code> incluso. Contudo, um &quot;caractere&quot; nÃ£o Ã© realmente um conceito em Unicode,
entÃ£o a sua intuiÃ§Ã£o de o que Ã© um &quot;caractere&quot; pode nÃ£o combinar com o que Ã© um
<code>char</code> em Rust. Discutiremos esse tÃ³pico em detalhes em &quot;Strings&quot; no CapÃ­tulo 8.</p>
<a class="header" href="print.html#tipos-compostos" id="tipos-compostos"><h3>Tipos compostos</h3></a>
<p><em>Tipos compostos</em> podem agrupar vÃ¡rios valores em um Ãºnico tipo. Rust tem dois
tipos primitivos compostos: tuplas e vetores.</p>
<a class="header" href="print.html#o-tipo-tuplaero-de-valores" id="o-tipo-tuplaero-de-valores"><h4>O tipo tuplaero de valores</h4></a>
<p>Uma tupla Ã© de modo geral uma forma de agrupar um certo nÃºmero de valores
com uma variÃ¡vel do tipo composto.</p>
<p>Criamos uma tupla escrevendo uma lista de valores separados por vÃ­rgula
dentro de parÃªnteses. Cada posiÃ§Ã£o da tupla tem um tipo e os tipos dos elementos
da tupla nÃ£o necessitam serem iguais.
Adicionamos anotaÃ§Ãµes de tipo neste exemplo:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
</code></pre></pre>
<p>A variÃ¡vel <code>tup</code> liga-se a tupla, porque uma tupla Ã© considerada
um Ãºnico elemento composto. Para pegar os valores da tupla individualmente, podemos usar
a correspondÃªncia de padrÃµes para desestruturar o valor de uma tupla, como este:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!(&quot;O valor do y Ã©: {}&quot;, y);
}
</code></pre></pre>
<p>Esse primeito programa cria uma tupla e vincula ela Ã  variÃ¡vel <code>tup</code>. Em seguida,
ele usa um padrÃ£o com <code>let</code> para tirar <code>tup</code> e tranformÃ¡-lo em trÃªs variÃ¡veis
separadas, <code>x</code>, <code>y</code> e <code>z</code>. Isso Ã© chamado de <em>desestruturaÃ§Ã£o</em>, porque quebra uma Ãºnica tupla
em trÃªs partes. Finalmente, o programa exibe o valor de <code>y</code>,
que Ã© <code>6.4</code>.</p>
<p>AlÃ©m de desestruturar atravÃ©s da correspondÃªncia de padrÃµes, podemos
acessar diretamente um elemento da tupla usando um ponto (<code>.</code>) como Ã­ndice
do valor que queremos acessar. Por exemplo:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let quinhentos = x.0;

    let seis_ponto_quatro = x.1;

    let um = x.2;
}
</code></pre></pre>
<p>Esse programa cria uma tupla, <code>x</code>, e entÃ£o cria uma variÃ¡vel para cada
elemento usando seus Ã­ndices. Como ocorre nas maiorias das linguagens, o primeiro
Ã­ndice em uma tupla Ã© o 0.</p>
<a class="header" href="print.html#o-tipo-matriz" id="o-tipo-matriz"><h4>O tipo matriz</h4></a>
<p>Uma outra maneira de ter uma coleÃ§Ã£o de vÃ¡rios valores Ã© uma <em>matriz</em>. Diferentemente
de uma tupla, todos os elementos de uma matriz devem ser do mesmo tipo.
Matrizes em Rust sÃ£o diferentes de matrizes de outras linguagens, porque matrizes em Rust sÃ£o de
tamanhos fixos: uma vez declarado, eles nÃ£o podem aumentar ou diminuir de tamanho.</p>
<p>Em Rust, os valores que entram numa matriz sÃ£o escritos em uma lista separados
por vÃ­rgulas dentro de colchetes:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];
}
</code></pre></pre>
<p>Matrizes sÃ£o Ãºteis quando vocÃª deseja que seus dados sejam alocados em pilha do que
no heap (discutiremos mais sobre pilha e heap no CapÃ­tulo 4), ou quando
vocÃª quer garantir que sempre terÃ¡ um nÃºmero fixo de elementos. Uma matriz nÃ£o
Ã© tÃ£o flexÃ­vel como um vetor. Um vetor Ã© de tipo semelhante,
fornecido pela biblioteca padrÃ£o que <em>Ã©</em> permitido diminuir ou aumentar o tamanho.
Se vocÃª nÃ£o tem certeza se deve usar uma matriz ou vetor, vocÃª provavlemente usarÃ¡ um
vetor. O CapÃ­tulo 8 discute sobre vetores com mais detalhes.</p>
<p>Um exemplo de quando vocÃª poderia necessitar usar uma matriz no lugar de um vetor Ã©
um programa em que vocÃª precisa saber o nome dos meses do ano. Ã‰ improvÃ¡vel
que tal programa deseje adicionar ou remover meses, entÃ£o vocÃª pode usar uma matriz
porque vocÃª sabe que sempre conterÃ¡ 12 itens:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let meses = [&quot;Janeiro&quot;, &quot;Fevereiro&quot;, &quot;MarÃ§o&quot;, &quot;Abril&quot;, &quot;Maio&quot;, &quot;Junho&quot;, &quot;Julho&quot;,
              &quot;Agosto&quot;, &quot;Setembro&quot;, &quot;Outubro&quot;, &quot;Novembro&quot;, &quot;Dezembro&quot;];
#}</code></pre></pre>
<a class="header" href="print.html#acessando-um-elemento-da-matriz" id="acessando-um-elemento-da-matriz"><h5>Acessando um elemento da matriz</h5></a>
<p>Uma matriz Ã© um pedaÃ§o da memÃ³ria alocada na pilha. VocÃª pode acessar
os elementos da matriz usando indices, como a seguir:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];

    let primeiro = a[0];
    let segundo = a[1];
}
</code></pre></pre>
<p>Neste exemplo, a variÃ¡vel chamada <code>primeiro</code> irÃ¡ pegar o valor <code>1</code>, porque
Ã© o valor indexado por <code>[0]</code> na matriz. A variÃ¡vel chamada <code>segundo</code> irÃ¡
pegar o valor <code>2</code>, do indice <code>[1]</code> da matriz.</p>
<a class="header" href="print.html#acesso-invÃ¡lido-a-elemento-da-matriz" id="acesso-invÃ¡lido-a-elemento-da-matriz"><h5>Acesso invÃ¡lido a elemento da matriz</h5></a>
<p>O que acontece se vocÃª tentar acessar um elemento da matriz que estÃ¡ alÃ©m do fim
da matriz? Digamos que vocÃª mude o exemplo para o cÃ³digo a seguir, que serÃ¡ compilado,
mas existe um erro quando for executar:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let a = [1, 2, 3, 4, 5];
    let indice = 10;

    let elemento = a[indice];

    println!(&quot;O valor do elemento Ã©: {}&quot;, elemento);
}
</code></pre>
<p>Executando esse cÃ³digo usando <code>cargo run</code>, Ã© produzido o seguinte resultado:</p>
<pre><code class="language-text">$ cargo run
   Compiling arrays v0.1.0 (file:///projects/arrays)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/arrays`
thread '&lt;main&gt;' panicked at 'index out of bounds: the len is 5 but the index is
 10', src/main.rs:6
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>A compilaÃ§Ã£o nÃ£o produz nenhum erro, mas o programa resulta um
erro <em>em tempo de execuÃ§Ã£o</em> e nÃ£o uma saÃ­da com sucesso. Quando vocÃª
tenta acessar um elemento usando indexaÃ§Ã£o, o Rust verifica se o Ã­ndice especificado Ã© menor que o tamaho
da matriz. Se o Ã­ndice Ã© maior que o tamanho, o Rust vai entrar
em <em>pÃ¢nico</em>, que Ã© o termo usado pelo Rust quando um programa resulta em erro.</p>
<p>Esse Ã© o primeiro exemplo dos pricÃ­pios de seguranÃ§a do Rust em aÃ§Ã£o. Em vÃ¡rias
linguagens de baixo nÃ­vel, esse tipo de verificaÃ§Ã£o nÃ£o Ã© feita e quando vocÃª fornece um
Ã­ndice incorreto, memÃ³ria invÃ¡lida pode ser acessada. Rust protege vocÃª deste tipo
de erro ao sair imediatamente, em vez de permitir o acesso Ã  memÃ³ria e
continuando. O CapÃ­tulo 9 discute mais sobre o tratamento de erros do Rust.</p>
<a class="header" href="print.html#funÃ§Ãµes" id="funÃ§Ãµes"><h1>FunÃ§Ãµes</h1></a>
<p>FunÃ§Ãµes sÃ£o difundidas em cÃ³digos em Rust. VocÃª jÃ¡ viu uma das mais
importantes funÃ§Ãµes da linguagem: a funÃ§Ã£o <code>main</code>, que Ã© o
ponto de entrada de diversos programas. VocÃª tambÃ©m jÃ¡ viu a notaÃ§Ã£o <code>fn</code>, que permite vocÃª
declarar uma nova funÃ§Ã£o.</p>
<p>CÃ³digos em Rust usam, por convenÃ§Ã£o, o estilo <em>snake case</em> para nomes de funÃ§Ã£o e
variÃ¡vel. No snake case, todas as letras sÃ£o minÃºsculas e sublinhado (underline) separa as palavras.
Aqui estÃ¡ um programa que contÃ©m uma definiÃ§Ã£o de funÃ§Ã£o de exemplo:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;OlÃ¡, mundo!&quot;);

    outra_funcao();
}

fn outra_funcao() {
    println!(&quot;Outra funÃ§Ã£o.&quot;);
}
</code></pre></pre>
<p>As definiÃ§Ãµes de funÃ§Ãµes em Rust iniciam com <code>fn</code> e tem um par de parÃªnteses
depois do nome da funÃ§Ã£o. As chaves dizem ao compilador onde o
corpo da funÃ§Ã£o comeÃ§a e termina.</p>
<p>Podemos chamar qualqer funÃ§Ã£o que tenhamos definido, inserindo seu nome, seguido de um
conjunto de parenteses. Pelo fato da <code>outra_funcao</code> ter sido definida no programa, ela pode
ser chamada dentro da funÃ§Ã£o <code>main</code>. Note que definimos <code>outra_funcao</code>
<em>depois</em> da funÃ§Ã£o <code>main</code>; poderÃ­amos ter definido antes
tambÃ©m. Rust nÃ£o se importa onde vocÃª definiu suas funÃ§Ãµes, apenas que elas foram
definidas em algum lugar.</p>
<p>Vamos comeÃ§ar um novo projeto binÃ¡rio, chamado <em>funcoes</em> para explorar mais
funÃ§Ãµes. Coloque o exemplo <code>outra_funcao</code> em <em>src/main.rs</em> e execute-o. VocÃª
verÃ¡ a seguinte saÃ­da:</p>
<pre><code class="language-text">$ cargo run
   Compiling funcoes v0.1.0 (file:///projects/funcoes)
    Finished dev [unoptimized + debuginfo] target(s) in 0.28 secs
     Running `target/debug/funcoes`
OlÃ¡, mundo!
Outra funÃ§Ã£o.
</code></pre>
<p>As linhas sÃ£o executadas na ordem em que aparecem na funÃ§Ã£o <code>main</code>.
Primeiro, a mensagem &quot;OlÃ¡, mundo!&quot; Ã© exibida, e entÃ£o
<code>outra_funcao</code> Ã© chamada e exibida a mensagem.</p>
<a class="header" href="print.html#parÃ¢metros-de-funÃ§Ã£o" id="parÃ¢metros-de-funÃ§Ã£o"><h3>ParÃ¢metros de funÃ§Ã£o</h3></a>
<p>FunÃ§Ãµes tambÃ©m podem ser definidas tendo <em>parÃ¢metros</em>, que sÃ£o variÃ¡veis especiais
que fazem parte da assinatura da funÃ§Ã£o. Quando uma funÃ§Ã£o tem parÃ¢metros, vocÃª
pode fornecer tipos especÃ­ficos para esses parÃ¢metros. Tecnicamente, os
valores definidos sÃ£o chamados de <em>argumentos</em>, mas informalmente, as pessoas tendem
a usar as palavras <em>parÃ¢metro</em> e <em>argumento</em> para falar tanto de
variÃ¡veis da definiÃ§Ã£o da funÃ§Ã£o como os valores passados quando vocÃª
chama uma funÃ§Ã£o.</p>
<p>A seguinte versÃ£o (reescrita) da <code>outra_funcao</code> mostra como os parÃ¢metros
aparecem no Rust:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    outra_funcao(5);
}

fn outra_funcao(x: i32) {
    println!(&quot;O valor de x Ã©: {}&quot;, x);
}
</code></pre></pre>
<p>Tente executar este programa; vocÃª verÃ¡ a seguinte saÃ­da:</p>
<pre><code class="language-text">$ cargo run
   Compiling funcoes v0.1.0 (file:///projects/funcoes)
    Finished dev [unoptimized + debuginfo] target(s) in 1.21 secs
     Running `target/debug/funcoes`
O valor de x Ã©: 5
</code></pre>
<p>A declaraÃ§Ã£o de <code>outra_funcao</code> tem um parÃ¢metro chamado <code>x</code>. O tipo do
<code>x</code> Ã© especificado como <code>i32</code>. Quando <code>5</code> Ã© passado para a <code>outra_funcao</code>, a macro
<code>println!</code> coloca <code>5</code> onde o par de chaves estava na string
de formato.</p>
<p>Nas assinaturas de funÃ§Ã£o, vocÃª <em>deve</em> declarar o tipo de cada parÃ¢metro. Essa Ã©
decisÃ£o deliberada no design do Rust: exigir anotaÃ§Ãµes de tipo na definiÃ§Ã£o da funÃ§Ã£o,
significa que o compilador quase nunca precisarÃ¡ que as use em outro lugar do cÃ³digo
para especificar o que vocÃª quer.</p>
<p>Quando vocÃª precisa que uma funÃ§Ã£o tenha vÃ¡rios parÃ¢metros, separe as declaraÃ§Ãµes de parÃ¢metros
com vÃ­rgula, como a seguir:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    outra_funcao(5, 6);
}

fn outra_funcao(x: i32, y: i32) {
    println!(&quot;O valor de x Ã©: {}&quot;, x);
    println!(&quot;O valor de y Ã©: {}&quot;, y);
}
</code></pre></pre>
<p>Este exemplo cria uma funÃ§Ã£o com dois parÃ¢metros, ambos com o
tipo <code>i32</code>. EntÃ£o a funÃ§Ã£o exibe os valores de ambos os parÃ¢metros. Note que os
parÃ¢metros de funÃ§Ã£o nÃ£o precisam ser do mesmo tipo, isto apenas
aconteceu neste exemplo.</p>
<p>Vamos tentar executar este cÃ³digo. Substitua o programa <em>src/main.rs</em>, atualmente em seu projeto <em>funcoes</em>
com o exemplo anterior e execute-o usando <code>cargo run</code>:</p>
<pre><code class="language-text">$ cargo run
   Compiling funcoes v0.1.0 (file:///projects/funcoes)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/funcoes`
O valor de x Ã©: 5
O valor de y Ã©: 6
</code></pre>
<p>Porque nÃ³s chamamos a funÃ§Ã£o com <code>5</code> sendo o valor de<code>x</code> e <code>6</code> Ã© passado
como o valor de <code>y</code>, as duas cadeias sÃ£o impressas com esses valores.</p>
<a class="header" href="print.html#corpos-de-funÃ§Ã£o" id="corpos-de-funÃ§Ã£o"><h3>Corpos de funÃ§Ã£o</h3></a>
<p>Corpos de funÃ§Ã£o sÃ£o constituÃ­dos por uma sÃ©rie de declaraÃ§Ãµes que terminam,
opcionalmente, em uma expressÃ£o. AtÃ© agora, foram apresentadas apenas funÃ§Ãµes sem uma expressÃ£o final,
mas vocÃª viu uma expressÃ£o como parte de instruÃ§Ãµes. Porque Rust Ã© uma
linguagem baseada em expressÃ£o, essa Ã© uma importante distinÃ§Ã£o a ser entendida.
Outras linguagens nÃ£o tÃªm as mesmas distinÃ§Ãµes, entÃ£o, vamos ver o que sÃ£o
declaraÃ§Ãµes e expressÃµes e como elas afetam o corpo
das funÃ§Ãµes.</p>
<a class="header" href="print.html#declaraÃ§Ãµes-e-expressÃµes" id="declaraÃ§Ãµes-e-expressÃµes"><h3>DeclaraÃ§Ãµes e ExpressÃµes</h3></a>
<p>Na verdade, jÃ¡ usamos declaraÃ§Ãµes e expressÃµes. <em>DeclaraÃ§Ãµes</em> sÃ£o
instruÃ§Ãµes que executam alguma aÃ§Ã£o e nÃ£o retornam um resultado. E <em>expressÃµes</em>
retornam um resultado. Vamos ver alguns exemplos.</p>
<p>Criar uma variÃ¡vel e atribuir um valor a ela com a palavra-chave <code>let</code> Ã© uma declaraÃ§Ã£o.
Na Listagem 3-1, <code>let y = 6;</code> Ã© uma declaraÃ§Ã£o:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let y = 6;
}
</code></pre></pre>
<p><span class="caption">Listagem 3-1: A declaraÃ§Ã£o da funÃ§Ã£o <code>main</code> contendo uma declaraÃ§Ã£o.</span></p>
<p>DefiniÃ§Ãµes de funÃ§Ã£o tambÃ©m sÃ£o definiÃ§Ãµes; todo o exemplo
Ã© uma declaraÃ§Ã£o em si.</p>
<p>DefiniÃ§Ãµes nÃ£o retornam valores. Assim sendo, vocÃª nÃ£o pode atribuir uma declaraÃ§Ã£o <code>let</code> para
outra variÃ¡vel, como o cÃ³digo a seguir tenta fazer; vocÃª receberÃ¡ um erro:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let x = (let y = 6);
}
</code></pre>
<p>Quando vocÃª rodar esse programa, o erro serÃ¡ o seguinte:</p>
<pre><code class="language-text">$ cargo run
   Compiling funcoes v0.1.0 (file:///projects/funcoes)
error: expected expression, found statement (`let`)
 --&gt; src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^
  |
  = note: variable declaration using `let` is a statement
</code></pre>
<p>A declaraÃ§Ã£o <code>let y = 6</code> nÃ£o retorna um valor, entÃ£o nÃ£o existe nada para o
<code>x</code> se ligar. Isso Ã© diferente do que acontece em
outras linguagens, como
C e Ruby, onde a atribuiÃ§Ã£o retorna o valor atribuÃ­do. Nestas linguagens, vocÃª pode escrever <code>x = y = 6</code> e ter ambos, <code>x</code> e <code>y</code> contendo o valor
<code>6</code>; esse nÃ£o Ã© o caso em Rust.</p>
<p>ExpressÃµes avaliam algo e compÃµem a maior parte do cÃ³digo que
vocÃª escreverÃ¡ em Rust. Considere uma simples operaÃ§Ã£o matemÃ¡tica, como um <code>5 + 6</code>, que
Ã© uma expressÃ£o que avalia o valor <code>11</code>. ExpressÃµes podem fazer parte de
declaraÃ§Ãµes: na Listagem 3-1, o <code>6</code> na declaraÃ§Ã£o <code>let y = 6;</code> Ã© uma
expressÃ£o que avalia o valor <code>6</code>. A chamada de funÃ§Ã£o Ã© uma
expressÃ£o. Chamar uma macro Ã© uma expressÃ£o. O bloco que vamos usar para criar
um novo escopo, <code>{}</code>, Ã© uma expressÃ£o, por exemplo:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 5;

    let y = {
        let x = 3;
        x + 1
    };

    println!(&quot;O valor de y Ã©: {}&quot;, y);
}
</code></pre></pre>
<p>A expressÃ£o:</p>
<pre><code class="language-rust ignore">{
    let x = 3;
    x + 1
}
</code></pre>
<p>Ã© um bloco que, nesse exemplo, avalia <code>4</code>. Esse valor fica vinculado ao <code>y</code>
como parte da declaraÃ§Ã£o <code>let</code>. Note o  <code>x + 1</code> sem um ponto e vÃ­rgula no final, que Ã© diferente da maioria das linhas vistas atÃ© agora.
ExpressÃµes nÃ£o terminam com ponto e vÃ­rgula.
Se vocÃª adicionar um ponto e vÃ­rgula ao fim de uma expressÃ£o,
vocÃª a transforma em uma declaraÃ§Ã£o, que entÃ£o nÃ£o retornarÃ¡ um valor.
Tenha isso em mente, enquanto explora os valores e expressÃµes de retorno da funÃ§Ã£o a seguir.</p>
<a class="header" href="print.html#funÃ§Ãµes-com-valor-de-retorno" id="funÃ§Ãµes-com-valor-de-retorno"><h3>FunÃ§Ãµes com valor de retorno</h3></a>
<p>FunÃ§Ãµes podem retornar valores para o cÃ³digo que os chama. NÃ£o nomeamos valores de
retorno, mas declaramos o tipo deles depois de uma seta (<code>-&gt;</code>). Em Rust, o valor de retorno
da funÃ§Ã£o Ã© sinÃ´nimo do valor da expressÃ£o
final no bloco do corpo de uma funÃ§Ã£o. VocÃª pode retornar cedo de uma funÃ§Ã£o usando
a palavra-chave <code>return</code> e especificando um valor, mas a maioria das funÃ§Ãµes retorna
a Ãºltima expressÃ£o implicitamente. Veja um exemplo de uma funÃ§Ã£o que retorna um
valor:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn cinco() -&gt; i32 {
    5
}

fn main() {
    let x = cinco();

    println!(&quot;O valor de x Ã©: {}&quot;, x);
}
</code></pre></pre>
<p>NÃ£o hÃ¡ chamadas de funÃ§Ã£o, macros ou atÃ© mesmo declaraÃ§Ãµes <code>let</code> na funÃ§Ã£o<code>cinco</code></p>
<ul>
<li>apenas o nÃºmero <code>5</code> por si sÃ³. Essa Ã© uma funÃ§Ã£o perfeitamente vÃ¡lida em
Rust. Observe que o tipo de retorno da funÃ§Ã£o tambÃ©m Ã© especificado como <code>-&gt; i32</code>. Tente
executar este cÃ³digo; a saÃ­da deve ficar assim:</li>
</ul>
<pre><code class="language-text">$ cargo run
   Compiling funcoes v0.1.0 (file:///projects/funcoes)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30 secs
     Running `target/debug/funcoes`
O valor de x Ã©: 5
</code></pre>
<p>O <code>5</code> em<code>cinco</code> Ã© o valor de retorno da funÃ§Ã£o, e Ã© por isso que o tipo de retorno
Ã© <code>i32</code>. Vamos verificar isso com mais detalhes. Existem dois bits importantes:
primeiro, a linha <code>let x = cinco ();</code> mostra que estamos usando o valor de retorno de uma
funÃ§Ã£o para inicializar uma variÃ¡vel. Porque a funÃ§Ã£o <code>cinco</code> retorna um<code>5</code>,
essa linha Ã© a mesma que a seguinte:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
#}</code></pre></pre>
<p>Em segundo lugar, a funÃ§Ã£o <code>cinco</code> nÃ£o tem parÃ¢metros e define o tipo de
valor de retorno, mas o corpo da funÃ§Ã£o Ã© um <code>5</code> solitÃ¡rio sem ponto e vÃ­rgula
porque Ã© uma expressÃ£o cujo valor queremos retornar.</p>
<p>Vamos ver outro exemplo:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = soma_um(5);

    println!(&quot;O valor de x Ã©: {}&quot;, x);
}

fn soma_um(x: i32) -&gt; i32 {
    x + 1
}
</code></pre></pre>
<p>A execuÃ§Ã£o deste cÃ³digo irÃ¡ imprimir <code>O valor de x Ã©: 6</code>. Mas se colocarmos um
ponto e vÃ­rgula no final da linha que contÃ©m <code>x + 1</code>, alterando-o de
expressÃ£o para uma declaraÃ§Ã£o, receberemos um erro.</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let x = soma_um(5);

    println!(&quot;O valor de x Ã©: {}&quot;, x);
}

fn soma_um(x: i32) -&gt; i32 {
    x + 1;
}
</code></pre>
<p>Executar este cÃ³digo produz um erro, da seguinte maneira:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:7:28
  |
7 |   fn soma_um(x: i32) -&gt; i32 {
  |  ____________________________^
8 | |     x + 1;
  | |          - help: consider removing this semicolon
9 | | }
  | |_^ expected i32, found ()
  |
  = note: expected type `i32`
             found type `()`
</code></pre>
<p>A principal mensagem de erro, &quot;tipos incompatÃ­veis&quot;, revela o problema central com este
cÃ³digo. A definiÃ§Ã£o da funÃ§Ã£o <code>soma_um</code> diz que retornarÃ¡ uma
<code>i32</code>, mas as declaraÃ§Ãµes nÃ£o avaliam um valor expresso por<code>()</code>,
a tupla vazia. Portanto, nada Ã© retornado, o que contradiz a funÃ§Ã£o
definiÃ§Ã£o e resulta em erro. Nesta saÃ­da, Rust fornece uma mensagem para
possivelmente ajudar a corrigir este problema: sugere a remoÃ§Ã£o do ponto e vÃ­rgula, que
iria corrigir o erro.</p>
<a class="header" href="print.html#comentÃ¡rios" id="comentÃ¡rios"><h2>ComentÃ¡rios</h2></a>
<p>Todos os programadores se esforÃ§am para tornar seu cÃ³digo fÃ¡cil de entender, mas Ã s vezes
explicaÃ§Ã£o extra Ã© garantida. Nestes casos, os programadores deixam notas ou
<em>comentÃ¡rios</em>, em seus cÃ³digos fonte que o compilador irÃ¡ ignorar, mas as pessoas que
lerem o cÃ³digo-fonte podem achar Ãºtil.</p>
<p>Aqui estÃ¡ um comentÃ¡rio simples:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// OlÃ¡, mundo.
#}</code></pre></pre>
<p>Em Rust, os comentÃ¡rios devem comeÃ§ar com duas barras e continuar atÃ© o final da
linha. Para comentÃ¡rios que se estendem alÃ©m de uma Ãºnica linha, vocÃª precisarÃ¡ incluir
<code>//</code> em cada linha, assim:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// EntÃ£o, estamos fazendo algo complicado aqui, tempo suficiente para que precisemos
// vÃ¡rias linhas de comentÃ¡rios para fazer isso! Ufa! Espero que este comentÃ¡rio
// explique o que estÃ¡ acontecendo.
#}</code></pre></pre>
<p>ComentÃ¡rios tambÃ©m podem ser colocados no final das linhas contendo cÃ³digo:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let numero_da_sorte = 7; // Estou com sorte hoje.
}
</code></pre></pre>
<p>Mas vocÃª verÃ¡ com mais frequÃªncia essas palavras nesse formato, com o comentÃ¡rio em uma
linha separada acima do cÃ³digo que estÃ¡ anotando:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // Estou com sorte hoje.
    let numero_da_sorte = 7;
}
</code></pre></pre>
<p>O Rust tambÃ©m tem outro tipo de comentÃ¡rio, comentÃ¡rios de documentaÃ§Ã£o, que discutiremos
no CapÃ­tulo 14.</p>
<a class="header" href="print.html#controle-de-fluxo" id="controle-de-fluxo"><h2>Controle de fluxo</h2></a>
<p>Decidir se deve ou nÃ£o executar algum cÃ³digo, dependendo se uma condiÃ§Ã£o Ã© verdadeira
e decidir executar algum cÃ³digo repetidamente enquanto uma condiÃ§Ã£o Ã© verdadeira,
sÃ£o blocos de construÃ§Ã£o bÃ¡sicos na maioria das linguagens de programaÃ§Ã£o. As construÃ§Ãµes
mais comuns que permitem controlar o fluxo de execuÃ§Ã£o do cÃ³digo Rust sÃ£o as expressÃµes <code>if</code> e
laÃ§os de repetiÃ§Ã£o.</p>
<a class="header" href="print.html#expressÃ£o-if" id="expressÃ£o-if"><h3>ExpressÃ£o <code>if</code></h3></a>
<p>Uma expressÃ£o <code>if</code> permite ramificar seu cÃ³digo dependendo das condiÃ§Ãµes. VocÃª
fornecer uma condiÃ§Ã£o e, em seguida, estado, &quot;Se esta condiÃ§Ã£o for cumprida, execute este bloco
de cÃ³digo. Se a condiÃ§Ã£o nÃ£o for atendida, nÃ£o execute este bloco de cÃ³digo. â€</p>
<p>Crie um novo projeto chamado <em>branches</em> no seu diretÃ³rio <em>projects</em> para explorar
a expressÃ£o <code>if</code>. No arquivo * src / main.rs *, digite o seguinte:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let numero = 3;

    if numero &lt; 5 {
        println!(&quot;condiÃ§Ã£o era verdadeira&quot;);
    } else {
        println!(&quot;condiÃ§Ã£o era falsa&quot;);
    }
}
</code></pre></pre>
<!-- NEXT PARAGRAPH WRAPPED WEIRD INTENTIONALLY SEE #199 -->
<p>Todas as expressÃµes <code>if</code> comeÃ§am com a palavra-chave <code>if</code>, que Ã© seguida por uma
condiÃ§Ã£o. Neste caso, a condiÃ§Ã£o verifica se a variÃ¡vel
<code>number</code> tem um valor menor que 5. O bloco de cÃ³digo que queremos executar se o
condiÃ§Ã£o Ã© verdadeira Ã© colocada imediatamente apÃ³s a condiÃ§Ã£o dentro de chaves.
Blocos de cÃ³digo associados Ã s condiÃ§Ãµes em expressÃµes <code>if</code> sÃ£o
Ã s vezes chamado de <em>divisÃµes</em>, assim como as expressÃµes <code>de combinaÃ§Ã£o</code> que nÃ³s
discutimos na seÃ§Ã£o â€œComparando o Palpite ao NÃºmero Secretoâ€ de
CapÃ­tulo 2.</p>
<p>Opcionalmente, tambÃ©m podemos incluir uma expressÃ£o <code>else</code>, que escolhemos
fazer aqui, para dar ao programa um bloco de cÃ³digo alternativo a ser executado, caso a
condiÃ§Ã£o seja avaliada como falsa. Se vocÃª nÃ£o fornecer uma expressÃ£o <code>else</code> e a
condiÃ§Ã£o for falsa, o programa simplesmente ignorarÃ¡ o bloco <code>if</code> e passarÃ¡ para o
prÃ³ximo bit de cÃ³digo.</p>
<p>Tente executar este cÃ³digo; vocÃª deve ver a seguinte saÃ­da:</p>
<pre><code class="language-text">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/branches`
condiÃ§Ã£o era verdadeira
</code></pre>
<p>Vamos tentar alterar o valor de <code>numero</code> para um valor que torne a condiÃ§Ã£o
<code>false</code> para ver o que acontece:</p>
<pre><code class="language-rust ignore">let numero = 7;
</code></pre>
<p>Execute o programa novamente e observe a saÃ­da:</p>
<pre><code class="language-text">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/branches`
condiÃ§Ã£o era falsa
</code></pre>
<p>TambÃ©m Ã© importante notar que a condiÃ§Ã£o neste cÃ³digo <em>deve</em> ser um <code>bool</code>. E se
a condiÃ§Ã£o nÃ£o Ã© um <code>bool</code>, nÃ³s vamos receber um erro. Por exemplo:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let numero = 3;

    if numero {
        println!(&quot;nÃºmero era 3&quot;);
    }
}
</code></pre>
<p>A condiÃ§Ã£o <code>if</code> Ã© avaliada para um valor de <code>3</code> desta vez, e Rust lanÃ§a um
erro:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:4:8
  |
4 |     if numero {
  |        ^^^^^^ expected bool, found integral variable
  |
  = note: expected type `bool`
             found type `{integer}`
</code></pre>
<p>O erro indica que Rust esperava um <code>bool</code>, mas obteve um inteiro. Ao contrÃ¡rio de
linguagens como Ruby e JavaScript, o Rust nÃ£o tentarÃ¡ automaticamente
converter tipos nÃ£o-booleanos em um booleano. VocÃª deve explicitar e sempre fornecer
<code>if</code> com um booleano como sua condiÃ§Ã£o. Se quisermos que o bloco de cÃ³digo <code>if</code> seja executado
somente quando um nÃºmero nÃ£o Ã© igual a <code>0</code>, por exemplo, podemos mudar o <code>if</code>
para o seguinte:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let numero = 3;

    if numero != 0 {
        println!(&quot;nÃºmero era algo diferente de zero&quot;);
    }
}
</code></pre></pre>
<p>A execuÃ§Ã£o deste cÃ³digo irÃ¡ imprimir <code>nÃºmero era algo diferente de zero</code>.</p>
<a class="header" href="print.html#gerenciando-mÃºltiplas-condiÃ§Ãµes-com-else-if" id="gerenciando-mÃºltiplas-condiÃ§Ãµes-com-else-if"><h4>Gerenciando MÃºltiplas CondiÃ§Ãµes com <code>else if</code></h4></a>
<p>VocÃª pode ter vÃ¡rias condiÃ§Ãµes combinando <code>if</code> e<code>else</code> em um <code>else if</code>.
Por exemplo:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let numero = 6;

    if numero % 4 == 0 {
        println!(&quot;nÃºmero Ã© divisÃ­vel por 4&quot;);
    } else if numero % 3 == 0 {
        println!(&quot;nÃºmero Ã© divisÃ­vel por 3&quot;);
    } else if numero % 2 == 0 {
        println!(&quot;nÃºmero Ã© divisÃ­vel por 2&quot;);
    } else {
        println!(&quot;nÃºmero nÃ£o Ã© divisÃ­vel por 4, 3 ou 2&quot;);
    }
}
</code></pre></pre>
<p>Este programa tem quatro caminhos possÃ­veis. Depois de executÃ¡-lo, vocÃª deve
ver a seguinte saÃ­da:</p>
<pre><code class="language-text">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/branches`
nÃºmero Ã© divisÃ­vel por 3
</code></pre>
<p>Quando este programa Ã© executado, ele verifica cada expressÃ£o <code>if</code> por sua vez e executa
o primeiro corpo para o qual a condiÃ§Ã£o Ã© verdadeira. Note que mesmo que 6 seja
divisÃ­vel por 2, nÃ³s nÃ£o vemos a saÃ­da <code>o nÃºmero Ã© divisÃ­vel por 2</code>, nem vemos o
texto <code>nÃºmero nÃ£o Ã© divisÃ­vel por 4, 3 ou 2</code> do bloco <code>else</code>.
Isso ocorre porque o Rust sÃ³ executa o bloco para a primeira condiÃ§Ã£o verdadeira e,
depois de encontrar um, nÃ£o verifica o restante.</p>
<p>Usar muitas expressÃµes <code>else if</code> pode confundir seu cÃ³digo, portanto, se vocÃª tiver
mais de uma, convÃ©m refatorar seu cÃ³digo. O CapÃ­tulo 6 descreve uma poderosa
construÃ§Ã£o de ramificaÃ§Ã£o em Rust chamada <code>match</code> para esses casos.</p>
<a class="header" href="print.html#usando-if-em-uma-declaraÃ§Ã£o-let" id="usando-if-em-uma-declaraÃ§Ã£o-let"><h4>Usando <code>if</code> em uma declaraÃ§Ã£o <code>let</code></h4></a>
<p>Pelo fato de <code>if</code> ser uma expressÃ£o, podemos usÃ¡-la do lado direito de uma declaraÃ§Ã£o <code>let</code>,
como na Listagem 3-2:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let condicao = true;
    let numero = if condicao {
        5
    } else {
        6
    };

    println!(&quot;O valor do nÃºmero Ã©: {}&quot;, numero);
}
</code></pre></pre>
<p><span class = "caption"> Listagem 3-2: Atribuindo o resultado de uma expressÃ£o <code>if</code>
para uma variÃ¡vel </span></p>
<p>A variÃ¡vel <code>numero</code> serÃ¡ ligada a um valor baseado no resultado da expressÃ£o <code>if</code>.
Execute este cÃ³digo para ver o que acontece:</p>
<pre><code class="language-text">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30 secs
     Running `target/debug/branches`
O valor do nÃºmero Ã©: 5
</code></pre>
<p>Lembre-se de que os blocos de cÃ³digo sÃ£o avaliados atÃ© a Ãºltima expressÃ£o, e os
nÃºmeros por si mesmos tambÃ©m sÃ£o expressÃµes. Neste caso, o valor de
toda a expressÃ£o <code>if</code> depende de qual bloco de cÃ³digo Ã© executado. Isso significa que
os valores que tÃªm o potencial de serem resultados de cada braÃ§o do <code>if</code> e que devem ser
do mesmo tipo; na Listagem 3-2, os resultados do braÃ§o <code>if</code> e do <code>else</code>
eram inteiros <code>i32</code>. Se os tipos forem incompatÃ­veis, como no exemplo a
seguir, receberemos um erro:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let condicao = true;

    let numero = if condicao {
        5
    } else {
        &quot;seis&quot;
    };

    println!(&quot;O valor do nÃºmero Ã©: {}&quot;, numero);
}
</code></pre>
<p>Quando tentamos executar esse cÃ³digo, recebemos um erro. Os braÃ§os <code>if</code> e<code>else</code> possuem
valores de tipos que sÃ£o incompatÃ­veis, e Rust indica exatamente onde encontrar o
problema no programa:</p>
<pre><code class="language-text">error[E0308]: if and else have incompatible types
 --&gt; src/main.rs:4:18
  |
4 |       let numero = if condicao {
  |  __________________^
5 | |         5
6 | |     } else {
7 | |         &quot;seis&quot;
8 | |     };
  | |_____^ expected integral variable, found &amp;str
  |
  = note: expected type `{integer}`
             found type `&amp;str`
</code></pre>
<p>A expressÃ£o no bloco <code>if</code> Ã© avaliada como um inteiro, e a expressÃ£o no bloco<code>else</code> Ã©
avaliada como uma string. Isso nÃ£o funcionarÃ¡ porque as variÃ¡veis precisam ter
um Ãºnico tipo. Rust precisa saber em tempo de compilaÃ§Ã£o qual Ã© o tipo da variÃ¡vel <code>numero</code>,
definitivamente, para que possa verificar em tempo de compilaÃ§Ã£o que seu tipo Ã©
vÃ¡lido em todos os lugares em que usamos <code>numero</code>. Rust nÃ£o seria capaz de fazer isso se o tipo
de <code>numero</code> fosse determinado apenas em tempo de execuÃ§Ã£o; o compilador seria mais complexo e
faria menos garantias sobre o cÃ³digo se tivesse que manter o controle de
vÃ¡rios tipos hipotÃ©ticos para qualquer variÃ¡vel.</p>
<a class="header" href="print.html#repetiÃ§Ã£o-com-laÃ§os-de-repetiÃ§Ã£o" id="repetiÃ§Ã£o-com-laÃ§os-de-repetiÃ§Ã£o"><h3>RepetiÃ§Ã£o com laÃ§os de repetiÃ§Ã£o</h3></a>
<p>Geralmente, Ã© Ãºtil executar um bloco de cÃ³digo mais de uma vez. Para essa tarefa,
o Rust fornece vÃ¡rios <em>loops</em>. Um loop percorre o cÃ³digo dentro do corpo do loop
atÃ© o final e, em seguida, inicia imediatamente no inÃ­cio. Para
experimentar loops, vamos criar um novo projeto chamado <em>loops</em>.</p>
<p>O Rust possui trÃªs tipos de loops: <code>loop</code>,<code>while</code> e <code>for</code>. Vamos tentar cada um.</p>
<a class="header" href="print.html#cÃ³digo-de-repetiÃ§Ã£o-com-loop" id="cÃ³digo-de-repetiÃ§Ã£o-com-loop"><h4>CÃ³digo de RepetiÃ§Ã£o com <code>loop</code></h4></a>
<p>A palavra-chave <code>loop</code> diz ao Rust para executar um bloco de cÃ³digo vÃ¡rias vezes
para sempre ou atÃ© que vocÃª diga explicitamente para parar.</p>
<p>Como exemplo, altere o arquivo <em>src/main.rs</em> do diretÃ³rio <em>loops</em> para algo
como isso:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    loop {
        println!(&quot;novamente!&quot;);
    }
}
</code></pre>
<p>Quando executamos este programa, veremos ``novamente!` impresso repetidamente
atÃ© que paremos o programa manualmente. A maioria dos terminais suporta um atalho de teclado,
<span class = "keystroke"> ctrl-c </span>, para parar um programa que estÃ¡ preso em um
loop contÃ­nuo. De uma chance:</p>
<pre><code class="language-text">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.29 secs
     Running `target/debug/loops`
novamente!
novamente!
novamente!
novamente!
^Cnovamente!
</code></pre>
<p>O sÃ­mbolo <code>^C</code> representa onde vocÃª pressionou <span class ="keystroke"> ctrl-c
</span>. VocÃª pode ou nÃ£o ver a palavra <code>novamente!</code> Impressa depois do <code>^C</code>,
dependendo de onde o cÃ³digo estava no loop quando recebeu o sinal de parada.</p>
<p>Felizmente, o Rust oferece outra maneira mais confiÃ¡vel de sair de um loop.
VocÃª pode colocar a palavra-chave <code>break</code> dentro do loop para dizer ao programa quando
parar de executar o loop. Lembre-se que fizemos isso no jogo de adivinhaÃ§Ã£o no
â€œQuitting After a Guess Correctâ€ do CapÃ­tulo 2 para sair do
programa quando o usuÃ¡rio ganhou o jogo, adivinhando o nÃºmero correto.</p>
<a class="header" href="print.html#loops-condicionais-com-while" id="loops-condicionais-com-while"><h4>Loops condicionais com <code>while</code></h4></a>
<p>Geralmente, Ã© Ãºtil para um programa avaliar uma condiÃ§Ã£o dentro de um loop. Enquanto
a condiÃ§Ã£o Ã© verdadeira, o loop Ã© executado. Quando a condiÃ§Ã£o deixa de ser verdadeira,
o programa chama o <code>break</code>, parando o loop. Esse tipo de loop pode ser implementado
usando uma combinaÃ§Ã£o de <code>loop</code>,<code>if</code>, <code>else</code> e<code>break</code>; vocÃª poderia tentar isso
agora em um programa, se vocÃª quiser.</p>
<p>No entanto, esse padrÃ£o Ã© tÃ£o comum que o Rust possui uma construÃ§Ã£o de linguagem integrada
para isso, chamado de loop <code>while</code>. A Listagem 3-3 usa <code>while</code>: o programa faz o loop
trÃªs vezes, a contagem decrescente de cada vez e, depois do ciclo, imprime
outra mensagem e sai.</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut numero = 3;

    while numero != 0 {
        println!(&quot;{}!&quot;, numero);

        numero = numero - 1;
    }

    println!(&quot;LIFTOFF!!!&quot;);
}
</code></pre></pre>
<p><span class = "caption"> Listagem 3-3: Usando um loop <code>while</code> para executar o cÃ³digo enquanto
condiÃ§Ã£o for verdadeira </span></p>
<p>Essa construÃ§Ã£o elimina muito o aninhamento que seria necessÃ¡rio se vocÃª usasse
<code>loop</code>,<code>if</code>, <code>else</code> e<code>break</code>, e Ã© mais claro. Enquanto a condiÃ§Ã£o for
verdadeira, o cÃ³digo Ã© executado; caso contrÃ¡rio, sai do loop.</p>
<a class="header" href="print.html#looping-atravÃ©s-de-uma-coleÃ§Ã£o-com-for" id="looping-atravÃ©s-de-uma-coleÃ§Ã£o-com-for"><h4>Looping atravÃ©s de uma coleÃ§Ã£o com <code>for</code></h4></a>
<p>VocÃª poderia usar a construÃ§Ã£o <code>while</code> para fazer um loop sobre os elementos de uma coleÃ§Ã£o,
como uma matriz. Por exemplo, vamos ver a Listagem 3-4:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut indice = 0;

    while indice &lt; 5 {
        println!(&quot;O valor Ã©: {}&quot;, a[indice]);

        indice = indice + 1;
    }
}
</code></pre></pre>
<p><span class = "caption"> Listagem 3-4: percorrendo cada elemento de uma coleÃ§Ã£o
usando um loop <code>while</code> </span></p>
<p>Aqui, o cÃ³digo conta atravÃ©s dos elementos na matriz. ComeÃ§a no Ã­ndice
<code>0</code> e, em seguida, faz um loop atÃ© atingir o Ã­ndice final na matriz (isto Ã©,
quando <code>indice &lt;5</code> nÃ£o Ã© mais verdadeiro). Executando este cÃ³digo irÃ¡ imprimir todos os elementos
na matriz:</p>
<pre><code class="language-text">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
     Running `target/debug/loops`
O valor Ã©: 10
O valor Ã©: 20
O valor Ã©: 30
O valor Ã©: 40
O valor Ã©: 50
</code></pre>
<p>Todos os cinco valores de matriz aparecem no terminal, conforme esperado. Embora <code>indice</code>
vai chegar a um valor de <code>5</code> em algum momento, o loop para de executar antes de tentar
para buscar um sexto valor da matriz.</p>
<p>Mas essa abordagem Ã© propensa a erros; poderÃ­amos fazer o programa entrar em pÃ¢nico se o
o comprimento do Ã­ndice estivesse incorreto. TambÃ©m Ã© lento, porque o compilador adiciona cÃ³digo de tempo de execuÃ§Ã£o
para executar a verificaÃ§Ã£o condicional em cada elemento em cada iteraÃ§Ã£o
atravÃ©s do loop.</p>
<p>Como uma alternativa mais concisa, vocÃª pode usar um laÃ§o <code>for</code> e executar algum cÃ³digo
para cada item de uma coleÃ§Ã£o. Um laÃ§o <code>for</code> parece com este cÃ³digo na Listagem 3-5:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];

    for elemento in a.iter() {
        println!(&quot;O valor Ã©: {}&quot;, elemento);
    }
}
</code></pre></pre>
<p><span class = "caption"> Listagem 3-5: percorrendo cada elemento de uma coleÃ§Ã£o
usando um laÃ§o <code>for</code> </span></p>
<p>Quando executamos esse cÃ³digo, veremos a mesma saÃ­da da listagem 3-4. Mais
importante, agora aumentamos a seguranÃ§a do cÃ³digo e eliminamos a
chance de erros que podem resultar de ir alÃ©m do final da matriz ou nÃ£o
indo longe o suficiente e faltando alguns itens.</p>
<p>Por exemplo, no cÃ³digo da Listagem 3-4, se vocÃª removeu um item do array <code>a</code>,
mas esqueceu de atualizar a condiÃ§Ã£o para <code>while indice &lt;4</code>, o cÃ³digo causaria um
pÃ¢nico. Usando o loop <code>for</code>, vocÃª nÃ£o precisa se lembrar de alterar qualquer outro
cÃ³digo se vocÃª alterou o nÃºmero de valores na matriz.</p>
<p>A seguranÃ§a e a concisÃ£o dos loops <code>for</code> fazem deles o loop mais comumente usado
em Rust. Mesmo em situaÃ§Ãµes em que vocÃª deseja executar algum cÃ³digo
certo nÃºmero de vezes, como no exemplo da contagem regressiva que usou um loop <code>while</code>
da Listagem 3-3, a maioria dos Rustaceans usaria um loop <code>for</code>. A maneira de fazer isso
seria usar um <code>Range</code>, que Ã© um tipo fornecido pela biblioteca padrÃ£o
que gera todos os nÃºmeros em sequÃªncia a partir de um nÃºmero e terminando
antes de outro nÃºmero.</p>
<p>Veja como seria a contagem regressiva usando um loop <code>for</code> e outro mÃ©todo,
que nÃ³s ainda nÃ£o falamos, <code>rev</code>, para reverter o intervalo:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    for numero in (1..4).rev() {
        println!(&quot;{}!&quot;, numero);
    }
    println!(&quot;LIFTOFF!!!&quot;);
}
</code></pre></pre>
<p>Este cÃ³digo Ã© um pouco melhor, nÃ£o Ã©?</p>
<a class="header" href="print.html#resumo-1" id="resumo-1"><h2>Resumo</h2></a>
<p>VocÃª conseguiu! Esse foi um capÃ­tulo considerÃ¡vel: vocÃª aprendeu sobre variÃ¡veis, tipos
de dados escalares e compostos, funÃ§Ãµes, comentÃ¡rios, expressÃµes <code>if</code> e loops! E se
vocÃª quer praticar com os conceitos discutidos neste capÃ­tulo, tente construir
programas para fazer o seguinte:</p>
<ul>
<li>Converta temperaturas entre Fahrenheit e Celsius.</li>
<li>Gerar o n-Ã©simo nÃºmero de Fibonacci.</li>
<li>Imprima a letra da canÃ§Ã£o de natal &quot;Os Doze Dias de Natal&quot;
aproveitando a repetiÃ§Ã£o na mÃºsica.</li>
</ul>
<p>Quando vocÃª estiver pronto para seguir em frente, falaremos sobre um conceito em Rust que <em>nÃ£o</em>
comumente existente em outras linguagens de programaÃ§Ã£o: propriedade.</p>
<a class="header" href="print.html#entendendo-ownership" id="entendendo-ownership"><h1>Entendendo <em>Ownership</em></h1></a>
<p><em>Ownership</em> (posse) Ã© a caracterÃ­stica mais Ãºnica do Rust, que o permite ter
garantias de seguranÃ§a de memÃ³ria sem precisar de um <em>garbage collector</em>. Logo,
Ã© importante entender como funciona ownership no Rust. Neste capÃ­tulo, falaremos
sobre ownership e tambÃ©m sobre vÃ¡rias caracterÃ­sticas relacionadas: <em>borrowing</em>,
<em>slices</em> e como o Rust dispÃµe seus dados na memÃ³ria.</p>
<a class="header" href="print.html#o-que-Ã‰-ownership" id="o-que-Ã‰-ownership"><h2>O Que Ã‰ Ownership?</h2></a>
<p>A caracterÃ­stica central do Rust Ã© <em>ownership</em>. Embora seja bem direta de
explicar, ela tem implicaÃ§Ãµes profundas em todo o resto da linguagem.</p>
<p>Todos os programas tÃªm que decidir de que forma vÃ£o usar a memÃ³ria do computador
durante a execuÃ§Ã£o. Algumas linguagens possuem <em>garbage collection</em> (coleta de
lixo), que constantemente busca segmentos de memÃ³ria que jÃ¡ nÃ£o sÃ£o mais
utilizados enquanto o programa executa; em outras linguagens, o programador deve
alocar e liberar memÃ³ria de forma explÃ­cita. Rust usa uma terceira abordagem: a
memÃ³ria Ã© gerenciada atravÃ©s de um sistema de posse, que tem um conjunto de
regras verificadas em tempo de compilaÃ§Ã£o. Nenhuma caracterÃ­stica relacionada ao
ownership implica qulaquer custo em tempo de execuÃ§Ã£o.</p>
<p>Como ownership Ã© um conceito novo para muitos programadores, leva um pouco de
tempo para se acostumar. A boa notÃ­cia Ã© que quanto mais experiente vocÃª se
torna em Rust e nas regras do sistema de posse, mais vocÃª serÃ¡ capaz de
escrever, naturalmente, cÃ³digo seguro e eficiente. Fique aÃ­!</p>
<p>Quando vocÃª entender ownership, vocÃª terÃ¡ uma fundaÃ§Ã£o sÃ³lida para entender as
caracterÃ­sticas que fazem o Rust ser Ãºnico. Neste capÃ­tulo, vocÃª vai aprender
ownership trabalhando em alguns exemplos com foco em uma estrutura de dados
muito comum: <em>strings</em>.</p>
<!-- PROD: START BOX -->
<blockquote>
<a class="header" href="print.html#a-pilha-e-a-heap" id="a-pilha-e-a-heap"><h3>A Pilha e a <em>Heap</em></h3></a>
<p>Em muitas linguagens de programaÃ§Ã£o, nÃ£o temos que pensar muito sobre a pilha
e sobre a <em>heap</em>. Mas em uma linguagem de programaÃ§Ã£o de sistemas, como Rust,
o fato de um valor estar na pilha ou na heap tem impacto na forma como a
linguagem se comporta e no porquÃª de termos que tomar certas decisÃµes. Vamos
descrever partes do ownership em relaÃ§Ã£o Ã  pilha e Ã  heap mais para a frente
neste capÃ­tulo, entÃ£o aqui vai uma explicaÃ§Ã£o preparatÃ³ria.</p>
<p>Tanto a pilha como a heap sÃ£o partes da memÃ³ria que estÃ£o disponÃ­veis ao seu
cÃ³digo para uso em tempo de execuÃ§Ã£o, mas elas sÃ£o estruturadas de formas
diferentes. A pilha armazena valores na ordem em que eles chegam, e os remove
na ordem inversa. Isto Ã© chamado de <em>last in, first out</em> (Ãºltimo a chegar,
primeiro a sair). Imagine uma pilha de pratos: quando vocÃª coloca mais pratos,
vocÃª os pÃµe em cima da pilha, e quando vocÃª precisa de um prato, vocÃª pega o
que estÃ¡ no topo. Adicionar ou remover pratos do meio ou do fundo nÃ£o funciona
tÃ£o bem! Dizemos fazer um <em>push</em> na pilha quando nos refererimos a inserir
dados, e fazer um <em>pop</em> da pilha quando nos referimos a remover dados.</p>
<p>A pilha Ã© rÃ¡pida por conta da forma como ela acessa os dados: ela nunca tem
que procurar um lugar para colocar novos dados, ou um lugar de onde obter
dados, este lugar Ã© sempre o topo da pilha. Outra propriedade que faz a pilha
ser rÃ¡pida Ã© que todos os dados contidos nela devem ocupar um tamanho fixo e
conhecido.</p>
<p>Para dados com um tamanho desconhecido em tempo de compilaÃ§Ã£o, ou com um
tamanho que pode mudar, podemos usar a heap em vez da pilha. A heap Ã© menos
organizada: quando colocamos dados na heap, nÃ³s pedimos um certo espaÃ§o de
memÃ³ria. O sistema operacional encontra um espaÃ§o vazio em algum lugar na heap
que seja grande o suficiente, marca este espaÃ§o como em uso, e nos retorna um
<em>ponteiro</em>, que Ã© o endereÃ§o deste local. Este processo Ã© chamado de
<em>alocar na heap</em>, e Ã s vezes se abrevia esta frase como apenas &quot;alocaÃ§Ã£o&quot;.
Colocar valores na pilha nÃ£o Ã© considerado uma alocaÃ§Ã£o. Como o ponteiro tem
um tamanho fixo e conhecido, podemos armazenÃ¡-lo na pilha, mas quando queremos
os dados, de fato, temos que seguir o ponteiro.</p>
<p>Imagine que vocÃª estÃ¡ sentado em um restaurante. Quando vocÃª entra, vocÃª diz
o nÃºmero de pessoas que estÃ£o com vocÃª, o atendente encontra uma mesa vazia
que acomode todos e os leva para lÃ¡. Se alguÃ©m do seu grupo chegar mais tarde,
poderÃ¡ perguntar onde vocÃªs estÃ£o para encontrÃ¡-los.</p>
<p>Acessar dados na heap Ã© mais lento do que acessar dados na pilha, porque vocÃª
precisa seguir um ponteiro para chegar lÃ¡. Processadores de hoje em dia sÃ£o
mais rÃ¡pidos se nÃ£o precisarem pular tanto de um lugar para outro na memÃ³ria.
Continuando com a analogia, considere um garÃ§om no restaurante anotando os
pedidos de vÃ¡rias mesas. Ã‰ mais eficiente anotar todos os pedidos de uma Ãºnica
mesa antes de passar para a mesa seguinte. Anotar um pedido da mesa A, depois
um da mesa B, depois outro da mesa A, e outro da mesa B novamente seria um
processo bem mais lento. Da mesma forma, um processador pode cumprir melhor
sua tarefa se trabalhar em dados que estÃ£o prÃ³ximos uns dos outros (assim como
estÃ£o na pilha) em vez de dados afastados entre si (como podem estar na heap).
Alocar um espaÃ§o grande na heap tambÃ©m pode levar tempo.</p>
<p>Quando nosso cÃ³digo chama uma funÃ§Ã£o, os valores passados para ela (incluindo
possÃ­veis ponteiros para dados na heap) e as variÃ¡veis locais da funÃ§Ã£o sÃ£o
colocados na pilha. Quando a funÃ§Ã£o termina, esses valores sÃ£o removidos dela.</p>
<p>Rastrear quais partes do cÃ³digo estÃ£o usando quais dados na heap, minimizar a
quantidade de dados duplicados na heap e limpar segmentos inutilizados da heap
para que nÃ£o fiquemos sem espaÃ§o sÃ£o todos problemas tratados pelo ownership.
Uma vez que vocÃª entende ownership, vocÃª nÃ£o vai mais precisar pensar tanto
sobre a pilha e a heap, mas saber que ownership existe para gerenciar os dados
na heap pode ajudar a explicar como e por que ele funciona.</p>
</blockquote>
<!-- PROD: END BOX -->
<a class="header" href="print.html#regras-de-ownership" id="regras-de-ownership"><h3>Regras de Ownership</h3></a>
<p>Primeiro, vamos dar uma olhada nas regras de ownership. Mantenha em mente essas
regras quando trabalharmos com os exemplos em seguida:</p>
<blockquote>
<ol>
<li>Cada valor em Rust possui uma variÃ¡vel que Ã© dita seu <em>owner</em> (sua dona).</li>
<li>Pode apenas haver um owner por vez.</li>
<li>Quando o owner sai fora de escopo, o valor serÃ¡ destruÃ­do.</li>
</ol>
</blockquote>
<a class="header" href="print.html#escopo-de-variÃ¡veis" id="escopo-de-variÃ¡veis"><h3>Escopo de VariÃ¡veis</h3></a>
<p>JÃ¡ analisamos um exemplo de programa em Rust no CapÃ­tulo 2. Agora que jÃ¡
passamos da sintaxe bÃ¡sica, nÃ£o vamos incluir o cÃ³digo <code>fn main() {</code> nos
prÃ³ximos exemplos, entÃ£o se vocÃª estiver acompanhando, terÃ¡ que colocÃ¡-los
manualmente dentro de uma funÃ§Ã£o <code>main</code>. Como resultado, nossos exemplos serÃ£o
um pouco mais concisos, mantendo o foco nos detalhes que realmente interessam.</p>
<p>Como um primeiro exemplo de ownership, vamos olhar para o <em>escopo</em> de algumas
variÃ¡veis. Um escopo Ã© a Ã¡rea dentro de um programa para a qual um item Ã©
vÃ¡lido. Digamos que nÃ³s temos uma variÃ¡vel como esta:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = &quot;olÃ¡&quot;;
#}</code></pre></pre>
<p>A variÃ¡vel <code>s</code> se refere a uma string literal cujo valor Ã© fixo no cÃ³digo. A
variÃ¡vel Ã© vÃ¡lida do ponto em que Ã© declarada atÃ© o fim do atual <em>escopo</em>. A
Listagem 4-1 tem comentÃ¡rios indicando onde a variÃ¡vel <code>s</code> Ã© vÃ¡lida:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{                      // s nÃ£o Ã© vÃ¡lida aqui, ainda nÃ£o estÃ¡ declarada
    let s = &quot;texto&quot;;   // s Ã© vÃ¡lida deste ponto em diante

    // faz alguma coisa com s
}                      // agora este escopo terminou, e s nÃ£o Ã© mais vÃ¡lida
#}</code></pre></pre>
<p><span class="caption">Listagem 4-1: Uma variÃ¡vel e o escopo em que ela Ã©
vÃ¡lida.</span></p>
<p>Em outras palavras, existem dois pontos no tempo que sÃ£o importantes aqui:</p>
<ol>
<li>Quando <code>s</code> <em>entra no escopo</em>, ela Ã© vÃ¡lida.</li>
<li>Permanece dessa maneira atÃ© que ela <em>saia de escopo</em>.</li>
</ol>
<p>Neste ponto, a relaÃ§Ã£o entre escopos e quando variÃ¡veis sÃ£o vÃ¡lidas Ã© similar a
outras linguagens de programaÃ§Ã£o. Agora vamos construir sobre este entendimento,
apresentando o tipo <code>String</code>.</p>
<a class="header" href="print.html#o-tipo-string" id="o-tipo-string"><h3>O Tipo <code>String</code></h3></a>
<p>Para ilustrar as regras de ownership, precisamos de um tipo de dados que seja
mais complexo do que aqueles abordados no CapÃ­tulo 3. Os tipos abordados na
seÃ§Ã£o &quot;Tipos de Dados&quot; sÃ£o todos armazenados na pilha, e retirados dela quando
seu escopo termina, mas queremos ver dados que sÃ£o armazenados na heap e
explorar como o Rust faz para saber quando limpar esses dados.</p>
<p>Vamos usar <code>String</code> como exemplo aqui, e concentrar nas partes de <code>String</code> que
estÃ£o relacionadas ao ownership. Esses aspectos tambÃ©m se aplicam aos outros
tipos complexos de dados fornecidos pela biblioteca padrÃ£o e os que vocÃª mesmo
cria. Vamos discutir <code>String</code> mais a fundo no CapÃ­tulo 8.</p>
<p>JÃ¡ vimos strings literais, em que um valor de string Ã© fixado pelo cÃ³digo do
nosso programa. Strings literais sÃ£o convenientes, mas nem sempre sÃ£o adequadas
para situaÃ§Ãµes em que queremos usar texto. Um motivo Ã© que elas sÃ£o imutÃ¡veis.
Outro Ã© que nem todos os valores de string sÃ£o conhecidos enquanto escrevemos
nosso cÃ³digo: por exemplo, o que fazer se queremos obter uma entrada do usuÃ¡rio
e armazenÃ¡-la? Para essas situaÃ§Ãµes, Rust tem um segundo tipo de strings,
<code>String</code>. Este tipo Ã© alocado na heap, e como tal, Ã© capaz de armazenar uma
quantidade de texto que Ã© desconhecida em tempo de compilaÃ§Ã£o. VocÃª pode criar
uma <code>String</code> de uma string literal usando a funÃ§Ã£o <code>from</code>, da seguinte forma:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;texto&quot;);
#}</code></pre></pre>
<p>O <code>::</code> Ã© um operador que nos permite indicar que o <em>namespace</em> desta funÃ§Ã£o
<code>from</code>, em particular, Ã© o tipo <code>String</code>, de forma que nÃ£o precisamos usar um
nome especÃ­fico como <code>string_from</code>. Vamos discutir esta sintaxe na seÃ§Ã£o
&quot;Sintaxe do MÃ©todo&quot; do CapÃ­tulo 5, e quando falarmos sobre <em>namespaces</em> com
mÃ³dulos no CapÃ­tulo 7.</p>
<p>Este tipo de string <em>pode</em> ser alterada:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::from(&quot;olÃ¡&quot;);

s.push_str(&quot;, mundo!&quot;); // push_str() adiciona um literal Ã  String

println!(&quot;{}&quot;, s); // Isso vai exibir `olÃ¡, mundo!`
#}</code></pre></pre>
<p>Mas entÃ£o, qual Ã© a diferenÃ§a aqui? Por que <code>String</code> pode ser alterada enquanto
literais nÃ£o podem? A diferenÃ§a estÃ¡ em como esses dois tipos lidam com memÃ³ria.</p>
<a class="header" href="print.html#memÃ³ria-e-alocaÃ§Ã£o" id="memÃ³ria-e-alocaÃ§Ã£o"><h3>MemÃ³ria e AlocaÃ§Ã£o</h3></a>
<p>No caso de uma string literal, sabemos o seu conteÃºdo em tempo de compilaÃ§Ã£o,
entÃ£o o texto Ã© injetado diretamente para dentro do executÃ¡vel final, o que
faz strings literais serem rÃ¡pidas e eficientes. Mas essas propriedades provÃªm
apenas da sua imutabilidade. Infelizmente, nÃ£o podemos colocar um segmento de
memÃ³ria dentro do binÃ¡rio para cada texto cujo tamanho Ã© desconhecido em tempo
de compilaÃ§Ã£o, e cujo tamanho pode mudar ao longo da execuÃ§Ã£o do programa.</p>
<p>Com o tipo <code>String</code>, para poder acomodar um trecho mutÃ¡vel e expansÃ­vel de
texto, precisamos alocar uma quantidade de memÃ³ria na heap, que Ã© desconhecida
em tempo de compilaÃ§Ã£o, para manter o seu conteÃºdo. Isto significa que:</p>
<ol>
<li>A memÃ³ria deve ser solicitada ao sistema operacional em tempo de execuÃ§Ã£o.</li>
<li>Precisamos de uma forma de retornar esta memÃ³ria ao sistema operacional
quando tivermos finalizado nossa <code>String</code>.</li>
</ol>
<p>A primeira parte Ã© feita por nÃ³s: quando chamamos <code>String::from</code>, sua
implementaÃ§Ã£o solicita a memÃ³ria de que precisa. Isso Ã© meio que universal em
linguagens de programaÃ§Ã£o.</p>
<p>No entanto, a segunda parte Ã© diferente. Em linguagnes com um <em>garbage collector
(GC)</em>, o GC rastreia e limpa a memÃ³ria que nÃ£o estÃ¡ mais sendo usada, e nÃ³s,
como programadores, nÃ£o precisamos pensar sobre isso. Sem um GC, Ã©
resposabilidade do programador identificar quando a memÃ³ria nÃ£o estÃ¡ mais sendo
usada e chamar, explicitamente, um cÃ³digo que a retorne, assim como fizemos para
solicitÃ¡-la. Fazer isso corretamente tem sido, historicamente, um problema
difÃ­cil de programaÃ§Ã£o. Se esquecermos, vamos desperdiÃ§ar memÃ³ria. Se fizermos
cedo demais, teremos uma variÃ¡vel invÃ¡lida. Se fizermos duas vezes, tambÃ©m serÃ¡
um bug. Precisamos casar exatamente um <code>allocate</code> (alocar) com exatamente um
<code>free</code> (liberar).</p>
<p>Rust segue um caminho diferente: a memÃ³ria Ã© automaticamente retornada assim que
a variÃ¡vel que a possui sai de escopo. Aqui estÃ¡ uma versÃ£o do nosso exemplo de
escopo da Listagem 4-1 usando uma <code>String</code> em vez de uma string literal:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    let s = String::from(&quot;texto&quot;); // s Ã© vÃ¡lida deste ponto em diante

    // faz alguma coisa com s
}                                  // agora este escopo terminou, e s nÃ£o Ã©
                                   // mais vÃ¡lida
#}</code></pre></pre>
<p>Existe um ponto natural em que podemos retornar ao sistema operacional a memÃ³ria
da qual precisa nossa <code>String</code>: quando <code>s</code> sai de escopo. Quando uma variÃ¡vel
sai de escopo, o Rust chama para nÃ³s uma funÃ§Ã£o especial. Essa funÃ§Ã£o Ã© chamada
<code>drop</code>, e Ã© aÃ­ que o autor de <code>String</code> pode colocar o cÃ³digo que retorna
a memÃ³ria. Rust chama <code>drop</code> automaticamente ao fechar chaves (<code>}</code>).</p>
<blockquote>
<p>Nota: Em C++, esta forma de desalocar recursos no fim do tempo de vida Ãºtil de
um item Ã s vezes Ã© chamado de <em>Resource Acquisition Is Initialization</em> (RAII,
do inglÃªs, AquisiÃ§Ã£o de Recurso Ã‰ InicializaÃ§Ã£o). A funÃ§Ã£o <code>drop</code> em Rust vai
lhe ser bastante familar se vocÃª jÃ¡ tiver usado padrÃµes RAII.</p>
</blockquote>
<p>Este padrÃ£o tem um profundo impacto na forma de escrever cÃ³digo em Rust. Pode
parecer simples agora, mas o comportamento do cÃ³digo pode ser inesperado em
situaÃ§Ãµes mais complicadas, quando queremos que mÃºltiplas variÃ¡veis usem os
dados que alocamos na heap. Vamos explorar algumas dessas situaÃ§Ãµes agora.</p>
<a class="header" href="print.html#formas-de-interaÃ§Ã£o-entre-variÃ¡veis-e-dados-move" id="formas-de-interaÃ§Ã£o-entre-variÃ¡veis-e-dados-move"><h4>Formas de InteraÃ§Ã£o Entre VariÃ¡veis e Dados: <em>Move</em></h4></a>
<p>MÃºltiplas variÃ¡veis podem interagir com os mesmos dados de diferentes formas em
Rust. Vamos ver um exemplo usando um nÃºmero inteiro na Listagem 4-2:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
let y = x;
#}</code></pre></pre>
<p><span class="caption">Listagem 4-2: Atribuindo o valor inteiro da variÃ¡vel <code>x</code>
para <code>y</code>.</span></p>
<p>Provavelmente podemos advinhar o que isto faz com base nas nossas experiÃªncias
com outras linguagens: &quot;Associe o valor <code>5</code> a <code>x</code>; depois faÃ§a uma cÃ³pia do
valor em <code>x</code> e a associe a <code>y</code>.&quot; Agora temos duas variÃ¡veis, <code>x</code> e <code>y</code>, e ambas
sÃ£o iguais a <code>5</code>. Ã‰ isto mesmo que acontece, porque nÃºmeros inteiros sÃ£o valores
simples que possuem um tamanho fixo e conhecido, e esses dois valores <code>5</code> sÃ£o
colocados na pilha.</p>
<p>Agora vamos ver a versÃ£o usando <code>String</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;texto&quot;);
let s2 = s1;
#}</code></pre></pre>
<p>Isso parece bem similar ao cÃ³digo anterior, entÃ£o poderÃ­amos assumir que
funcionaria da mesma forma, isto Ã©, a segunda linha faria uma cÃ³pia do valor em
<code>s1</code> e a associaria a <code>s2</code>. Mas nÃ£o Ã© exatamente isso que acontece.</p>
<p>Para explicar isso mais detalhadamente, vamos ver como a <code>String</code> funciona por
baixo dos panos na Figura 4-1. Uma <code>String</code> Ã© feita de trÃªs partes, mostradas
Ã  esquerda: um ponteiro para a memÃ³ria que guarda o conteÃºdo da string, um
tamanho, e uma capacidade. Este grupo de dados Ã© armazenado na pilha. No lado
direito estÃ¡ a memÃ³ria na heap que guarda o conteÃºdo.</p>
<p><img alt="String na memÃ³ria" src="img/trpl04-01.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Figura 4-1: RepresentaÃ§Ã£o na memÃ³ria de uma <code>String</code>
contendo o valor <code>&quot;texto&quot;</code> associado a <code>s1</code>.</span></p>
<p>O tamanho representa quanta memÃ³ria, em bytes, o conteÃºdo da <code>String</code> estÃ¡
usando atualmente. A capacidade Ã© a quantidade total de memÃ³ria, em bytes, que
a <code>String</code> recebeu do sistema operacional. A diferenÃ§a entre tamanho e
capacidade Ã© importante, mas nÃ£o neste contexto, entÃ£o nÃ£o hÃ¡ problema em
ignorar a capacidade por enquanto.</p>
<p>Quando atribuÃ­mos <code>s1</code> a <code>s2</code>, os dados da <code>String</code> sÃ£o copiados, o que
significa que estamos copiando o ponteiro, o tamanho e a capacidade que estÃ£o na
pilha. NÃ£o estamos copiando os dados que estÃ£o na heap, aos quais o ponteiro se
refere. Em outras palavras, a representaÃ§Ã£o dos dados na memÃ³ria ocorre como
na Figura 4-2.</p>
<p><img alt="s1 e s2 apontando para o mesmo valor" src="img/trpl04-02.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Figura 4-2: RepresentaÃ§Ã£o na memÃ³ria da variÃ¡vel <code>s2</code>, que
tem uma cÃ³pia do ponteiro, tamanho e capacidade de <code>s1</code>.</span></p>
<p>A representaÃ§Ã£o <em>nÃ£o</em> ocorre como na Figura 4-3, que Ã© como ficaria a memÃ³ria se
o Rust tambÃ©m copiasse os dados da heap. Se o Rust fizesse isso, a operaÃ§Ã£o
<code>s2 = s1</code> seria potencialmente bastante custosa em termos de desempenho em tempo
de execuÃ§Ã£o caso os dados na heap fossem grandes.</p>
<p><img alt="s1 e s2 em dois lugares" src="img/trpl04-03.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Figura 4-3: Outra possibilidade do que <code>s2 = s1</code> poderia
fazer se o Rust tambÃ©m copiasse os dados da heap.</span></p>
<p>Anteriormente, dissemos que, quando uma variÃ¡vel sai de escopo, o Rust
automaticamente chama a funÃ§Ã£o <code>drop</code> e limpa a memÃ³ria da heap para esta
variÃ¡vel. Mas a Figura 4-2 mostra que os dois ponteiros estÃ£o apontando para o
mesmo lugar. Isso Ã© um problema: quando <code>s2</code> e <code>s1</code> saem de escopo, os dois vÃ£o
tentar liberar a mesma memÃ³ria. Isso Ã© conhecido como erro de <em>double free</em>
(liberaÃ§Ã£o dupla), e Ã© um dos bugs de seguranÃ§a de memÃ³ria que mencionamos
anteriormente. Liberar memÃ³ria duas vezes pode levar Ã  corrupÃ§Ã£o da memÃ³ria,
o que pode, por sua vez, trazer potenciais vulnerabilidades de seguranÃ§a.</p>
<p>Para garantir a seguranÃ§a de memÃ³ria, hÃ¡ um outro detalhe sobre o que acontece
nesta situaÃ§Ã£o em Rust. Em vez de tentar copiar a memÃ³ria alocada, o Rust
considera que <code>s1</code> deixa de ser vÃ¡lida, e portanto, o Rust nÃ£o precisa liberar
nenhuma memÃ³ria quando <code>s1</code> sai de escopo. Veja sÃ³ o que acontece quando vocÃª
tenta usar <code>s1</code> depois que <code>s2</code> Ã© criada, nÃ£o vai funcionar:</p>
<pre><code class="language-rust ignore">let s1 = String::from(&quot;texto&quot;);
let s2 = s1;

println!(&quot;{}&quot;, s1);
</code></pre>
<p>VocÃª vai ter um erro como este, porque o Rust lhe impede de usar a referÃªncia
que foi invalidada:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `s1`
 --&gt; src/main.rs:5:20
  |
3 |     let s2 = s1;
  |         -- value moved here
4 |
5 |     println!(&quot;{}&quot;, s1);
  |                    ^^ value used here after move
  |
  = note: move occurs because `s1` has type `std::string::String`, which does
  not implement the `Copy` trait
</code></pre>
<p>Se vocÃª jÃ¡ ouviu os termos &quot;cÃ³pia rasa&quot; e &quot;cÃ³pia profunda&quot; (<em>shallow copy</em> e
<em>deep copy</em>) enquanto trabalhava com outras linguagens, o conceito de copiar o
ponteiro, tamanho e capacidade sem copiar os dados provavelmente parece uma
cÃ³pia rasa. Mas como o Rust tambÃ©m invalida a primeira variÃ¡vel, em vez de
chamar isto de cÃ³pia rasa, isto Ã© conhecido como um <em>move</em>. Aqui poderÃ­amos
dizer que <code>s1</code> foi <em>movida</em> para <code>s2</code>. EntÃ£o, o que realmente acontece Ã©
mostrado na Figura 4-4.</p>
<p><img alt="s1 movida para s2" src="img/trpl04-04.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Figura 4-4: RepresentaÃ§Ã£o na memÃ³ria depois de <code>s1</code> ter
sido invalidada.</span></p>
<p>Isso resolve o nosso problema! Tendo apenas <code>s2</code> vÃ¡lida, quando ela sair de
escopo, somente ela vai liberar a memÃ³ria, e pronto.</p>
<p>Ademais, isto implica uma decisÃ£o de projeto: Rust nunca vai criar <em>deep copies</em>
dos seus dados. Logo, para qualquer cÃ³pia <em>automÃ¡tica</em> que aconteÃ§a, pode-se
assumir que ela nÃ£o serÃ¡ custosa em termos de desempenho em tempo de execuÃ§Ã£o.</p>
<a class="header" href="print.html#formas-de-interaÃ§Ã£o-entre-variÃ¡veis-e-dados-clone" id="formas-de-interaÃ§Ã£o-entre-variÃ¡veis-e-dados-clone"><h4>Formas de InteraÃ§Ã£o Entre VariÃ¡veis e Dados: Clone</h4></a>
<p>Se nÃ³s <em>queremos</em> fazer uma cÃ³pia profunda dos dados da <code>String</code> que estÃ£o na
heap, e nÃ£o apenas os dados que estÃ£o na pilha, podemos usar um mÃ©todo comum
chamado <code>clone</code>. Vamos discutir sintaxe de mÃ©todos no CapÃ­tulo 5, mas como os
mÃ©todos constituem uma caracterÃ­stica comum em vÃ¡rias linguagens de programaÃ§Ã£o,
vocÃª provavelmente jÃ¡ os viu antes.</p>
<p>Aqui estÃ¡ um exemplo de uso do mÃ©todo <code>clone</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;texto&quot;);
let s2 = s1.clone();

println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);
#}</code></pre></pre>
<p>Isto funciona bem, e Ã© assim que vocÃª pode, explicitamente, produzir o
comportamento mostrado na Figura 4-3, onde os dados da heap <em>sÃ£o</em> copiados.</p>
<p>Quando vocÃª ver uma chamada para <code>clone</code>, vocÃª sabe que algum cÃ³digo arbitrÃ¡rio
estÃ¡ sendo executado, e que este cÃ³digo talvez seja custoso. Ã‰ um indicador
visual de que algo diferente estÃ¡ acontecendo.</p>
<a class="header" href="print.html#dados-somente-da-pilha-copy" id="dados-somente-da-pilha-copy"><h4>Dados Somente da Pilha: Copy</h4></a>
<p>HÃ¡ um outro detalhezinho de que ainda nÃ£o falamos. Este cÃ³digo usando nÃºmeros
inteiros, parte do qual foi mostrado anteriormente na Listagem 4-2, funciona e Ã©
vÃ¡lido:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
let y = x;

println!(&quot;x = {}, y = {}&quot;, x, y);
#}</code></pre></pre>
<p>Mas este cÃ³digo parece contradizer o que acabamos de aprender: nÃ£o temos uma
chamada ao mÃ©todo <code>clone</code>, mas <code>x</code> ainda Ã© vÃ¡lido e nÃ£o foi movido para <code>y</code>.</p>
<p>O motivo Ã© que tipos como nÃºmeros inteiros tÃªm um tamanho conhecido em tempo de
compilaÃ§Ã£o e sÃ£o armazenados inteiramente na pilha, e por isso, cÃ³pias desses
valores sÃ£o rÃ¡pidas de se fazer. Isso significa que nÃ£o hÃ¡ razÃ£o para impedir
<code>x</code> de ser vÃ¡lido apÃ³s criarmos a variÃ¡vel <code>y</code>. Em outras palavras, nÃ£o hÃ¡
diferenÃ§a entre cÃ³pia rasa e profunda aqui, entÃ£o chamar o mÃ©todo <code>clone</code> nÃ£o
faria nada diferente de uma cÃ³pia rasa, por isso podemos deixÃ¡-lo de lado.</p>
<p>O Rust tem uma anotaÃ§Ã£o especial chamada de <em>trait</em> <code>Copy</code>, que podemos colocar
em tipos como nÃºmeros inteiros, que sÃ£o armazenados na pilha (falaremos mais
sobre traits no CapÃ­tulo 10). Se um tipo possui o trait <code>Copy</code>, uma variÃ¡vel
anterior vai continuar sendo utilizÃ¡vel depois de uma atribuiÃ§Ã£o. O Rust nÃ£o vai
nos deixar anotar um tipo com o trait <code>Copy</code> se este tipo, ou qualquer uma de
suas partes, tiver implementado o trait <code>Drop</code>. Se o tipo precisa que algo
especial aconteÃ§a quando o valor sair de escopo e hÃ¡ uma anotaÃ§Ã£o <code>Copy</code> neste
tipo, vamos ter um erro de compilaÃ§Ã£o. Para aprender sobre como inserir a
anotaÃ§Ã£o <code>Copy</code> ao seu tipo, veja o ApÃªndice C em Traits DerivÃ¡veis.</p>
<p>EntÃ£o quais tipos sÃ£o <code>Copy</code>? VocÃª pode verificar a documentaÃ§Ã£o de um
determinado tipo para se certificar, mas como regra geral, qualquer grupo de
valores simples escalares podem ser <code>Copy</code>, e nada que precise de alocaÃ§Ã£o ou
que seja uma forma de recurso Ã© <code>Copy</code>. Aqui estÃ£o alguns tipos que sÃ£o <code>Copy</code>:</p>
<ul>
<li>Todos os tipos inteiros, como <code>u32</code>.</li>
<li>O tipo booleano, <code>bool</code>, com valores <code>true</code> e <code>false</code>.</li>
<li>O tipo caractere, <code>char</code>.</li>
<li>Todos os tipos de ponto flutuante, como <code>f64</code>.</li>
<li>Tuplas, mas apenas aquelas que contÃ©m tipos que tambÃ©m sÃ£o <code>Copy</code>.
<code>(i32, i32)</code> Ã© <code>Copy</code>, mas <code>(i32, String)</code> nÃ£o.</li>
</ul>
<a class="header" href="print.html#ownership-e-funÃ§Ãµes" id="ownership-e-funÃ§Ãµes"><h3>Ownership e FunÃ§Ãµes</h3></a>
<p>A semÃ¢ntica para passar um valor a uma funÃ§Ã£o Ã© similar Ã  de atribuir um valor
a uma variÃ¡vel. Passar uma variÃ¡vel a uma funÃ§Ã£o irÃ¡ mover ou copiar, assim como
acontece em uma atribuiÃ§Ã£o. A Listagem 4-3 tem um exemplo com algumas anotaÃ§Ãµes
mostrando onde as variÃ¡veis entram e saem de escopo:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s = String::from(&quot;texto&quot;);  // s entra em escopo.

    toma_posse(s);                  // move o valor de s para dentro da funÃ§Ã£o...
                                    // ... e ele nÃ£o Ã© mais vÃ¡lido aqui.

    let x = 5;                      // x entra em escopo.

    faz_uma_copia(x);               // x seria movido para dentro da funÃ§Ã£o,
                                    // mas i32 Ã© Copy, entÃ£o estÃ¡ tudo bem em
                                    // usar x daqui para a frente.

} // Aqui, x sai de escopo, e depois s. Mas como o valor de s foi movido, nada
  // de especial acontece.

fn toma_posse(uma_string: String) { // uma_string entra em escopo.
    println!(&quot;{}&quot;, uma_string);
} // Aqui, uma_string sai de escopo, e o mÃ©todo `drop` Ã© chamado. A memÃ³ria que
  // guarda seus dados Ã© liberada.

fn faz_uma_copia(um_inteiro: i32) { // um_inteiro entra em escopo.
    println!(&quot;{}&quot;, um_inteiro);
} // Aqui, um_inteiro sai de escopo. Nada de especial acontece.
</code></pre></pre>
<p><span class="caption">Listagem 4-3: FunÃ§Ãµes com anotaÃ§Ãµes de ownership e
escopo</span></p>
<p>Se tentÃ¡ssemos usar <code>s</code> apÃ³s a chamada para <code>toma_posse</code>, o Rust iria lanÃ§ar um
erro de compilaÃ§Ã£o. Essas verificaÃ§Ãµes estÃ¡ticas nos protegem de certo enganos.
Tente adicionar um cÃ³digo Ã  funÃ§Ã£o <code>main</code> que usa <code>s</code> e <code>x</code> para ver onde vocÃª
pode usÃ¡-los e onde as regras de ownership lhe impedem de fazÃª-lo.</p>
<a class="header" href="print.html#retorno-de-valores-e-escopo" id="retorno-de-valores-e-escopo"><h3>Retorno de Valores e Escopo</h3></a>
<p>Retornar valores tambÃ©m pode transferir a posse de um valor. Aqui estÃ¡ um
exemplo com anotaÃ§Ãµes similares Ã quelas da Listagem 4-3:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = entrega_valor();           // entrega_valor move o valor retornado
                                        // para s1.

    let s2 = String::from(&quot;texto&quot;);     // s2 entra em escopo.

    let s3 = pega_e_entrega_valor(s2);  // s2 Ã© movido para dentro da funÃ§Ã£o
                                        // pega_e_entrega_valor, que tambÃ©m
                                        // move o valor retornado para s3.
} // Aqui, s3 sai de escopo e Ã© destruÃ­da. s2 sai de escopo, mas jÃ¡ foi movida,
  // entÃ£o nada demais acontece. s1 sai de escopo e Ã© destruÃ­da.

fn entrega_valor() -&gt; String {               // entrega_valor move o valor
                                             // retornado para dentro da funÃ§Ã£o
                                             // que a chamou.

    let uma_string = String::from(&quot;olÃ¡&quot;);    // uma_string entra em escopo.

    uma_string                               // uma_string Ã© retornada e movida
                                             // para a funÃ§Ã£o que chamou
                                             // entrega_valor.
}

// pega_e_entrega_valor vai pegar uma String e retornÃ¡-la.
fn pega_e_entrega_valor(uma_string: String) -&gt; String { // uma_string entra em
                                                        // escopo.

    uma_string  // uma_string Ã© retornada e movida para a funÃ§Ã£o que chamou
                // pega_e_entrega_valor.
}
</code></pre></pre>
<p>A posse de uma variÃ¡vel segue o mesmo padrÃ£o toda vez: atribuir um valor a outra
variÃ¡vel irÃ¡ movÃª-lo. Quando uma variÃ¡vel que inclui dados na heap sai de
escopo, o valor serÃ¡ destruÃ­do pelo mÃ©todo <code>drop</code>, a nÃ£o ser que os dados tenham
sido movidos para outra variÃ¡vel.</p>
<p>Obter e retornar a posse de um valor em cada funÃ§Ã£o Ã© um pouco tedioso. O que
fazer se queremos deixar uma funÃ§Ã£o usar um valor sem tomar posse dele? Ã‰ meio
irritante saber que qualquer coisa que passemos a uma funÃ§Ã£o tambÃ©m precisa ser
passado de volta se quisermos usÃ¡-lo novamente, alÃ©m de algum possÃ­vel resultado
proveniente do corpo da funÃ§Ã£o que tambÃ©m queremos retornar.</p>
<p>Ã‰ possÃ­vel retornar mÃºltiplos valores usando uma tupla, da seguinte forma:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;texto&quot;);

    let (s2, tamanho) = calcula_tamanho(s1);

    println!(&quot;O tamanho de '{}' Ã© {}.&quot;, s2, tamanho);
}

fn calcula_tamanho(s: String) -&gt; (String, usize) {
    let tamanho = s.len(); // len() retorna o tamanho de uma String.

    (s, tamanho)
}
</code></pre></pre>
<p>Mas isto Ã© muita cerimÃ´nia e trabalho para um conceito que deveria ser comum.
Para nossa sorte, Rust tem uma ferramenta para este conceito, e ela Ã© chamada de
<em>referÃªncias</em>.</p>
<a class="header" href="print.html#referÃªncias-e-borrowing" id="referÃªncias-e-borrowing"><h2>ReferÃªncias e <em>Borrowing</em></h2></a>
<p>O problema de usar tuplas, que vimos no fim da seÃ§Ã£o anterior, Ã© que precisamos
retornar a <code>String</code>, de forma que ainda possamos usÃ¡-la apÃ³s a chamada Ã  funÃ§Ã£o
<code>calcula_tamanho</code>, para dentro da qual a <code>String</code> foi movida.</p>
<p>Aqui estÃ¡ uma forma de como vocÃª poderia definir e usar uma funÃ§Ã£o
<code>calcula_tamanho</code> que recebe uma <em>referÃªncia</em> para um objeto como parÃ¢metro, em
vez de pegar este valor para si:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;texto&quot;);

    let tamanho = calcula_tamanho(&amp;s1);

    println!(&quot;O tamanho de '{}' Ã© {}.&quot;, s1, tamanho);
}

fn calcula_tamanho(s: &amp;String) -&gt; usize {
    s.len()
}
</code></pre></pre>
<p>Primeiro, repare que todo aquele cÃ³digo usando uma tupla na declaraÃ§Ã£o da
variÃ¡vel e no retorno da funÃ§Ã£o jÃ¡ se foi. Segundo, note que passamos <code>&amp;s1</code> para
<code>calcula_tamanho</code>, e na sua definiÃ§Ã£o, temos <code>&amp;String</code> em vez de apenas
<code>String</code>.</p>
<p>Esses <code>&amp;</code> sÃ£o <em>referÃªncias</em>, e eles permitem que vocÃª se refira a algum valor
sem tomar posse dele. A Figura 4-5 mostra um diagrama.</p>
<p><img alt="&String s apontando para String s1" src="img/trpl04-05.svg" class="center" /></p>
<p><span class="caption">Figura 4-5: <code>&amp;String s</code> apontando para <code>String s1</code></span></p>
<blockquote>
<p>Nota: O oposto de referenciar usando <code>&amp;</code> Ã© <em>derreferenciar</em>, feito por meio do
operador derreferenciador, <code>*</code>. Veremos alguns usos do operador
derreferenciador no CapÃ­tulo 8 e vamos discutir detalhes da derreferenciaÃ§Ã£o
no CapÃ­tulo 15.</p>
</blockquote>
<p>Vamos olhar mais de perto esta chamada de funÃ§Ã£o:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# fn calcula_tamanho(s: &amp;String) -&gt; usize {
#     s.len()
# }
let s1 = String::from(&quot;texto&quot;);

let tamanho = calcula_tamanho(&amp;s1);
#}</code></pre></pre>
<p>A sintaxe <code>&amp;s1</code> nos permite criar uma referÃªncia que <em>se refere</em> ao valor <code>s1</code>,
mas nÃ£o o possui. Como ela nÃ£o o possui, o valor a que ela aponta nÃ£o serÃ¡
destruÃ­do quando a referÃªncia sair de escopo.</p>
<p>Da mesma forma, a assinatura da funÃ§Ã£o usa <code>&amp;</code> para indicar que o tipo do
parÃ¢metro <code>s</code> Ã© uma referÃªncia. Vamos adicionar algumas anotaÃ§Ãµes para explicar:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn calcula_tamanho(s: &amp;String) -&gt; usize { // s Ã© uma referÃªncia para uma String
    s.len()
} // Aqui, s sai de escopo. Mas como ela nÃ£o possui o valor a que se refere,
  // nada acontece.
#}</code></pre></pre>
<p>O escopo no qual a variÃ¡vel <code>s</code> Ã© vÃ¡lida Ã© o mesmo escopo de qualquer parÃ¢metro
de funÃ§Ã£o, mas nÃ£o destruÃ­mos o valor apontado pela referÃªncia quando ela sai de
escopo, pois ela nÃ£o tem posse dele. FunÃ§Ãµes que tÃªm referÃªncias como
parÃ¢metros, em vez dos prÃ³prios valores, nÃ£o precisam retornar os valores para
devolver a posse deles, jÃ¡ que nunca tiveram esta posse.</p>
<p>Colocar referÃªncias como parÃ¢metros de funÃ§Ãµes Ã© chamado de <em>borrowing</em> (do
inglÃªs, emprÃ©stimo). Assim como na vida real, se uma pessoa possui alguma coisa,
vocÃª pode pegar emprestado dela. Quando vocÃª termina de usar, vocÃª deve
devolver.</p>
<p>E o que acontece se tentarmos modificar alguma coisa que pegamos emprestado?
Tente rodar o cÃ³digo da Listagem 4-4. Alerta de spoiler: nÃ£o funciona!</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let s = String::from(&quot;texto&quot;);

    modifica(&amp;s);
}

fn modifica(uma_string: &amp;String) {
    uma_string.push_str(&quot; longo&quot;);
}
</code></pre>
<p><span class="caption">Listagem 4-4: Tentativa de modificar um valor emprestado</span></p>
<p>Aqui estÃ¡ o erro:</p>
<pre><code class="language-text">error[E0596]: cannot borrow immutable borrowed content `*uma_string` as mutable
 --&gt; main.rs:8:5
  |
7 | fn modifica(uma_string: &amp;String) {
  |                         ------- use `&amp;mut String` here to make mutable
8 |     uma_string.push_str(&quot; longo&quot;);
  |     ^^^^^^^^^^ cannot borrow as mutable
</code></pre>
<p>Assim como as variÃ¡veis sÃ£o imutÃ¡veis por padrÃ£o, referÃªncias tambÃ©m sÃ£o. NÃ£o
temos permissÃ£o para modificar algo para o qual temos uma referÃªncia.</p>
<a class="header" href="print.html#referÃªncias-mutÃ¡veis" id="referÃªncias-mutÃ¡veis"><h3>ReferÃªncias MutÃ¡veis</h3></a>
<p>Podemos corrigir o erro no cÃ³digo da Listagem 4-4 com um pequeno ajuste:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut s = String::from(&quot;texto&quot;);

    modifica(&amp;mut s);
}

fn modifica(uma_string: &amp;mut String) {
    uma_string.push_str(&quot; longo&quot;);
}
</code></pre></pre>
<p>Primeiro, temos que fazer com que <code>s</code> seja <code>mut</code>. Depois, temos que criar uma
referÃªncia mutÃ¡vel com <code>&amp;mut s</code> e aceitar uma referÃªncia mutÃ¡vel com
<code>uma_string: &amp;mut String</code>.</p>
<p>Mas referÃªncias mutÃ¡veis possuem uma grande restriÃ§Ã£o: vocÃª sÃ³ pode ter uma
referÃªncia mutÃ¡vel para um determinado dado em um determinado escopo. Este
cÃ³digo vai falhar:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">let mut s = String::from(&quot;texto&quot;);

let r1 = &amp;mut s;
let r2 = &amp;mut s;
</code></pre>
<p>Aqui estÃ¡ o erro:</p>
<pre><code class="language-text">error[E0499]: cannot borrow `s` as mutable more than once at a time
 --&gt; main.rs:5:19
  |
4 |     let r1 = &amp;mut s;
  |                   - first mutable borrow occurs here
5 |     let r2 = &amp;mut s;
  |                   ^ second mutable borrow occurs here
6 | }
  | - first borrow ends here
</code></pre>
<p>Esta restriÃ§Ã£o permite a mutaÃ§Ã£o, mas de uma forma bem controlada. Isto Ã© algo
com que novos RustÃ¡ceos passam trabalho, porque a maioria das linguagens de
programaÃ§Ã£o permitem modificar um valor quando vocÃª quiser. O benefÃ­cio de ter
esta restriÃ§Ã£o Ã© que o Rust previne <em>data races</em> em tempo de compilaÃ§Ã£o.</p>
<p>Um <em>data race</em> Ã© parecido com uma condiÃ§Ã£o de corrida, e acontece quando esses
trÃªs fatores ocorrem:</p>
<ol>
<li>Dois ou mais ponteiros acessam o mesmo dado ao mesmo tempo.</li>
<li>Ao menos um dos ponteiros Ã© usado para escrever sobre o dado.</li>
<li>NÃ£o hÃ¡ nenhum mecanismo sendo usado para sincronizar o acesso ao dado.</li>
</ol>
<p>Data races causam comportamento indefinido e pode ser difÃ­ceis de diagnosticar
e corrigir quando vocÃª estÃ¡ tentando rastreÃ¡-los em tempo de execuÃ§Ã£o. Rust
previne este problema de acontecer porque nÃ£o vai nem deixar compilar um cÃ³digo
com data races!</p>
<p>Como sempre, podemos usar chaves (<code>{}</code>) para criar um novo escopo, permitindo
mÃºltiplas referÃªncias mutÃ¡veis, mas nÃ£o <em>simultÃ¢neas</em>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::from(&quot;texto&quot;);

{
    let r1 = &amp;mut s;

} // aqui r1 sai de escopo, entÃ£o jÃ¡ podemos criar uma nova referÃªncia sem
  // problema nenhum.

let r2 = &amp;mut s;
#}</code></pre></pre>
<p>Existe uma regra parecida para combinar referÃªncias mutÃ¡veis e imutÃ¡veis. Este
cÃ³digo resulta em erro:</p>
<pre><code class="language-rust ignore">let mut s = String::from(&quot;texto&quot;);

let r1 = &amp;s; // sem problema
let r2 = &amp;s; // sem problema
let r3 = &amp;mut s; // PROBLEMA GRANDE
</code></pre>
<p>Aqui estÃ¡ o erro:</p>
<pre><code class="language-text">error[E0502]: cannot borrow `s` as mutable because it is also borrowed as
immutable
 --&gt; main.rs:6:19
  |
4 |     let r1 = &amp;s; // sem problema
  |               - immutable borrow occurs here
5 |     let r2 = &amp;s; // sem problema
6 |     let r3 = &amp;mut s; // PROBLEMA GRANDE
  |                   ^ mutable borrow occurs here
7 | }
  | - immutable borrow ends here
</code></pre>
<p>Eita! NÃ³s <em>tambÃ©m</em> nÃ£o podemos ter uma referÃªncia mutÃ¡vel enquanto temos uma
imutÃ¡vel. UsuÃ¡rios de uma referÃªncia imutÃ¡vel nÃ£o esperam que os valores mudem
de repente! PorÃ©m, mÃºltiplas referÃªncias imutÃ¡veis sÃ£o permitidas, pois ninguÃ©m
que esteja apenas lendo os dados serÃ¡ capaz de afetar a leitura que estÃ¡ sendo
feita em outra parte do cÃ³digo.</p>
<p>Mesmo que esses erros sejam frustrantes Ã s vezes, lembre-se que Ã© o compilador
do Rust apontando um bug potencial antecipadamente (em tempo de compilaÃ§Ã£o,
em vez de execuÃ§ao), e mostrando exatamente onde estÃ¡ o problema, em vez de vocÃª
ter que investigar por que algumas vezes os seus dados nÃ£o sÃ£o aquilo que vocÃª
esperava que fosse.</p>
<a class="header" href="print.html#referÃªncias-soltas" id="referÃªncias-soltas"><h3>ReferÃªncias Soltas</h3></a>
<p>Em linguagens com ponteiros, Ã© fÃ¡cil criar erroneamente um <em>ponteiro solto</em>, um
ponteiro que referencia um local na memÃ³ria que pode ter sido dado para outra
parte do programa, basta liberar alguma memÃ³ria e preservar um ponteiro para
ela. Por outro lado, em Rust, o compilador garante que nenhuma referÃªncia serÃ¡
uma referÃªncia solta: se temos uma referÃªncia para algum dado, o compilador vai
se certificar que esse dado nÃ£o vai sair de escopo antes da referÃªncia.</p>
<p>Vamos tentar criar uma referÃªncia solta, que o Rust vai impedir com um erro em
tempo de compilaÃ§Ã£o:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let referencia_para_o_nada = soltar();
}

fn soltar() -&gt; &amp;String {
    let s = String::from(&quot;texto&quot;);

    &amp;s
}
</code></pre>
<p>Aqui estÃ¡ o erro:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt; main.rs:5:16
  |
5 | fn soltar() -&gt; &amp;String {
  |                ^ expected lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is
  no value for it to be borrowed from
  = help: consider giving it a 'static lifetime
</code></pre>
<p>Esta mensagem de erro se refere a uma caracterÃ­stica que nÃ£o abordamos ainda:
<em>lifetimes</em>. Vamos discutir lifetimes em detalhe no CapÃ­tulo 10. Mas, se vocÃª
desconsiderar a parte sobre lifetimes, a mensagem mostra a razÃ£o deste cÃ³digo
ser um problema:</p>
<pre><code class="language-text">this function's return type contains a borrowed value, but there is no value
for it to be borrowed from.
</code></pre>
<blockquote>
<p>TraduÃ§Ã£o: o tipo de retorno desta funÃ§Ã£o contÃ©m um valor emprestado, mas nÃ£o
hÃ¡ nenhum valor que se possa pegar emprestado.</p>
</blockquote>
<p>Vamos dar uma olhada mais de perto no que estÃ¡ acontecendo, exatamente, em cada
estÃ¡gio da nossa funÃ§Ã£o <code>soltar</code>:</p>
<pre><code class="language-rust ignore">fn soltar() -&gt; &amp;String { // soltar retorna uma referÃªncia a uma String

    let s = String::from(&quot;texto&quot;); // s Ã© uma nova String

    &amp;s // retornamos uma referÃªncia a uma String, s
} // Aqui, s sai de escopo e Ã© destruÃ­da. Sua memÃ³ria Ã© devolvida.
  // Perigo!
</code></pre>
<p>Como <code>s</code> Ã© criada dentro da funÃ§Ã£o <code>soltar</code>, quando o cÃ³digo desta funÃ§Ã£o
termina, <code>s</code> Ã© desalocada. Mas nÃ³s tentamos retornar uma referÃªncia para ela.
Isto significa que esta referÃªncia apontaria para uma <code>String</code> invÃ¡lida! Isso
nÃ£o Ã© bom. Rust nÃ£o vai nos deixar fazer isso.</p>
<p>A soluÃ§Ã£o aqui Ã© retornar a <code>String</code> diretamente:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn nÃ£o_soltar() -&gt; String {
    let s = String::from(&quot;texto&quot;);

    s
}
#}</code></pre></pre>
<p>Isto funciona sem nenhum problema. A <code>String</code> Ã© movida para fora, e nada Ã©
desalocado.</p>
<a class="header" href="print.html#as-regras-de-referÃªncias" id="as-regras-de-referÃªncias"><h3>As Regras de ReferÃªncias</h3></a>
<p>Vamos recapitular o que discutimos sobre referÃªncias:</p>
<ol>
<li>Em um dado momento, vocÃª pode ter <em>um ou outro</em>, mas nÃ£o os dois:</li>
</ol>
<ul>
<li>Uma referÃªncia mutÃ¡vel.</li>
<li>Qualquer nÃºmero de referÃªncias imutÃ¡veis.</li>
</ul>
<ol start="2">
<li>ReferÃªncias devem ser vÃ¡lidas sempre.</li>
</ol>
<p>Em seguida, vamos ver um tipo diferente de referÃªncias: <em>slices</em>.</p>
<a class="header" href="print.html#slices" id="slices"><h2><em>Slices</em></h2></a>
<p>Outro tipo de dados em que nÃ£o hÃ¡ ownership Ã© a <em>slice</em> (do inglÃªs, fatia).
Slices lhe permitem referenciar uma sequÃªncia contÃ­gua de elementos em uma
coleÃ§Ã£o em vez de referenciar a coleÃ§Ã£o inteira.</p>
<p>Aqui estÃ¡ um pequeno problema de programaÃ§Ã£o: escrever uma funÃ§Ã£o que pega uma
string e retorna a primeira palavra que encontrar dentro dela. Se a funÃ§Ã£o nÃ£o
encontrar um espaÃ§o na string, significa que a string inteira Ã© uma palavra sÃ³,
entÃ£o a string toda deve ser retornada.</p>
<p>Vamos pensar sobre a assinatura desta funÃ§Ã£o:</p>
<pre><code class="language-rust ignore">fn primeira_palavra(s: &amp;String) -&gt; ?
</code></pre>
<p>Esta funÃ§Ã£o, <code>primeira_palavra</code>, tem uma <code>&amp;String</code> como parÃ¢metro. NÃ³s nÃ£o
queremos tomar posse dela, entÃ£o tudo bem. Mas o que nÃ³s deverÃ­amos retornar?
NÃ£o temos uma forma de falar sobre <em>parte</em> de uma string. No entanto, poderÃ­amos
retornar o Ã­ndice do final de uma palavra. Vamos tentar fazer isso, conforme
mostrado na Listagem 4-5:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn primeira_palavra(s: &amp;String) -&gt; usize {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
#}</code></pre></pre>
<p><span class="caption">Listagem 4-5: A funÃ§Ã£o <code>primeira_palavra</code>, que retorna um
Ã­ndice para um byte da <code>String</code> passada como parÃ¢metro.</span></p>
<p>Vamos dividir este cÃ³digo em algumas partes. Como precisamos varrer a <code>String</code>
elemento por elemento, e verificar se algum valor Ã© um espaÃ§o, vamos converter
nossa <code>String</code> em um array de bytes usando o mÃ©todo <code>as_bytes</code>:</p>
<pre><code class="language-rust ignore">let bytes = s.as_bytes();
</code></pre>
<p>Depois, criamos um iterador sobre o array de bytes usando o mÃ©todo <code>iter</code>:</p>
<pre><code class="language-rust ignore">for (i, &amp;item) in bytes.iter().enumerate() {
</code></pre>
<p>Vamos discutir sobre iteradores em mais detalhes no CapÃ­tulo 13. Por enquanto,
saiba que <code>iter</code> Ã© um mÃ©todo que retorna cada elemento em uma coleÃ§Ã£o, e
<code>enumerate</code> encapsula o resultado do <code>iter</code> e retorna cada elemento como parte
de uma tupla. O primeiro elemento da tupla Ã© o Ã­ndice, e o segundo elemento Ã©
uma referÃªncia ao valor. Isto Ã© um pouco mais conveniente do que calcular o
Ã­ndice nÃ³s mesmos.</p>
<p>Como o mÃ©todo <code>enumerate</code> retorna uma tupla, podemos usar padrÃµes para
desestruturar esta tupla, assim como qualquer outra coisa em Rust. EntÃ£o, no
<code>for</code>, especificamos um padrÃ£o que tem <code>i</code> para o Ã­ndice na tupla e <code>&amp;item</code> para
o byte. Como pegamos uma referÃªncia ao elemento atravÃ©s do
<code>.iter().enumerate()</code>, usamos um <code>&amp;</code> neste padrÃ£o.</p>
<p>NÃ³s procuramos o byte que representa um espaÃ§o usando a sintaxe de byte literal.
Se encontrarmos um espaÃ§o, retornamos a posiÃ§Ã£o dele. Caso contrÃ¡rio, retornamos
o tamanho da string usando <code>s.len()</code>:</p>
<pre><code class="language-rust ignore">    if item == b' ' {
        return i;
    }
}
s.len()
</code></pre>
<p>Agora temos uma forma de descobrir o Ã­ndice do fim da primeira palavra na
string, mas tem um problema. Estamos retornando um <code>usize</code> por si sÃ³, mas ele sÃ³
possui um significado no contexto da <code>&amp;String</code>. Em outras palavras, como Ã© um
valor separado da <code>String</code>, nÃ£o hÃ¡ garantia de que ele ainda serÃ¡ vÃ¡lido no
futuro. Considere o programa na Listagem 4-6, que usa a funÃ§Ã£o da Listagem 4-5:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn primeira_palavra(s: &amp;String) -&gt; usize {
#     let bytes = s.as_bytes();
#
#     for (i, &amp;item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return i;
#         }
#     }
#
#     s.len()
# }
#
fn main() {
    let mut s = String::from(&quot;texto longo&quot;);

    let palavra = primeira_palavra(&amp;s); // palavra vai ter o valor 5.

    s.clear(); // Isso esvazia a String, deixando ela igual a &quot;&quot;.

    // palavra ainda tem o valor 5 aqui, mas jÃ¡ nÃ£o hÃ¡ mais uma string para a
    // qual o valor 5 faÃ§a algum sentido. palavra agora Ã© totalmente invÃ¡lida!
}
</code></pre></pre>
<p><span class="caption">Listagem 4-6: Armazenando o resultado de uma chamada Ã 
funÃ§Ã£o <code>primeira_palavra</code>, e depois, mudando o conteÃºdo da <code>String</code>.</span></p>
<p>Este programa compila sem erros, e tambÃ©m o faria se usÃ¡ssemos a variÃ¡vel
<code>palavra</code> depois de chamar <code>s.clear()</code>. <code>palavra</code> nÃ£o estÃ¡ conectada ao estado
de <code>s</code> de nenhuma forma, entÃ£o, <code>palavra</code> ainda contÃ©m o valor <code>5</code>. PoderÃ­amos
usar esse valor <code>5</code> com a variÃ¡vel <code>s</code> para tentar extrair a primeira palavra da
string, mas isso seria um bug, pois o conteÃºdo de <code>s</code> jÃ¡ mudou apÃ³s termos salvo
o valor <code>5</code> na variÃ¡vel <code>word</code>.</p>
<p>Ter que se preocupar sobre o Ã­ndice da <code>palavra</code> ficar fora de sincronia com os
dados em <code>s</code> Ã© tedioso e propenso a erros! Gerenciar esses Ã­ndices Ã© ainda mais
delicado se escrevermos uma funÃ§Ã£o <code>segunda_palavra</code>. Sua assinatura teria que
ser algo do tipo:</p>
<pre><code class="language-rust ignore">fn segunda_palavra(s: &amp;String) -&gt; (usize, usize) {
</code></pre>
<p>Agora estamos rastreando os Ã­ndices do inÃ­cio <em>e</em> do final, e temos ainda mais
valores que sÃ£o calculados a partir dos dados em um estado particular, mas que
nÃ£o estÃ£o vinculados a este estado de nenhuma forma. Agora temos trÃªs variÃ¡veis
nÃ£o relacionadas flutuando que precisam ser mantidas em sincronia.</p>
<p>Felizmente, Rust possui uma soluÃ§Ã£o para este problema: slices de string.</p>
<a class="header" href="print.html#slices-de-string" id="slices-de-string"><h3>Slices de String</h3></a>
<p>Uma <em>slice de string</em> Ã© uma referÃªncia para uma parte de uma <code>String</code>, e tem a
seguinte forma:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;texto longo&quot;);

let texto = &amp;s[0..5];
let longo = &amp;s[6..11];
#}</code></pre></pre>
<p>Isto Ã© similar a pegar uma referÃªncia Ã  <code>String</code> inteira, mas com um <code>[0..5]</code> a
mais. Em vez de uma referÃªncia Ã  <code>String</code> inteira, trata-se de uma referÃªncia a
uma porÃ§Ã£o da <code>String</code>. A sintaxe <code>inÃ­cio..fim</code> representa um <em>range</em>
(uma faixa) que comeÃ§a em <code>inÃ­cio</code> e continua atÃ©, mas nÃ£o incluindo, <code>fim</code>.</p>
<p>Podemos criar slices usando um range entre colchetes especificando
<code>[Ã­ndice_inicial..Ã­ndice_final]</code>, em que <code>Ã­ndice_inicial</code> Ã© a primeira posiÃ§Ã£o
inclusa na slice, e <code>Ã­ndice_final</code> Ã© um a mais que a Ãºltima posiÃ§Ã£o inclusa na
slice. Internamente, a estrutura de dados de uma slice armazena a posiÃ§Ã£o
inicial e o tamanho da slice, que corresponde a <code>Ã­ndice_final</code> menos
<code>Ã­ndice_inicial</code>. EntÃ£o, no caso do <code>let longo = &amp;s[6..11];</code>, <code>longo</code> seria uma
slice que contÃ©m um ponteiro para o sÃ©timo byte de <code>s</code> (Ã­ndice 6) e um tamanho
igual a 5.</p>
<p>A Figura 4-6 mostra isto em um diagrama.</p>
<p><img alt="mundo contendo um ponteiro para o 7o byte da String s e um tamanho 5" src="img/trpl04-06.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Figura 4-6: Slice referente a uma parte de uma
<code>String</code></span></p>
<p>Com a sintaxe de range do Rust (<code>..</code>), se vocÃª quiser comeÃ§ar com o primeiro
elemento (Ã­ndice zero), vocÃª pode omitir o valor antes dos dois pontos. Em
outras palavras, estas formas sÃ£o equivalentes:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;texto&quot;);

let slice = &amp;s[0..2];
let slice = &amp;s[..2];
#}</code></pre></pre>
<p>Da mesma forma, se a sua slice inclui o Ãºltimo byte da <code>String</code>, vocÃª pode
omitir o Ãºltimo nÃºmero. Isso significa que as seguintes formas sÃ£o equivalentes:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;texto&quot;);

let tamanho = s.len();

let slice = &amp;s[3..tamanho];
let slice = &amp;s[3..];
#}</code></pre></pre>
<p>VocÃª tambÃ©m pode omitir ambos os valores para pegar uma slice da string inteira.
Logo, essas duas formas sÃ£o equivalentes:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;texto&quot;);

let tamanho = s.len();

let slice = &amp;s[0..tamanho];
let slice = &amp;s[..];
#}</code></pre></pre>
<blockquote>
<p>Nota: Os Ã­ndices do range de uma slice de string devem coincidir com os
limites entre caracteres UTF-8 vÃ¡lidos. Se vocÃª tentar criar uma slice de
string no meio de um caractere que tenha mais de um byte, seu programa vai
terminar com erro. Para introduzir slices de string, estamos utilizando
apenas caracteres ASCII nesta seÃ§Ã£o; uma discussÃ£o mais detalhada sobre
manipulaÃ§Ã£o de caracteres UTF-8 serÃ¡ feita na seÃ§Ã£o &quot;Strings&quot; do CapÃ­tulo 8.</p>
</blockquote>
<p>Com toda essa informaÃ§Ã£o em mente, vamos reescrever a funÃ§Ã£o <code>primeira_palavra</code>
para retornar uma slice. O tipo que representa &quot;slice de string&quot; Ã© escrito como
<code>&amp;str</code>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn primeira_palavra(s: &amp;String) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
#}</code></pre></pre>
<p>Pegamos o Ã­ndice para o fim da palavra da mesma forma como fizemos na Listagem
4-5, buscando a primeira ocorrÃªncia de um espaÃ§o. Quando o encontramos,
retornamos uma slice de string usando o inÃ­cio da string e o Ã­ndice do espaÃ§o
como Ã­ndices inicial e final, respectivamente.</p>
<p>Agora, quando chamamos <code>primeira_palavra</code>, pegamos de volta um Ãºnico valor que
estÃ¡ vinculado Ã  string. O valor Ã© composto de uma referÃªncia para o ponto
inicial da slice e o nÃºmero de elementos que ela contÃ©m.</p>
<p>Retornar uma slice tambÃ©m funcionaria para uma funÃ§Ã£o <code>segunda_palavra</code>:</p>
<pre><code class="language-rust ignore">fn segunda_palavra(s: &amp;String) -&gt; &amp;str {
</code></pre>
<p>Agora, temos uma API bem direta que Ã© bem mais difÃ­cil de bagunÃ§ar, uma vez que
o compilador vai se certificar que as referÃªncias dentro da <code>String</code>
permanecerÃ£o vÃ¡lidas. Lembra do bug do programa na Listagem 4-6, quando
obtivemos o Ã­ndice para o fim da primeira palavra mas depois limpamos a string,
invalidando o Ã­ndice obtido? Aquele cÃ³digo era logicamente incorreto, mas nÃ£o
mostrava nenhum erro imediato. Os problemas apareceriam mais tarde quando
tentÃ¡ssemos usar o Ã­ndice da primeira palavra com uma string que foi esvaziada.
Slices tornam esse bug impossÃ­vel de acontecer e nos permitem saber que temos um
problema no cÃ³digo muito mais cedo. Na versÃ£o usando slice, a funÃ§Ã£o
<code>primeira_palavra</code> vai lanÃ§ar um erro em tempo de compilaÃ§Ã£o:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let mut s = String::from(&quot;texto longo&quot;);

    let palavra = first_word(&amp;s);

    s.clear(); // Erro!
}
</code></pre>
<p>Aqui estÃ¡ o erro:</p>
<pre><code class="language-text">error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:5
  |
4 |     let word = primeira_palavra(&amp;s);
  |                                  - immutable borrow occurs here
5 |
6 |     s.clear(); // Erro!
  |     ^ mutable borrow occurs here
7 | }
  | - immutable borrow ends here
</code></pre>
<p>Voltando Ã s regras de borrowing, lembre-se que, se temos uma referÃªncia imutÃ¡vel
para algum valor, nÃ£o podemos tambÃ©m obter uma referÃªncia mutÃ¡vel do mesmo. Como
<code>clear</code> precisa truncar a <code>String</code>, esse mÃ©todo tenta obter uma referÃªncia
mutÃ¡vel, e acaba falhando. O Rust nÃ£o sÃ³ tornou nossa API mais fÃ¡cil de usar,
como tambÃ©m eliminou uma classe inteira de erros em tempo de compilaÃ§Ã£o!</p>
<a class="header" href="print.html#strings-literais-sÃ£o-slices" id="strings-literais-sÃ£o-slices"><h4>Strings Literais SÃ£o Slices</h4></a>
<p>Lembre-se de que falamos sobre strings literais serem armazenadas dentro do
binÃ¡rio. Agora que conhecemos slices, podemos entender strings literais
adequadamente:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = &quot;OlÃ¡, mundo!&quot;;
#}</code></pre></pre>
<p>O tipo de <code>s</code> aqui Ã© <code>&amp;str</code>: Ã© uma slice apontando para aquele ponto especÃ­fico
do binÃ¡rio. TambÃ©m Ã© por isso que strings literais sÃ£o imutÃ¡veis; <code>&amp;str</code> Ã© uma
referÃªncia imutÃ¡vel.</p>
<a class="header" href="print.html#slices-de-strings-como-parÃ¢metros" id="slices-de-strings-como-parÃ¢metros"><h4>Slices de Strings como ParÃ¢metros</h4></a>
<p>Saber que vocÃª pode obter slices de literais e <code>String</code>s nos levam a mais um
aprimoramento da funÃ§Ã£o <code>primeira_palavra</code>, e aqui estÃ¡ sua assinatura:</p>
<pre><code class="language-rust ignore">fn primeira_palavra(s: &amp;String) -&gt; &amp;str {
</code></pre>
<p>Um RustÃ¡ceo mais experiente escreveria esta funÃ§Ã£o conforme a seguir, permitindo
utilizar a mesma funÃ§Ã£o com <code>String</code>s e <code>&amp;str</code>s:</p>
<pre><code class="language-rust ignore">fn primeira_palavra(s: &amp;str) -&gt; &amp;str {
</code></pre>
<p>Se temos uma slice de string, podemos passÃ¡-la diretamente. Se temos uma
<code>String</code>, podemos passar uma slice da <code>String</code> inteira. Definir uma funÃ§Ã£o que
recebe uma slice em vez de uma referÃªncia para uma String deixa nossa API mais
genÃ©rica e Ãºtil sem perder nenhuma funcionalidade:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn primeira_palavra(s: &amp;str) -&gt; &amp;str {
#     let bytes = s.as_bytes();
#
#     for (i, &amp;item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return &amp;s[0..i];
#         }
#     }
#
#     &amp;s[..]
# }
fn main() {
    let minha_string = String::from(&quot;texto longo&quot;);

    // primeira_palavra funciona com slices de `String`s
    let palavra = primeira_palavra(&amp;minha_string[..]);

    let minha_string_literal = &quot;texto longo&quot;;

    // primeira_palavra funciona com strings literais
    let palavra = primeira_palavra(&amp;minha_string_literal[..]);
    
    // uma vez que strings literais *sÃ£o* slices de strings,
    // isso tambÃ©m funciona, sem nem usar sintaxe de slice!
    let palavra = primeira_palavra(minha_string_literal);
}
</code></pre></pre>
<a class="header" href="print.html#outras-slices" id="outras-slices"><h3>Outras Slices</h3></a>
<p>Slices de string, como vocÃª pode imaginar, sÃ£o especÃ­ficas de strings. Mas hÃ¡
tambÃ©m um tipo de slice mais genÃ©rico. Considere esta array:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a = [1, 2, 3, 4, 5];
#}</code></pre></pre>
<p>Assim como Ã s vezes queremos nos referir a uma parte de uma string, podemos
tambÃ©m querer nos referir a uma parte de uma array, e farÃ­amos isso da seguinte
forma:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];
#}</code></pre></pre>
<p>Essa slice tem o tipo <code>&amp;[i32]</code>. Ela funciona da mesma forma que as slices de
string, armazenando uma referÃªncia para o primeiro elemento e um tamanho. VocÃª
vai usar esse tipo de slice para todos os tipos de coleÃ§Ãµes. Vamos discutir
essas coleÃ§Ãµes em mais detalhe quando falarmos sobre vetores no CapÃ­tulo 8.</p>
<a class="header" href="print.html#resumo-2" id="resumo-2"><h2>Resumo</h2></a>
<p>Os conceitos de ownership, borrowing, e slices sÃ£o o que garante a seguranÃ§a de
memÃ³ria dos programas em Rust em tempo de compilaÃ§Ã£o. A linguagem Rust lhe dÃ¡
controle sobre o uso da memÃ³ria, assim como outras linguagens de programaÃ§Ã£o de
sistemas, mas como o dono dos dados limpa automaticamente a memÃ³ria quando ele
sai de escopo, vocÃª nÃ£o tem que escrever e debugar cÃ³digo extra para ter esse
controle.</p>
<p>O ownership afeta o funcionamento de vÃ¡rias outras partes do Rust, por isso
vamos falar um pouco mais sobre esses conceitos neste livro daqui para a frente.
Vamos seguir para o prÃ³ximo capÃ­tulo e ver como agrupar dados em uma <code>struct</code>.</p>
<a class="header" href="print.html#usando-structs-para-estruturar-dados-relacionados" id="usando-structs-para-estruturar-dados-relacionados"><h1>Usando Structs para Estruturar Dados Relacionados</h1></a>
<p>Uma <em>struct</em>, ou <em>estrutura</em>, Ã© um tipo de dados personalizado que nos permite
nomear e criar um conjunto de vÃ¡rios valores relacionados que compÃµem um grupo
de dados. Se vocÃª estiver familiarizado com uma linguagem orientada a objeto,
um <em>struct</em> Ã© como os atributos de dados de um objeto. Neste capÃ­tulo, vamos
comparar e diferenciar tuplas com structs, demonstrar como usar structs e
discutir como definir os mÃ©todos e funÃ§Ãµes associadas Ã s structs para
especificar o comportamento associado com os dados de uma struct. Os conceitos
de struct e <em>enum</em> (que serÃ¡ discutido no CapÃ­tulo 6) sÃ£o os blocos necessÃ¡rios
para a criaÃ§Ã£o de novos tipos para o seu programa, para tirar o mÃ¡ximo proveito
da verificaÃ§Ã£o de tipo no tempo de compilaÃ§Ã£o do Rust.</p>
<a class="header" href="print.html#method-syntax" id="method-syntax"><h1>Method Syntax</h1></a>
<a class="header" href="print.html#enums-e-casamento-de-padrÃµes-pattern-matching" id="enums-e-casamento-de-padrÃµes-pattern-matching"><h1>Enums e Casamento de PadrÃµes (<em>Pattern Matching</em>)</h1></a>
<p>Neste capÃ­tulo vamos ver <em>enumeraÃ§Ãµes</em>, tambÃ©m chamadas de <em>enums</em>. Enums
permitem definir um tipo por meio da enumeraÃ§Ã£o de seus possÃ­veis valores.
Primeiro, vamos definir e usar uma enum para mostrar como ela pode atrelar
significado aos nossos dados. Depois, vamos explorar uma enum particularmente
Ãºtil, chamada <code>Option</code>, que expressa um valor que tanto pode ser algo quanto
pode nÃ£o ser nada. Em seguida, vamos ver como o casamento de padrÃµes por meio
da expressÃ£o <code>match</code> facilita a execuÃ§Ã£o de cÃ³digos diferentes para diferentes
valores de uma enum. Por fim, vamos abordar o <code>if let</code>, outra forma concisa e
conveniente que vocÃª pode usar para tratar enums no seu cÃ³digo.</p>
<p>Enums sÃ£o ferramentas que aparecem em muitas linguagens, mas suas
caracterÃ­sticas variam de uma para outra. Em Rust, enums sÃ£o mais parecidas com
os <em>tipos de dados algÃ©bricos</em> das linguagens de programaÃ§Ã£o funcional como F#,
OCaml e Haskell.</p>
<a class="header" href="print.html#definindo-uma-enum" id="definindo-uma-enum"><h2>Definindo uma Enum</h2></a>
<p>Vamos ver um caso em que enums podem ser mais apropriadas do que structs e
descobrir como elas podem ser Ãºteis. Digamos que estamos trabalhando com
endereÃ§os IP. Atualmente, existem duas versÃµes do protocolo IP que sÃ£o mais
utilizadas: a quatro e a seis. Estas sÃ£o as Ãºnicas possibilidades para um
endereÃ§o IP com que o nosso programa vai trabalhar: nÃ³s podemos <em>enumerar</em>
todos os possÃ­veis valores, Ã© daÃ­ que vem o nome enumeraÃ§Ã£o.</p>
<p>Um endereÃ§o IP qualquer pode ser ou da versÃ£o quatro ou da versÃ£o seis, mas
nunca das duas ao mesmo tempo. Esta propriedade dos endereÃ§os IP faz com que a
enum seja bem apropriada para este caso, pois enums sÃ³ podem assumir o valor de
uma de suas variantes. Os endereÃ§os de ambas as versÃµes, seja quatro ou seis,
ainda sÃ£o, fundamentalmente, endereÃ§os IP, e deveriam ser tratados pelo mesmo
tipo no cÃ³digo em situaÃ§Ãµes que se aplicam a qualquer versÃ£o de endereÃ§o IP.</p>
<p>Podemos expressar esse conceito em cÃ³digo definindo uma enum <code>VersaoIp</code> e
listando os possÃ­veis tipos de que um endereÃ§o IP pode ser: <code>V4</code> e <code>V6</code>. Estas
sÃ£o as chamadas <em>variantes</em> da enum:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum VersaoIp {
    V4,
    V6,
}
#}</code></pre></pre>
<p><code>VersaoIp</code> Ã© um tipo de dados que agora nÃ³s podemos usar em qualquer lugar no
nosso cÃ³digo.</p>
<a class="header" href="print.html#valores-de-uma-enum" id="valores-de-uma-enum"><h3>Valores de uma Enum</h3></a>
<p>Podemos criar instÃ¢ncias de cada uma das duas variantes de <code>VersaoIp</code>, da
seguinte forma:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum VersaoIp {
#     V4,
#     V6,
# }
#
let quatro = VersaoIp::V4;
let seis = VersaoIp::V6;
#}</code></pre></pre>
<p>Repare que as variantes pertencem ao <em>namespace</em> da enum, e se usa <code>::</code> para
separar os dois. Isso Ã© Ãºtil porque agora ambos os valores <code>VersaoIp::V4</code> e
<code>VersaoIp::V6</code> sÃ£o do mesmo tipo: <code>VersaoIp</code>. Agora nÃ³s podemos, por exemplo,
definir uma funÃ§Ã£o que usa qualquer <code>VersaoIp</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum VersaoIp {
#     V4,
#     V6,
# }
#
fn rotear(versao_ip: VersaoIp) { }
#}</code></pre></pre>
<p>E podemos ainda chamar esta funÃ§Ã£o passando qualquer uma das variantes:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum VersaoIp {
#     V4,
#     V6,
# }
#
# fn rotear(versao_ip: VersaoIp) { }
#
rotear(VersaoIp::V4);
rotear(VersaoIp::V6);
#}</code></pre></pre>
<p>O uso de enums tem ainda mais vantagens. Pensando mais a fundo sobre o nosso
tipo de endereÃ§o IP, ainda nÃ£o temos uma forma de representar o <em>endereÃ§o</em> em
si, apenas sabemos qual a <em>versÃ£o</em> dele. Tendo em vista o que vocÃª acabou de
aprender sobre structs no CapÃ­tulo 5, vocÃª poderia abordar esse problema assim
como visto na Listagem 6-1:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum VersaoIp {
    V4,
    V6,
}

struct EnderecoIp {
    versao: VersaoIp,
    endereco: String,
}

let local = EnderecoIp {
    versao: VersaoIp::V4,
    endereco: String::from(&quot;127.0.0.1&quot;),
};

let loopback = EnderecoIp {
    versao: VersaoIp::V6,
    endereco: String::from(&quot;::1&quot;),
};
#}</code></pre></pre>
<p><span class="caption">Listagem 6-1: RepresentaÃ§Ã£o do endereÃ§o e da variante
<code>VersaoIp</code> de um endereÃ§o IP usando uma <code>struct</code></span></p>
<p>Aqui nÃ³s definimos uma struct <code>EnderecoIp</code> que tem dois membros: <code>versao</code>, do
tipo <code>VersaoIp</code> (que definimos anteriormente) e <code>endereco</code>, do tipo <code>String</code>.
Temos duas instÃ¢ncias dessa struct. A primeira, <code>local</code>, tem o valor
<code>VersaoIp::V4</code> como sua <code>versao</code>, e um endereÃ§o associado igual a <code>127.0.0.1</code>.
A segunda instÃ¢ncia, <code>loopback</code>, tem como sua <code>versao</code> a outra variante de
<code>VersaoIp</code>, <code>V6</code>, e o endereÃ§o <code>::1</code> associado a ela. NÃ³s usamos uma struct
para encapsular os valores de <code>versao</code> e <code>endereco</code>, agora a variante estÃ¡
associada ao valor.</p>
<p>Podemos representar o mesmo conceito de uma forma mais concisa usando apenas
uma enum, em vez de uma enum dentro de uma struct, colocando dados dentro de
cada variante da enum, diretamente. Esta nova definiÃ§Ã£o da enum <code>EnderecoIp</code>
diz que ambas as variantes, <code>V4</code> e <code>V6</code>, terÃ£o uma <code>String</code> associada:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum EnderecoIp {
    V4(String),
    V6(String),
}

let local = EnderecoIp::V4(String::from(&quot;127.0.0.1&quot;));

let loopback = EnderecoIp::V6(String::from(&quot;::1&quot;));
#}</code></pre></pre>
<p>Podemos anexar dados a cada variante da enum diretamente, assim nÃ£o existe mais
a necessidade de uma struct adicional.</p>
<p>HÃ¡ uma outra vantagem de se usar uma enum em vez de uma struct: cada variante
pode conter dados de diferentes tipos e quantidades. Os endereÃ§os IP da versÃ£o
quatro tÃªm sempre quatro componentes numÃ©ricas, cada uma com valor de 0 a 255.
Se quisÃ©ssemos representar endereÃ§os <code>V4</code> como quatro valores <code>u8</code>, e ao mesmo
tempo manter os endereÃ§os <code>V6</code> como uma <code>String</code>, nÃ£o poderÃ­amos usar uma
struct. JÃ¡ as enums podem facilmente atender a este caso:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum EnderecoIp {
    V4(u8, u8, u8, u8),
    V6(String),
}

let local = EnderecoIp::V4(127, 0, 0, 1);

let loopback = EnderecoIp::V6(String::from(&quot;::1&quot;));
#}</code></pre></pre>
<p>Acabamos de ver algumas possibilidades que poderÃ­amos usar para representar
endereÃ§os IP das duas versÃµes por meio de uma enum. Acontece que essa
necessidade de representar endereÃ§os IP, incluindo sua versÃ£o, Ã© tÃ£o comum que
a biblioteca padrÃ£o jÃ¡ possui uma definiÃ§Ã£o que podemos usar! (<a href="https://doc.rust-lang.org/std/net/enum.IpAddr.html">Veja a
documentaÃ§Ã£o em inglÃªs</a><!-- ignore -->). Vamos ver como a biblioteca
padrÃ£o define <code>IpAddr</code>: ele tem basicamente a mesma enum e as mesmas variantes
que nÃ³s definimos e usamos anteriormente, mas os dados do endereÃ§o sÃ£o
embutidos dentro das variantes na forma de duas structs separadas, que sÃ£o
definidas de um jeito diferente pra cada variante.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Ipv4Addr {
    // detalhes omitidos
}

struct Ipv6Addr {
    // detalhes omitidos
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
#}</code></pre></pre>
<p>Esse cÃ³digo mostra que vocÃª pode colocar qualquer tipo de dados dentro de uma
variante de enum: strings, tipos numÃ©ricos ou structs, por exemplo. VocÃª pode
atÃ© mesmo incluir outra enum! AlÃ©m disso, os tipos definidos pela biblioteca
padrÃ£o nÃ£o sÃ£o tÃ£o mais complicados do que o que talvez vocÃª pensaria em fazer.</p>
<p>Repare que, mesmo havendo um <code>IpAddr</code>definido pela biblioteca padrÃ£o, nÃ³s ainda
podemos criar e utilizar nossa prÃ³pria definiÃ§Ã£o (com o mesmo nome, inclusive)
sem nenhum conflito, porque nÃ£o trouxemos a definiÃ§Ã£o da biblioteca padrÃ£o para
dentro do nosso escopo. Falaremos mais sobre a inclusÃ£o de tipos em um escopo
no CapÃ­tulo 7.</p>
<p>Vamos ver outro exemplo de uma enum na Listagem 6-2: esta tem uma grande
variedade de tipos embutidos nas suas variantes:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Mensagem {
    Sair,
    Mover { x: i32, y: i32 },
    Escrever(String),
    MudarCor(i32, i32, i32),
}
#}</code></pre></pre>
<p><span class="caption">Listagem 6-2: Enum <code>Mensagem</code>, cujas variantes contÃªm,
cada uma, diferentes tipos e quantidades de dados</span></p>
<p>Esta enum tem quatro variantes de diferentes tipos:</p>
<ul>
<li><code>Sair</code> nÃ£o tem nenhum dado associado.</li>
<li><code>Mover</code> contÃ©m uma struct anÃ´nima.</li>
<li><code>Escrever</code> contÃ©m uma Ãºnica <code>String</code>.</li>
<li><code>MudarCor</code> contÃ©m trÃªs valores do tipo <code>i32</code>.</li>
</ul>
<p>Definir uma enum com variantes iguais Ã s da Listagem 6-2 Ã© similar a definir
diferentes tipos de struct, exceto que a enum nÃ£o usa a palavra-chave <code>struct</code>,
e todas as variantes sÃ£o agrupadas dentro do tipo <code>Mensagem</code>. As structs
seguintes podem guardar os mesmos dados que as variantes da enum anterior:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct MensagemSair; // unit struct
struct MensagemMover {
    x: i32,
    y: i32,
}
struct MensagemEscrever(String); // tuple struct
struct MensagemMudarCor(i32, i32, i32); // tuple struct
#}</code></pre></pre>
<p>Mas se usarmos structs diferentes, cada uma tendo seu prÃ³prio tipo, nÃ£o vamos
conseguir tÃ£o facilmente definir uma funÃ§Ã£o que possa receber qualquer um
desses tipos de mensagens, assim como fizemos com a enum <code>Mensagem</code>, definida
na Listagem 6-2, que consiste em um tipo Ãºnico.</p>
<p>HÃ¡ mais uma similaridade entre enums e structs: da mesma forma como podemos
definir mÃ©todos em structs usando <code>impl</code>, tambÃ©m podemos definir mÃ©todos em
enums. Aqui estÃ¡ um mÃ©todo chamado <code>invocar</code>, que poderia ser definido na nossa
enum <code>Mensagem</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum Mensagem {
#     Sair,
#     Mover { x: i32, y: i32 },
#     Escrever(String),
#     MudarCor(i32, i32, i32),
# }
#
impl Mensagem {
    fn invocar(&amp;self) {
        // o corpo do mÃ©todo Ã© definido aqui
    }
}

let m = Mensagem::Escrever(String::from(&quot;olÃ¡&quot;));
m.invocar();
#}</code></pre></pre>
<p>O corpo do mÃ©todo usaria o valor <code>self</code> para obter a mensagem sobre a qual o
mÃ©todo foi chamado. Neste exemplo, criamos a variÃ¡vel <code>m</code>, que contÃ©m o valor
<code>Mensagem::Escrever(String::from(&quot;olÃ¡&quot;))</code>, e Ã© isso que <code>self</code> vai ser no corpo
do mÃ©todo <code>invocar</code> quando <code>m.invocar()</code> for executado.</p>
<p>Vamos ver agora outra enum da biblioteca padrÃ£o que tambÃ©m Ã© muito Ãºtil e
comum: <code>Option</code>.</p>
<a class="header" href="print.html#a-enum-option-e-suas-vantagens-sobre-valores-nulos" id="a-enum-option-e-suas-vantagens-sobre-valores-nulos"><h3>A Enum <code>Option</code> e Suas Vantagens Sobre Valores Nulos</h3></a>
<p>Na seÃ§Ã£o anterior, vimos como a enum <code>EnderecoIp</code> nos permite usar o sistema de
tipos do Rust para codificar em nosso programa mais informaÃ§Ã£o do que apenas os
dados que queremos representar. Essa seÃ§Ã£o explora um caso de estudo da
<code>Option</code>, que Ã© outra enum definida pela biblioteca padrÃ£o. O tipo <code>Option</code> Ã©
muito utilizado, pois engloba um cenÃ¡rio muito comum, em que um valor pode ser
algo ou pode nÃ£o ser nada. Expressar esse conceito por meio do sistema de tipos
significa que o compilador pode verificar se vocÃª tratou, ou nÃ£o, todos os
casos que deveriam ser tratados, podendo evitar <em>bugs</em> que sÃ£o extremamente
comuns em outras linguagens de programaÃ§Ã£o.</p>
<p>O <em>design</em> de uma linguagem de programaÃ§Ã£o Ã© geralmente tratado em termos de
quais caracterÃ­sticas sÃ£o incluÃ­das, mas as que sÃ£o excluÃ­das tambÃ©m tÃªm
importÃ¢ncia. Rust nÃ£o tem o valor nulo (<em>null</em>) que outras linguagens tÃªm. O
valor nulo quer dizer que nÃ£o hÃ¡ nenhum valor. Em linguagens que tÃªm essa
caracterÃ­stica, as variÃ¡veis sempre estÃ£o em um dos dois estados: nulo ou nÃ£o
nulo.</p>
<p>Em uma conferÃªncia, Tony Hoare, inventor do valor nulo, disse o seguinte:</p>
<blockquote>
<p>Eu o chamo meu erro de um bilhÃ£o de dÃ³lares. Naquela Ã©poca, eu estava
projetando o primeiro sistema abrangente de tipos para referÃªncias em uma
linguagem orientada a objetos. Meu objetivo era garantir que todo uso de
referÃªncias deveria ser absolutamente seguro, com verificaÃ§Ã£o automÃ¡tica
feita pelo compilador. Mas nÃ£o pude resistir Ã  tentaÃ§Ã£o de colocar uma
referÃªncia nula, simplesmente porque era tÃ£o fÃ¡cil de implementar. Isso tem
provocado inÃºmeros erros, vulnerabilidades, e falhas de sistemas que
provavelmente causaram um bilhÃ£o de dÃ³lares de dor e danos nos Ãºltimos
quarenta anos.</p>
</blockquote>
<p>O problema com valores nulos Ã© que, se vocÃª tentar usar um valor nulo como se
fosse nÃ£o nulo, vai acontecer algum tipo de erro. Pelo fato dessa propriedade
de nulo e nÃ£o nulo ser tÃ£o sutil, Ã© extremamente fÃ¡cil cometer esse tipo de
erro.</p>
<p>PorÃ©m, o conceito que o valor nulo tenta expressar ainda Ã© Ãºtil: um valor nulo
representa algo que, por algum motivo, estÃ¡ invÃ¡lido ou ausente no momento.</p>
<p>O problema, na verdade, nÃ£o estÃ¡ no conceito, mas na implementaÃ§Ã£o em
particular. Por isso, Rust nÃ£o possui valores nulos, mas sim uma enum que
engloba o conceito de um valor estar presente ou ausente. Esta enum Ã© a
<code>Option&lt;T&gt;</code>, que estÃ¡ definida na biblioteca padrÃ£o da seguinte forma:
(<a href="https://doc.rust-lang.org/std/option/enum.Option.html">Veja a documentaÃ§Ã£o em inglÃªs</a><!-- ignore -->).</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Option&lt;T&gt; {
    Some(T), // algum valor
    None, // nenhum valor
}
#}</code></pre></pre>
<p>A enum <code>Option&lt;T&gt;</code> Ã© tÃ£o Ãºtil que ela jÃ¡ vem inclusa no prelÃºdio: vocÃª nÃ£o
precisa trazÃª-la explicitamente para o seu escopo. AlÃ©m disso, o mesmo ocorre
com suas variantes: vocÃª pode usar <code>Some</code> e <code>None</code> diretamente sem prefixÃ¡-las
com <code>Option::</code>. <code>Option&lt;T&gt;</code> continua sendo uma enum como qualquer outra, e
<code>Some(T)</code> e <code>None</code> ainda sÃ£o variantes do tipo <code>Option&lt;T&gt;</code>.</p>
<p>A sintaxe do <code>&lt;T&gt;</code> Ã© uma caracterÃ­stica do Rust de que nÃ£o falamos ainda.
Trata-se de um parÃ¢metro de tipo genÃ©rico, vamos abordÃ¡-lo com mais detalhe no
CapÃ­tulo 10. Por ora, tudo que vocÃª precisa saber Ã© que <code>&lt;T&gt;</code> significa que a
variante <code>Some</code> da enum <code>Option</code> pode conter um dado de qualquer tipo. Aqui vÃ£o
alguns exemplos de <code>Option</code> contendo tipos de nÃºmero e texto:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let algum_numero = Some(5);
let algum_texto = Some(&quot;um texto&quot;);

let numero_ausente: Option&lt;i32&gt; = None;
#}</code></pre></pre>
<p>Se usamos <code>None</code> em vez de <code>Some</code>, precisamos dizer ao Rust qual Ã© o tipo de
<code>Option&lt;T&gt;</code> que nÃ³s temos, porque o compilador nÃ£o consegue inferir qual tipo
estarÃ¡ contido na variante <code>Some</code> apenas olhando para um valor <code>None</code>.</p>
<p>Quando temos um <code>Some</code>, sabemos que um valor estÃ¡ presente, contido dentro do
<code>Some</code>. JÃ¡ quando temos um <code>None</code>, de certa forma, significa o mesmo que um
valor nulo: nÃ£o temos um valor que seja vÃ¡lido. EntÃ£o por que a <code>Option&lt;T&gt;</code> Ã©
tÃ£o melhor que usar um valor nulo?</p>
<p>Em resumo, Ã© porque <code>Option&lt;T&gt;</code> e <code>T</code> (podendo <code>T</code> ser de qualquer tipo) sÃ£o
tipos diferentes, por isso, o compilador nÃ£o vai permitir usar um valor do tipo
<code>Option&lt;T&gt;</code> como se ele definitivamente tivesse um valor vÃ¡lido. Por exemplo,
o cÃ³digo seguinte nÃ£o vai compilar, porque ele estÃ¡ tentando somar um <code>i8</code> a um
<code>Option&lt;i8&gt;</code>:</p>
<pre><code class="language-rust ignore">let x: i8 = 5;
let y: Option&lt;i8&gt; = Some(5);

let soma = x + y;
</code></pre>
<p>Quando executamos esse cÃ³digo, temos uma mensagem de erro como essa:</p>
<pre><code class="language-text">error[E0277]: the trait bound `i8: std::ops::Add&lt;std::option::Option&lt;i8&gt;&gt;` is
not satisfied
 --&gt;
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + std::option::Option&lt;i8&gt;`
  |
</code></pre>
<p>Intenso! O que essa mensagem quer dizer Ã© que o Rust nÃ£o consegue entender como
somar um <code>i8</code> e um <code>Option&lt;i8&gt;</code>, porque eles sÃ£o de tipos diferentes. Quando
temos um valor de um tipo como <code>i8</code> em Rust, o compilador tem certeza de que
temos sempre um valor vÃ¡lido. Podemos prosseguir com confianÃ§a, sem ter de
verificar se o valor Ã© nulo antes de usÃ¡-lo. Somente quando temos um
<code>Option&lt;i8&gt;</code> (ou qualquer que seja o tipo com que estamos trabalhando), vamos
ter de nos preocupar com a possibilidade de nÃ£o haver um valor, e o compilador
vai se certificar de que nÃ³s estamos tratando este caso antes de usar o valor.</p>
<p>Em outras palavras, vocÃª tem que converter um <code>Option&lt;T&gt;</code> em um <code>T</code> antes de
poder executar operaÃ§Ãµes com ele. Geralmente, isso ajuda a detectar um dos
problemas mais comuns com valores nulos: assumir que algo nÃ£o Ã© nulo quando,
na verdade, ele Ã©.</p>
<p>SÃ³ de nÃ£o ter que se preocupar com a possibilidade de ter deixado um valor nulo
escapar jÃ¡ lhe dÃ¡ mais confianÃ§a em seu cÃ³digo. Pra ter um valor que pode ser
nulo em algum momento, vocÃª precisa, explicitamente, marcÃ¡-lo como sendo do
tipo <code>Option&lt;T&gt;</code>. A partir daÃ­, sempre que for usar o valor, vocÃª serÃ¡ obrigado
a tratar, de forma explÃ­cita, o caso do valor sendo nulo. Sempre que houver um
valor que nÃ£o seja um <code>Option&lt;T&gt;</code>, vocÃª <em>pode</em> assumir, com seguranÃ§a, que o
valor nÃ£o Ã© nulo. Esta foi uma decisÃ£o deliberada de projeto do Rust para
limitar as sutilezas dos valores nulos e aumentar a seguranÃ§a do cÃ³digo.</p>
<p>EntÃ£o, como obter o valor <code>T</code> da variante <code>Some</code> quando se tem um <code>Option&lt;T&gt;</code>,
para que se possa usar seu valor? A enum <code>Option&lt;T&gt;</code> possui diversos mÃ©todos
que sÃ£o Ãºteis em uma variedade de situaÃ§Ãµes, vocÃª pode pesquisÃ¡-los na
<a href="https://doc.rust-lang.org/std/option/enum.Option.html">documentaÃ§Ã£o</a><!-- ignore --> (em inglÃªs). SerÃ¡ extremamente Ãºtil na sua
jornada com Rust se familizarizar com os mÃ©todos da enum <code>Option&lt;T&gt;</code>.</p>
<p>Em geral, pra usar um valor <code>Option&lt;T&gt;</code>, queremos ter um cÃ³digo que trate cada
uma das variantes. Queremos um cÃ³digo que sÃ³ serÃ¡ executado quando tivermos um
valor <code>Some(T)</code>, e esse cÃ³digo terÃ¡ permissÃ£o para usar o valor <code>T</code> que estÃ¡
embutido. Queremos tambÃ©m um outro cÃ³digo que seja executado se tivermos um
valor <code>None</code>, e esse cÃ³digo nÃ£o terÃ¡ um valor <code>T</code> disponÃ­vel. A expressÃ£o
<code>match</code> Ã© uma instruÃ§Ã£o de controle de fluxo que faz exatamente isso quando
usada com enums: ela executa cÃ³digos diferentes dependendo de qual variante
tiver a enum, e esse cÃ³digo poderÃ¡ usar os dados contidos na variante
encontrada.</p>
<a class="header" href="print.html#operador-match-de-controle-de-fluxo" id="operador-match-de-controle-de-fluxo"><h2>Operador <code>match</code> de Controle de Fluxo</h2></a>
<p>O Rust tem um excelente operador de controle de fluxo chamado <code>match</code>, que nos
permite comparar um valor com uma sÃ©rie de padrÃµes e executar um cÃ³digo com
base no padrÃ£o que casar. PadrÃµes podem ser compostos de valores literais,
variÃ¡veis, caracteres-curinga e vÃ¡rias outras coisas. O CapÃ­tulo 18 aborda
todos os tipos de padrÃµes e o que eles fazem. A grande utilidade do <code>match</code> vem
da expressividade dos padrÃµes e das anÃ¡lises feitas pelo compilador, tendo
certeza de que todos os casos possÃ­veis estÃ£o sendo tratados.</p>
<p>Imagine que expressÃ£o <code>match</code> funciona como uma mÃ¡quina de contar moedas: as
moedas passam por um canal que possui furos de vÃ¡rios tamanhos, e cada moeda
cai no primeiro furo em que ela couber. Da mesma forma, os valores passam por
cada padrÃ£o de um <code>match</code>, e logo no primeiro padrÃ£o que o valor &quot;se encaixar&quot;,
o bloco de cÃ³digo que estiver associado a ele serÃ¡ executado.</p>
<p>Aproveitando que acabamos de falar sobre moedas, vamos usÃ¡-las como exemplo de
utilizaÃ§Ã£o do <code>match</code>! Podemos escrever uma funÃ§Ã£o que recebe uma moeda
qualquer dos Estados Unidos e, assim como uma mÃ¡quina, determina qual moeda ela
Ã© e retorna seu valor em <em>cents</em>, como mostra a Listagem 6-3:</p>
<blockquote>
<p><strong>Nota do tradutor:</strong> diferentemente do que acontece na maioria dos paÃ­ses,
as moedas dos Estados Unidos possuem nomes: as de 1 <em>cent</em> sÃ£o chamadas de
<em>Penny</em>; as de 5 <em>cents</em>, de <em>Nickel</em>; as de 10 <em>cents</em>, de <em>Dime</em>; e as de 25
<em>cents</em>, de <em>Quarter</em>.</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Moeda {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn valor_em_cents(moeda: Moeda) -&gt; u32 {
    match moeda {
        Moeda::Penny =&gt; 1,
        Moeda::Nickel =&gt; 5,
        Moeda::Dime =&gt; 10,
        Moeda::Quarter =&gt; 25,
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 6-3: Uma enum e uma expressÃ£o <code>match</code> em que os
padrÃµes comparados sÃ£o as variantes da enum.</span></p>
<p>Vamos analisar o <code>match</code> da funÃ§Ã£o <code>valor_em_cents</code>. Primeiro, usamos a
palavra-chave <code>match</code> seguida de uma expressÃ£o, que neste caso Ã© o valor
<code>moeda</code>. Ã‰ parecido a uma expressÃ£o utilizada com <code>if</code>, mas tem uma grande
diferenÃ§a: com <code>if</code>, a expressÃ£o precisa retornar um valor <em>booleano</em>. Aqui,
pode ser de qualquer tipo. O tipo da variÃ¡vel <code>moeda</code>, neste exemplo, Ã© a enum
<code>Moeda</code>, que definimos na Listagem 6-3.</p>
<p>Em seguida vÃªm os braÃ§os do <code>match</code>. Um braÃ§o Ã© composto por duas partes: um
padrÃ£o e algum cÃ³digo. O primeiro braÃ§o deste exemplo tem um padrÃ£o, que Ã© o
valor <code>Moeda::Penny</code>, e o operador <code>=&gt;</code> que separa o padrÃ£o do cÃ³digo associado
a ele. O cÃ³digo, nesse caso, Ã© apenas o valor <code>1</code>. Os braÃ§os sÃ£o separados uns
dos outros com uma vÃ­rgula.</p>
<p>Quando o <code>match</code> Ã© executado, ele compara o valor resultante com o padrÃ£o de
cada braÃ§o, na ordem. Se o valor casar com um determinado padrÃ£o, o cÃ³digo
associado a esse padrÃ£o serÃ¡ executado. Se o valor nÃ£o se encaixa nesse padrÃ£o,
a execuÃ§Ã£o passa para o prÃ³ximo braÃ§o, bem parecido com a mÃ¡quina de contar
moedas. Podemos ter tantos braÃ§os quanto precisamos. No caso da Listagem 6-3,
nosso <code>match</code> tem quatro braÃ§os.</p>
<p>O cÃ³digo associado a cada braÃ§o Ã© uma expressÃ£o, e o seu valor resultante, no
braÃ§o que combinar, Ã© o que serÃ¡ retornado pela expressÃ£o <code>match</code>.</p>
<p>Tipicamente nÃ£o se usa chaves se o braÃ§o do <code>match</code> for curto, como Ã© o caso na
Listagem 6-3, em que cada braÃ§o retorna apenas um valor. Se vocÃª quiser
executar mais de uma linha de cÃ³digo em um braÃ§o, vocÃª pode usar chaves para
delimitÃ¡-las. Por exemplo, o cÃ³digo seguinte vai escrever na tela &quot;Moeda da
sorte!&quot; sempre que o mÃ©todo for chamado com uma <code>Moeda::Penny</code>, mas ainda vai
retornar o Ãºltimo valor do bloco, <code>1</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum Moeda {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter,
# }
#
fn valor_em_cents(moeda: Moeda) -&gt; u32 {
    match moeda {
        Moeda::Penny =&gt; {
            println!(&quot;Moeda da sorte!&quot;);
            1
        },
        Moeda::Nickel =&gt; 5,
        Moeda::Dime =&gt; 10,
        Moeda::Quarter =&gt; 25,
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#padrÃµes-atrelados-a-valores" id="padrÃµes-atrelados-a-valores"><h3>PadrÃµes Atrelados a Valores</h3></a>
<p>Outra caracterÃ­stica Ãºtil dos braÃ§os do <code>match</code> Ã© que eles podem ser atrelados
a partes dos valores que se encaixam no padrÃ£o. Ã‰ assim que podemos extrair
valores dentro de uma variante de uma enum.</p>
<p>Por exemplo, vamos alterar uma das nossas variantes, inserindo dados dentro
dela. De 1999 atÃ© 2008, os Estados Unidos cunhou <em>quarters</em> com um <em>design</em>
diferente para cada um dos 50 estados em um dos lados da moeda. Nenhuma outra
moeda tinha essa diferenÃ§a no <em>design</em>, apenas os <em>quarters</em>. Podemos adicionar
essa informaÃ§Ã£o Ã  nossa <code>enum</code> alterando a variante <code>Quarter</code> para incluir o
valor <code>Estado</code>, como Ã© feito na Listagem 6-4:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug)] // Para podermos ver qual Ã© o estado com mais facilidade
enum Estado {
    Alabama,
    Alaska,
    // ... etc
}

enum Moeda {
    Penny,
    Nickel,
    Dime,
    Quarter(Estado),
}
#}</code></pre></pre>
<p><span class="caption">Listagem 6-4: Enum <code>Moeda</code>, cuja variante <code>Quarter</code>
tambÃ©m guarda o valor <code>Estado</code>.</span></p>
<p>Vamos imaginar que um amigo nosso estÃ¡ tentando colecionar todas os <em>quarters</em>
dos 50 estados. Enquanto separamos nosso troco por tipo de moeda, vamos tambÃ©m
dizer o nome do estado associado a cada <em>quarter</em>. Se for um dos que o nosso
amigo ainda nÃ£o tem, ele pode colocÃ¡-lo na sua coleÃ§Ã£o.</p>
<p>Na expressÃ£o <code>match</code> desse cÃ³digo, vamos adicionar uma variÃ¡vel chamada
<code>estado</code> ao padrÃ£o que casa com os valores da variante <code>Moeda::Quarter</code>. Quando
uma <code>Moeda::Quarter</code> Ã© testada, a variÃ¡vel <code>estado</code> vai ser atrelada ao valor
do estado daquele <em>quarter</em>. Assim vamos poder usar o <code>estado</code> no cÃ³digo do
braÃ§o, desse jeito:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug)]
# enum Estado {
#    Alabama,
#    Alaska,
# }
#
# enum Moeda {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter(Estado),
# }
#
fn valor_em_cents(moeda: Moeda) -&gt; u32 {
    match moeda {
        Moeda::Penny =&gt; 1,
        Moeda::Nickel =&gt; 5,
        Moeda::Dime =&gt; 10,
        Moeda::Quarter(estado) =&gt; {
            println!(&quot;Quarter do estado {:?}!&quot;, estado);
            25
        },
    }
}
#}</code></pre></pre>
<p>Se executarmos <code>valor_em_cents(Moeda::Quarter(Estado::Alaska))</code>, <code>moeda</code> seria
<code>Moeda::Quarter(Estado::Alaska)</code>. Quando comparamos esse valor em cada um dos
braÃ§os do <code>match</code>, nenhum deles vai casar enquanto nÃ£o chegar em
<code>Moeda::Quarter(estado)</code>. Nesse ponto, <code>estado</code> vai estar atrelado ao valor
<code>Estado::Alaska</code>. Podemos, entÃ£o, usar esse valor na expressÃ£o <code>println!</code>,
obtendo o estado contido na variante <code>Quarter</code> da enum <code>Moeda</code>.</p>
<a class="header" href="print.html#usando-match-com-optiont" id="usando-match-com-optiont"><h3>Usando <code>match</code> com <code>Option&lt;T&gt;</code></h3></a>
<p>Na seÃ§Ã£o anterior, querÃ­amos obter o valor <code>T</code> contido em um <code>Some</code> quando era
o caso em uma <code>Option&lt;T&gt;</code>. TambÃ©m podemos manipular uma <code>Option&lt;T&gt; usando</code>match<code>, assim como fizemos com a enum</code>Moeda<code>! Em vez de comparar moedas, vamos comparar as variantes de</code>Option<T><code>, mas a forma de trabalhar com a expressÃ£o</code>match` continua a mesma.</p>
<p>Digamos que queremos escrever uma funÃ§Ã£o que recebe um <code>Option&lt;i32&gt;</code>, e se
houver um valor embutido nele, soma um a esse valor. Se nÃ£o houver um valor,
a funÃ§Ã£o deve retornar <code>None</code>, e nem tentar executar nenhuma operaÃ§Ã£o.</p>
<p>Essa funÃ§Ã£o Ã© bem fÃ¡cil de implementar, graÃ§as ao <code>match</code>, e vai ficar conforme
visto na Listagem 6-5:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn mais_um(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        None =&gt; None,
        Some(i) =&gt; Some(i + 1),
    }
}

let cinco = Some(5);
let seis = mais_um(cinco);
let nenhum = mais_um(None);
#}</code></pre></pre>
<p><span class="caption">Listagem 6-5: Uma funÃ§Ã£o que usa um <code>match</code> para tratar
uma <code>Option&lt;i32&gt;</code>.</span></p>
<a class="header" href="print.html#casando-somet" id="casando-somet"><h4>Casando <code>Some(T)</code></h4></a>
<p>Vamos examinar a primeira execuÃ§Ã£o de <code>mais_um</code> em mais detalhes. Quando
chamamos <code>mais_um(cinco)</code>, a variÃ¡vel <code>x</code> no corpo da funÃ§Ã£o <code>mais_um</code> vai ter
o valor <code>Some(5)</code>. EntÃ£o comparamos ele a cada braÃ§o do <code>match</code>.</p>
<pre><code class="language-rust ignore">None =&gt; None,
</code></pre>
<p>O valor <code>Some(5)</code> nÃ£o casa com o padrÃ£o <code>None</code>, entÃ£o seguimos para o
prÃ³ximo braÃ§o.</p>
<pre><code class="language-rust ignore">Some(i) =&gt; Some(i + 1),
</code></pre>
<p><code>Some(5) casa com</code>Some(i)<code>? Sim, casa! Temos a mesma variante. O</code>i<code>estÃ¡ atrelado ao valor contido em</code>Some<code>, entÃ£o</code>i<code>passa a ter o valor</code>5<code>. O cÃ³digo desse braÃ§o Ã© executado, entÃ£o somamos um ao valor de</code>i<code>e criamos um novo</code>Some<code>contendo nosso total de</code>6`.</p>
<a class="header" href="print.html#casando-none" id="casando-none"><h4>Casando <code>None</code></h4></a>
<p>Agora vamos considerar a segunda chamada da funÃ§Ã£o <code>mais_um</code> na Listagem 6-5,
em que <code>x</code> Ã© <code>None</code>. NÃ³s entramos no <code>match</code> e comparamos com o primeiro braÃ§o.</p>
<pre><code class="language-rust ignore">None =&gt; None,
</code></pre>
<p>Confere! NÃ£o hÃ¡ nenhum valor para somar, entÃ£o o programa pÃ¡ra e retorna o
valor <code>None</code> do lado direito do <code>=&gt;</code>. Como o primeiro braÃ§o jÃ¡ casou, nenhum
dos demais serÃ¡ testado.</p>
<p>A combinaÃ§Ã£o de enums e a expressÃ£o <code>match</code> Ã© Ãºtil em diversas situaÃ§Ãµes. VocÃª
verÃ¡ muito esse padrÃ£o em Rust: fazer o <code>match</code> de uma enum, associar uma
variÃ¡vel ao valor embutido, e entÃ£o executar um cÃ³digo baseado nele. Pode
parecer complicado no comeÃ§o, mas uma vez que vocÃª se acostume, vocÃª vai querer
que tivesse isso em todas as linguagens. Ã‰, sistematicamente, um favorito dos
usuÃ¡rios.</p>
<a class="header" href="print.html#matches-sÃ£o-exaustivos" id="matches-sÃ£o-exaustivos"><h3><em>Matches</em> SÃ£o Exaustivos</h3></a>
<p>HÃ¡ outro aspecto do <code>match</code> que precisamos discutir. Considere essa versÃ£o da
nossa funÃ§Ã£o <code>mais_um</code>:</p>
<pre><code class="language-rust ignore">fn mais_um(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        Some(i) =&gt; Some(i + 1),
    }
}
</code></pre>
<p>NÃ³s nÃ£o tratamos o caso <code>None</code>, logo vai ocorrer um <em>bug</em> no nosso cÃ³digo. Por
sorte, Ã© um <em>bug</em> que o Rust sabe detectar. Se tentarmos compilar esse cÃ³digo,
vamos ter esse erro:</p>
<pre><code class="language-text">error[E0004]: non-exhaustive patterns: `None` not covered
 --&gt;
  |
6 |         match x {
  |               ^ pattern `None` not covered
</code></pre>
<p>O Rust sabe que nÃ³s nÃ£o cobrimos todos os casos possÃ­veis, e sabe atÃ© de qual
padrÃ£o nos esquecemos! <em>Matches</em> em Rust sÃ£o <em>exaustivos</em>: precisamos extinguir
atÃ© a Ãºltima possibilidade pra que o nosso cÃ³digo seja vÃ¡lido. Especialmente no
caso de uma <code>Option&lt;T&gt;</code>, em que o Rust nÃ£o nos deixa esquecer de tratar
explicitamente o caso <code>None</code>. Ele nos impede de assumir que temos um valor
vÃ¡lido quando possivelmente temos um valor nulo, e portanto, cometer o erro de
um bilhÃ£o de dÃ³lares que vimos mais cedo.</p>
<a class="header" href="print.html#the-_-placeholder" id="the-_-placeholder"><h3>The <code>_</code> Placeholder</h3></a>
<a class="header" href="print.html#o-placeholder-_" id="o-placeholder-_"><h3>O <em>Placeholder</em> <code>_</code></h3></a>
<p>O Rust tambÃ©m tem um padrÃ£o que podemos usar em situaÃ§Ãµes em que nÃ£o queremos
listar todos os valores possÃ­veis. Por exemplo, um <code>u8</code> pode ter valores
vÃ¡lidos de 0 a 255. Se nos importamos apenas com os valores 1, 3, 5 e 7, nÃ£o
queremos ser obrigados a listar o 0, 2, 4, 6, 8, 9, e assim por diante atÃ© 255.
Felizmente, nem precisamos: em vez disso, podemos usar o padrÃ£o especial <code>_</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let algum_valor_u8 = 0u8;
match algum_valor_u8 {
    1 =&gt; println!(&quot;um&quot;),
    3 =&gt; println!(&quot;trÃªs&quot;),
    5 =&gt; println!(&quot;cinco&quot;),
    7 =&gt; println!(&quot;sete&quot;),
    _ =&gt; (),
}
#}</code></pre></pre>
<p>O padrÃ£o <code>_</code> casa com qualquer valor. Colocando ele depois dos demais
braÃ§os, o <code>_</code> vai casar com todos os casos possÃ­veis que nÃ£o foram
especificados antes dele. O <code>()</code> Ã© sÃ³ o valor-unidade, pra que nada aconteÃ§a no
caso <code>_</code>. Como resultado, podemos dizer que nÃ£o queremos fazer nada com os
possÃ­veis valores que nÃ£o listamos antes do <em>placeholder</em> <code>_</code>.</p>
<p>Contudo, a expressÃ£o <code>match</code> pode ser um tanto verbosa em uma situaÃ§Ã£o em que
queremos apenas lidar com <em>um</em> dos casos. Pra essa situaÃ§Ã£o, o Rust oferece o
<code>if let</code>.</p>
<a class="header" href="print.html#controle-de-fluxo-conciso-com-if-let" id="controle-de-fluxo-conciso-com-if-let"><h2>Controle de Fluxo Conciso com <code>if let</code></h2></a>
<p>A sintaxe do <code>if let</code> permite combinar <code>if</code> e <code>let</code> em uma forma menos verbosa
de tratar apenas os valores que casam com um padrÃ£o e ignorar os demais.
Considere o programa da Listagem 6-6, que confere um valor do tipo
<code>Option&lt;u8&gt;</code>, mas sÃ³ executa um cÃ³digo se houver um valor associado igual a
trÃªs:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let algum_valor_u8 = Some(0u8);
match algum_valor_u8 {
    Some(3) =&gt; println!(&quot;trÃªs&quot;),
    _ =&gt; (),
}
#}</code></pre></pre>
<p><span class="caption">Listagem 6-6: Um <code>match</code> que sÃ³ executa um cÃ³digo quando
o valor Ã© <code>Some(3)</code>.</span></p>
<p>Queremos fazer alguma coisa com o <code>Some(3)</code>, mas nÃ£o queremos fazer nada com
nenhum outro valor, seja <code>Some&lt;u8&gt;</code> ou <code>None</code>. Pra satisfazer a expressÃ£o
<code>match</code>, temos que colocar <code>_ =&gt; ()</code> apÃ³s processar apenas uma variante, ou
seja, Ã© muito cÃ³digo para pouca coisa.</p>
<p>Em vez disso, poderÃ­amos escrever o mesmo cÃ³digo de uma forma mais compacta,
usando <code>if let</code>. O cÃ³digo seguinte tem o mesmo comportamento do <code>match</code> na
Listagem 6-6:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# let algum_valor_u8 = Some(0u8);
if let Some(3) = algum_valor_u8 {
    println!(&quot;trÃªs&quot;);
}
#}</code></pre></pre>
<p><code>if let</code> recebe um padrÃ£o e uma expressÃ£o separados por um <code>=</code>. Isso funciona
da mesma forma que um <code>match</code>, em que a expressÃ£o seria passada para o <code>match</code>,
e o padrÃ£o apareceria no primeiro braÃ§o.</p>
<p>Usar o <code>if let</code> implica menos cÃ³digo pra digitar e menos indentaÃ§Ã£o. PorÃ©m,
perdemos a verificaÃ§Ã£o exaustiva que Ã© garantida pelo <code>match</code>. A escolhe entre
<code>match</code> e <code>if let</code> depende do que vocÃª estÃ¡ fazendo em uma situaÃ§Ã£o particular,
e se a reduÃ§Ã£o no volume de cÃ³digo compensa a perda da verificaÃ§Ã£o exaustiva.</p>
<p>Em outras palavras, vocÃª pode enxergar o <code>if let</code> como um <em>syntax sugar</em> (um
atalho) para um <code>match</code> que sÃ³ executa um cÃ³digo quando o valor casa com um
Ãºnico padrÃ£o, e ignora todos os outros valores.</p>
<p>TambÃ©m podemos incluir um <code>else</code> em um <code>if let</code>. O bloco de cÃ³digo que vai no
<code>else</code> Ã© o mesmo que iria no caso <code>_</code> da expressÃ£o <code>match</code> equivalente.
Lembre-se da enum <code>Moeda</code> que definimos na Listagem 6-4, cuja variante
<code>Quarter</code> guardava um valor do tipo <code>Estado</code>. Se queremos contar todas as
moedas que nÃ£o forem <em>quarters</em>, enquanto tambÃ©m anunciamos o estado dos
<em>quarters</em>, poderÃ­amos fazer isso com uma expressÃ£o <code>match</code> igual a esta:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug)]
# enum Estado {
#    Alabama,
#    Alaska,
# }
#
# enum Moeda {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter(Estado),
# }
# let moeda = Coin::Penny;
let mut contagem = 0;
match moeda {
    Moeda::Quarter(estado) =&gt; println!(&quot;Quarter do estado {:?}!&quot;, estado),
    _ =&gt; contagem += 1,
}
#}</code></pre></pre>
<p>Ou poderÃ­amos usar um <code>if let</code> e um <code>else</code> desta forma:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug)]
# enum Estado {
#    Alabama,
#    Alaska,
# }
#
# enum Moeda {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter(Estado),
# }
# let moeda = Moeda::Penny;
let mut contagem = 0;
if let Moeda::Quarter(estado) = moeda {
    println!(&quot;Quarter do estado {:?}!&quot;, estado);
} else {
    contagem += 1;
}
#}</code></pre></pre>
<p>Se a lÃ³gica do seu programa fica muito verbosa quando Ã© expressa por meio de um
<code>match</code>, lembre-se que vocÃª tambÃ©m dispÃµe do <code>if let</code>.</p>
<a class="header" href="print.html#resumo-3" id="resumo-3"><h2>Resumo</h2></a>
<p>NÃ³s acabamos de ver como usar enums para criar tipos customizados a partir de
um conjunto de valores enumerados. Mostramos como o tipo <code>Option&lt;T&gt;</code>, da
biblioteca padrÃ£o, ajuda vocÃª a usar o sistema de tipos para evitar erros.
Quando as enums contÃªm dados, vocÃª pode usar <code>match</code> ou <code>if let</code> para extrair
e usar esses valores, dependendo de quantos casos vocÃª precisa tratar.</p>
<p>Agora, seus programas em Rust podem expressar conceitos em seu domÃ­nio usando
structs e enums. Criar tipos customizados para a sua <em>API</em> aumenta sua
seguranÃ§a: o compilador vai se certificar de que suas funÃ§Ãµes recebem apenas
os valores que correspondem aos tipos esperados.</p>
<p>Para fornecer uma API bem organizada aos seus usuÃ¡rios, que seja simples de
usar, e que exponha apenas o que Ã© necessÃ¡rio aos usuÃ¡rios, vamos agora passar
para os mÃ³dulos em Rust.</p>
<a class="header" href="print.html#usando-mÃ³dulos-para-reutilizar-e-organizar-cÃ³digo" id="usando-mÃ³dulos-para-reutilizar-e-organizar-cÃ³digo"><h1>Usando MÃ³dulos para Reutilizar e Organizar CÃ³digo</h1></a>
<p>Quando vocÃª comeÃ§a a escrever programas em Rust, seu cÃ³digo pode se manter apenas na
funÃ§Ã£o <code>main</code>. Ã€ medida que seu cÃ³digo cresce, vocÃª acabarÃ¡ por mover funcionalidades para
outras outras funÃ§Ãµes a fim de reutilizar cÃ³digo e melhorar a organizaÃ§Ã£o. Ao dividir seu cÃ³digo em
pequenos pedaÃ§os, cada pedaÃ§o Ã© mais fÃ¡cil de entender por si sÃ³. Mas o que acontece
se vocÃª tem muitas funÃ§Ãµes? Rust possui um sistema de mÃ³dulos que permite a reutilizaÃ§Ã£o
de cÃ³digo de forma organizada.</p>
<p>Da mesma forma que vocÃª extrai linhas de cÃ³digo em uma funÃ§Ã£o, vocÃª pode extrair
funÃ§Ãµes (e outros cÃ³digos, como structs e enums) em diferentes mÃ³dulos. Um
<em>mÃ³dulo</em> Ã© um namespace que contÃ©m definiÃ§Ãµes de funÃ§Ãµes ou tipos, e
vocÃª pode escolher se essas definiÃ§Ãµes sÃ£o visÃ­veis fora de seu mÃ³dulo
(pÃºblico) ou nÃ£o (privado). Aqui estÃ¡ uma visÃ£o geral de como os mÃ³dulos funcionam:</p>
<ul>
<li>A palavra-chave <code>mod</code> declara um novo mÃ³dulo. O cÃ³digo dentro do mÃ³dulo aparece
Â Â  imediatamente apÃ³s esta declaraÃ§Ã£o dentro de chaves ou em
Â Â  outro arquivo.</li>
<li>Por padrÃ£o, as funÃ§Ãµes, tipos, constantes e mÃ³dulos sÃ£o privados. A palavra-chave <code>pub</code>
Â Â   torna um item pÃºblico e, portanto, visÃ­vel fora do seu namespace.</li>
<li>A palavra-chave <code>use</code> traz mÃ³dulos, ou as definiÃ§Ãµes dentro dos mÃ³dulos, ao
Â Â  escopo, assim Ã© mais fÃ¡cil se referir a eles.</li>
</ul>
<p>Examinaremos cada uma dessas partes para ver como elas se encaixam no todo.</p>
<a class="header" href="print.html#mod-e-o-sistema-de-arquivos" id="mod-e-o-sistema-de-arquivos"><h2><code>mod</code> e o Sistema de Arquivos</h2></a>
<p>Vamos iniciar o nosso exemplo de mÃ³dulo fazendo um novo projeto com o Cargo, mas em vez de
criar um crate binÃ¡rio, faremos um crate de biblioteca: um projeto que
as outras pessoas podem puxar para os seus projetos como uma dependÃªncia. Por exemplo, o crate <code>rand</code>
discutido no CapÃ­tulo 2, Ã© um crate de biblioteca que usamos como uma dependÃªncia no
projeto do jogo de adivinhaÃ§Ã£o.</p>
<p>Criaremos um esqueleto de uma biblioteca que fornece algumas funcionalidades gerais
de rede; nos concentraremos na organizaÃ§Ã£o dos mÃ³dulos e funÃ§Ãµes,
mas nÃ£o nos preocuparemos com o cÃ³digo que estÃ¡ dentro das funÃ§Ãµes. Chamaremos
nossa biblioteca de <code>communicator</code>. Por padrÃ£o, o Cargo criarÃ¡ uma biblioteca, a menos que
outro tipo de projeto seja especificado: se omitimos a opÃ§Ã£o <code>--bin</code>, que temos
usado em todos os capÃ­tulos anteriores a este, nosso projeto serÃ¡ um
biblioteca:</p>
<pre><code class="language-text">$ cargo new communicator
$ cd communicator
</code></pre>
<p>Observe que Cargo gerou <em>src/lib.rs</em> em vez de <em>src/main.rs</em>. Dentro de
<em>src/lib.rs</em> encontraremos o seguinte:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
#}</code></pre></pre>
<p>Cargo cria um teste de exemplo para nos ajudar a comeÃ§ar nossa biblioteca, em vez de
o binÃ¡rio â€œHello, world!â€ que recebemos quando usamos a opÃ§Ã£o <code>--bin</code>. Olharemos
a sintaxe <code>#[]</code> e <code>mod tests</code> no â€œUsando <code>super</code> para Acessar um
MÃ³dulo Paiâ€ mais adiante neste capÃ­tulo, mas por agora, deixe este cÃ³digo
na parte inferior de <em>src/lib.rs</em>.</p>
<p>Como nÃ£o temos um arquivo <em>src/main.rs</em>, nÃ£o hÃ¡ nada para ser executado pelo Cargo
com o comando <code>cargo run</code>. Portanto, usaremos o comando  <code>cargo build</code>
para compilar o cÃ³digo da nossa biblioteca.</p>
<p>Examinaremos diferentes opÃ§Ãµes para organizar o cÃ³digo da sua biblioteca que serÃ£o
adequados em uma variedade de situaÃ§Ãµes, dependendo da intenÃ§Ã£o do cÃ³digo.</p>
<a class="header" href="print.html#definiÃ§Ãµes-do-mÃ³dulo" id="definiÃ§Ãµes-do-mÃ³dulo"><h3>DefiniÃ§Ãµes do MÃ³dulo</h3></a>
<p>Para a nossa biblioteca de rede <code>communicator</code>, primeiro definiremos um mÃ³dulo chamado
<code>network</code> que contÃ©m a definiÃ§Ã£o de uma funÃ§Ã£o chamada<code>connect</code>. Cada
definiÃ§Ã£o de mÃ³dulo em Rust comeÃ§a com a palavra-chave <code>mod</code>. Adicione este cÃ³digo ao
inÃ­cio do arquivo <em>src/lib.rs</em>, acima do cÃ³digo de teste:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod network {
    fn connect() {
    }
}
#}</code></pre></pre>
<p>ApÃ³s a palavra-chave <code>mod</code>, colocamos o nome do mÃ³dulo, <code>network</code> e, em seguida, um
bloco de cÃ³digo entre chaves. Tudo dentro deste bloco estÃ¡ dentro do
namespace <code>network</code>. Neste caso, temos uma Ãºnica funÃ§Ã£o, <code>connect</code>. Se nÃ³s
quisermos chamar essa funÃ§Ã£o do cÃ³digo fora do mÃ³dulo <code>network</code>, nÃ³s
precisaremos especificar o mÃ³dulo e usar a sintaxe do namespace <code>::</code>, assim:
<code>network::connect()</code> em vez de apenas <code>connect()</code>.</p>
<p>TambÃ©m podemos ter mÃºltiplos mÃ³dulos, lado a lado, no mesmo arquivo <em>src/lib.rs</em>.
Por exemplo, para ter mais um mÃ³dulo <code>client</code> que possui uma funÃ§Ã£o chamada <code>connect</code>
, podemos adicionÃ¡-lo como mostrado na Listagem 7-1:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod network {
    fn connect() {
    }
}

mod client {
    fn connect() {
    }
}
#}</code></pre></pre>
<p><span class = "caption"> Listagem 7-1: O mÃ³dulo <code>network</code> e o mÃ³dulo <code>client</code>
definidos lado a lado em <em>src/lib.rs</em> </span></p>
<p>Agora, temos uma funÃ§Ã£o <code>network::connect</code> e uma funÃ§Ã£o <code>client::connect</code>.
Estas podem ter funcionalidades completamente diferentes, e os nomes das funÃ§Ãµes
nÃ£o estÃ£o em conflito entre si porque estÃ£o em mÃ³dulos diferentes.</p>
<p>Nesse caso, como estamos construindo uma biblioteca, o arquivo que serve como
ponto de entrada para construir nossa biblioteca Ã© <em>src/lib.rs</em>. No entanto, em relaÃ§Ã£o a
criaÃ§Ã£o de mÃ³dulos, nÃ£o hÃ¡ nada de especial sobre <em>src/lib.rs</em>. PoderÃ­amos tambÃ©m
criar mÃ³dulos em <em>src/main.rs</em> para um crate binÃ¡rio da mesma forma que nÃ³s
criamos mÃ³dulos em <em>src/lib.rs</em> para o crate de biblioteca. Na verdade, podemos colocar mÃ³dulos
dentro de mÃ³dulos, o que pode ser Ãºtil Ã  medida que seus mÃ³dulos crescem para manter juntas
funcionalidades relacionadas e separar funcionalidades nÃ£o relacionadas. A
escolha de como vocÃª organiza seu cÃ³digo depende do que vocÃª pensa sobre a
relaÃ§Ã£o entre as partes do seu cÃ³digo. Por exemplo, o cÃ³digo <code>client</code>
e a funÃ§Ã£o <code>connect</code> podem ter mais sentido para os usuÃ¡rios de nossa biblioteca se
eles estivessem dentro do namespace <code>network</code>, como na Listagem 7-2:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod network {
    fn connect() {
    }

    mod client {
        fn connect() {
        }
    }
}
#}</code></pre></pre>
<p><span class = "caption"> Listagem 7-2: Movendo o mÃ³dulo <code>client</code> para dentro do
mÃ³dulo <code>network</code></span></p>
<p>No seu arquivo <em>src/lib.rs</em>, substitua as definiÃ§Ãµes <code>mod network</code> e <code>mod client</code>
pelas da Listagem 7-2, que possuem o mÃ³dulo <code>client</code> como um
mÃ³dulo interno da <code>network</code>. Agora temos as funÃ§Ãµes <code>network::connect</code> e
<code>network::client::connect</code>: novamente, as duas funÃ§Ãµes denominadas <code>connect</code> nÃ£o conflitam
uma com a outra porque elas estÃ£o em diferentes namespaces.</p>
<p>Desta forma, os mÃ³dulos formam uma hierarquia. O conteÃºdo de <em>src/lib.rs</em> estÃ¡ no
nÃ­vel superior mais alto, e os submÃ³dulos estÃ£o em nÃ­veis mais baixos. Aqui estÃ¡
a nossa organizaÃ§Ã£o quando pensada de forma hierÃ¡rquica na Listagem 7-1:</p>
<pre><code class="language-text">communicator
 â”œâ”€â”€ network
 â””â”€â”€ client
</code></pre>
<p>E aqui estÃ¡ a hierarquia correspondente ao exemplo na Listagem 7-2:</p>
<pre><code class="language-text">communicator
 â””â”€â”€ network
     â””â”€â”€ client
</code></pre>
<p>Conforme a hierarquia mostrada na Listagem 7-2, <code>client</code> Ã© um filho do mÃ³dulo <code>network</code>
em vez de um irmÃ£o. Projetos mais complicados podem ter muitos mÃ³dulos, Ã© necessÃ¡rio
organizÃ¡-los logicamente para mantÃª-los sob controle. O que &quot;logicamente&quot; significa em
seu projeto fica a seu critÃ©rio, e depende do que vocÃª e os usuÃ¡rios da sua biblioteca
pensam sobre o domÃ­nio do seu projeto. Use as tÃ©cnicas mostradas
aqui para criar mÃ³dulos lado a lado e mÃ³dulos aninhados em qualquer estrutura que
vocÃª queira.</p>
<a class="header" href="print.html#movendo-mÃ³dulos-para-outros-arquivos" id="movendo-mÃ³dulos-para-outros-arquivos"><h3>Movendo MÃ³dulos para Outros Arquivos</h3></a>
<p>Os mÃ³dulos formam uma estrutura hierÃ¡rquica, bem parecida com outra estrutura computacional
que vocÃª conhece: sistemas de arquivos! Podemos usar o sistema de mÃ³dulos do Rust juntamente com
vÃ¡rios arquivos para dividir projetos Rust de forma que nem tudo resida em
<em>src/lib.rs</em> ou <em>src/main.rs</em>. Para este exemplo, vamos comeÃ§ar com o cÃ³digo em
Listagem 7-3:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod client {
    fn connect() {
    }
}

mod network {
    fn connect() {
    }

    mod server {
        fn connect() {
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 7-3: TrÃªs mÃ³dulos, <code>client</code>, <code>network</code>, e
<code>network::server</code>, todos definidos em <em>src/lib.rs</em></span></p>
<p>O arquivo <em>src/lib.rs</em> possui esta hierarquia de mÃ³dulos:</p>
<pre><code class="language-text">communicator
 â”œâ”€â”€ client
 â””â”€â”€ network
     â””â”€â”€ server
</code></pre>
<p>Se esses mÃ³dulos tivessem muitas funÃ§Ãµes, e elas estivessem se alongando muito,
seria difÃ­cil percorrer esse arquivo para encontrar o cÃ³digo com que queremos
trabalhar. Como as funÃ§Ãµes estÃ£o aninhadas dentro de um ou mais blocos <code>mod</code>,
as linhas de cÃ³digo dentro das funÃ§Ãµes comeÃ§arÃ£o a se alongar tambÃ©m.
Estes seriam bons motivos para separar os mÃ³dulos <code>client</code>, <code>network</code>, e <code>server</code>
de <em>src/lib.rs</em> e colocÃ¡-los em seus prÃ³prios arquivos.</p>
<p>Primeiro, substitua o cÃ³digo do mÃ³dulo <code>client</code> por apenas a declaraÃ§Ã£o do
mÃ³dulo <code>client</code>, para que seu <em>src/lib.rs</em> se pareÃ§a com o cÃ³digo mostrado na Listagem 7-4:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">mod client;

mod network {
    fn connect() {
    }

    mod server {
        fn connect() {
        }
    }
}
</code></pre>
<p><span class="caption"> Listagem 7-4: Extraindo o conteÃºdo do mÃ³dulo <code>client</code>, mas deixando a declaraÃ§Ã£o em <em>src/lib.rs</em> </span></p>
<p>Ainda estamos <em>declarando</em> o mÃ³dulo <code>client</code> aqui, mas ao substituir o bloco
por um ponto e vÃ­rgula, estamos dizendo ao Rust para que procure, em outro local, o cÃ³digo
definido no escopo do mÃ³dulo <code>client</code>. Em outras palavras, a linha <code>mod client;</code> significa:</p>
<pre><code class="language-rust ignore">mod client {
    // conteÃºdo de client.rs
}
</code></pre>
<p>Agora precisamos criar o arquivo externo com o nome do mÃ³dulo. Crie um
arquivo <em>client.rs</em> em <em>src/</em> e abra-o. Em seguida digite o seguinte,
que Ã© a funÃ§Ã£o <code>connect</code> do mÃ³dulo <code>client</code> que foi
removida na etapa anterior:</p>
<p><span class="filename">Arquivo: src/client.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn connect() {
}
#}</code></pre></pre>
<p>Observe que nÃ£o precisamos de uma declaraÃ§Ã£o <code>mod</code> neste arquivo porque jÃ¡ fizemos
a declaraÃ§Ã£o do mÃ³dulo <code>client</code> com <code>mod</code> em <em>src/lib.rs</em>. Este arquivo apenas
fornece o <em>conteÃºdo</em> do mÃ³dulo <code>client</code>. Se colocarmos um <code>mod client</code> aqui,
nÃ³s estarÃ­amos dando ao mÃ³dulo <code>client</code> seu prÃ³prio submÃ³dulo chamado <code>client</code>!</p>
<p>Rust sÃ³ sabe olhar em <em>src/lib.rs</em> por padrÃ£o. Se quisermos adicionar mais
arquivos para o nosso projeto, precisamos dizer ao Rust em <em>src/lib.rs</em> para procurar em outros
arquivos; Ã© por isso que <code>mod client</code> precisa ser definido em <em>src/lib.rs</em> e nÃ£o pode
ser definido em <em>src/client.rs</em>.</p>
<p>Agora, o projeto deve compilar com sucesso, embora vocÃª obtenha alguns
warnings (avisos). Lembre-se de usar <code>cargo build</code>, em vez de <code>cargo run</code>, porque temos
um crate de biblioteca em vez de um crate binÃ¡rio:</p>
<pre><code class="language-text">$ cargo build
   Compiling communicator v0.1.0 (file:///projects/communicator)
warning: function is never used: `connect`
 --&gt; src/client.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
  |
  = note: #[warn(dead_code)] on by default

warning: function is never used: `connect`
 --&gt; src/lib.rs:4:5
  |
4 | /     fn connect() {
5 | |     }
  | |_____^

warning: function is never used: `connect`
 --&gt; src/lib.rs:8:9
  |
8 | /         fn connect() {
9 | |         }
  | |_________^
</code></pre>
<p>Esses <em>warnings</em> nos dizem que temos funÃ§Ãµes que nunca sÃ£o usadas. NÃ£o se preocupe
com esses <em>warnings</em> por enquanto; vamos abordÃ¡-los mais adiante neste capÃ­tulo, na
seÃ§Ã£o â€œControlando a visibilidade com <code>pub</code>â€. A boa notÃ­cia Ã© que eles sÃ£o apenas
<em>warnings</em>; nosso projeto foi construÃ­do com sucesso!</p>
<p>Em seguida, vamos extrair o mÃ³dulo <code>network</code> em seu prÃ³prio arquivo usando o mesmo
procedimento. Em <em>src/lib.rs</em>, exclua o corpo do mÃ³dulo <code>network</code> e adicione um
ponto e vÃ­rgula Ã  declaraÃ§Ã£o, assim:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">mod client;

mod network;
</code></pre>
<p>Em seguida, crie um novo arquivo <em>src/network.rs</em> e digite o seguinte:</p>
<p><span class="filename">Arquivo: src/network.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn connect() {
}

mod server {
    fn connect() {
    }
}
#}</code></pre></pre>
<p>Observe que ainda temos uma declaraÃ§Ã£o <code>mod</code> dentro deste arquivo de mÃ³dulo; isto Ã©
porque ainda queremos que <code>server</code> seja um submÃ³dulo de <code>network</code>.</p>
<p>Execute <code>cargo build</code> novamente. Sucesso! Temos mais um mÃ³dulo para extrair: <code>server</code>.
Como ele Ã© um submÃ³dulo - ou seja, um mÃ³dulo dentro de outro - nossa tÃ¡tica atual de
extrair um mÃ³dulo para um arquivo com o nome do mÃ³dulo nÃ£o funcionarÃ¡. Iremos
tentar, de qualquer maneira, para que vocÃª possa ver o erro. Primeiro, altere o arquivo <em>src/network.rs</em> colocando
<code>mod server;</code> no lugar do conteÃºdo do mÃ³dulo <code>server</code>:</p>
<p><span class="filename">Arquivo: src/network.rs</span></p>
<pre><code class="language-rust ignore">fn connect() {
}

mod server;
</code></pre>
<p>Em seguida, crie um arquivo <em>src/server.rs</em> e insira o conteÃºdo do mÃ³dulo <code>server</code>
que extraÃ­mos:</p>
<p><span class="filename">Arquivo: src/server.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn connect() {
}
#}</code></pre></pre>
<p>Quando tentamos <code>cargo build</code>, obteremos o erro mostrado na Listagem 7-5:</p>
<pre><code class="language-text">$ cargo build
   Compiling communicator v0.1.0 (file:///projects/communicator)
error: cannot declare a new module at this location
 --&gt; src/network.rs:4:5
  |
4 | mod server;
  |     ^^^^^^
  |
note: maybe move this module `src/network.rs` to its own directory via `src/network/mod.rs`
 --&gt; src/network.rs:4:5
  |
4 | mod server;
  |     ^^^^^^
note: ... or maybe `use` the module `server` instead of possibly redeclaring it
 --&gt; src/network.rs:4:5
  |
4 | mod server;
  |     ^^^^^^
</code></pre>
<p><span class="caption">Listagem 7-5: Erro ao tentar extrair o submÃ³dulo <code>server</code>
em <em>src/server.rs</em> </span></p>
<p>O erro diz que nÃ£o podemos declarar um novo mÃ³dulo neste local (<code>cannot declare a new module at this location</code>)
e estÃ¡ apontando para a linha <code>mod server</code>; em <em>src/network.rs</em>. EntÃ£o <em>src/network.rs</em> Ã©
diferente de <em>src/lib.rs</em> de alguma forma: continue lendo para entender o porquÃª.</p>
<p>A nota no meio da Listagem 7-5 Ã© realmente muito Ãºtil,
porque ela aponta para algo de que nÃ£o falamos ainda:</p>
<pre><code class="language-text">note: maybe move this module `network` to its own directory via
`network/mod.rs`
</code></pre>
<p>(<strong>TraduÃ§Ã£o:</strong> talvez mover este mÃ³dulo network para o seu prÃ³prio diretÃ³rio via <code>network/mod.rs</code>)</p>
<p>Em vez de continuar a seguir o mesmo padrÃ£o de nomeaÃ§Ã£o de arquivo usado
anteriormente, podemos fazer o que a nota sugere:</p>
<ol>
<li>Crie um novo <em>diretÃ³rio</em> chamado <em>network</em>, o nome do mÃ³dulo pai.</li>
<li>Mova o arquivo <em>src/network.rs</em> para o novo diretÃ³rio <em>network</em> e
Â Â Â  renomeie para <em>src/network/mod.rs</em>.</li>
<li>Mova o arquivo de submÃ³dulo <em>src/server.rs</em> para o diretÃ³rio <em>network</em>.</li>
</ol>
<p>Aqui estÃ£o os comandos para executar estas etapas:</p>
<pre><code class="language-text">$ mkdir src/network
$ mv src/network.rs src/network/mod.rs
$ mv src/server.rs src/network
</code></pre>
<p>Agora, quando tentamos executar <code>cargo build</code>, a compilaÃ§Ã£o funcionarÃ¡ (embora ainda teremos
avisos). O layout dos nossos mÃ³dulos ainda Ã© exatamente o
mesmo de quando tÃ­nhamos todo o cÃ³digo em <em>src/lib.rs</em> na Listagem 7-3:</p>
<pre><code class="language-text">communicator
 â”œâ”€â”€ client
 â””â”€â”€ network
     â””â”€â”€ server
</code></pre>
<p>O layout dos arquivos correspondentes agora ficou assim:</p>
<pre><code class="language-text">â”œâ”€â”€ src
â”‚   â”œâ”€â”€ client.rs
â”‚   â”œâ”€â”€ lib.rs
â”‚   â””â”€â”€ network
â”‚       â”œâ”€â”€ mod.rs
â”‚       â””â”€â”€ server.rs
</code></pre>
<p>Quando querÃ­amos extrair o mÃ³dulo <code>network::server</code>, por que precisÃ¡vamos
tambÃ©m mudar o arquivo <em>src/network.rs</em> para o arquivo <em>src/network/mod.rs</em> e colocar
o cÃ³digo de <code>network::server</code> no diretÃ³rio <em>network</em> em
<em>src/network/server.rs</em> em vez de apenas extrair o
mÃ³dulo <code>network::server</code> em <em>src/server.rs</em>? O motivo Ã© que Rust nÃ£o
serÃ¡ capaz de reconhecer que <code>server</code> deveria ser um submÃ³dulo de <code>network</code>
se o arquivo <em>server.rs</em> estiver no diretÃ³rio <em>src</em>. Para esclarecer o comportamento de Rust
aqui, consideremos um exemplo diferente com a seguinte hierarquia de mÃ³dulos,
onde todas as definiÃ§Ãµes estÃ£o em <em>src/lib.rs</em>:</p>
<pre><code class="language-text">communicator
 â”œâ”€â”€ client
 â””â”€â”€ network
     â””â”€â”€ client
</code></pre>
<p>Neste exemplo, temos novamente trÃªs mÃ³dulos : <code>client</code>,<code>network</code>, e
<code>network::client</code>. Seguindo os mesmos passos anteriores para extrair
mÃ³dulos em arquivos, poderÃ­amos criar <em>src/client.rs</em> para o mÃ³dulo <code>client</code>.
Para o mÃ³dulo <code>network</code>, poderÃ­amos criar <em>src/network.rs</em>. Mas nÃ£o serÃ­amos
capazes de extrair o mÃ³dulo <code>network::client</code> para um arquivo <em>src/client.rs</em>
porque ele jÃ¡ existe para o mÃ³dulo <code>client</code> de nÃ­vel superior! Se pudÃ©ssemos colocar
o cÃ³digo para <em>ambos</em> os mÃ³dulos <code>client</code> e<code>network::client</code> no arquivo
<em>src/client.rs</em>, Rust nÃ£o teria nenhuma maneira de saber se o cÃ³digo era
para <code>client</code> ou para <code>network::client</code>.</p>
<p>Portanto, para extrair um arquivo para o submÃ³dulo <code>network::client</code> do
mÃ³dulo <code>network</code>, precisamos criar um diretÃ³rio para o mÃ³dulo <code>network</code>
em vez de um arquivo <em>src/network.rs</em>. O cÃ³digo que estÃ¡ no mÃ³dulo <code>network</code>
entra no arquivo <em>src/network/mod.rs</em>, e o submÃ³dulo
<code>network::client</code> pode ter seu prÃ³prio arquivo <em>src/network/client.rs</em>. Agora o
o nÃ­vel superior <em>src/client.rs</em> Ã© inequivocamente o cÃ³digo que pertence ao
mÃ³dulo <code>client</code>.</p>
<a class="header" href="print.html#regras-dos-mÃ³dulos-e-seus-arquivos" id="regras-dos-mÃ³dulos-e-seus-arquivos"><h3>Regras dos MÃ³dulos e Seus Arquivos</h3></a>
<p>Vamos resumir as regras dos mÃ³dulos em relaÃ§Ã£o aos arquivos:</p>
<ul>
<li>Se um mÃ³dulo chamado <code>foo</code> nÃ£o possui submÃ³dulos, vocÃª deve colocar as declaraÃ§Ãµes
Â Â  para <code>foo</code> em um arquivo chamado <em>foo.rs</em>.</li>
<li>Se um mÃ³dulo chamado <code>foo</code> possui submÃ³dulos, vocÃª deve colocar as declaraÃ§Ãµes
Â Â  para <code>foo</code> em um arquivo chamado <em>foo/mod.rs</em>.</li>
</ul>
<p>Essas regras se aplicam de forma recursiva, entÃ£o, se um mÃ³dulo chamado <code>foo</code> tiver um submÃ³dulo chamado
<code>bar</code> e<code>bar</code> nÃ£o possui submÃ³dulos, vocÃª deve ter os seguintes arquivos
no seu diretÃ³rio <em>src</em>:</p>
<pre><code class="language-text">â”œâ”€â”€ foo
â”‚   â”œâ”€â”€ bar.rs (contÃ©m as declaraÃ§Ãµes em `foo::bar`)
â”‚   â””â”€â”€ mod.rs (contÃ©m as declaraÃ§Ãµes em `foo`, incluindo `mod bar`)
</code></pre>
<p>Os mÃ³dulos devem ser declarados no arquivo do mÃ³dulo pai usando a palavra-chave <code>mod</code>.</p>
<p>Em seguida, vamos falar sobre a palavra-chave <code>pub</code> e nos livrar dessas warnings!</p>
<a class="header" href="print.html#controlando-a-visibilidade-com-pub" id="controlando-a-visibilidade-com-pub"><h2>Controlando a Visibilidade com <code>pub</code></h2></a>
<p>Resolvemos as mensagens de erro mostradas na Listagem 7-5 movendo o cÃ³digo de <code>network</code> e
<code>network::server</code> para  os arquivos <em>src/network/mod.rs</em> e
<em>src/network/server.rs</em>, respectivamente. Nesse ponto, <code>cargo build</code> era
capaz de construir nosso projeto, mas ainda recebemos mensagens de <em>warning</em> sobre as
funÃ§Ãµes <code>client::connect</code>, <code>network::connect</code>, e <code>network::server::connect</code>
nÃ£o estarem em uso:</p>
<pre><code class="language-text">warning: function is never used: `connect`
 --&gt; src/client.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
  |
  = note: #[warn(dead_code)] on by default

warning: function is never used: `connect`
 --&gt; src/network/mod.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^

warning: function is never used: `connect`
 --&gt; src/network/server.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
</code></pre>
<p>EntÃ£o, por que estamos recebendo esses warnings(avisos)? Afinal, estamos construindo uma biblioteca
com funÃ§Ãµes que se destinam a ser usadas pelos nossos <em>usuÃ¡rios</em>, nÃ£o necessariamente por
nÃ³s dentro de nosso prÃ³prio projeto, por isso nÃ£o deveria importar que essas funÃ§Ãµes <code>connect</code>
nÃ£o sejam utilizadas. O ponto de criÃ¡-las Ã© que elas serÃ£o usadas por
outro projeto, nÃ£o o nosso.</p>
<p>Para entender por que esse programa invoca esses warnings(avisos), vamos tentar usar a
biblioteca <code>connect</code> de outro projeto, chamando-a externamente. Para fazer isso,
vamos criar um crate binÃ¡rio no mesmo diretÃ³rio que o nosso crate de biblioteca
inserindo um arquivo <em>src/main.rs</em> que contÃ©m esse cÃ³digo:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate communicator;

fn main() {
    communicator::client::connect();
}
</code></pre>
<p>Usamos o comando <code>extern crate</code> para trazer o crate de biblioteca <code>communicator</code>
para o escopo. Nosso pacote agora contÃ©m <em>duas</em> crates. Cargo trata <em>src/main.rs</em>
como um arquivo raiz de um crate binÃ¡rio, que Ã© separado do crate de biblioteca existente
cujo arquivo raiz Ã© <em>src/lib.rs</em>. Esse padrÃ£o Ã© bastante comum para
projetos executÃ¡veis: a maioria das funcionalidades estÃ¡ em um crate de biblioteca e o crate binÃ¡rio
usa esse crate de biblioteca. Como resultado, outros programas tambÃ©m podem usar o
crate de biblioteca, e Ã© uma boa separaÃ§Ã£o de responsabilidades.</p>
<p>Do ponto de vista de um crate fora da biblioteca <code>communicator</code>
todos os mÃ³dulos que criamos estÃ£o dentro de um mÃ³dulo que tem o mesmo
nome como do crate, <code>communicator</code>. Chamamos o mÃ³dulo de nÃ­vel superior de um
crate de <em>mÃ³dulo raiz</em>.</p>
<p>Observe tambÃ©m que, mesmo que estejamos usando um crate externo dentro de um submÃ³dulo do nosso
projeto, o <code>extern crate</code> deve entrar em nosso mÃ³dulo raiz (entÃ£o em <em>src/main.rs</em>
ou <em>src/lib.rs</em>). EntÃ£o, em nossos submÃ³dulos, podemos consultar itens de crates externos
como se os itens fossem mÃ³dulos de nÃ­vel superior.</p>
<p>Agora, nosso crate binÃ¡rio apenas chama a funÃ§Ã£o <code>connect</code> da nossa biblioteca do
mÃ³dulo <code>client</code>. No entanto, invocar agora <code>cargo build</code> nos darÃ¡ um erro
apÃ³s os <em>warnings</em>:</p>
<pre><code class="language-text">error[E0603]: module `client` is private
 --&gt; src/main.rs:4:5
  |
4 |     communicator::client::connect();
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</code></pre>
<p>Ah ha! Este erro nos diz que o mÃ³dulo <code>client</code> Ã© privado, que Ã© o
cerne das advertÃªncias. Ã‰ tambÃ©m a primeira vez em que nos encontramos com os conceitos de
<em>pÃºblico</em> e <em>privado</em> no contexto do Rust. O estado padrÃ£o de todos os cÃ³digos em
Rust Ã© privado: ninguÃ©m mais tem permissÃ£o para usar o cÃ³digo. Se vocÃª nÃ£o usar uma
funÃ§Ã£o privada dentro do seu programa, como ele Ã© o Ãºnico cÃ³digo
permitido a usar essa funÃ§Ã£o, Rust irÃ¡ avisÃ¡-lo de que a funÃ§Ã£o
nÃ£o foi utilizada.</p>
<p>Depois de especificar que uma funÃ§Ã£o como <code>client::connect</code> Ã© pÃºblica, nÃ£o sÃ³
serÃ¡ permitida a nossa chamada para essa funÃ§Ã£o a partir de nosso crate binÃ¡rio, mas o
warning(aviso) de que a funÃ§Ã£o nÃ£o Ã© utilizada irÃ¡ desaparecer. Marcar uma funÃ§Ã£o como pÃºblica
permite ao Rust saber que a funÃ§Ã£o serÃ¡ usada por cÃ³digo fora do nosso programa.
Rust considera que agora Ã© possÃ­vel que a
funÃ§Ã£o esteja &quot;sendo usada&quot;. Assim, quando uma funÃ§Ã£o Ã© marcada como pÃºblica, Rust nÃ£o
exige que seja usada em nosso programa e deixarÃ¡ de avisar que a funÃ§Ã£o
nÃ£o Ã© utilizada.</p>
<a class="header" href="print.html#fazendo-uma-funÃ§Ã£o-pÃºblica" id="fazendo-uma-funÃ§Ã£o-pÃºblica"><h3>Fazendo uma FunÃ§Ã£o PÃºblica</h3></a>
<p>Para dizer ao Rust que torne pÃºblica uma funÃ§Ã£o, adicionamos a palavra-chave <code>pub</code> ao inÃ­cio
da declaraÃ§Ã£o. Nos focaremos em corrigir o <em>warning</em> que indica
<code>client::connect</code> nÃ£o foi utilizado por enquanto, assim como o erro <code>module `client` is private</code> (<code>mÃ³dulo `client` Ã© privado</code>) do nosso crate binÃ¡rio. Modifique <em>src/lib.rs</em> para tornar
o mÃ³dulo <code>client</code> pÃºblico, assim:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub mod client;

mod network;
</code></pre>
<p>A palavra-chave <code>pub</code> Ã© colocada logo antes do <code>mod</code>. Vamos tentar fazer o build novamente:</p>
<pre><code class="language-text">error[E0603]: function `connect` is private
 --&gt; src/main.rs:4:5
  |
4 |     communicator::client::connect();
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</code></pre>
<p>Opa! Temos um erro diferente! Sim, mensagens diferentes de erro
sÃ£o motivo para comemorar. O novo erro mostra que que a funÃ§Ã£o <code>connect</code> Ã© privada
(function <code>connect</code> is private), entÃ£o vamos editar <em>src/client.rs</em> para tornÃ¡-la pÃºblica tambÃ©m:</p>
<p><span class="filename">Arquivo: src/client.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn connect() {
}
#}</code></pre></pre>
<p>Agora execute <code>cargo build</code> novamente:</p>
<pre><code class="language-text">warning: function is never used: `connect`
 --&gt; src/network/mod.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
  |
  = note: #[warn(dead_code)] on by default

warning: function is never used: `connect`
 --&gt; src/network/server.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
</code></pre>
<p>O cÃ³digo compila, e o warning(aviso) sobre <code>client::connect</code> nÃ£o estar em uso
se foi!</p>
<p>Os avisos de cÃ³digo nÃ£o utilizados nem sempre indicam que um item no seu cÃ³digo precisa
se tornar pÃºblico: se vocÃª <em>nÃ£o</em> quiser que essas funÃ§Ãµes faÃ§am parte de sua
API pÃºblica, <em>warnings</em> de cÃ³digo nÃ£o utilizado podem alertÃ¡-lo de que esses cÃ³digos nÃ£o sÃ£o mais necessÃ¡rios,
e que podem ser excluÃ­dos com seguranÃ§a. Eles tambÃ©m podem estar alertando vocÃª para um bug, caso vocÃª tivesse apenas
acidentalmente removido todos os lugares dentro da sua biblioteca onde esta funÃ§Ã£o Ã©
chamada.</p>
<p>Mas neste caso, nÃ³s <em>queremos</em> que as outras duas funÃ§Ãµes faÃ§am parte da nossa
API pÃºblica do crate, entÃ£o vamos marcÃ¡-las como <code>pub</code> tambÃ©m para nos livrar dos
<em>warnings</em> remanescentes. Modifique <em>src/network/mod.rs</em> dessa forma:</p>
<p><span class="filename">Arquivo: src/network/mod.rs</span></p>
<pre><code class="language-rust ignore">pub fn connect() {
}

mod server;
</code></pre>
<p>Em seguida, compile o cÃ³digo:</p>
<pre><code class="language-text">warning: function is never used: `connect`
 --&gt; src/network/mod.rs:1:1
  |
1 | / pub fn connect() {
2 | | }
  | |_^
  |
  = note: #[warn(dead_code)] on by default

warning: function is never used: `connect`
 --&gt; src/network/server.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
</code></pre>
<p>Hmmm, ainda estamos recebendo um <em>warning</em> de funÃ§Ã£o nÃ£o utilizada, embora
<code>network::connect</code> esteja marcada como <code>pub</code>. A razÃ£o Ã© que a funÃ§Ã£o Ã© pÃºblica
dentro do mÃ³dulo, mas o mÃ³dulo <code>network</code> na qual a funÃ§Ã£o reside nÃ£o Ã©
pÃºblico. Estamos trabalhando a partir do interior da biblioteca desta vez, enquanto que
com <code>client::connect</code> trabalhamos de fora. Precisamos mudar
<em>src/lib.rs</em> para tornar <code>network</code> pÃºblica tambÃ©m, assim:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub mod client;

pub mod network;
</code></pre>
<p>Agora, quando compilamos, esse aviso desapareceu:</p>
<pre><code class="language-text">warning: function is never used: `connect`
 --&gt; src/network/server.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
  |
  = note: #[warn(dead_code)] on by default
</code></pre>
<p>Apenas um warning(aviso) permanece. Tente consertar isso por conta prÃ³pria!</p>
<a class="header" href="print.html#regras-de-privacidade" id="regras-de-privacidade"><h3>Regras de Privacidade</h3></a>
<p>No geral, estas sÃ£o as regras para a visibilidade do item:</p>
<ol>
<li>Se um item for pÃºblico, ele pode ser acessado atravÃ©s de qualquer um dos seus mÃ³dulos pais.</li>
<li>Se um item Ã© privado, ele sÃ³ pode ser acessado por seu mÃ³dulo pai imediato e
Â Â Â qualquer um dos mÃ³dulos filhos do pai.</li>
</ol>
<a class="header" href="print.html#exemplos-de-privacidade" id="exemplos-de-privacidade"><h3>Exemplos de Privacidade</h3></a>
<p>Vejamos mais alguns exemplos de privacidade para obter alguma prÃ¡tica. Crie um novo
projeto de biblioteca e digite o cÃ³digo da Listagem 7-6 no arquivo
<em>src/lib.rs</em> desse novo projeto:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">mod outermost {
    pub fn middle_function() {}

    fn middle_secret_function() {}

    mod inside {
        pub fn inner_function() {}

        fn secret_function() {}
    }
}

fn try_me() {
    outermost::middle_function();
    outermost::middle_secret_function();
    outermost::inside::inner_function();
    outermost::inside::secret_function();
}
</code></pre>
<p><span class="caption">Lista 7-6: Exemplos de funÃ§Ãµes pÃºblicas e privadas,
alguns dos quais estÃ£o incorretos</span></p>
<p>Antes de tentar compilar este cÃ³digo, tente um palpite sobre quais linhas na
funÃ§Ã£o <code>try_me</code> terÃ¡ erros. Em seguida, tente compilar o cÃ³digo para ver se
vocÃª estava certo e leia sobre a discussÃ£o dos erros!</p>
<a class="header" href="print.html#olhando-para-os-erros" id="olhando-para-os-erros"><h4>Olhando para os Erros</h4></a>
<p>A funÃ§Ã£o <code>try_me</code> estÃ¡ no mÃ³dulo raiz do nosso projeto. O mÃ³dulo chamado
<code>outermost</code> Ã© privado, mas a segunda regra de privacidade afirma que a funÃ§Ã£o <code>try_me</code>
pode acessar o mÃ³dulo <code>outermost</code> porque <code>outermost</code> estÃ¡ no
mÃ³dulo atual (raiz), bem como <code>try_me</code>.</p>
<p>A chamada para <code>outermost::middle_function</code> funcionarÃ¡ porque <code>middle_function</code> Ã©
pÃºblica e <code>try_me</code> estÃ¡ acessando <code>middle_function</code> atravÃ©s do seu mÃ³dulo pai
<code>outermost</code>. Determinamos no parÃ¡grafo anterior que este mÃ³dulo Ã©
acessÃ­vel.</p>
<p>A chamada para <code>outermost::middle_secret_function</code> causarÃ¡ um erro de compilaÃ§Ã£o.
<code>middle_secret_function</code> Ã© privado, entÃ£o a segunda regra se aplica. O mÃ³dulo raiz
nÃ£o Ã© nem o mÃ³dulo atual de <code>middle_secret_function</code> (que seria o <code>outermost</code>),
nem um mÃ³dulo filho do mÃ³dulo atual de <code>middle_secret_function</code>.</p>
<p>O mÃ³dulo denominado <code>inside</code> Ã© privado e nÃ£o tem mÃ³dulos filhos, portanto, ele sÃ³ pode
ser acessado pelo seu mÃ³dulo atual <code>outermost</code>. Isso significa que a funÃ§Ã£o <code>try_me</code>
nÃ£o tem permissÃ£o de chamar <code>outermost::inside::inner_function</code> ou
<code>outermost::inside::secret_function</code>.</p>
<a class="header" href="print.html#reparando-os-erros" id="reparando-os-erros"><h4>Reparando os Erros</h4></a>
<p>Aqui estÃ£o algumas sugestÃµes para alterar o cÃ³digo na tentativa de corrigir os
erros. Antes de tentar cada uma, tente adivinhar se ela irÃ¡ consertar os
erros e, em seguida, compile o cÃ³digo para ver se vocÃª estÃ¡ certo ou nÃ£o, usando as
regras de privacidade para entender o porquÃª.</p>
<ul>
<li>E se o mÃ³dulo <code>inside</code> fosse pÃºblico?</li>
<li>E se <code>outermost</code> fosse pÃºblico e <code>inside</code> fosse privado?</li>
<li>E se, no corpo de <code>inner_function</code>, vocÃª chamasse o
Â Â <code>::outermost::middle_secret_function()</code>? (Os dois dois pontos no inÃ­cio significam
Â Â  que queremos consultar os mÃ³dulos a partir do mÃ³dulo raiz.)</li>
</ul>
<p>Sinta-se livre para projetar mais experimentos que lhe vierem Ã  mente!</p>
<p>Em seguida, vamos falar sobre trazer itens ao escopo com a palavra-chave <code>use</code>.</p>
<a class="header" href="print.html#referindo-se-a-nomes-em-mÃ³dulos-diferentes" id="referindo-se-a-nomes-em-mÃ³dulos-diferentes"><h2>Referindo-se a Nomes em MÃ³dulos Diferentes</h2></a>
<p>Vimos como chamar funÃ§Ãµes definidas dentro de um mÃ³dulo usando o nome do mÃ³dulo
como parte da chamada, como na chamada para a funÃ§Ã£o <code>nested_modules</code> mostrada
aqui na Listagem 7-7:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">pub mod a {
    pub mod series {
        pub mod of {
            pub fn nested_modules() {}
        }
    }
}

fn main() {
    a::series::of::nested_modules();
}
</code></pre></pre>
<p><span class="caption">Listagem 7-7: Chamando uma funÃ§Ã£o especificando completamente
o caminho do mÃ³dulo que a cerca</span></p>
<p>Como vocÃª pode ver, referir-se ao nome totalmente qualificado pode ficar bastante longo.
Felizmente, Rust tem uma palavra-chave para tornar estas chamadas mais concisas.</p>
<a class="header" href="print.html#trazendo-nomes-no-escopo-com-a-palavra-chave-use" id="trazendo-nomes-no-escopo-com-a-palavra-chave-use"><h3>Trazendo Nomes no Escopo com a Palavra-Chave <code>use</code></h3></a>
<p>A palavra-chave <code>use</code> de Rust encurta as chamadas de funÃ§Ã£o longas, trazendo os mÃ³dulos e
a funÃ§Ã£o que deseja chamar para o escopo. Aqui estÃ¡ um exemplo de como trazer o
mÃ³dulo <code>a::series::of</code> para dentro do escopo raiz de um crate binÃ¡rio:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">pub mod a {
    pub mod series {
        pub mod of {
            pub fn nested_modules() {}
        }
    }
}

use a::series::of;

fn main() {
    of::nested_modules();
}
</code></pre></pre>
<p>A linha <code>use a::series::of;</code> significa que, em vez de usar todo o caminho
<code>a::series::of</code> sempre que quisermos nos referir ao mÃ³dulo <code>of</code>, podemos usar
<code>of</code>.</p>
<p>A palavra-chave <code>use</code> traz apenas o que especificamos no escopo: ela nÃ£o
leva os filhos dos mÃ³dulos ao escopo. Ã‰ por isso que ainda temos que usar
<code>of::nested_modules</code> quando queremos chamar a funÃ§Ã£o <code>nested_modules</code>.</p>
<p>PoderÃ­amos ter escolhido trazer a funÃ§Ã£o para o escopo, em vez de especificar a funÃ§Ã£o
no <code>use</code> da seguinte forma:</p>
<pre><pre class="playpen"><code class="language-rust">pub mod a {
    pub mod series {
        pub mod of {
            pub fn nested_modules() {}
        }
    }
}

use a::series::of::nested_modules;

fn main() {
    nested_modules();
}
</code></pre></pre>
<p>Isso nos permite excluir todos os mÃ³dulos e fazer referÃªncia Ã  funÃ§Ã£o
diretamente.</p>
<p>Como as enums tambÃ©m formam uma espÃ©cie de <em>namespace</em>, assim como os mÃ³dulos, podemos trazer
as variantes de uma enum para o escopo com <code>use</code> tambÃ©m. Para qualquer tipo de declaraÃ§Ã£o de <code>use</code>
se vocÃª estiver trazendo vÃ¡rios itens de um <em>namespace</em> para o escopo, vocÃª pode listÃ¡-los
usando chaves e vÃ­rgulas na Ãºltima posiÃ§Ã£o, assim:</p>
<pre><pre class="playpen"><code class="language-rust">enum TrafficLight {
    Red,
    Yellow,
    Green,
}

use TrafficLight::{Red, Yellow};

fn main() {
    let red = Red;
    let yellow = Yellow;
    let green = TrafficLight::Green;
}
</code></pre></pre>
<p>NÃ³s ainda estamos especificando o <em>namespace</em> <code>TrafficLight</code> para a variante <code>Green</code>
porque nÃ£o incluÃ­mos <code>Green</code> na declaraÃ§Ã£o <code>use</code>.</p>
<a class="header" href="print.html#trazendo-todos-os-nomes-para-o-escopo-com-um-glob" id="trazendo-todos-os-nomes-para-o-escopo-com-um-glob"><h3>Trazendo Todos os Nomes para o Escopo com um Glob</h3></a>
<p>Para trazer todos os itens de um <em>namespace</em> para o escopo ao mesmo tempo, podemos usar a sintaxe <code>*</code>, que Ã© chamada de <em>operador glob</em>. Este exemplo traz todas as variantes de uma enum ao escopo sem ter que listar cada uma especificamente:</p>
<pre><pre class="playpen"><code class="language-rust">enum TrafficLight {
    Red,
    Yellow,
    Green,
}

use TrafficLight::*;

fn main() {
    let red = Red;
    let yellow = Yellow;
    let green = Green;
}
</code></pre></pre>
<p>O <code>*</code> trarÃ¡ para o escopo todos os itens visÃ­veis no <em>namespace</em> <code>TrafficLight</code>.
VocÃª deve usar globs com moderaÃ§Ã£o: eles sÃ£o convenientes, mas isso pode
tambÃ©m trazer mais itens do que se esperava e causar conflitos de nomeaÃ§Ã£o.</p>
<a class="header" href="print.html#usando-super-para-acessar-um-mÃ³dulo-pai" id="usando-super-para-acessar-um-mÃ³dulo-pai"><h3>Usando <code>super</code> para Acessar um MÃ³dulo Pai</h3></a>
<p>Como vimos no inÃ­cio deste capÃ­tulo, quando vocÃª cria um crate de biblioteca,
o Cargo faz um mÃ³dulo <code>tests</code> para vocÃª. Vamos ver isso em mais detalhes agora.
No seu projeto <code>communicator</code>, abra <em>src/lib.rs</em>:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub mod client;

pub mod network;

#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
</code></pre>
<p>O CapÃ­tulo 11 explica mais sobre testes, mas algumas partes deste exemplo devem fazer
sentido agora: temos um mÃ³dulo chamado <code>tests</code> que se situa ao lado de nossos outros mÃ³dulos
e contÃ©m uma funÃ§Ã£o chamada <code>it_works</code>. Embora existam anotaÃ§Ãµes especiais,
o mÃ³dulo <code>tests</code> Ã© apenas outro mÃ³dulo! EntÃ£o nossa hierarquia de mÃ³dulos
se parece com isso:</p>
<pre><code class="language-text">communicator
 â”œâ”€â”€ client
 â”œâ”€â”€ network
 |   â””â”€â”€ client
 â””â”€â”€ tests
</code></pre>
<p>Os testes servem para exercitar o cÃ³digo dentro da nossa biblioteca, entÃ£o vamos tentar chamar nossa
funÃ§Ã£o <code>client :: connect</code> a partir da funÃ§Ã£o<code>it_works</code>, mesmo que nÃ£o verefiquemos nenhuma
funcionalidade agora. Isso ainda nÃ£o funcionarÃ¡:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        client::connect();
    }
}
#}</code></pre></pre>
<p>Execute os testes invocando o comando <code>cargo test</code>:</p>
<pre><code class="language-text">$ cargo test
   Compiling communicator v0.1.0 (file:///projects/communicator)
error[E0433]: failed to resolve. Use of undeclared type or module `client`
 --&gt; src/lib.rs:9:9
  |
9 |         client::connect();
  |         ^^^^^^ Use of undeclared type or module `client`
</code></pre>
<p>A compilaÃ§Ã£o falhou, mas por quÃª? NÃ£o precisamos colocar <code>communicator ::</code> em
frente da funÃ§Ã£o como fizemos em <em>src/main.rs</em> porque estamos definitivamente
dentro do crate da biblioteca <code>communicator</code> aqui. A razÃ£o Ã© que os caminhos sÃ£o
sempre relativos ao mÃ³dulo atual, que aqui Ã© <code>tests</code>. A Ãºnica
exceÃ§Ã£o estÃ¡ em uma instruÃ§Ã£o <code>use</code>, onde os caminhos sÃ£o relativos Ã  crate raiz
por padrÃ£o. Nosso mÃ³dulo <code>tests</code> precisa do mÃ³dulo <code>client</code> no seu escopo!</p>
<p>EntÃ£o, como podemos retroceder um mÃ³dulo na hierarquia para chamar a
funÃ§Ã£o <code>client::connect</code> no mÃ³dulo <code>tests</code>? No mÃ³dulo <code>tests</code>, temos a opÃ§Ã£o de
usar <code>::</code> na frente para indicar ao Rust que queremos comeÃ§ar a partir da raiz
e listar todo o caminho, assim:</p>
<pre><code class="language-rust ignore">::client::connect();
</code></pre>
<p>Ou, podemos usar <code>super</code> para voltar um mÃ³dulo na hierarquia a partir de nosso
mÃ³dulo atual, assim:</p>
<pre><code class="language-rust ignore">super::client::connect();
</code></pre>
<p>Essas duas opÃ§Ãµes nÃ£o parecem tÃ£o diferentes neste exemplo, mas se vocÃª estiver
mais fundo em uma hierarquia de mÃ³dulos, comeÃ§ar sempre a partir da raiz tornaria
seu cÃ³digo muito longo. Nesses casos, usar <code>super</code> para ir do mÃ³dulo atual aos
mÃ³dulos irmÃ£os Ã© um bom atalho. AlÃ©m disso, se vocÃª especificou o caminho a partir da
raiz em muitos lugares do seu cÃ³digo e depois vai reorganizar seus mÃ³dulos movendo
uma sub-Ã¡rvore para outro lugar, vocÃª acabaria precisando atualizar o caminho em vÃ¡rios
lugares, o que seria tedioso.</p>
<p>TambÃ©m seria chato ter que digitar <code>super ::</code> em cada teste, mas vocÃª
jÃ¡ viu a ferramenta para essa soluÃ§Ã£o: <code>use</code>! A funcionalidade <code>super ::</code>
altera o caminho que vocÃª dÃ¡ para <code>use</code>, tornando-o relativo ao mÃ³dulo pai
em vez do mÃ³dulo raiz.</p>
<p>Por estas razÃµes, especialmente no mÃ³dulo <code>tests</code>, <code>use super::alguma_coisa</code> Ã©
geralmente a melhor soluÃ§Ã£o. EntÃ£o, agora nosso teste ficou assim:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    use super::client;

    #[test]
    fn it_works() {
        client::connect();
    }
}
#}</code></pre></pre>
<p>Quando executarmos novamente <code>cargo test</code>, o teste passarÃ¡ e a primeira parte do
resultado do teste serÃ¡ o seguinte:</p>
<pre><code class="language-text">$ cargo test
   Compiling communicator v0.1.0 (file:///projects/communicator)
     Running target/debug/communicator-92007ddb5330fa5a

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<a class="header" href="print.html#resumo-4" id="resumo-4"><h2>Resumo</h2></a>
<p>Agora vocÃª conhece algumas tÃ©cnicas novas para organizar o seu cÃ³digo! Use estas tÃ©cnicas
para agrupar as funcionalidades relacionadas, evitar que os arquivos tornem-se muito longos, e
apresentar uma API pÃºblica arrumada para os usuÃ¡rios da sua biblioteca.</p>
<p>Em seguida, analisaremos algumas estruturas de dados de coleÃ§Ãµes na biblioteca padrÃ£o
que vocÃª pode usar em seu cÃ³digo limpo e elegante!</p>
<a class="header" href="print.html#fundamental-collections" id="fundamental-collections"><h1>Fundamental Collections</h1></a>
<a class="header" href="print.html#vetores" id="vetores"><h2>Vetores</h2></a>
<p>O primeiro tipo que iremos ver Ã© <code>Vec&lt;T&gt;</code>, tambÃ©m conhecido como <em>vetor</em>. Vetores
permitem guardar mais de um valor na mesma estrutura de dados que coloca todos
os valores um ao lado do outro na memÃ³ria. Vetores sÃ³ podem guardar valores do
mesmo tipo. Eles sÃ£o Ãºteis em situaÃ§Ãµes onde hÃ¡ uma lista de itens, como
as linha de texto em um arquivo ou preÃ§os de itens em um carrinho de compras.</p>
<a class="header" href="print.html#criando-um-novo-vetor" id="criando-um-novo-vetor"><h3>Criando um Novo Vetor</h3></a>
<p>Para criar um novo vetor, vazio, chamamos a funÃ§Ã£o <code>Vec::new</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v: Vec&lt;i32&gt; = Vec::new();
#}</code></pre></pre>
<p>Note que adicionamos uma anotaÃ§Ã£o de tipo aqui. Como nÃ£o estamos inserindo nenhum valor
no vetor, Rust nÃ£o sabe o tipo de elementos que irÃ¡ guardar.
Isto Ã© um ponto importante. Vetores sÃ£o homogÃªneos: eles podem guardar muitos
valores, mas todos esses valores devem ser do mesmo tipo. Vetores sÃ£o implementados
usando genÃ©ricos, onde o capÃ­tulo 10 irÃ¡ cobrir como usar em seus tipos. Por
agora, tudo o que precisa saber Ã© que o tipo <code>Vec</code> fornecido pela biblioteca
padrÃ£o pode conter qualquer tipo, e quando um <code>Vec</code> especÃ­fico possui um tipo especÃ­fico, o
tipo vai dentro de <code>&lt; &gt;</code>. Falamos para Rust que <code>Vec</code> em <code>v</code> guardarÃ¡
elementos do tipo <code>i32</code>.</p>
<p>No cÃ³digo real, a Rust pode inferir o tipo de valor que queremos armazenar uma vez que inserimos
valores, entÃ£o vocÃª raramente precisa fazer essa anotaÃ§Ã£o de tipo. Ã‰ mais comum
criar um <code>Vec</code> que possui valores iniciais, e o Rust fornece a macro <code>vec!</code> por
conveniÃªncia. A macro criarÃ¡ um novo <code>Vec</code> que contÃ©m os valores que damos
. Isso criarÃ¡ um novo <code>Vec &lt;i32&gt;</code> que contÃ©m os valores <code>1</code>,<code>2</code> e <code>3</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3];
#}</code></pre></pre>
<p>Como nÃ³s damos valores iniciais  <code>i32</code>, Rust pode inferir que o tipo de <code>v</code>
Ã© <code>Vec &lt;i32&gt;</code>, e a anotaÃ§Ã£o de tipo nÃ£o Ã© necessÃ¡ria. Vejamos a seguir como
modificar um vetor.</p>
<a class="header" href="print.html#modificando-um-vetor" id="modificando-um-vetor"><h3>Modificando um Vetor</h3></a>
<p>Para criar um vetor e adicionar elementos a ele, podemos usar o mÃ©todo <code>push</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut v = Vec::new();

v.push(5);
v.push(6);
v.push(7);
v.push(8);
#}</code></pre></pre>
<p>Como qualquer variÃ¡vel que discutimos no CapÃ­tulo 3, se quisermos poder
alterar seu valor, precisamos fazÃª-lo mutÃ¡vel com a palavra-chave <code>mut</code>. Os
nÃºmeros que inserimos sÃ£o todos do tipo <code>i32</code>, e Rust infere isso dos
dados, por isso nÃ£o precisamos da anotaÃ§Ã£o <code>Vec &lt;i32&gt;</code>.</p>
<a class="header" href="print.html#descartar-um-vetor-descarta-seus-elementos" id="descartar-um-vetor-descarta-seus-elementos"><h3>Descartar um Vetor Descarta seus Elementos</h3></a>
<p>Como qualquer outro <code>struct</code>, um vetor serÃ¡ liberado quando ele sair do escopo:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    let v = vec![1, 2, 3, 4];

    // use as informaÃ§Ãµes em v

} // &lt;- v sai do escopo e Ã© liberado aqui
#}</code></pre></pre>
<p>Quando o vetor Ã© descartado, todos os seus conteÃºdos tambÃ©m serÃ¡ descartado, o que significa
esses inteiros que ele contÃ©m serÃ£o limpos. Isso pode parecer um
ponto direto, mas pode ficar um pouco mais complicado quando comeÃ§amos a
introduzir referÃªncias aos elementos do vetor. Vamos abordar isso em seguida!</p>
<a class="header" href="print.html#lendo-elementos-do-vetor" id="lendo-elementos-do-vetor"><h3>Lendo Elementos do Vetor</h3></a>
<p>Agora que vocÃª sabe como criar, atualizar e destruir vetores,
saber ler o seu conteÃºdo Ã© um bom passo seguinte. Existem duas maneiras de fazer referÃªncia a
valores armazenados em um vetor. Nos exemplos, anotamos os tipos de
valores que sÃ£o retornados dessas funÃ§Ãµes para maior clareza.</p>
<p>Este exemplo mostra os dois mÃ©todos de acesso a um valor em um vetor com
sintaxe de indexaÃ§Ã£o ou o mÃ©todo <code>get</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3, 4, 5];

let third: &amp;i32 = &amp;v[2];
let third: Option&lt;&amp;i32&gt; = v.get(2);
#}</code></pre></pre>
<p>HÃ¡ algumas coisas a serem observadas aqui. Primeiro, que usamos o valor do Ã­ndice de <code>2</code>
para obter o terceiro elemento: os vetores sÃ£o indexados por nÃºmero, comeÃ§ando em zero.
Em segundo lugar, as duas maneiras diferentes de obter o terceiro elemento sÃ£o: usando <code>&amp;</code> e
<code>[]</code>, que nos dÃ¡ uma referÃªncia, ou usando o mÃ©todo <code>get</code> com o Ã­ndice
passado como um argumento, o que nos dÃ¡ uma <code>Option&lt;&amp;T&gt;</code>.</p>
<p>A razÃ£o pela qual Rust tem duas maneiras de fazer referÃªncia a um elemento Ã© para que vocÃª possa escolher
como o programa se comporta quando vocÃª tenta usar um valor de Ã­ndice para o qual
o vetor nÃ£o tem um elemento correspondente. Por exemplo, o que um programa deve fazer se tiver
um vetor que contÃ©m cinco elementos, entÃ£o tenta acessar um elemento no Ã­ndice 100
dessa maneira:</p>
<pre><pre class="playpen"><code class="language-rust should_panic">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &amp;v[100];
let does_not_exist = v.get(100);
#}</code></pre></pre>
<p>Quando vocÃª executar isso, vocÃª verÃ¡ que com o primeiro mÃ©todo <code>[]</code>, Rust irÃ¡
causar um <code>panic!</code> quando um elemento inexistente Ã© referenciado. Este mÃ©todo seria
preferÃ­vel se vocÃª quiser que seu programa considere uma tentativa de acessar um
elemento, passado o fim do vetor, para ser um erro fatal que deve finalizar o
programa.</p>
<p>Quando Ã© passado um Ã­ndice que estÃ¡ fora da matriz para o mÃ©todo <code>get</code>, ele
retorna <code>None</code> sem entrar em pÃ¢nico. VocÃª usaria isso se acessar um elemento
alÃ©m do alcance do vetor ocorrerÃ¡ ocasionalmente sob
circunstÃ¢ncias normais. Seu cÃ³digo pode entÃ£o ter lÃ³gica para lidar tanto com
<code>Some(&amp;element)</code> ou <code>None</code>, como discutimos no CapÃ­tulo 6. Por exemplo, o
O Ã­ndice pode ser proveniente de uma pessoa que digite um nÃºmero. Se eles acidentalmente
insira um nÃºmero que Ã© muito grande e seu programa recebe um valor <code>None</code>, vocÃª poderia
dizer ao usuÃ¡rio quantos itens estÃ£o no atual <code>Vec</code> e dar uma nova
chance de inserir um valor vÃ¡lido. Isso seria mais amigÃ¡vel do que quebrar o
programa por um erro de digitaÃ§Ã£o!</p>
<a class="header" href="print.html#referÃªncias-invÃ¡lidas" id="referÃªncias-invÃ¡lidas"><h4>ReferÃªncias InvÃ¡lidas</h4></a>
<p>Uma vez que o programa tenha uma referÃªncia vÃ¡lida, o verificador de emprÃ©stimo (borrow checker) faz valer
as regras de propriedade e emprÃ©stimo abrangidas no CapÃ­tulo 4 para garantir que essa referÃªncia e
quaisquer outras referÃªncias aos conteÃºdos do vetor permaneÃ§am vÃ¡lidas. Lembre-se da regra
que diz que nÃ£o podemos ter referÃªncias mutÃ¡veis e imutÃ¡veis no mesmo escopo.
Essa regra se aplica neste exemplo, onde mantemos uma referÃªncia imutÃ¡vel ao
primeiro elemento em um vetor e tentamos adicionar um elemento ao final:</p>
<pre><code class="language-rust ignore">let mut v = vec![1, 2, 3, 4, 5];

let first = &amp;v[0];

v.push(6);
</code></pre>
<p>Compilar isso nos darÃ¡ esse erro:</p>
<pre><code class="language-text">error[E0502]: cannot borrow `v` as mutable because it is also borrowed as
immutable
  |
4 | let first = &amp;v[0];
  |              - immutable borrow occurs here
5 |
6 | v.push(6);
  | ^ mutable borrow occurs here
7 | }
  | - immutable borrow ends here
</code></pre>
<p>Este cÃ³digo pode parecer que deveria funcionar: por que uma referÃªncia ao primeiro
elemento deveria se preocupar com o que muda sobre o final do vetor? A razÃ£o porque
este cÃ³digo nÃ£o Ã© permitido Ã© devido Ã  forma como os vetores funcionam. Adicionando um novo elemento
no final do vetor pode exigir a atribuiÃ§Ã£o de nova alocaÃ§Ã£o de memÃ³ria e copiar os
elementos antigos para o novo espaÃ§o, na circunstÃ¢ncia de nÃ£o haver espaÃ§o suficiente
para colocar todos os elementos prÃ³ximos um do outro onde o vetor estava. Nesse
caso, a referÃªncia ao primeiro elemento apontaria para memÃ³ria nÃ£o alocada.
As regras de emprÃ©stimo impedem que os programas acabem nessa situaÃ§Ã£o.</p>
<blockquote>
<p>Nota: para mais informaÃ§Ãµes, veja o Rustonomicon em
<em>https://doc.rust-lang.org/stable/nomicon/vec.html</em>.</p>
</blockquote>
<a class="header" href="print.html#usando-um-enum-para-armazenar-vÃ¡rios-tipos" id="usando-um-enum-para-armazenar-vÃ¡rios-tipos"><h3>Usando um Enum para Armazenar VÃ¡rios Tipos</h3></a>
<p>No inÃ­cio deste capÃ­tulo, dissemos que os vetores sÃ³ podem armazenar valores
que sÃ£o todos do mesmo tipo. Isso pode ser inconveniente; definitivamente hÃ¡ casos
de uso para a necessidade de armazenar uma lista de coisas de diferentes tipos. Felizmente,
as variantes de um enum sÃ£o todas definidas sob o mesmo tipo de enum, entÃ£o, quando precisamos
armazenar elementos de um tipo diferente em um vetor, podemos definir e usar um
enum!</p>
<p>Por exemplo, digamos que queremos obter valores de uma linha em uma planilha, onde
algumas das colunas da linha contÃªm nÃºmeros inteiros, alguns nÃºmeros de ponto flutuante,
e algumas strings. Podemos definir um enum cujas variantes guardarÃ£o os diferentes
tipos de valor, e entÃ£o todas as variantes de enum serÃ£o consideradas do mesmos
tipo, o do enum. EntÃ£o, podemos criar um vetor que contenha esse enum e
entÃ£o, em Ãºltima instÃ¢ncia, possui diferentes tipos:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from(&quot;blue&quot;)),
    SpreadsheetCell::Float(10.12),
];
#}</code></pre></pre>
<p><span class="caption">Listagem 8-1: Definindo um enum para poder guardar
diferentes tipos de dados em um vetor</span></p>
<p>A razÃ£o pela qual Rust precisa saber exatamente quais tipos estarÃ£o no vetor em
tempo de compilaÃ§Ã£o Ã© para que ele saiba exatamente a quantidade de memÃ³ria no heap que serÃ¡
necessÃ¡ria para armazenar cada elemento. Uma vantagem secundÃ¡ria para isso Ã© que podemos ser
explÃ­citos sobre quais tipos sÃ£o permitidos neste vetor. Se Rust permitisse um vetor
guardar qualquer tipo, haveria uma chance de que um ou mais dos tipos
causar erros com as operaÃ§Ãµes realizadas nos elementos do vetor. Usando
um enum mais um <code>match</code> significa que a Rust garantirÃ¡ no tempo de compilaÃ§Ã£o que nÃ³s
sempre lidaremos com todos os casos possÃ­veis, como discutimos no CapÃ­tulo 6.</p>
<p>Se vocÃª nÃ£o sabe no momento em que vocÃª estÃ¡ escrevendo um programa, o conjunto exaustivo
dos tipos que o programa irÃ¡ precisar no tempo de execuÃ§Ã£o para armazenar em um vetor, a tÃ©cnica de usar
o enum nÃ£o funcionarÃ¡. Em vez disso, vocÃª pode usar um objeto trait, que abordaremos no
CapÃ­tulo 17.</p>
<p>Agora que examinamos algumas das maneiras mais comuns de usar vetores, certifique-se
para dar uma olhada na documentaÃ§Ã£o da API para todos os muitos mÃ©todos Ãºteis
definidos no <code>Vec</code> pela biblioteca padrÃ£o. Por exemplo, alÃ©m de <code>push</code>
existe um mÃ©todo <code>pop</code> que irÃ¡ remover e retornar o Ãºltimo elemento. Vamos mover
para o prÃ³ximo tipo de coleÃ§Ã£o: <code>String</code>!</p>
<a class="header" href="print.html#strings" id="strings"><h2>Strings</h2></a>
<p>NÃ³s jÃ¡ conversamos sobre as strings no capÃ­tulo 4, mas vamos dar uma olhada mais
em profundidade agora. As strings sÃ£o uma Ã¡rea que os novos RustÃ¡ceos geralmente tem maior
dificuldade. Isto Ã© devido a uma combinaÃ§Ã£o de trÃªs coisas: a propensÃ£o de Rust de
certificar-se de expor possÃ­veis erros, as strings sÃ£o estruturas de dados mais complicadas
que muitos programadores lhes dÃ£o crÃ©dito, e UTF-8. Essas coisas
combina de tal forma que parecem difÃ­cil quando se vem de outras linguagens.</p>
<p>A razÃ£o pela qual as strings estÃ£o no capÃ­tulo de coleÃ§Ãµes Ã© que as strings sÃ£o
implementadas como uma coleÃ§Ã£o de bytes mais alguns mÃ©todos para fornecer informaÃ§Ãµes Ãºteis e
funcionalidade quando esses bytes sÃ£o interpretados como texto. Nesta seÃ§Ã£o, iremos
falar sobre as operaÃ§Ãµes em <code>String</code> que todo tipo de coleÃ§Ã£o tem, como
criar, atualizar e ler. TambÃ©m discutiremos as formas em que <code>String</code>
Ã© diferente das outras coleÃ§Ãµes, a saber, como a indexaÃ§Ã£o em um <code>String</code> Ã©
complicada pelas diferenÃ§as entre como as pessoas e os computadores interpretam
dados <code>String</code>.</p>
<a class="header" href="print.html#o-que-Ã©-string" id="o-que-Ã©-string"><h3>O que Ã© String?</h3></a>
<p>Antes de podermos explorar esses aspectos, precisamos falar sobre o que exatamente
significa o termo <em>string</em>. Rust realmente sÃ³ tem um tipo de string no nÃºcleo
da prÃ³pria linguagem: <code>str</code>, a fatia de string, que geralmente Ã© vista na forma emprestada
, <code>&amp;str</code>. NÃ³s falamos sobre <em>fatias de strings</em> no CapÃ­tulo 4: estas sÃ£o uma
referÃªncia a alguns dados de string codificados em UTF-8 armazenados em outro lugar. Literais de strings,
por exemplo, sÃ£o armazenados na saÃ­da binÃ¡ria do programa e, portanto, sÃ£o
fatias de string.</p>
<p>O tipo chamado <code>String</code> Ã© fornecido na biblioteca padrÃ£o do Rust, em vez de
codificado no nÃºleo da linguagem, e Ã© um extensÃ­vel, mutÃ¡vel, <code>owned</code>, tipo string
codificado UTF-8. Quando RustÃ¡ceos falam sobre â€œstringsâ€ em Rust, geralmente significa
tanto os tipos <code>String</code> quanto os tipos de string<code>&amp;str</code>, normalmente ambos.
Esta seÃ§Ã£o, Ã© em grande parte sobre <code>String</code>, mas ambos esses tipos sÃ£o usados em grande parte
na biblioteca padrÃ£o da Rust. Tanto o <code>String</code> como as fatias de string sÃ£o codificadas em UTF-8.</p>
<p>A biblioteca padrÃ£o do Rust tambÃ©m inclui uma sÃ©rie de outros tipos de string, como
<code>OsString</code>,<code>OsStr</code>, <code>CString</code> e<code>CStr</code>. Bibliotecas crates podem fornecer
mais opÃ§Ãµes para armazenar dados de string. Semelhante ao nome <code>*String</code>/<code>*Str</code>,
elas geralmente fornecem uma variante owned e borrowed, assim como <code>String</code>/<code>&amp;str</code>.
Esses tipos de string podem armazenar diferentes codificaÃ§Ãµes ou ser representados na memÃ³ria de
maneira diferente, por exemplo. NÃ³s nÃ£o estaremos falando sobre esse outro tipo de string
neste capÃ­tulo; veja a documentaÃ§Ã£o da API para obter mais informaÃ§Ãµes sobre como usÃ¡-los
e quando cada um Ã© apropriado.</p>
<a class="header" href="print.html#criando-uma-nova-string" id="criando-uma-nova-string"><h3>Criando uma Nova String</h3></a>
<p>Muitas das mesmas operaÃ§Ãµes disponÃ­veis com <code>Vec</code> tambÃ©m estÃ£o disponÃ­veis em <code>String</code>,
comeÃ§ando com a funÃ§Ã£o <code>new</code> para criar uma string, assim:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::new();
#}</code></pre></pre>
<p>Isso cria uma nova string vazia chamada <code>s</code> na qual podemos carregar dados.</p>
<p>Muitas vezes, teremos alguns dados iniciais que gostarÃ­amos de jÃ¡ colocar na string.
Para isso, usamos o mÃ©todo <code>to_string</code>, que estÃ¡ disponÃ­vel em qualquer tipo
que implementa a trait <code>Display</code>, como as strings literais:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let data = &quot;initial contents&quot;;

let s = data.to_string();

// o mÃ©todo tambÃ©m funciona em literais diretamente
let s = &quot;initial contents&quot;.to_string();
#}</code></pre></pre>
<p>Isso cria uma string contendo <code>initial contents</code>.</p>
<p>TambÃ©m podemos usar a funÃ§Ã£o <code>String :: from</code> para criar uma<code>String</code> de uma string
literal. Isso equivale a usar <code>to_string</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;initial contents&quot;);
#}</code></pre></pre>
<p>Como as strings sÃ£o usadas para tantas coisas, existem vÃ¡rias APIs genÃ©ricas diferentes
que podem ser usadas para strings, entÃ£o hÃ¡ muitas opÃ§Ãµes. Algumas delas
podem parecer redundantes, mas todas tÃªm seu lugar! Nesse caso, <code>String :: from</code>
e <code>.to_string</code> acabam fazendo exatamente o mesmo, entÃ£o a que vocÃª escolher Ã© uma
questÃ£o de estilo.</p>
<p>Lembre-se de que as string sÃ£o codificadas em UTF-8, para que possamos incluir qualquer dados apropriadamente codificados
neles:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let hello = &quot;Ø§Ù„Ø³Ù„Ø§Ù… Ø¹Ù„ÙŠÙƒÙ…&quot;;
let hello = &quot;DobrÃ½ den&quot;;
let hello = &quot;Hello&quot;;
let hello = &quot;×©Ö¸××œ×•Ö¹×&quot;;
let hello = &quot;à¤¨à¤®à¤¸à¥à¤¤à¥‡&quot;;
let hello = &quot;ã“ã‚“ã«ã¡ã¯&quot;;
let hello = &quot;ì•ˆë…•í•˜ì„¸ìš”&quot;;
let hello = &quot;ä½ å¥½&quot;;
let hello = &quot;OlÃ¡&quot;;
let hello = &quot;Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ&quot;;
let hello = &quot;Hola&quot;;
#}</code></pre></pre>
<a class="header" href="print.html#atualizando-uma-string" id="atualizando-uma-string"><h3>Atualizando uma String</h3></a>
<p>Uma <code>String</code> pode crescer em tamanho e seu conteÃºdo pode mudar assim como o conteÃºdo
de um <code>Vec</code>, empurrando mais dados para ela. AlÃ©m disso, <code>String</code> tem
operaÃ§Ãµes de concatenaÃ§Ã£o implementadas com o operador <code>+</code> por conveniÃªncia.</p>
<a class="header" href="print.html#anexando-a-uma-string-com-push" id="anexando-a-uma-string-com-push"><h4>Anexando a uma String com Push</h4></a>
<p>Podemos criar uma <code>String</code> usando o mÃ©todo <code>push_str</code> para adicionar uma  seqÃ¼Ãªncia de caracteres:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::from(&quot;foo&quot;);
s.push_str(&quot;bar&quot;);
#}</code></pre></pre>
<p><code>s</code> conterÃ¡ â€œfoobarâ€œ apÃ³s essas duas linhas. O mÃ©todo <code>push_str</code> leva um
fatia de string porque nÃ£o necessariamente queremos ownership do
parÃ¢metro. Por exemplo, seria lamentÃ¡vel se nÃ£o pudÃ©ssemos usar <code>s2</code>
depois de atualizar o seu conteÃºdo a <code>s1</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s1 = String::from(&quot;foo&quot;);
let s2 = String::from(&quot;bar&quot;);
s1.push_str(&amp;s2);
#}</code></pre></pre>
<p>O mÃ©todo <code>push</code> Ã© definido para ter um Ãºnico caractere como parÃ¢metro e adicionar
Ã  <code>String</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::from(&quot;lo&quot;);
s.push('l');
#}</code></pre></pre>
<p>ApÃ³s isso, <code>s</code> irÃ¡ conter â€œlolâ€.</p>
<a class="header" href="print.html#concatenaÃ§Ã£o-com-o-operador--ou-a-macro-format" id="concatenaÃ§Ã£o-com-o-operador--ou-a-macro-format"><h4>ConcatenaÃ§Ã£o com o Operador + ou a macro <code>format!</code></h4></a>
<p>Muitas vezes, queremos combinar duas strings existentes. Uma maneira Ã© usar
o operador <code>+</code> dessa forma:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;Hello, &quot;);
let s2 = String::from(&quot;world!&quot;);
let s3 = s1 + &amp;s2; // Note que s1 foi movido aqui e nÃ£o pode ser mais usado
#}</code></pre></pre>
<p>ApÃ³s este cÃ³digo, a String <code>s3</code> conterÃ¡ <code>Hello, world!</code>. O motivo que
<code>s1</code> nÃ£o Ã© mais vÃ¡lido apÃ³s a adiÃ§Ã£o e o motivo que usamos uma
referÃªncia a <code>s2</code> tem a ver com a assinatura do mÃ©todo que Ã© chamado
quando usamos o operador <code>+</code>. O operador <code>+</code> usa o mÃ©todo <code>add</code>, cuja
assinatura parece algo assim:</p>
<pre><code class="language-rust ignore">fn add(self, s: &amp;str) -&gt; String {
</code></pre>
<p>Esta nÃ£o Ã© a assinatura exata que estÃ¡ na biblioteca padrÃ£o; lÃ¡ o <code>add</code> Ã©
definido usando genÃ©ricos. Aqui, estamos olhando a assinatura do <code>add</code> com
tipos de concreto substituÃ­dos pelos genÃ©ricos, o que acontece quando nÃ³s
chamamos esse mÃ©todo com valores <code>String</code>. Vamos discutir genÃ©ricos no
CapÃ­tulo 10. Esta assinatura nos dÃ¡ as pistas que precisamos para entender o complicado
operador <code>+</code>.</p>
<p>Antes de tudo, <code>s2</code> tem um <code>&amp;</code>, o que significa que estamos adicionando uma <em>referÃªncia</em> da
segunda string para a primeira string. Isso Ã© devido ao parÃ¢metro <code>s</code> na
funÃ§Ã£o <code>add</code>: sÃ³ podemos adicionar um <code>&amp;str</code> Ã  <code>String</code>, nÃ£o podemos adicionar dois
valores <code>String</code> juntos. Mas espere - o tipo de <code>&amp;s2</code> Ã© <code>&amp;String</code>, nÃ£o
<code>&amp;str</code>, conforme especificado no segundo parÃ¢metro para<code>add</code>. Por que nosso exemplo
compila? Podemos usar <code>&amp;s2</code> na chamada para <code>add</code> porque um <code>&amp;String</code>
o argumento pode ser <em>coerced</em> em um <code>&amp;str</code> - quando a funÃ§Ã£o<code>add</code> Ã© chamada,
Rust usa algo chamado de <em>deref coercion</em>, o que vocÃª poderia pensar aqui como
virando <code>&amp;s2</code> para<code>&amp;s2[..]</code> para uso na funÃ§Ã£o <code>add</code>. Vamos discutir deref
coercion  em maior profundidade no CapÃ­tulo 15. Como o <code>add</code> nÃ£o se apropria
o parÃ¢metro <code>s2</code> ainda serÃ¡ uma <code>String</code> vÃ¡lida apÃ³s essa operaÃ§Ã£o.</p>
<p>Em segundo lugar, podemos ver na assinatura que <code>add</code> toma posse de<code>self</code>,
porque <code>self</code> <em>nÃ£o</em> tem <code>&amp;</code>. Isso significa <code>s1</code> no exemplo acima
serÃ¡ transferido para a chamada <code>add</code> e nÃ£o serÃ¡ mais vÃ¡lido depois disso. Por enquanto
<code>let s3 = s1 + &amp;s2;</code> parece que irÃ¡ copiar ambas as strings e criar uma nova,
esta declaraÃ§Ã£o realmente adere a <code>s1</code>, acrescenta uma cÃ³pia do conteÃºdo
de <code>s2</code>, entÃ£o retorna ownership do resultado. Em outras palavras, parece
estar fazendo muitas cÃ³pias, mas nÃ£o Ã©: a implementaÃ§Ã£o Ã© mais eficiente
do que copiar.</p>
<p>Se precisarmos concatenar vÃ¡rias strings, o comportamento de <code>+</code> fica complicado:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;tic&quot;);
let s2 = String::from(&quot;tac&quot;);
let s3 = String::from(&quot;toe&quot;);

let s = s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;s3;
#}</code></pre></pre>
<p><code>s</code> serÃ¡ â€œtic-tac-toeâ€ neste momento. Com todos os <code>+</code> e <code>&quot;</code>,
fica difÃ­cil ver o que estÃ¡ acontecendo. Para strings mais complicadas
, podemos usar o macro <code>format!</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;tic&quot;);
let s2 = String::from(&quot;tac&quot;);
let s3 = String::from(&quot;toe&quot;);

let s = format!(&quot;{}-{}-{}&quot;, s1, s2, s3);
#}</code></pre></pre>
<p>Este cÃ³digo tambÃ©m definirÃ¡ <code>s</code> para â€œtic-tac-toeâ€. A macro <code>format!</code> funciona
do mesmo modo que <code>println!</code>, mas em vez de imprimir a saÃ­da para a tela, ela
retorna uma <code>String</code> com o conteÃºdo. Esta versÃ£o Ã© muito mais fÃ¡cil de ler, e
tambÃ©m nÃ£o incide ownership em nenhum dos seus parÃ¢metros.</p>
<a class="header" href="print.html#indexaÃ§Ã£o-em-strings" id="indexaÃ§Ã£o-em-strings"><h3>IndexaÃ§Ã£o em Strings</h3></a>
<p>Em muitas outras linguagens, acessar caracteres individuais em uma string por
referenciando por Ã­ndice Ã© uma operaÃ§Ã£o vÃ¡lida e comum. Em Rust, no entanto, se
nÃ³s tentamos acessar partes de uma <code>String</code> usando sintaxe de indexaÃ§Ã£o, vamos ter um erro.
Ou seja, este cÃ³digo:</p>
<pre><code class="language-rust ignore">let s1 = String::from(&quot;hello&quot;);
let h = s1[0];
</code></pre>
<p>resultarÃ¡ neste erro:</p>
<pre><code class="language-text">error: the trait bound `std::string::String: std::ops::Index&lt;_&gt;` is not
satisfied [--explain E0277]
  |&gt;
  |&gt;     let h = s1[0];
  |&gt;             ^^^^^
note: the type `std::string::String` cannot be indexed by `_`
</code></pre>
<p>O erro e a nota contam a histÃ³ria: as strings em Rust nÃ£o suportam a indexaÃ§Ã£o. Assim
a prÃ³xima pergunta Ã©, por que nÃ£o? Para responder a isso, temos que conversar um
pouco sobre como o Rust armazena strings na memÃ³ria.</p>
<a class="header" href="print.html#representaÃ§Ã£o-interna" id="representaÃ§Ã£o-interna"><h4>RepresentaÃ§Ã£o Interna</h4></a>
<p>Uma <code>String</code> Ã© um invÃ³lucro sobre um <code>Vec &lt;u8&gt;</code>. Vejamos alguns dos nossos
exemplos UTF-8, codificadas corretamente, de strings vistas anteriormente. Primeiro, este:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let len = String::from(&quot;Hola&quot;).len();
#}</code></pre></pre>
<p>Neste caso, <code>len</code> terÃ¡ valor de quatro, o que significa que o<code>Vec</code> armazena a string
â€Holaâ€ tem quatro bytes de comprimento: cada uma dessas letras leva um byte quando codificado em
UTF-8. E o que acontece para esse exemplo?</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let len = String::from(&quot;Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ&quot;).len();
#}</code></pre></pre>
<p>Uma pessoa que pergunte pelo comprimento da string pode dizer que ela deva ter 12.No entanto, a resposta de Rust
Ã© 24. Este Ã© o nÃºmero de bytes que Ã© necessÃ¡rio para codificar â€œĞ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµâ€œ em
UTF-8, uma vez que cada valor escalar Unicode leva dois bytes de armazenamento. Assim sendo,
um Ã­ndice nos bytes da string nem sempre se correlaciona com um  valor escalar Unicode vÃ¡lido.</p>
<p>Para demonstrar, considere este cÃ³digo invÃ¡lido do Rust:</p>
<pre><code class="language-rust ignore">let hello = &quot;Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ&quot;;
let answer = &amp;hello[0];
</code></pre>
<p>Qual deve ser o valor da <code>answer</code>? Seria <code>Ğ—</code>, a primeira letra? Quando
codificado em UTF-8, o primeiro byte de <code>Ğ—</code> Ã© <code>208</code>, e o segundo Ã© <code>151</code>, entÃ£o
a <code>answer</code> deve, na verdade, ser <code>208</code>, mas <code>208</code> nÃ£o Ã© um caractere vÃ¡lido em
si. Retornar <code>208</code> provavelmente nÃ£o Ã© o que uma pessoa gostaria se eles pedissem
a primeira letra desta string, mas esse Ã© o Ãºnico dado que Rust tem no byte
de Ã­ndice 0. O retorno do valor do byte provavelmente nÃ£o Ã© o que as pessoas querem, mesmo com
caracteres contendo acentuaÃ§Ã£o: <code>&amp;&quot;hello&quot;[0]</code> retornaria <code>104</code>, nÃ£o<code>h</code>. Para evitar o
retornando um valor inesperado e causando erros que podem nÃ£o ser descobertos
imediatamente, Rust escolhe nÃ£o compilar este cÃ³digo e previne
mal-entendidos anteriormente.</p>
<a class="header" href="print.html#bytes-e-valores-escalares-e-clusters-de-grafemas-nossa" id="bytes-e-valores-escalares-e-clusters-de-grafemas-nossa"><h4>Bytes e Valores Escalares e Clusters de Grafemas! Nossa!</h4></a>
<p>Isso leva a outro ponto sobre UTF-8: existem realmente trÃªs maneiras relevantes
de olhar para as strings, da perspectiva do Rust: como bytes, valores escalares e
clusters de grafemas (a coisa mais prÃ³xima do que as pessoas chamariam <em>letras</em>).</p>
<p>Se olharmos para a palavra Hindi â€œà¤¨à¤®à¤¸à¥à¤¤à¥‡â€ escrita na escrita Devanagari, Ã©
em Ãºltima instÃ¢ncia, armazenada como um <code>Vec</code> de valores <code>u8</code> que se parece com isto:</p>
<pre><code class="language-text">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
</code></pre>
<p>Isso Ã© 18 bytes, e Ã© como os computadores de fato armazenam esses dados. Se olharmos para
eles como valores escalares Unicode, que sÃ£o o tipo <code>char</code> de Rust, aqueles
bytes se parecem com isto:</p>
<pre><code class="language-text">['à¤¨', 'à¤®', 'à¤¸', 'à¥', 'à¤¤', 'à¥‡']
</code></pre>
<p>Existem seis valores <code>char</code> aqui, mas o quarto e o sexto nÃ£o sÃ£o letras,
Eles sÃ£o diacrÃ­ticos que nÃ£o fazem sentido por conta prÃ³pria. Finalmente, se olharmos para
eles como clusters de grafemas, terÃ­amos o que uma pessoa chamaria as quatro letras
que compÃµem esta palavra:</p>
<pre><code class="language-text">[&quot;à¤¨&quot;, &quot;à¤®&quot;, &quot;à¤¸à¥&quot;, &quot;à¤¤à¥‡&quot;]
</code></pre>
<p>Rust fornece diferentes maneiras de interpretar os dados de uma string bruta que os computadores
armazenem para que cada programa possa escolher a interpretaÃ§Ã£o que necessite, nÃ£o importa
em que idioma humano os dados estÃ£o.</p>
<p>Uma razÃ£o final do Rust nÃ£o permitir que vocÃª indexe uma <code>String</code> para obter um
caracter Ã© que as operaÃ§Ãµes de indexaÃ§Ã£o sempre esperam um tempo constante
(O(1)). NÃ£o Ã© possÃ­vel garantir que o desempenho com uma <code>String</code>,
entretanto, jÃ¡ que o Rust teria que percorrer todo o conteÃºdo desde o inÃ­cio
atÃ© o Ã­ndice para determinar quantos caracteres vÃ¡lidos havia.</p>
<a class="header" href="print.html#fatiando-strings" id="fatiando-strings"><h3>Fatiando Strings</h3></a>
<p>Porque nÃ£o estÃ¡ claro qual seria o tipo de retorno da indexaÃ§Ã£o de string, e
muitas vezes Ã© uma mÃ¡ idÃ©ia indexar uma string, Rust dissuade-o de fazÃª-lo
pedindo que vocÃª seja mais especÃ­fico se vocÃª realmente precisar disso. Do jeito que vocÃª pode ser
mais especÃ­fico que a indexaÃ§Ã£o usando <code>[]</code> com um Ãºnico nÃºmero Ã© usando <code>[]</code> com
um intervalo para criar uma fatia de string contendo bytes especÃ­ficos:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let hello = &quot;Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ&quot;;

let s = &amp;hello[0..4];
#}</code></pre></pre>
<p>Aqui, <code>s</code> serÃ¡ um <code>&amp;str</code> que contÃ©m os primeiros quatro bytes da string.
Mais cedo, mencionamos que cada um desses personagens era de dois bytes, de modo que
significa que <code>s</code> serÃ¡ â€œĞ—Ğ´â€.</p>
<p>O que aconteceria se fizÃ©ssemos <code>&amp;hello[0..1]</code>? A resposta: entrarÃ¡ em pÃ¢nico
em tempo de execuÃ§Ã£o, da mesma maneira que acessar um Ã­ndice invÃ¡lido em um vetor:</p>
<pre><code class="language-text">thread 'main' panicked at 'index 0 and/or 1 in `Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ` do not lie on
character boundary', ../src/libcore/str/mod.rs:1694
</code></pre>
<p>VocÃª deve usar isso com cautela, pois isso pode fazer com que seu programa falhe.</p>
<a class="header" href="print.html#mÃ©todos-para-interagir-sobre-strings" id="mÃ©todos-para-interagir-sobre-strings"><h3>MÃ©todos para Interagir Sobre Strings</h3></a>
<p>Felizmente, existem outras maneiras de acessar elementos em um String.</p>
<p>Se precisarmos realizar operaÃ§Ãµes em valores escalares Unicode individuais, a melhor
maneira de fazer isso Ã© usar o mÃ©todo <code>chars</code>. Chamando <code>chars</code> em â€œà¤¨à¤®à¤¸à¥à¤¤à¥‡â€
Ã© separado e retorna seis valores do tipo <code>char</code>, e vocÃª pode interar
no resultado para acessar cada elemento:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
for c in &quot;à¤¨à¤®à¤¸à¥à¤¤à¥‡&quot;.chars() {
    println!(&quot;{}&quot;, c);
}
#}</code></pre></pre>
<p>Este cÃ³digo irÃ¡ imprimir:</p>
<pre><code class="language-text">à¤¨
à¤®
à¤¸
à¥
à¤¤
à¥‡
</code></pre>
<p>O mÃ©todo <code>bytes</code> retorna cada byte bruto, que pode ser apropriado para o seu
domÃ­nio:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
for b in &quot;à¤¨à¤®à¤¸à¥à¤¤à¥‡&quot;.bytes() {
    println!(&quot;{}&quot;, b);
}
#}</code></pre></pre>
<p>Este cÃ³digo imprimirÃ¡ os 18 bytes que compÃµem esse <code>String</code>, comeÃ§ando por:</p>
<pre><code class="language-text">224
164
168
224
// ... etc
</code></pre>
<p>Mas lembre-se de que os valores escalares Unicode vÃ¡lidos podem ser constituÃ­dos por
mais de um byte.</p>
<p>Obter clusters de grafemas de strings Ã© complexo, entÃ£o esta funcionalidade nÃ£o Ã©
fornecida pela biblioteca padrÃ£o. Existem crates disponÃ­veis em crates.io se
Esta Ã© a funcionalidade que vocÃª precisa.</p>
<a class="header" href="print.html#as-strings-nÃ£o-sÃ£o-tÃ£o-simples" id="as-strings-nÃ£o-sÃ£o-tÃ£o-simples"><h3>As Strings NÃ£o sÃ£o tÃ£o Simples</h3></a>
<p>Para resumir, as strings sÃ£o complicadas. Diferentes linguagens de programaÃ§Ã£o fazem
escolhas diferentes sobre como apresentar essa complexidade ao programador. Rust
optou por fazer o tratamento correto dos dados <code>String</code> o comportamento padrÃ£o
para todos os programas Rust, o que significa que os programadores devem pensar mais
no gerenciamento de dados UTF-8 antecipadamente. Este tradeoff expÃµe mais da complexidade
de strings do que outras linguagens de programaÃ§Ã£o, mas isso irÃ¡ impedi-lo de
ter que lidar com erros envolvendo caracteres nÃ£o-ASCII mais tarde em seu
ciclo de desenvolvimento.</p>
<p>Vamos mudar para algo um pouco menos complexo: hash maps!</p>
<a class="header" href="print.html#hash-maps" id="hash-maps"><h2>Hash Maps</h2></a>
<p>A Ãºltima das nossas coleÃ§Ãµes comuns Ã© o <em>hash map</em>. O tipo <code>HashMap &lt;K, V&gt;</code>
armazena um mapeamento de chaves do tipo <code>K</code> para valores do tipo<code>V</code>. Ele faz isso atravÃ©s de um
<em>hashing function</em>, que determina como ele coloca essas chaves e valores em
memÃ³ria. Muitas linguagens de programaÃ§Ã£o diferentes suportam este tipo de
estrutura de dados, mas muitas vezes com um nome diferente: hash, map, object, hash table ou
associative array, apenas para citar alguns.</p>
<p>Os Hash maps sÃ£o Ãºteis para quando vocÃª deseja poder procurar dados sem uso de
Ã­ndice, como vocÃª pode com vetores, mas usando uma chave que pode ser de qualquer tipo. Por
exemplo, em um jogo, vocÃª poderia acompanhar a pontuaÃ§Ã£o de cada equipe em um hash map
onde cada chave Ã© o nome de uma equipe e os valores sÃ£o cada pontuaÃ§Ã£o da equipe. Dado um
nome da equipe, vocÃª pode recuperar sua pontuaÃ§Ã£o.</p>
<p>Examinaremos a API bÃ¡sica dos hash map neste capÃ­tulo, mas hÃ¡ muitos
mais coisas escondidas nas funÃ§Ãµes definidas no <code>HashMap</code> pela biblioteca
padrÃ£o. Como sempre, verifique a documentaÃ§Ã£o da biblioteca padrÃ£o para mais
informaÃ§Ã£o.</p>
<a class="header" href="print.html#criando-um-novo-hash-map" id="criando-um-novo-hash-map"><h3>Criando um novo Hash Map</h3></a>
<p>Podemos criar um <code>HashMap</code> vazio com <code>new</code>, e adicionar elementos com <code>insert</code>.
Aqui, estamos acompanhando as pontuaÃ§Ãµes de duas equipes cujos nomes sÃ£o Blue e
Yellow. A equipe blue comeÃ§arÃ¡ com 10 pontos e a equipe yellow comeÃ§a com
50:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);
#}</code></pre></pre>
<p>Observe que precisamos primeiro <code>use</code> o <code>HashMap</code> da parte de coleÃ§Ãµes da
biblioteca padrÃ£o. De nossas trÃªs coleÃ§Ãµes comuns, esta Ã© a de menor
frequencia de uso, por isso nÃ£o estÃ¡ inclusa nos recursos importados automaticamente no
prelÃºdio. Os Hash maps tambÃ©m tÃªm menos suporte da biblioteca padrÃ£o; nÃ£o hÃ¡
macro embutida para construÃ­-los, por exemplo.</p>
<p>Assim como os vetores, os mapas hash armazenam seus dados no heap. Este <code>HashMap</code> tem
chaves do tipo <code>String</code> e valores do tipo <code>i32</code>. Como vetores, os hash maps sÃ£o
homogÃªneos: todas as chaves devem ter o mesmo tipo e todos os valores
devem ter o mesmo tipo.</p>
<p>Outra maneira de construir um hash map Ã© usando o mÃ©todo <code>collect</code> em um
vetor de tuplas, onde cada tupla consiste de uma chave e seu valor. O
mÃ©todo <code>collect</code> reÃºne dados em vÃ¡rios tipos de coleÃ§Ã£o, incluindo
<code>HashMap</code>. Por exemplo, se tivÃ©ssemos os nomes das equipes e as pontuaÃ§Ãµes iniciais em dois
vetores separados, podemos usar o mÃ©todo <code>zip</code> para criar um vetor de tuplas
onde â€œBlueâ€ Ã© emparelhado com 10, e assim por diante. EntÃ£o podemos usar o mÃ©todo <code>collect</code>
para transformar esse vetor de tuplas em um <code>HashMap</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let teams  = vec![String::from(&quot;Blue&quot;), String::from(&quot;Yellow&quot;)];
let initial_scores = vec![10, 50];

let scores: HashMap&lt;_, _&gt; = teams.iter().zip(initial_scores.iter()).collect();
#}</code></pre></pre>
<p>A anotaÃ§Ã£o de tipo <code>HashMap &lt;_, _&gt;</code> Ã© necessÃ¡ria aqui porque Ã© possÃ­vel
<code>collect</code> em muitas estruturas de dados diferentes, e Rust nÃ£o sabe qual vocÃª
deseja, a menos que vocÃª especifique. Para os parÃ¢metros de tipo, para os tipos de chave e valor,
no entanto, usamos underscores e Rust pode inferir os tipos que o hash map
contÃ©m com base nos tipos de dados no vetor.</p>
<a class="header" href="print.html#hash-maps-e-ownership" id="hash-maps-e-ownership"><h3>Hash Maps e Ownership</h3></a>
<p>Para os tipos que implementam a <code>Copy</code> trait, como <code>i32</code>, os valores sÃ£o copiados
no hash map. Para valores owned como <code>String</code>, os valores serÃ£o movidos e
o hash map serÃ¡ o owner desses valores:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let field_name = String::from(&quot;Favorite color&quot;);
let field_value = String::from(&quot;Blue&quot;);

let mut map = HashMap::new();
map.insert(field_name, field_value);
// field_name e field_value sÃ£o invÃ¡lidos neste ponto
#}</code></pre></pre>
<p>NÃ£o poderÃ­amos usar as ligaÃ§Ãµes <code>field_name</code> e<code>field_value</code> depois
que foram transferidos para o hash map com a chamada para <code>insert</code>.</p>
<p>Se inserimos referÃªncias a valores no hash map, os prÃ³prios valores
nÃ£o serÃ£o movido para o hash map. Os valores que as referÃªncias apontam devem ser
vÃ¡lido pelo menos enquanto o hash map seja vÃ¡lido, no entanto. Falaremos mais
sobre esses problemas na seÃ§Ã£o Lifetimes do CapÃ­tulo 10.</p>
<a class="header" href="print.html#acessando-valores-em-um-hash-map" id="acessando-valores-em-um-hash-map"><h3>Acessando Valores em um Hash Map</h3></a>
<p>Podemos obter um valor do hash map fornecendo a chave para o mÃ©todo <code>get</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);

let team_name = String::from(&quot;Blue&quot;);
let score = scores.get(&amp;team_name);
#}</code></pre></pre>
<p>Aqui, <code>score</code> terÃ¡ o valor que estÃ¡ associado Ã  equipe Blue, e o
resultado serÃ¡ <code>Some(&amp;10)</code>. O resultado estÃ¡ envolvido em <code>Some</code> porque <code>get</code>
retorna <code>Option&lt;&amp;V&gt;</code>; se nÃ£o houver valor para essa chave no hash map, <code>get</code>
retornarÃ¡ <code>None</code>. O programa precisarÃ¡ lidar com <code>Option</code> em uma das
formas que abordamos no CapÃ­tulo 6.</p>
<p>Podemos iterar sobre cada par chave/valor em um hash map de uma maneira similar Ã  que
fazemos com vetores, usando um loop <code>for</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);

for (key, value) in &amp;scores {
    println!(&quot;{}: {}&quot;, key, value);
}
#}</code></pre></pre>
<p>Isso imprimirÃ¡ cada par, em uma ordem arbitrÃ¡ria:</p>
<pre><code class="language-text">Yellow: 50
Blue: 10
</code></pre>
<a class="header" href="print.html#atualizando-um-hash-map" id="atualizando-um-hash-map"><h3>Atualizando um Hash Map</h3></a>
<p>Embora o nÃºmero de chaves e valores sejam crescentes, cada chave individual pode apenas
tem um valor associado a ele por vez. Quando queremos mudar os dados em
um hash map, temos que decidir como lidar com o caso quando uma chave jÃ¡ possui uma
valor atribuÃ­do. PoderÃ­amos optar por substituir o valor antigo pelo novo valor,
desconsiderando completamente o valor antigo. PoderÃ­amos escolher manter o valor antigo
e ignorar o novo valor, e apenas adicione o novo valor se a chave ainda <em>nÃ£o</em>
tem um valor. Ou podemos combinar o valor antigo ao valor novo.
Vejamos como fazer cada um desses!</p>
<a class="header" href="print.html#sobrescrevendo-um-valor" id="sobrescrevendo-um-valor"><h4>Sobrescrevendo um Valor</h4></a>
<p>Se inserimos uma chave e um valor em um hash map, entÃ£o  se inserir essa mesma chave com
um valor diferente, o valor associado a essa chave serÃ¡ substituÃ­do. Eembora
o seguinte cÃ³digo chame <code>insert</code> duas vezes, o hash map sÃ³ conterÃ¡
um par de chave/valor porque inserimos o valor da chave da equipe Blue
ambas as vezes:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Blue&quot;), 25);

println!(&quot;{:?}&quot;, scores);
#}</code></pre></pre>
<p>Isso imprimirÃ¡ <code>{&quot;Blue&quot;: 25}</code>. O valor original de 10 foi substituÃ­do.</p>
<a class="header" href="print.html#insira-apenas-se-a-chave-nÃ£o-possui-valor" id="insira-apenas-se-a-chave-nÃ£o-possui-valor"><h4>Insira Apenas se a Chave NÃ£o Possui Valor</h4></a>
<p>Ã‰ comum querer verificar se uma determinada chave tem um valor e, se
nÃ£o tiver, inserir um valor para ela. Os Hash maps possuem uma API especial para isso, chamada
<code>entry</code>, que leva a chave que queremos verificar como um argumento. O valor de retorno
da funÃ§Ã£o <code>entry</code> Ã© um enum, <code>Entry</code>, que representa um valor que pode
ou nÃ£o existir. Digamos que queremos verificar se a chave para o time Yellow
tem um valor associado a ela. Se nÃ£o tiver, queremos inserir o valor
50, e o mesmo para a equipe Blue. Com a API de entrada, o cÃ³digo irÃ¡ parecer
com:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from(&quot;Blue&quot;), 10);

scores.entry(String::from(&quot;Yellow&quot;)).or_insert(50);
scores.entry(String::from(&quot;Blue&quot;)).or_insert(50);

println!(&quot;{:?}&quot;, scores);
#}</code></pre></pre>
<p>O mÃ©todo <code>or_insert</code> em <code>Entry</code> retorna o valor para o <code>Entry</code> correspondente
se a chave existir, e se nÃ£o, insere seu argumento como o novo valor para
esta chave e retorna a <code>Entry</code> modificada. Isso Ã© muito mais limpo do que escrever
a lÃ³gica por nÃ³s mesmos e, alÃ©m disso, trabalha-se de forma mais limpa com o borrow checker.</p>
<p>Este cÃ³digo imprimirÃ¡ <code>{&quot;Yellow&quot;: 50, &quot;Blue&quot;: 10}</code>. A primeira chamada para <code>entry</code>
irÃ¡ inserir a chave para a equipe Yellow com o valor 50, uma vez que o time Yellow
jÃ¡ nÃ£o possua um valor. A segunda chamada para <code>entry</code> nÃ£o vai mudar
o hash map pois o time Blue jÃ¡ possui o valor 10.</p>
<a class="header" href="print.html#atualize-um-valor-com-base-no-valor-antigo" id="atualize-um-valor-com-base-no-valor-antigo"><h4>Atualize um Valor com Base no Valor Antigo</h4></a>
<p>Outro caso de uso comum para hash maps Ã© procurar o valor de uma chave e, em seguida, atualiza-la
, com base no valor antigo. Por exemplo, se quisermos contar quantas vezes
cada palavra apareceu em algum texto, podemos usar um hash map com as palavras como chaves
e incrementar o valor para acompanhar quantas vezes vimos essa palavra.
Se esta Ã© a primeira vez que vimos uma palavra, primeiro inseriremos o valor <code>0</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let text = &quot;hello world wonderful world&quot;;

let mut map = HashMap::new();

for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    *count += 1;
}

println!(&quot;{:?}&quot;, map);
#}</code></pre></pre>
<p>Isso imprimirÃ¡ <code>{&quot;world&quot;: 2, &quot;hello&quot;: 1, &quot;wonderful&quot;: 1}</code>. O mÃ©todo <code>or_insert</code>
na verdade retorna uma referÃªncia mutÃ¡vel (<code>&amp; mutV</code>) para o valor desta
chave. Aqui nÃ³s armazenamos essa referÃªncia mutÃ¡vel na variÃ¡vel <code>count</code>, entÃ£o,
para poder atribuir esse valor, devemos primeiro desreferenciar <code>count</code> usando o asterisco
(<code>*</code>). A referÃªncia mutÃ¡vel fica fora do escopo no final do loop <code>for</code>, entÃ£o
todas essas mudanÃ§as sÃ£o seguras e permitidas pelas regras de borrow.</p>
<a class="header" href="print.html#funÃ§Ãµes-hashing" id="funÃ§Ãµes-hashing"><h3>FunÃ§Ãµes Hashing</h3></a>
<p>Por padrÃ£o, <code>HashMap</code> usa uma funÃ§Ã£o de hashing criptogrÃ¡ficamente segura que pode
fornecer resistÃªncia aos ataques de NegaÃ§Ã£o de ServiÃ§o (DoS). Este nÃ£o Ã© o algoritmo
mais rÃ¡pido de hashing por aÃ­, mas a compensaÃ§Ã£o por uma melhor seguranÃ§a que vem
com a queda na performance vale a pena. Se vocÃª testar a velocidade do seu cÃ³digo e encontrar
que a funÃ§Ã£o de hash padrÃ£o Ã© muito lenta para seus propÃ³sitos, vocÃª pode mudar para
outra funÃ§Ã£o especificando um <em>hasher</em> diferente. Um hasher Ã© um tipo que
implementa a trait <code>BuildHasher</code>. Vamos falar sobre traits e como
implementÃ¡-los no CapÃ­tulo 10. VocÃª nÃ£o precisa necessariamente implementar o seu prÃ³prio
hasher do zero; crates.io tem bibliotecas de hashers de uso comum que
outras pessoas compartilharam lÃ¡.</p>
<a class="header" href="print.html#sumÃ¡rio" id="sumÃ¡rio"><h2>SumÃ¡rio</h2></a>
<p>Vetores, strings e hash maps irÃ£o levÃ¡-lo longe em programas onde vocÃª precisa
armazenar, acessar e modificar dados. Aqui estÃ£o alguns exercÃ­cios que vocÃª deve estar
capacitado para resolver:</p>
<ul>
<li>Dada uma lista de inteiros, use um vetor e retorne a mÃ©dia, a mediana
Â Â  (quando classificado, o valor na posiÃ§Ã£o do meio) e modo (o valor que
Â Â  ocorre com mais frequÃªncia; um hash map serÃ¡ Ãºtil aqui) da lista.</li>
<li>Converta strings para Pig Latin, onde a primeira consoante de cada palavra Ã© movida
Â Â  para o final da palavra adicionado um &quot;ay&quot; , entÃ£o â€œfirstâ€ se torna â€œirst-fayâ€.
Â Â  Palavras que comeÃ§am com uma vogal recebem â€œhayâ€ adicionado ao final (â€œappleâ€
Â Â  torna-se â€œapple-hayâ€). Lembre-se sobre a codificaÃ§Ã£o UTF-8!</li>
<li>Usando um hash map e vetores, crie uma interface de texto para permitir que um usuÃ¡rio adicione
Â Â  nomes de funcionÃ¡rios para um departamento da empresa. Por exemplo, â€œAdd Sally to
Engineeringâ€ ou â€œAdd Amir to Salesâ€. Em seguida, deixe o usuÃ¡rio recuperar uma lista de todas
Â Â  as pessoas de um departamento ou todas as pessoas na empresa por departamento, ordenadas
Â Â  alfabeticamente.</li>
</ul>
<p>A documentaÃ§Ã£o da API da biblioteca padrÃ£o descreve mÃ©todos que esses tipos possuem
que serÃ¡ Ãºtil para esses exercÃ­cios!</p>
<p>Estamos entrando em programas mais complexos onde as operaÃ§Ãµes podem falhar, o que significa
que Ã© um momento perfeito para passar pelo tratamento de erros em seguida!</p>
<a class="header" href="print.html#tratamento-de-erros" id="tratamento-de-erros"><h1>Tratamento de Erros</h1></a>
<p>O comprometimento de Rust Ã  seguranÃ§a se extende ao tratamento de erros. Erros
sÃ£o um fato da vida em software, portanto Rust possui um nÃºmero de <em>features</em>
para lidar com situaÃ§Ãµes em que algo dÃ¡ errado. Em vÃ¡rios casos, Rust requer que
vocÃª reconheÃ§a a possibilidade de um erro acontecer e aja preventivamente antes
que seu cÃ³digo compile. Esse requisito torna seu programa mais robusto ao assegurar
que voce irÃ¡ descobrir erros e lidar com eles apropriadamente antes de mandar seu
cÃ³digo para produÃ§Ã£o!</p>
<p>Rust agrupa erros em duas categorias principais: <em>recuperÃ¡veis</em> e <em>irrecuperÃ¡veis</em>.
Erros recuperÃ¡veis sÃ£o situaÃ§Ãµes em que Ã© razoÃ¡vel reportar o problema ao usuÃ¡rio
e tentar a operaÃ§Ã£o novamente, como um erro de arquivo nÃ£o encontrado. Erros
irrecuperÃ¡veis sÃ£o sempre sintomas de bugs, como tentar acessar uma localizaÃ§Ã£o
alÃ©m do fim de um <em>array</em>.</p>
<p>A maioria das linguagens nÃ£o distingue esses dois tipos de erros e lida
com ambos da mesma maneira usando mecanismos como exceÃ§Ãµes. Rust nÃ£o tem
exceÃ§Ãµes. Em vez disso, ele tem o valor <code>Result&lt;T, E&gt;</code> para erros recuperÃ¡veis
e a macro <code>panic!</code> que para a execuÃ§Ã£o ao encontrar um erro irrecuperÃ¡vel. Esse
capÃ­tulo cobre primeiro como chamar <code>panic!</code> e depois fala sobre retornar valores
<code>Result&lt;T, E&gt;</code>. Adicionalmente, vamos explorar o que se levar em consideraÃ§Ã£o
para decidir entre tentar se recuperar de um erro ou parar execuÃ§Ã£o.</p>
<a class="header" href="print.html#erros-irrecuperÃ¡veis-com-panic" id="erros-irrecuperÃ¡veis-com-panic"><h2>Erros IrrecuperÃ¡veis com <code>panic!</code></h2></a>
<p>Ã€s vezes coisas ruins acontecem no seu cÃ³digo, e nÃ£o hÃ¡ nada que vocÃª possa fazer
sobre isso. Nesses casos, Rust tem a macro <code>panic!</code>. Quando ela Ã© executada, seu
programa vai imprimir uma mensagem de falha, resolver e limpar a pilha e entÃ£o
terminar. A situaÃ§Ã£o mais comum em que isso acontece Ã© quando algum tipo de bug
foi detectado, e nÃ£o Ã© claro para o programador como tratar esse erro.</p>
<blockquote>
<a class="header" href="print.html#resolver-a-pilha-ou-abortar-em-resposta-a-panic" id="resolver-a-pilha-ou-abortar-em-resposta-a-panic"><h3>Resolver a Pilha ou Abortar em Resposta a <code>panic!</code></h3></a>
<p>Por padrÃ£o, quando acontece um <code>panic!</code>, o programa comeÃ§a a <em>resolver</em> a pilha,
o que significa que Rust percorre a pilha e limpa os dados de cada funÃ§Ã£o que encontra.
Mas essa limpeza dÃ¡ bastante trabalho. A alternativa Ã© imediatamente <em>abortar</em>,
que termina o programa sem fazer a limpeza. A memÃ³ria que o programa estava usando vai entÃ£o
precisar ser limpada pelo sistema operacional. Se no seu projeto vocÃª precisa tornar
o binÃ¡rio final o menor possÃ­vel, vocÃª pode deixar de resolver e sim abortar no <em>panic</em>
adicionando <code>panic = 'abort'</code> Ã  seÃ§Ã£o apropriadada de <code>[profile]</code> no seu arquivo
<em>Cargo.toml</em>. Por exemplo, se vocÃª quiser abortar no <em>panic</em> no modo de <em>release</em>, adicione
isso:</p>
<pre><code class="language-toml">[profile.release]
panic = 'abort'
</code></pre>
</blockquote>
<p>Vamos tentar chamar <code>panic!</code> em um programa simples:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">fn main() {
    panic!(&quot;Quebra tudo&quot;);
}
</code></pre></pre>
<p>Quando vocÃª roda o programa, verÃ¡ algo como isso:</p>
<pre><code class="language-text">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.25 secs
     Running `target/debug/panic`
thread 'main' panicked at 'Quebra tudo', src/main.rs:2
note: Run with `RUST_BACKTRACE=1` for a backtrace.
error: Process didn't exit successfully: `target/debug/panic` (exit code: 101)
</code></pre>
<p>A chamada a <code>panic!</code> causa a mensagem de erro contida nas Ãºltimas trÃªs linhas.
A primeira linha mostra nossa mensagem de pÃ¢nico e a posiÃ§Ã£o no cÃ³digo fonte
em que ocorreu o pÃ¢nico: <em>src/main.rs:2</em> indica que Ã© a segunda linha do nosso
arquivo <em>src/main.rs</em>.</p>
<p>Nesse caso, a linha indicada Ã© parte do nosso cÃ³digo, e se formos Ã quela linha
veremos a chamada Ã  macro <code>panic!</code>. Em outros casos, a chamada a <code>panic!</code> pode
estar em cÃ³digo que nosso cÃ³digo chama. O nome do arquivo e nÃºmero de linha
reportado pela mensagem de erro serÃ¡ no cÃ³digo de outra pessoa quando a macro
<code>panic!</code> for chamada, nÃ£o a linha do nosso cÃ³digo que eventualmente levou a chamada
de <code>panic!</code>. Podemos usar o <em>backtrace</em> das funÃ§Ãµes de onde veio a chamada a <code>panic!</code>
para entender qual parte de nosso cÃ³digo estÃ¡ causando o problema. Vamos discutir
o que Ã© um <em>backtrace</em> em seguida.</p>
<a class="header" href="print.html#usando-um-backtrace-de-panic" id="usando-um-backtrace-de-panic"><h3>Usando um Backtrace de <code>panic!</code></h3></a>
<p>Vamos ver outro exemplo para ver o que acontece quando uma chamada <code>panic!</code> vem de uma
biblioteca por causa de um bug no nosso cÃ³digo em vez de nosso cÃ³digo chamar
a macro diretamente. A Listagem 9-1 tem cÃ³digo que tenta acessar um elemento em
um vetor por meio de um Ã­ndice:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">fn main() {
    let v = vec![1, 2, 3];

    v[99];
}
</code></pre></pre>
<p><span class="caption">Listagem 9-1: Tentativa de acessar um elemento alÃ©m do fim
de um vetor, que causarÃ¡ um <code>panic!</code></span></p>
<p>Aqui, estamos tentando acessar o centÃ©simo elemento (centÃ©simo pois o Ã­ndice
comeÃ§a em zero) de nosso vetor, mas ele sÃ³ tem trÃªs elementos. Nesse caso, Rust
entrarÃ¡ em pÃ¢nico. Supostamente <code>[]</code> devolve um elemento, mas se vocÃª passa um
Ã­ndice invÃ¡lido, nÃ£o hÃ¡ elemento que Rust possa retornar que fosse correto.</p>
<p>Outras linguagens, como C, vÃ£o tentar te dar exatamente o que vocÃª pediu nessa
situaÃ§Ã£o, mesmo que nÃ£o seja o que vocÃª quer: vocÃª vai receber o que quer que
esteja na localizaÃ§Ã£o na memÃ³ria que corresponderia Ã quele elemento no vetor,
mesmo que a memÃ³ria nÃ£o pertenÃ§a ao vetor. Isso se chama um <em>buffer overread</em> e
pode levar a vulnerabilidades de seguranÃ§a se um agressor for capaz de manipular
o Ã­ndice de forma a ler dados guardados depois do array aos quais ele nÃ£o deveria
ter acesso.</p>
<p>Para proteger seu programa desse tipo de vulnerabilidade, se vocÃª tentar ler
um elemento em um Ã­ndice que nÃ£o exista, Rust vai parar a execuÃ§Ã£o e se recusar
a continar. Vamos fazer isso e ver o que acontece:</p>
<pre><code class="language-text">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27 secs
     Running `target/debug/panic`
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is
100', /stable-dist-rustc/build/src/libcollections/vec.rs:1362
note: Run with `RUST_BACKTRACE=1` for a backtrace.
error: Process didn't exit successfully: `target/debug/panic` (exit code: 101)
</code></pre>
<p>Esse erro aponta para um arquivo que nÃ£o escrevemos, <em>libcollections/vec.rs</em>.
Essa Ã© a implementaÃ§Ã£o de <code>Vec&lt;T&gt;</code> na biblioteca padrÃ£o. O cÃ³digo que roda
quando usamos <code>[]</code> em nosso vetor <code>v</code> estÃ¡ em <em>libcollections/vec.rs</em>, e Ã© aÃ­
que o <code>panic!</code> estÃ¡ de fato acontecendo.</p>
<p>A prÃ³xima linha nos diz que podemos definir a variÃ¡vel de ambiente <code>RUST_BACKTRACE</code>
para ter um <em>backtrace</em> (rastro) do que aconteceu, exatamente, para causar o erro. Um
<em>backtrace</em> Ã© uma lista de todas as funÃ§Ãµes que foram chamadas para chegar a esse
ponto. <em>Backtraces</em> em Rust funcionam como em outras linguagens: a chave para ler
o <em>backtrace</em> Ã© comeÃ§ar do topo e ler atÃ© vocÃª ver os arquivos que vocÃª escreveu.
Esse Ã© o ponto em que o problema se originou. As linhas acima das que mencionam seu
cÃ³digo sÃ£o funÃ§Ãµes que vocÃª chamou; as linhas abaixo sÃ£o funÃ§Ãµes que chamaram seu
cÃ³digo. Essas linhas podem incluir cÃ³digo do nÃºcleo do Rust, cÃ³digo das bibliotecas
padrÃ£o, ou <em>crates</em> que vocÃª estÃ¡ usando. Vamos tentar ver um backtrace: a Listagem 9-2
mostra uma saÃ­da semelhante a o que vocÃª verÃ¡:</p>
<pre><code class="language-text">$ RUST_BACKTRACE=1 cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/panic`
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 100', /stable-dist-rustc/build/src/libcollections/vec.rs:1392
stack backtrace:
   1:     0x560ed90ec04c - std::sys::imp::backtrace::tracing::imp::write::hf33ae72d0baa11ed
                        at /stable-dist-rustc/build/src/libstd/sys/unix/backtrace/tracing/gcc_s.rs:42
   2:     0x560ed90ee03e - std::panicking::default_hook::{{closure}}::h59672b733cc6a455
                        at /stable-dist-rustc/build/src/libstd/panicking.rs:351
   3:     0x560ed90edc44 - std::panicking::default_hook::h1670459d2f3f8843
                        at /stable-dist-rustc/build/src/libstd/panicking.rs:367
   4:     0x560ed90ee41b - std::panicking::rust_panic_with_hook::hcf0ddb069e7abcd7
                        at /stable-dist-rustc/build/src/libstd/panicking.rs:555
   5:     0x560ed90ee2b4 - std::panicking::begin_panic::hd6eb68e27bdf6140
                        at /stable-dist-rustc/build/src/libstd/panicking.rs:517
   6:     0x560ed90ee1d9 - std::panicking::begin_panic_fmt::abcd5965948b877f8
                        at /stable-dist-rustc/build/src/libstd/panicking.rs:501
   7:     0x560ed90ee167 - rust_begin_unwind
                        at /stable-dist-rustc/build/src/libstd/panicking.rs:477
   8:     0x560ed911401d - core::panicking::panic_fmt::hc0f6d7b2c300cdd9
                        at /stable-dist-rustc/build/src/libcore/panicking.rs:69
   9:     0x560ed9113fc8 - core::panicking::panic_bounds_check::h02a4af86d01b3e96
                        at /stable-dist-rustc/build/src/libcore/panicking.rs:56
  10:     0x560ed90e71c5 - &lt;collections::vec::Vec&lt;T&gt; as core::ops::Index&lt;usize&gt;&gt;::index::h98abcd4e2a74c41
                        at /stable-dist-rustc/build/src/libcollections/vec.rs:1392
  11:     0x560ed90e727a - panic::main::h5d6b77c20526bc35
                        at /home/you/projects/panic/src/main.rs:4
  12:     0x560ed90f5d6a - __rust_maybe_catch_panic
                        at /stable-dist-rustc/build/src/libpanic_unwind/lib.rs:98
  13:     0x560ed90ee926 - std::rt::lang_start::hd7c880a37a646e81
                        at /stable-dist-rustc/build/src/libstd/panicking.rs:436
                        at /stable-dist-rustc/build/src/libstd/panic.rs:361
                        at /stable-dist-rustc/build/src/libstd/rt.rs:57
  14:     0x560ed90e7302 - main
  15:     0x7f0d53f16400 - __libc_start_main
  16:     0x560ed90e6659 - _start
  17:                0x0 - &lt;unknown&gt;

</code></pre>
<p><span class="caption">Listagem 9-2: O <em>backtrace</em> gerado por uma chamada
a <code>panic!</code> mostrado quando a variÃ¡vel de ambiente <code>RUST_BACKTRACE</code> estÃ¡ definida.</span></p>
<p>Isso Ã© bastante saÃ­da! A saÃ­da exata que vocÃª recebe pode ser diferente dependendo
do seu sistema operacional e versÃ£o de Rust. Para conseguir <em>backtraces</em> com essa
informaÃ§Ã£o, sÃ­mbolos de debug devem estar ativados. SÃ­mbolos de debug estÃ£o ativados
por padrÃ£o quando usamos cargo build ou cargo run sem a opÃ§Ã£o de --release,
como temos aqui.</p>
<p>Na saÃ­da da Listagem 9-2, a linha 11 do <em>backtrace</em> aponta para a linha no nosso
projeto que estÃ¡ causando o problema: <em>src/main.rs</em> na linha 4. Se nÃ£o
queremos que nosso programa entre em pÃ¢nico, a localizaÃ§Ã£o apontada pela primeira
linha mencionando um arquivo que escrevemos Ã© onde deverÃ­amos comeÃ§ar a investigar
para entender como chegamos nesse ponto com valores que causaram o pÃ¢nico. Na lista
9-1 onde nÃ³s deliberadamente escrevemos cÃ³digo que causaria pÃ¢nico para demonstrar
como usar <em>backtraces</em>, a forma de consertar o pÃ¢nico Ã© nÃ£o requisitar um elemento
no Ã­ndice 100 de um vetor que contÃ©m apenas trÃªs itens. Quando seu cÃ³digo entrar
em pÃ¢nico no futuro, vocÃª precisarÃ¡ descobrir quais aÃ§Ãµes o seu cÃ³digo estÃ¡ tomando,
e com quais valores, que estÃ£o causando o pÃ¢nico, e o que deveria ser feito em vez
disso.</p>
<p>Voltaremos ao <code>panic!</code> e veremos mais adiante no capÃ­tulo quando usÃ¡-lo, ou nÃ£o,
para lidar com erros. Em seguida, olharemos como se recuperar de um erro usando
<code>Result</code>.</p>
<a class="header" href="print.html#erros-recuperÃ¡veis-com-result" id="erros-recuperÃ¡veis-com-result"><h2>Erros recuperÃ¡veis com <code>Result</code></h2></a>
<p>A maior parte dos erros nÃ£o sÃ£o sÃ©rios o suficiente para precisar que o
programa pare totalmente. Ã€s vezes, quando uma funÃ§Ã£o falha, Ã© por uma
razÃ£o que nÃ³s podemos facilmente interpretar e responder. Por exemplo,
se tentamos abrir um arquivo e essa operaÃ§Ã£o falhar porque o arquivo nÃ£o
existe, nÃ³s podemos querer criar o arquivo em vez de terminar o processo.</p>
<p>Lembre-se do CapÃ­tulo 2, na seÃ§Ã£o â€œ<a href="ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-the-result-type">Tratando Potenciais Falhas com o Tipo Result</a></p>
<!-- ignore -->â€  que o enum `Result` Ã© definido como tendo duas variantes,
`Ok` e `Err`, como mostrado a seguir:
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
#}</code></pre></pre>
<p>O <code>T</code> e <code>E</code> sÃ£o parÃ¢metros de tipos genÃ©ricos: nÃ³s os discutiremos em mais
detalhe no CapÃ­tulo 10. O que vocÃª precisa saber agora Ã© que <code>T</code> representa
o tipo do valor que vai ser retornado dentro da variante <code>Ok</code> em caso de sucesso,
e <code>E</code> representa o tipo de erro que serÃ¡ retornado dentro da variante <code>Err</code>
em caso de falha. Por <code>Result</code> ter esses parÃ¢metros de tipo genÃ©ricos, nÃ³s
podemos usar o tipo <code>Result</code> e as funÃ§Ãµes que a biblioteca padrÃ£o definiu sobre
ele em diversas situaÃ§Ãµes em que o valor de sucesso e o valor de erro que
queremos retornar possam divergir.</p>
<p>Vamos chamar uma funÃ§Ã£o que retorna um valor <code>Result</code> porque a funÃ§Ã£o poderia
falhar: na Listagem 9-3 tentamos abrir um arquivo:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);
}
</code></pre></pre>
<p><span class="caption">Listagem 9-3: Abrindo um arquivo</span></p>
<p>Como sabemos que <code>File::open</code> retorna um <code>Result</code>? PoderÃ­amos olhar na documentaÃ§Ã£o
da API da biblioteca padrÃ£o, ou poderÃ­amos perguntar para o compilador! Se damos Ã  <code>f</code>
uma anotaÃ§Ã£o de tipo que sabemos <em>nÃ£o</em> ser o tipo retornado pela funÃ§Ã£o e tentamos
compilar o cÃ³digo, o compilador nos dirÃ¡ que os tipos nÃ£o casam. A mensagem de erro
vai entÃ£o nos dizer qual Ã©, <em>de fato</em>, o tipo de <code>f</code>. Vamos tentar isso: nÃ³s sabemos que
o tipo retornado por <code>File::open</code> nÃ£o Ã© <code>u32</code>, entÃ£o vamos mudar a declaraÃ§Ã£o
<code>let f</code> para isso:</p>
<pre><code class="language-rust ignore">let f: u32 = File::open(&quot;hello.txt&quot;);
</code></pre>
<p>Tentar compilar agora nos dÃ¡ a seguinte saÃ­da:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:4:18
  |
4 |     let f: u32 = File::open(&quot;hello.txt&quot;);
  |                  ^^^^^^^^^^^^^^^^^^^^^^^ expected u32, found enum
`std::result::Result`
  |
  = note: expected type `u32`
  = note:    found type `std::result::Result&lt;std::fs::File, std::io::Error&gt;`
</code></pre>
<p>Isso nos diz que o valor de retorno de <code>File::open</code> Ã© um <code>Result&lt;T, E&gt;</code>.
O parÃ¢metro genÃ©rico <code>T</code> foi preenchido aqui com o tipo do valor de sucesso,
<code>std::fs::File</code>, que Ã© um <em>handle</em> de arquivo. O tipo de <code>E</code> usado no valor
de erro Ã© <code>std::io::Error</code>.</p>
<p>Esse tipo de retorno significa que a chamada a <code>File::open</code> pode dar certo
e retornar para nÃ³s um <em>handle</em> de arquivo que podemos usar pra ler ou escrever
nele. Essa chamada de funÃ§Ã£o pode tambÃ©m falhar: por exemplo, o arquivo pode nÃ£o
existir ou talvez nÃ£o tenhamos permissÃ£o para acessar o arquivo. A funÃ§Ã£o <code>File::open</code>
precisa ter uma maneira de nos dizer se ela teve sucesso ou falhou e ao mesmo tempo
nos dar ou o <em>handle</em> de arquivo ou informaÃ§Ã£o sobre o erro. Essa informaÃ§Ã£o Ã©
exatamente o que o enum <code>Result</code> comunica.</p>
<p>No caso em que <code>File::open</code> tem sucesso, o valor na variÃ¡vel <code>f</code> serÃ¡ uma instÃ¢ncia
de <code>Ok</code> que contÃ©m um <em>handle</em> de arquivo. No caso em que ela falha, o valor em <code>f</code>
serÃ¡ uma instÃ¢ncia de <code>Err</code> que contÃ©m mais informaÃ§Ã£o sobre o tipo de erro que
aconteceu.</p>
<p>Devemos fazer com que o cÃ³digo na Listagem 9-3 faÃ§a diferentes aÃ§Ãµes dependendo
do valor retornado por <code>File::open</code>. A Listagem 9-4 mostra uma maneira de lidar
com o <code>Result</code> usando uma ferramenta bÃ¡sica: a expressÃ£o <code>match</code> que discutimos
no CapÃ­tulo 6.</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(error) =&gt; {
            panic!(&quot;Houve um problema ao abrir o arquivo: {:?}&quot;, error)
        },
    };
}
</code></pre></pre>
<p><span class="caption">Listagem 9-4: Usando uma expressÃ£o <code>match</code> para tratar as
variantes de <code>Result</code> que podemos encontrar.</span></p>
<p>Note que, como no enum <code>Option</code>, o enum <code>Result</code> e suas variantes foram importadas
no prelÃºdio, entÃ£o nÃ£o precisamos especificar <code>Result::</code> antes das variantes <code>Ok</code>
e <code>Err</code> nas linhas de <code>match</code>.</p>
<p>Aqui dizemos ao Rust que quando o resultado Ã© <code>Ok</code> ele deve retornar o valor
interno <code>file</code> de dentro da variante <code>Ok</code> e nÃ³s entÃ£o podemos atribuir este
valor de <em>handle</em> de arquivo Ã  variÃ¡vel <code>f</code>. Depois do <code>match</code>, nÃ³s podemos entÃ£o
usar o <em>handle</em> de arquivo para ler ou escrever.</p>
<p>A outra linha de <code>match</code> trata do caso em que recebemos um valor de <code>Err</code> de
<code>File::open</code>. Nesse exemplo, nÃ³s escolhemos chamar a macro <code>panic!</code>. Se nÃ£o
hÃ¡ nenhum arquivo chamado <em>hello.txt</em> no diretÃ³rio atual e rodarmos esse cÃ³digo,
veremos a seguinte saÃ­da da macro <code>panic!</code>:</p>
<pre><code class="language-text">thread 'main' panicked at 'Houve um problema ao abrir o arquivo: Error { repr:
Os { code: 2, message: &quot;No such file or directory&quot; } }', src/main.rs:9:12

</code></pre>
<p>Como sempre, essa saÃ­da nos diz exatamente o que aconteceu de errado.</p>
<a class="header" href="print.html#usando-match-com-diferentes-erros" id="usando-match-com-diferentes-erros"><h3>Usando <code>match</code> com Diferentes Erros</h3></a>
<p>O cÃ³digo na Listagem 9-4 chamarÃ¡ <code>panic!</code> nÃ£o importa a razÃ£o pra <code>File::open</code>
ter falhado. O que queremos fazer em vez disso Ã© tomar diferentes aÃ§Ãµes para diferentes
motivos de falha: se <code>File::open</code> falhou porque o arquivo nÃ£o existe, nÃ³s
queremos criar um arquivo e retornar o <em>handle</em> para ele. Se <code>File::open</code>
falhou por qualquer outra razÃ£o, por exemplo porque nÃ£o temos a permissÃ£o para
abrir o arquivo, nÃ³s ainda queremos chamar <code>panic!</code> da mesma maneira que fizemos
na Listagem 9-4. Veja a Listagem 9-5, que adiciona outra linha ao <code>match</code>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<!-- ignore this test because otherwise it creates hello.txt which causes other
tests to fail lol -->
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(ref error) if error.kind() == ErrorKind::NotFound =&gt; {
            match File::create(&quot;hello.txt&quot;) {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; {
                    panic!(
                        &quot;Tentou criar um arquivo e houve um problema: {:?}&quot;,
                        e
                    )
                },
            }
        },
        Err(error) =&gt; {
            panic!(
                &quot;Houve um problema ao abrir o arquivo: {:?}&quot;,
                error
            )
        },
    };
}
</code></pre>
<p><span class="caption">Listagem 9-5: Tratando diferentes tipos de erros de diversas
maneiras.</span></p>
<p>O tipo do valor que <code>File::open</code> retorna dentro da variante <code>Err</code> Ã© <code>io::Error</code>,
que Ã© uma struct fornecida pela biblioteca padrÃ£o. Essa struct tem o mÃ©todo
<code>kind</code> que podemos chamar para receber um valor de <code>io::ErrorKind</code>. <code>io::ErrorKind</code>
Ã© um enum fornecido pela biblioteca padrÃ£o que tem variantes representanto diversos
tipos de erros que podem ocorrer em uma operaÃ§Ã£o de <code>io</code>. A variante que queremos
usar Ã© <code>ErrorKind::NotFound</code>, que indica que o arquivo que queremos abrir nÃ£o existe
ainda.</p>
<p>A condiÃ§Ã£o <code>if error.kind() == ErrorKind::NotFound</code> Ã© chamada de um <em>match guard</em>:
Ã© uma condiÃ§Ã£o extra dentro de uma linha de <code>match</code> que posteriormente refina
o padrÃ£o da linha. Essa condiÃ§Ã£o deve ser verdadeira para o cÃ³digo da linha ser
executado; caso contrÃ¡rio a anÃ¡lise de padrÃµes vai continuar considerando as
prÃ³ximas linhas no <code>match</code>. O <code>ref</code> no padrÃ£o Ã© necessÃ¡rio para que o <code>error</code>
nÃ£o seja movido para a condiÃ§Ã£o do <em>guard</em>, mas meramente referenciado por ele.
A razÃ£o de <code>ref</code> ser utilizado em vez de <code>&amp;</code> para pegar uma referÃªncia vai ser
discutida em detalhe no CapÃ­tulo 18. Resumindo, no contexto de um padrÃ£o, <code>&amp;</code>
corresponde a uma referÃªncia e nos dÃ¡ seu valor, enquanto <code>ref</code> corresponde a um valor
e nos dÃ¡ uma referÃªncia a ele.</p>
<p>A condiÃ§Ã£o que queremos checar no <em>match guard</em> Ã© se o valor retornado pelo
<code>error.kind()</code> Ã© a variante <code>NotFound</code> do enum <code>ErrorKind</code>. Se Ã©, queremos
tentar criar um arquivo com <code>File::create</code>. No entanto, como <code>File::create</code>
pode tambÃ©m falhar, precisamos adicionar um <code>match</code> interno tambÃ©m. Quando
o arquivo nÃ£o pode ser aberto, outro tipo de mensagem de erro serÃ¡ mostrada.
A Ãºltima linha do <code>match</code> externo continua a mesma de forma que o programa
entre em pÃ¢nico pra qualquer erro alÃ©m do de arquivo ausente.</p>
<a class="header" href="print.html#atalhos-para-pÃ¢nico-em-erro-unwrap-e-expect" id="atalhos-para-pÃ¢nico-em-erro-unwrap-e-expect"><h3>Atalhos para PÃ¢nico em Erro: <code>unwrap</code> e <code>expect</code></h3></a>
<p>Usar <code>match</code> funciona bem o suficiente, mas pode ser um pouco verboso e nem
sempre comunica tÃ£o bem a intenÃ§Ã£o. O tipo <code>Result&lt;T, E&gt;</code> tem vÃ¡rios mÃ©todos
auxiliares definidos para fazer diversas tarefas. Um desses mÃ©todos, chamado
<code>unwrap</code>, Ã© um mÃ©todo de atalho que Ã© implementado justamente como o <code>match</code> que
escrevemos na Listagem 9-4. Se o valor de <code>Result</code> for da variante <code>Ok</code>, <code>unwrap</code>
vai retornar o valor dentro de <code>Ok</code>. Se o <code>Result</code> for da variante <code>Err</code>, <code>unwrap</code>
vai chamar a macro <code>panic!</code>. Aqui um exemplo de <code>unwrap</code> em aÃ§Ã£o:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).unwrap();
}
</code></pre></pre>
<p>Se rodarmos esse cÃ³digo sem um arquivo <em>hello.txt</em>, veremos uma mensagem de erro
da chamada de <code>panic!</code> que o mÃ©todo <code>unwrap</code> faz:</p>
<pre><code class="language-text">thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Error {
repr: Os { code: 2, message: &quot;No such file or directory&quot; } }',
/stable-dist-rustc/build/src/libcore/result.rs:868
</code></pre>
<p>Outro mÃ©todo, <code>expect</code>, que Ã© semelhante a <code>unwrap</code>, nos deixa tambÃ©m escolher
a mensagem de erro do <code>panic!</code>. Usar <code>expect</code> em vez de <code>unwrap</code> e fornecer
boas mensagens de erros podem transmitir sua intenÃ§Ã£o e tornar a procura pela
fonte de pÃ¢nico mais fÃ¡cil. A sintaxe de <code>expect</code> Ã© a seguinte:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).expect(&quot;Falhou ao abrir hello.txt&quot;);
}
</code></pre></pre>
<p>NÃ³s usamos <code>expect</code> da mesma maneira que <code>unwrap</code>: para retornar o <em>handle</em> de arquivo
ou chamar a macro de <code>panic!</code>. A mensagem de erro usada por <code>expect</code> na sua chamada
de <code>panic!</code> serÃ¡ o parÃ¢mtero que passamos para <code>expect</code> em vez da mensagem padrÃ£o
que o <code>unwrap</code> usa. Aqui estÃ¡ como ela aparece:</p>
<pre><code class="language-text">thread 'main' panicked at 'Falhou ao abrir hello.txt: Error { repr: Os { code:
2, message: &quot;No such file or directory&quot; } }',
/stable-dist-rustc/build/src/libcore/result.rs:868
</code></pre>
<p>Como essa mensagem de erro comeÃ§a com o texto que especificamos, <code>Falhou ao abrir hello.txt</code>, serÃ¡ mais fÃ¡cil encontrar o trecho do cÃ³digo de onde vem essa mensagem de erro. Se usamos <code>unwrap</code> em diversos lugares, pode tomar mais tempo encontrar
exatamente qual dos <code>unwrap</code> estÃ¡ causando o pÃ¢nico, dado que todas as chamadas
a <code>unwrap</code> chamam o print de pÃ¢nico com a mesma mensagem.</p>
<a class="header" href="print.html#propagando-erros" id="propagando-erros"><h3>Propagando Erros</h3></a>
<p>Quando vocÃª estÃ¡ escrevendo uma funÃ§Ã£o cuja implementaÃ§Ã£o chama algo que pode
falhar, em vez de tratar o erro dentro dessa funÃ§Ã£o, vocÃª pode retornar o
erro ao cÃ³digo que a chamou de forma que ele possa decidir o que fazer. Isso Ã©
conhecido como <em>propagar</em> o erro e dÃ¡ mais controle ao cÃ³digo que chamou sua
funÃ§Ã£o, onde talvez haja mais informaÃ§Ã£o sobre como tratar o erro
do que vocÃª tem disponÃ­vel no contexto do seu cÃ³digo.</p>
<p>Por exemplo, a Listagem 9-6 mostra uma funÃ§Ã£o que lÃª um nome de usuÃ¡rio de um arquivo.
Se o arquivo nÃ£o existe ou nÃ£o pode ser lido, essa funÃ§Ã£o vai retornar esses erros
ao cÃ³digo que chamou essa funÃ§Ã£o:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let f = File::open(&quot;hello.txt&quot;);

    let mut f = match f {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut s = String::new();

    match f.read_to_string(&amp;mut s) {
        Ok(_) =&gt; Ok(s),
        Err(e) =&gt; Err(e),
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 9-6: Uma funÃ§Ã£o que retorna erros ao cÃ³digo que a chamou
usando <code>match</code></span></p>
<p>Vamos olhar primeiro ao tipo retornado pela funÃ§Ã£o: <code>Result&lt;String, io::Error&gt;</code>.
Isso significa que a funÃ§Ã£o estÃ¡ retornando um valor do tipo <code>Result&lt;T, E&gt;</code> onde
o parÃ¢metro genÃ©rico <code>T</code> foi preenchido pelo tipo concreto <code>String</code> e o tipo genÃ©rico
<code>E</code> foi preenchido pelo tipo concreto <code>io::Error</code>. Se essa funÃ§Ã£o tem sucesso sem
nenhum problema, o cÃ³digo que chama essa funÃ§Ã£o vai receber um valor <code>Ok</code> que contÃ©m
uma <code>String</code>- o nome de usuÃ¡rio que essa funÃ§Ã£o leu do arquivo. Se essa funÃ§Ã£o
encontra qualquer problema, o cÃ³digo que a chama receberÃ¡ um valor de <code>Err</code>
que contÃ©m uma instÃ¢ncia de <code>io::Error</code>, que contÃ©m mais informaÃ§Ã£o
sobre o que foi o problema. Escolhemos <code>io::Error</code> como o tipo de retorno
dessa funÃ§Ã£o porque Ã© este o tipo de erro retornado pelas
duas operaÃ§Ãµes que estamos chamando no corpo dessa funÃ§Ã£o que podem falhar:
a funÃ§Ã£o <code>File::open</code> e o mÃ©todo <code>read_to_string</code>.</p>
<p>O corpo da funÃ§Ã£o comeÃ§a chamando a funÃ§Ã£o <code>File::open</code>. NÃ³s entÃ£o tratamos
o valor de <code>Result</code> retornado usando um <code>match</code> semelhante ao da Listagem 9-4,
sÃ³ que em vez de chamar <code>panic!</code> no caso de <code>Err</code>, retornamos mais cedo dessa funÃ§Ã£o
e passamos o valor de erro de <code>File::open</code> de volta ao cÃ³digo que a chamou, como o
valor de erro da nossa funÃ§Ã£o. Se <code>File::open</code> tem sucesso, nÃ³s guardamos o <em>handle</em> de
arquivo na variÃ¡vel <code>f</code> e continuamos.</p>
<p>EntÃ£o, criamos uma nova <code>String</code> na variÃ¡vel <code>s</code> e chamamos o mÃ©todo <code>read_to_string</code>
no <em>handle</em> de arquivo <code>f</code> para ler o conteÃºdo do arquivo e armazenÃ¡-lo em <code>s</code>. O mÃ©todo
<code>read_to_string</code> tambÃ©m retorna um <code>Result</code> porque ele pode falhar, mesmo que
<code>File::open</code> teve sucesso. EntÃ£o precisamos de outro <code>match</code> para tratar esse
<code>Result</code>: se <code>read_to_string</code> teve sucesso, entÃ£o nossa funÃ§Ã£o teve sucesso, e nÃ³s
retornamos o nome de usuÃ¡rio lido do arquivo que estÃ¡ agora em <code>s</code>, encapsulado em um <code>Ok</code>.
Se <code>read_to_string</code> falhou, retornamos o valor de erro da mesma maneira que retornamos
o valor de erro no <code>match</code> que tratou o valor de retorno de <code>File::open</code>.
No entanto, nÃ£o precisamos explicitamente escrever <code>return</code>, porque essa jÃ¡ Ã© a
Ãºltima expressÃ£o na funÃ§Ã£o.</p>
<p>O cÃ³digo que chama nossa funÃ§Ã£o vai entÃ£o receber ou um valor <code>Ok</code> que
contÃ©m um nome de usuÃ¡rio ou um valor de <code>Err</code> que contÃ©m um <code>io::Error</code>. NÃ³s
nÃ£o sabemos o que o cÃ³digo que chamou nossa funÃ§Ã£o farÃ¡ com esses valores. Se o
cÃ³digo que chamou recebe um valor de <code>Err</code>, ele poderia chamar <code>panic!</code> e causar
um crash, usar um nome de usuÃ¡rio padrÃ£o, ou procurar o nome de usuÃ¡rio em outro
lugar que nÃ£o um arquivo, por exemplo. NÃ³s nÃ£o temos informaÃ§Ã£o o suficiente sobre
o que o cÃ³digo que chamou estÃ¡ de fato tentando fazer, entÃ£o propagamos toda a
informaÃ§Ã£o de sucesso ou erro para cima para que ele a trate apropriadamente.</p>
<p>Esse padrÃ£o de propagaÃ§Ã£o de erros Ã© tÃ£o comum em Rust que a linguagem disponibiliza
o operador de interrogaÃ§Ã£o <code>?</code> para tornar isso mais fÃ¡cil.</p>
<a class="header" href="print.html#um-atalho-para-propagar-erros-" id="um-atalho-para-propagar-erros-"><h4>Um Atalho Para Propagar Erros: <code>?</code></h4></a>
<p>A Listagem 9-7 mostra uma implementaÃ§Ã£o de <code>read_username_from_file</code> que tem a
mesma funcionalidade que tinha na Listagem 9-6, mas esta implementaÃ§Ã£o usa o operador
de interrogaÃ§Ã£o:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut f = File::open(&quot;hello.txt&quot;)?;
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?;
    Ok(s)
}
#}</code></pre></pre>
<p><span class="caption">Listagem 9-7: Uma funÃ§Ã£o que retorna erros para o cÃ³digo
que a chamou usando <code>?</code>.</span></p>
<p>O <code>?</code> colocado apÃ³s um valor de <code>Result</code> Ã© definido para funcionar quase
da mesma maneira que as expressÃµes <code>match</code> que definimos para tratar o valor
de <code>Result</code> na Listagem 9-6. Se o valor de <code>Result</code> Ã© um <code>Ok</code>, o valor dentro dele
vai ser retornado dessa expressÃ£o e o programa vai continuar. Se o valor
Ã© um <code>Err</code>, o valor dentro dele vai ser retornado da funÃ§Ã£o inteira como se
tivÃ©ssemos usado a palavra-chave <code>return</code> de modo que o valor de erro Ã© propagado
ao cÃ³digo que chamou a funÃ§Ã£o.</p>
<p>A Ãºnica diferenÃ§a entre a expressÃ£o <code>match</code> da Listagem 9-6 e o que o operador
de interrogaÃ§Ã£o faz Ã© que quando usamos o operador de interrogaÃ§Ã£o, os valores
de erro passam pela funÃ§Ã£o <code>from</code> definida no <em>trait</em> <code>From</code> na biblioteca
padrÃ£o. VÃ¡rios tipos de erro implementam a funÃ§Ã£o <code>from</code> para converter um
erro de um tipo em outro. Quando usado pelo operador de
interrogaÃ§Ã£o, a chamada Ã  funÃ§Ã£o <code>from</code> converte o tipo de erro que o
operador recebe no tipo de erro definido no tipo de retorno da funÃ§Ã£o em
que estamos usando <code>?</code>. Isso Ã© Ãºtil quando partes de uma funÃ§Ã£o podem falhar
por vÃ¡rias razÃµes diferentes, mas a funÃ§Ã£o retorna um tipo de erro que
representa todas as maneiras que a funÃ§Ã£o pode falhar. Enquanto cada
tipo de erro implementar a funÃ§Ã£o <code>from</code> para definir como se converter
ao tipo de erro retornado, o operador de interrogaÃ§Ã£o lida com a conversÃ£o
automaticamente.</p>
<p>No contexto da Listagem 9-7, o <code>?</code> no final da chamada de <code>File::open</code> vai
retornar o valor dentro do <code>Ok</code> Ã  variÃ¡vel <code>f</code>. Se um erro ocorrer, <code>?</code>
vai retornar mais cedo a funÃ§Ã£o inteira e dar um valor de <code>Err</code> ao cÃ³digo
que a chamou. O mesmo se aplica ao <code>?</code> ao final da chamada de <code>read_to_string</code>.</p>
<p>O <code>?</code> elimina um monte de excesso e torna a implementaÃ§Ã£o dessa
funÃ§Ã£o mais simples. PoderÃ­amos atÃ© encurtar ainda mais esse cÃ³digo
ao encadear chamadas de mÃ©todo imediatamente depois do <code>?</code>, como mostrado
na Listagem 9-8:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut s = String::new();

    File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut s)?;

    Ok(s)
}
#}</code></pre></pre>
<p><span class="caption">Listagem 9-8: Encadeando chamadas de mÃ©todo apÃ³s o operador
de interrogaÃ§Ã£o.</span></p>
<p>NÃ³s movemos a criaÃ§Ã£o da nova <code>String</code> em <code>s</code> para o comeÃ§o da funÃ§Ã£o;
essa parte nÃ£o mudou. Em vez de criar uma variÃ¡vel <code>f</code>, nÃ³s encadeamos
a chamada para <code>read_to_string</code> diretamente ao resultado de
<code>File::open(&quot;hello.txt&quot;)?</code>. NÃ³s ainda temos um <code>?</code> ao fim da chamada a
<code>read_to_string</code>, e ainda retornamos um valor de <code>Ok</code> contendo o nome de usuÃ¡rio
em <code>s</code> quando ambos os mÃ©todos <code>File::open</code> e <code>read_to_string</code> tiveram sucesso ao invÃ©s
de retornarem erros. Essa funcionalidade Ã© novamente a mesma da Listagem 9-6 e
Listagem 9-7; essa Ã© sÃ³ uma maneira diferente e mais ergonÃ´mica de escrevÃª-la.</p>
<a class="header" href="print.html#-somente-pode-ser-usado-em-funÃ§Ãµes-que-retornam-result" id="-somente-pode-ser-usado-em-funÃ§Ãµes-que-retornam-result"><h4><code>?</code> Somente Pode Ser Usado em FunÃ§Ãµes Que Retornam Result</h4></a>
<p>O <code>?</code> sÃ³ pode ser usado em funÃ§Ãµes que tem um tipo de retorno de <code>Result</code>,
porque estÃ¡ definido a funcionar da mesma maneira que a expressÃ£o <code>match</code> que
definimos na Listagem 9-6. A parte do <code>match</code> que requer um tipo de retorno de
<code>Result</code> Ã© <code>return Err(e)</code>, entÃ£o o tipo de retorno da funÃ§Ã£o deve ser
um <code>Result</code> para ser compatÃ­vel com esse <code>return</code>.</p>
<p>Vamos ver o que ocorre quando usamos <code>?</code> na funÃ§Ã£o <code>main</code>, que como vimos, tem
um tipo de retorno de <code>()</code>:</p>
<pre><code class="language-rust ignore">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;)?;
}
</code></pre>
<p>Quando compilamos esse cÃ³digo recebemos a seguinte mensagem de erro:</p>
<pre><code class="language-text">error[E0277]: the `?` operator can only be used in a function that returns
`Result` (or another type that implements `std::ops::Try`)
 --&gt; src/main.rs:4:13
  |
4 |     let f = File::open(&quot;hello.txt&quot;)?;
  |             ------------------------
  |             |
  |             cannot use the `?` operator in a function that returns `()`
  |             in this macro invocation
  |
  = help: the trait `std::ops::Try` is not implemented for `()`
  = note: required by `std::ops::Try::from_error`
</code></pre>
<p>Esse erro aponta que sÃ³ podemos usar o operador de interrogaÃ§Ã£o em funÃ§Ãµes
que retornam <code>Result</code>. Em funÃ§Ãµes que nÃ£o retornam <code>Result</code>, quando vocÃª chama
outras funÃ§Ãµes que retornam <code>Result</code>, vocÃª deve usar um <code>match</code> ou um dos mÃ©todos
de <code>Result</code> para tratÃ¡-lo em vez de usar <code>?</code> para potencialmente
propagar o erro ao cÃ³digo que a chamou.</p>
<p>Agora que discutimos os detalhes de chamar <code>panic!</code> ou retornar <code>Result</code>, vamos
retornar ao tÃ³pico de como decidir qual Ã© apropriado para utilizar em quais
casos.</p>
<a class="header" href="print.html#entrar-em-panic-ou-nÃ£o-entrar-em-panic" id="entrar-em-panic-ou-nÃ£o-entrar-em-panic"><h2>Entrar em <code>panic!</code> ou NÃ£o Entrar em <code>panic!</code></h2></a>
<p>EntÃ£o como vocÃª decide quando entrar em <code>panic!</code> e quando vocÃª deveria retornar
um <code>Result</code>? Quando o cÃ³digo entra em pÃ¢nico, nÃ£o hÃ¡ maneira de se recuperar. VocÃª
poderia chamar <code>panic!</code> para qualquer situaÃ§Ã£o de erro, tendo uma maneira de se recuperar
ou nÃ£o, mas entÃ£o vocÃª estaria decidindo no lugar do cÃ³digo que chama seu cÃ³digo
que a situaÃ§Ã£o Ã© irrecuperÃ¡vel. Quando vocÃª decide retornar um valor de <code>Result</code>,
vocÃª lhe dÃ¡ opÃ§Ãµes em vez de tomar a decisÃ£o por ele. O cÃ³digo
que chama seu cÃ³digo pode tentar se recuperar de uma maneira que Ã© apropriada para
a situaÃ§Ã£o, ou ele pode decidir que um valor de <code>Err</code> nesse caso Ã© irrecuperÃ¡vel,
chamando <code>panic!</code> e transformando seu erro recuperÃ¡vel em um irrecuperÃ¡vel.
Portanto, retornar <code>Result</code> Ã© uma boa escolha padrÃ£o quando vocÃª estÃ¡ definindo
uma funÃ§Ã£o que pode falhar.</p>
<p>Em algumas situaÃ§Ãµes Ã© mais apropriado escrever cÃ³digo que entra em pÃ¢nico em vez
de retornar um <code>Result</code>, mas eles sÃ£o menos comuns. Vamos explorar porque Ã© apropriado
entrar em pÃ¢nico em alguns exemplos, protÃ³tipos de cÃ³digo e testes; depois situaÃ§Ãµes
em que vocÃª como humano pode saber que um mÃ©todo nÃ£o vai falhar, mas que o compilador nÃ£o
tem como saber; e concluir com algumas diretrizes sobre como decidir entrar ou
nÃ£o em pÃ¢nico em cÃ³digo de biblioteca.</p>
<a class="header" href="print.html#exemplos-protÃ³tipos-e-testes-sÃ£o-todos-lugares-em-que-Ã‰-perfeitamente-ok-entrar-em-pÃ¢nico" id="exemplos-protÃ³tipos-e-testes-sÃ£o-todos-lugares-em-que-Ã‰-perfeitamente-ok-entrar-em-pÃ¢nico"><h3>Exemplos, ProtÃ³tipos, e Testes SÃ£o Todos Lugares em que Ã‰ Perfeitamente Ok Entrar em PÃ¢nico</h3></a>
<p>Quando vocÃª estÃ¡ escrevendo um exemplo para ilustrar algum conceito, ter cÃ³digo
de tratamento de erro robusto junto do exemplo pode tornÃ¡-lo menos claro. Em exemplos,
Ã© compreensÃ­vel que uma chamada a um mÃ©todo como <code>unwrap</code> que poderia chamar <code>panic!</code>
apenas substitua a maneira como vocÃª trataria erros na sua aplicaÃ§Ã£o,
que pode ser diferente baseado no que o resto do seu cÃ³digo estÃ¡ fazendo.</p>
<p>De forma semelhante, os mÃ©todos <code>unwrap</code> e <code>expect</code> sÃ£o bem Ãºteis ao fazer
protÃ³tipos, antes de vocÃª estar pronto para decidir como tratar erros. Eles deixam
marcadores claros no seu cÃ³digo para quando vocÃª estiver pronto para tornar
seu programa mais robusto.</p>
<p>Se uma chamada de mÃ©todo falha em um teste, queremos que o teste inteiro falhe,
mesmo se esse mÃ©todo nÃ£o Ã© a funcionalidade sendo testada. Como <code>panic!</code> Ã© o modo
que um teste Ã© marcado como falha, chamar <code>unwrap</code> ou <code>expect</code> Ã© exatamente o que
deveria acontecer.</p>
<a class="header" href="print.html#casos-em-que-vocÃª-tem-mais-informaÃ§Ã£o-que-o-compilador" id="casos-em-que-vocÃª-tem-mais-informaÃ§Ã£o-que-o-compilador"><h3>Casos em que VocÃª Tem Mais InformaÃ§Ã£o Que o Compilador</h3></a>
<p>Seria tambÃ©m apropriado chamar <code>unwrap</code> quando vocÃª tem outra lÃ³gica que
assegura que o <code>Result</code> vai ter um valor <code>Ok</code>, mas essa lÃ³gica nÃ£o Ã© algo
que o compilador entenda. VocÃª ainda vai ter um valor de <code>Result</code> que precisa
lidar: seja qual for a operaÃ§Ã£o que vocÃª estÃ¡ chamando, ela ainda tem uma possibilidade
de falhar em geral, mesmo que seja logicamente impossÃ­vel que isso ocorra nessa
situaÃ§Ã£o particular. Se vocÃª consegue assegurar ao inspecionar manualmente o cÃ³digo que
vocÃª nunca tera uma variante <code>Err</code>, Ã© perfeitamente aceitÃ¡vel chamar <code>unwrap</code>.
Aqui temos um exemplo:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::net::IpAddr;

let home = &quot;127.0.0.1&quot;.parse::&lt;IpAddr&gt;().unwrap();
#}</code></pre></pre>
<p>NÃ³s estamos criando uma instÃ¢ncia <code>IpAddr</code> ao analisar uma string <em>hardcoded</em>. NÃ³s
podemos ver que <code>127.0.0.1</code> Ã© um endereÃ§o de IP vÃ¡lido, entÃ£o Ã© aceitÃ¡vel usar
<code>unwrap</code> aqui. No entanto, ter uma string vÃ¡lida <em>hardcoded</em> nÃ£o muda o tipo retornado
pelo mÃ©todo <code>parse</code>: ainda teremos um valor de <code>Result</code>, e o compilador ainda
vai nos fazer tratar o <code>Result</code> como se a variante <code>Err</code> fosse uma
possibilidade, porque o compilador nÃ£o Ã© inteligente o bastante para ver que essa string
Ã© sempre um endereÃ§o IP vÃ¡lido. Se a string de endereÃ§o IP viesse de um usuÃ¡rio ao invÃ©s
de ser <em>hardcoded</em> no programa, e portanto, de fato tivesse uma possibilidade de falha, nÃ³s
definitivamente irÃ­amos querer tratar o <code>Result</code> de uma forma mais robusta.</p>
<a class="header" href="print.html#diretrizes-para-tratamento-de-erro" id="diretrizes-para-tratamento-de-erro"><h3>Diretrizes para Tratamento de Erro</h3></a>
<p>Ã‰ aconselhÃ¡vel fazer que seu cÃ³digo entre em <code>panic!</code> quando Ã© possÃ­vel que
ele entre em um mau estado. Nesse contexto, mau estado Ã© quando
alguma hipÃ³tese, garantia, contrato ou invariante foi quebrada, tal como
valores invÃ¡lidos, valores contraditÃ³rios, ou valores faltando que sÃ£o passados
a seu cÃ³digo - alÃ©m de um ou mais dos seguintes:</p>
<ul>
<li>O mau estado nÃ£o Ã© algo que Ã© <em>esperado</em> que aconteÃ§a ocasionalmente.</li>
<li>Seu cÃ³digo apÃ³s certo ponto precisa confiar que ele nÃ£o estÃ¡ nesse mau estado.</li>
<li>NÃ£o hÃ¡ uma forma boa de codificar essa informaÃ§Ã£o nos tipos que vocÃª usa.</li>
</ul>
<p>Se alguÃ©m chama seu cÃ³digo e passa valores que nÃ£o fazem sentido, a melhor escolha
talvez seja entrar em <code>panic!</code> e alertar a pessoa usando sua biblioteca do bug no
cÃ³digo dela para que ela possa consertÃ¡-la durante o desenvolvimento. Similarmente,
<code>panic!</code> Ã© em geral apropriado se vocÃª estÃ¡ chamando cÃ³digo externo que estÃ¡ fora
do seu controle e ele retorna um estado invÃ¡lido que vocÃª nÃ£o tem como consertar.</p>
<p>Quando se chega a um mau estado, mas isso Ã© esperado que aconteÃ§a nÃ£o importa
quÃ£o bem vocÃª escreva seu cÃ³digo, ainda Ã© mais apropriado retornar um <code>Result</code>
a fazer uma chamada a <code>panic!</code>. Um exemplo disso Ã© um <em>parser</em> recebendo dados
malformados ou uma requisiÃ§Ã£o HTTP retornando um status que indique que vocÃª atingiu
um limite de taxa. Nesses casos, vocÃª deveria indicar que falha Ã© uma possibilidade
esperada ao retornar um <code>Result</code> para propagar esses estados ruins para cima,
de forma que o cÃ³digo que chamou seu cÃ³digo pode decidir como tratar o problema.
Entrar em <code>panic!</code> nÃ£o seria a melhor maneira de lidar com esses casos.</p>
<p>Quando seu cÃ³digo realiza operaÃ§Ãµes em valores, ele deveria verificar que os valores
sÃ£o vÃ¡lidos primeiro, e entrar em <code>panic!</code> caso nÃ£o sejam. Isso Ã©
em boa parte por razÃµes de seguranÃ§a: tentar operar em dados invÃ¡lidos pode expor seu
cÃ³digo a vulnerabilidades. Essa Ã© a principal razÃ£o para a biblioteca padrÃ£o entrar em
<code>panic!</code> se vocÃª tentar um acesso de memÃ³ria fora dos limites: tentar acessar memÃ³ria
que nÃ£o pertence Ã  estrutura de dados atual Ã© um problema de seguranÃ§a comum. FunÃ§Ãµes
frequentemente tem <em>contratos</em>: seu comportamento somente Ã© garantido se os inputs cumprem
requerimentos especÃ­ficos. Entrar em pÃ¢nico quando o contrato Ã© violado faz sentido
porque uma violaÃ§Ã£o de contrato sempre indica um bug da parte do chamador, e nÃ£o Ã© o tipo
de erro que vocÃª quer que seja tratado explicitamente. De fato,
nÃ£o hÃ¡ nenhuma maneira razoÃ¡vel para o cÃ³digo chamador se recuperar: os <em>programadores</em>
que precisam consertar o cÃ³digo. Contratos para uma funÃ§Ã£o, especialmente quando uma
violaÃ§Ã£o leva a pÃ¢nico, devem ser explicados na documentaÃ§Ã£o da API da funÃ§Ã£o.</p>
<p>No entanto, ter vÃ¡rias checagens de erro em todas suas funÃ§Ãµes pode ser verboso
e irritante. Felizmente, vocÃª pode usar o sistema de tipos do Rust (e portanto a
checagem que o compilador faz) para fazer vÃ¡rias dessas checagens para vocÃª. Se
sua funÃ§Ã£o tem um tipo particular como parÃ¢metro, vocÃª pode continuar com a lÃ³gica
do seu cÃ³digo sabendo que o compilador jÃ¡ assegurou que vocÃª tem um valor vÃ¡lido.
Por exemplo, se vocÃª tem um tipo em vez de uma <code>Option</code>, seu programa espera
ter <em>algo</em> ao invÃ©s de <em>nada</em>. Seu cÃ³digo nÃ£o precisa tratar dois casos para
as variantes <code>Some</code> e <code>None</code>: ele vai somente ter um caso para definitivamente ter
um valor. Um cÃ³digo que tente passar nada para sua funÃ§Ã£o nÃ£o vai nem compilar,
entÃ£o sua funÃ§Ã£o nÃ£o precisa checar esse caso em tempo de execuÃ§Ã£o. Outro exemplo Ã© usar
um tipo de inteiro sem sinal como <code>u32</code>, que assegura que o parÃ¢metro nunca Ã©
negativo.</p>
<a class="header" href="print.html#criando-tipos-customizados-para-validaÃ§Ã£o" id="criando-tipos-customizados-para-validaÃ§Ã£o"><h3>Criando Tipos Customizados para ValidaÃ§Ã£o</h3></a>
<p>Vamos dar um passo alÃ©m na ideia de usar o sistema de tipos de Rust para assegurar que temos
um valor vÃ¡lido e ver como criar um tipo customizado para validaÃ§Ã£o.
Lembre do jogo de adivinhaÃ§Ã£o no CapÃ­tulo 2 onde nosso cÃ³digo pedia ao usuÃ¡rio
para adivinhar um nÃºmero entre 1 e 100. NÃ³s nunca validamos que o chute do usuÃ¡rio
fosse entre esses nÃºmeros antes de comparÃ¡-lo com o nÃºmero secreto; nÃ³s somente
validamos que o chute era positivo. Nesse caso, as consequÃªncias nÃ£o foram tÃ£o
drÃ¡sticas: nosso output de &quot;Muito alto&quot; ou &quot;Muito baixo&quot; ainda estariam corretos. Seria
uma melhoria Ãºtil guiar o usuÃ¡rio para chutes vÃ¡lidos, e ter um comportamento distinto
quando um usuÃ¡rio chuta um nÃºmero fora do limite e quando um usuÃ¡rio digita letras, por exemplo.</p>
<p>Uma maneira de fazer isso seria interpretar o chute como um <code>i32</code> em vez de
somente um <code>u32</code> para permitir nÃºmeros potenciamente negativos, e entÃ£o adicionar
uma checagem se o nÃºmero estÃ¡ dentro dos limites, conforme a seguir:</p>
<pre><code class="language-rust ignore">loop {
    // snip

    let palpite: i32 = match palpite.trim().parse() {
        Ok(num) =&gt; num,
        Err(_) =&gt; continue,
    };

    if palpite &lt; 1 || palpite &gt; 100 {
        println!(&quot;O nÃºmero secreto vai estar entre 1 e 100.&quot;);
        continue;
    }

    match palpite.cmp(&amp;numero_secreto) {
    // snip
}
</code></pre>
<p>A expressÃ£o <code>if</code> checa se nosso valor estÃ¡ fora dos limites, informa o usuÃ¡rio
sobre o problema, e chama <code>continue</code> para comeÃ§ar a prÃ³xima iteraÃ§Ã£o do loop
e pedir por outro chute. Depois da expressÃ£o <code>if</code> podemos proceder com as
comparaÃ§Ãµes entre <code>palpite</code> e o nÃºmero secreto sabendo que <code>palpite</code> estÃ¡
entre 1 e 100.</p>
<p>No entanto, essa nÃ£o Ã© a soluÃ§Ã£o ideal: se fosse absolutamente crÃ­tico que o
programa somente operasse em valores entre 1 e 100, e ele tivesse vÃ¡rias funÃ§Ãµes
com esse requisito, seria tedioso (e potencialmente impactante na performance)
ter uma checagem dessa em cada funÃ§Ã£o.</p>
<p>Em vez disso, podemos fazer um novo tipo e colocar as validaÃ§Ãµes em uma funÃ§Ã£o
para criar uma instÃ¢ncia do tipo em vez de repetir as validaÃ§Ãµes em todo lugar.
Dessa maneira, Ã© seguro para funÃ§Ãµes usarem o novo tipo nas suas assinaturas e
confidentemente usar os valores que recebem. A Listagem 9-9  mostra uma maneira de
definir um tipo <code>Palpite</code> que vai somente criar uma instÃ¢ncia de <code>Palpite</code> se a funÃ§Ã£o
<code>new</code> receber um valor entre 1 e 100:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Palpite {
    valor: u32,
}

impl Palpite {
    pub fn new(valor: u32) -&gt; Palpite {
        if valor &lt; 1 || valor &gt; 100 {
            panic!(&quot;Valor de chute deve ser entre 1 e 100, recebi {}.&quot;, valor);
        }

        Palpite {
            valor
        }
    }

    pub fn valor(&amp;self) -&gt; u32 {
        self.valor
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 9-9: Um tipo <code>Palpite</code> que somente funciona com valores
entre 1 e 100.</span></p>
<p>Primeiro, definimos uma struct chamada <code>Palpite</code> que tem um campo chamado <code>valor</code>
que guarda um <code>u32</code>. Isso Ã© onde o nÃºmero vai ser guardado.</p>
<p>EntÃ£o nÃ³s implementamos uma funÃ§Ã£o associada chamada <code>new</code> em <code>Palpite</code> que cria
instÃ¢ncias de valores <code>Palpite</code>. A funÃ§Ã£o <code>new</code> Ã© definida a ter um parÃ¢metro
chamado <code>valor</code> de tipo <code>u32</code> e retornar um <code>Palpite</code>. O cÃ³digo no corpo da funÃ§Ã£o
<code>new</code> testa para ter certeza que <code>valor</code> estÃ¡ entre 1 e 100. Se <code>valor</code> nÃ£o passa
nesse teste, fazemos uma chamada a <code>panic!</code>, que vai alertar ao programador que
estÃ¡ escrevendo o cÃ³digo chamando a funÃ§Ã£o que ele tem um bug que precisa ser
corrigido, porque criar um <code>Palpite</code> com um <code>valor</code> fora desses limites violaria
o contrato em que <code>Palpite::new</code> se baseia. As condiÃ§Ãµes em que <code>Palpite::new</code> pode
entrar em pÃ¢nico devem ser discutidas na sua documentaÃ§Ã£o da API voltada ao pÃºblico;
no CapÃ­tulo 14 nÃ³s cobriremos convenÃ§Ãµes de documentaÃ§Ã£o indicando a possibilidade de um <code>panic!</code>
na documentaÃ§Ã£o de API. Se <code>valor</code> de fato passa no
teste, criamos um novo <code>Palpite</code> com o campo <code>valor</code> preenchido com o parÃ¢metro
<code>valor</code> e retornamos o <code>Palpite</code>.</p>
<p>Em seguida, implementamos um mÃ©todo chamado <code>valor</code> que pega <code>self</code> emprestado, nÃ£o
tem nenhum outro parÃ¢metro, e retorna um <code>u32</code>. Esse Ã© o tipo de mÃ©todo Ã s vezes
chamado de <em>getter</em>, pois seu propÃ³sito Ã© pegar um dado de um dos campos e o retornar.
Esse mÃ©todo pÃºblico Ã© necessÃ¡rio porque o campo <code>valor</code> da struct <code>Palpite</code> Ã© privado.
Ã‰ importante que o campo <code>valor</code> seja privado para que cÃ³digo usando a struct <code>Palpite</code>
nÃ£o tenha permissÃ£o de definir o valor de <code>valor</code> diretamente: cÃ³digo de fora do mÃ³dulo
<em>deve</em> usar a funÃ§Ã£o <code>Palpite::new</code> para criar uma instÃ¢ncia de <code>Palpite</code>, o que certifica
que nÃ£o hÃ¡ maneira de um <code>Palpite</code> ter um <code>valor</code> que nÃ£o foi checado pelas condiÃ§Ãµes
definidas na funÃ§Ã£o <code>Palpite::new</code>.</p>
<p>Uma funÃ§Ã£o que tem um parÃ¢metro ou retorna somente nÃºmeros entre 1 e 100 pode
entÃ£o declarar na sua assinatura que ela recebe ou retorna um <code>Palpite</code> em vez
de um <code>u32</code> e nÃ£o precisaria fazer nenhuma checagem adicional no seu corpo.</p>
<a class="header" href="print.html#resumo-5" id="resumo-5"><h2>Resumo</h2></a>
<p>As ferramentas de tratamento de erros de Rust sÃ£o feitas para te ajudar a escrever
cÃ³digo mais robusto. A macro <code>panic!</code> sinaliza que seu programa estÃ¡ num estado que
nÃ£o consegue lidar e deixa vocÃª parar o processo ao invÃ©s de tentar prosseguir com
valores invÃ¡lidos ou incorretos. O enum <code>Result</code> usa o sistema de tipos de Rust para
indicar que operaÃ§Ãµes podem falhar de uma maneira que seu cÃ³digo pode se recuperar.
VocÃª pode usar <code>Result</code> para dizer ao cÃ³digo que chama seu cÃ³digo que ele precisa
tratar potenciais sucessos ou falhas tambÃ©m. Usar <code>panic!</code> e <code>Result</code> nas situaÃ§Ãµes
apropriadas farÃ¡ seu cÃ³digo mais confiÃ¡vel em face aos problemas inevitÃ¡veis.</p>
<p>Agora que vocÃª viu as maneiras Ãºteis em que a biblioteca padrÃ£o usa genÃ©ricos com
os enums <code>Option</code> e <code>Result</code>, nÃ³s falaremos como genÃ©ricos funcionam e como vocÃª
pode usÃ¡-los em seu cÃ³digo no prÃ³ximo capÃ­tulo.</p>
<p>#Tipos GenÃ©ricos, <em>Traits</em>, e Tempos de vida (<em>Lifetimes</em>)</p>
<p>Cada linguagem de programaÃ§Ã£o tem ferramentas para lidar de forma efetiva com a
duplicaÃ§Ã£o de conceitos; em Rust, uma dessas ferramentas sÃ£o os tipos
genÃ©ricos. Tipos genÃ©ricos sÃ£o substitutos abstratos para tipos concretos ou
para outras propriedades. Quando estamos escrevendo e compilando o cÃ³digo
podemos expressar propriedades de tipos genÃ©ricos, como seu comportamento ou
como eles se relacionam com outros tipos genÃ©ricos, sem precisar saber o que
realmente estarÃ¡ no lugar deles.</p>
<p>Do mesmo modo que uma funÃ§Ã£o aceita parÃ¢metros cujos valores nÃ£o sabemos
para escrever cÃ³digo que serÃ¡ processado em mÃºltiplos valores concretos, nÃ³s
podemos escrever funÃ§Ãµes que recebem parÃ¢metros de alguns tipos genÃ©ricos ao
invÃ©s de tipos concretos como <code>i32</code> ou <code>String</code>. NÃ³s jÃ¡ usamos tipos genÃ©ricos
no CapÃ­tulo 6 com <code>Option&lt;T&gt;</code>, no CapÃ­tulo 8 com <code>Vec&lt;T&gt;</code> e <code>HashMap&lt;K, V&gt;</code>, e
no CapÃ­tulo 9 com <code>Result&lt;T, E&gt;</code>. Nesse capÃ­tulo, vamos explorar como definir
nossos prÃ³prios tipos, funÃ§Ãµes e mÃ©todos usando tipos genÃ©ricos!</p>
<p>Primeiro, nÃ³s vamos revisar as mecÃ¢nicas de extrair uma funÃ§Ã£o que reduz
duplicaÃ§Ã£o de cÃ³digo. EntÃ£o usaremos a mesma mecÃ¢nica para fazer uma funÃ§Ã£o
genÃ©rica usando duas funÃ§Ãµes que sÃ³ diferem uma da outra nos tipos dos seus
parÃ¢metros. NÃ³s vamos usar tipos genÃ©ricos em definiÃ§Ãµes de struct e enum
tambÃ©m.</p>
<p>Depois disso, nÃ³s vamos discutir traits, que sÃ£o um modo de definir
comportamento de uma forma genÃ©rica. Traits podem ser combinados com tipos
genÃ©ricos para restringir um tipo genÃ©rico aos tipos que tem um comportamento
particular ao invÃ©s de qualquer tipo.</p>
<p>Finalmente, nÃ³s discutiremos <em>tempos de vida</em>, que sÃ£o um tipo de generalizaÃ§Ã£o
que nos permite dar ao compilador informaÃ§Ãµes sobre como as referÃªncias sÃ£o
relacionadas umas com as outras. Tempos de vida sÃ£o as caracterÃ­sticas em Rust
que nos permitem pegar valores emprestados em muitas situaÃ§Ãµes e ainda ter a
aprovaÃ§Ã£o do compilador de que as referÃªncias serÃ£o vÃ¡lidas.</p>
<a class="header" href="print.html#removendo-duplicaÃ§Ã£o-por-meio-da-extraÃ§Ã£o-de-uma-funÃ§Ã£o" id="removendo-duplicaÃ§Ã£o-por-meio-da-extraÃ§Ã£o-de-uma-funÃ§Ã£o"><h2>Removendo DuplicaÃ§Ã£o por meio da ExtraÃ§Ã£o de uma FunÃ§Ã£o</h2></a>
<p>Antes de entrar na sintaxe de tipos genÃ©ricos, vamos primeiro revisar uma
tÃ©cnica para lidar com duplicatas que nÃ£o usa tipos genÃ©ricos: extraindo uma
funÃ§Ã£o. Uma vez que isso esteja fresco em nossas mentes, usaremos as mesmas
mecÃ¢nicas com tipos genÃ©ricos para extrair uma funÃ§Ã£o genÃ©rica! Do mesmo modo
que vocÃª reconhece cÃ³digo duplicado para extrair para uma funÃ§Ã£o, vocÃª comeÃ§arÃ¡
a reconhecer cÃ³digo duplicado que pode usar tipos genÃ©ricos.</p>
<p>Considere um pequeno programa que acha o maior nÃºmero em uma lsita, mostrado
na Listagem 10-1:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let lista_numero = vec![34, 50, 25, 100, 65];

    let mut maior = lista_numero[0];

    for numero in lista_numero {
        if numero &gt; maior {
            maior = numero;
        }
    }

    println!(&quot;O maior nÃºmero Ã© {}&quot;, maior);
#  assert_eq!(maior, 100);
}
</code></pre></pre>
<p><span class="caption">Listagem 10-1: CÃ³digo para achar o maior nÃºmero em uma
lista de nÃºmeros</span></p>
<p>Esse cÃ³digo recebe uma lista de inteiros, guardados aqui na variÃ¡vel
<code>lista_numero</code>. Coloca o primeiro item da lista na variÃ¡vel chamada <code>maior</code>.
EntÃ£o ele itera por todos os nÃºmeros da lista, e se o valor atual Ã© maior que
o nÃºmero guardado em <code>maior</code>, substitui o valor em <code>maior</code>. Se o valor atual Ã©
menor que o valor visto atÃ© entÃ£o, <code>maior</code> nÃ£o Ã© mudado. Quando todos os items
da lista foram considerados, <code>maior</code> terÃ¡ o maior valor, que nesse caso Ã© 100.</p>
<p>Se nÃ³s precisÃ¡ssemos encontrar o maior nÃºmero em duas listas diferentes de
nÃºmeros, nÃ³s poderÃ­amos duplicar o cÃ³digo da Listagem 10-1 e usar a mesma
lÃ³gica nas duas partes do programa, como na Listagem 10-2:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let lista_numero = vec![34, 50, 25, 100, 65];

    let mut maior = lista_numero[0];

    for numero in lista_numero {
        if numero &gt; maior {
            maior = numero;
        }
    }

    println!(&quot;O maior nÃºmero Ã© {}&quot;, maior);

    let lista_numero = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut maior = lista_numero[0];

    for numero in lista_numero {
        if numero &gt; maior {
            maior = numero;
        }
    }

    println!(&quot;O maior nÃºmero Ã© {}&quot;, maior);
}
</code></pre></pre>
<p><span class="caption">Listagem 10-2: CÃ³digo para encontrar o maior nÃºmero em
duas listas de nÃºmeros</span></p>
<p>Ao passo que esse cÃ³digo funciona, duplicar cÃ³digo Ã© tedioso e tende a causar
erros, e significa que temos mÃºltiplos lugares para atualizar a lÃ³gica se
precisarmos mudÃ¡-lo.</p>
<p>Para eliminar essa duplicaÃ§Ã£o, nÃ³s podemos criar uma abstraÃ§Ã£o, que nesse caso
serÃ¡ na forma de uma funÃ§Ã£o que opera em uma lista de inteiros passadas Ã 
funÃ§Ã£o como um parÃ¢metro. Isso aumentarÃ¡ a clareza do nosso cÃ³digo e nos
permitirÃ¡ comunicar e pensar sobre o conceito de achar o maior nÃºmero em uma
lista independentemente do lugar no qual esse conceito Ã© usado.</p>
<p>No programa na Listagem 10-3, nÃ³s extraÃ­mos o cÃ³digo que encontra o maior
nÃºmero para uma funÃ§Ã£o chamada <code>maior</code>. Esse programa pode achar o maior nÃºmero
em duas listas de nÃºmeros diferentes, mas o cÃ³digo da lista 10-1 existe apenas
em um lugar:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn maior(list: &amp;[i32]) -&gt; i32 {
    let mut maior = list[0];

    for &amp;item in list.iter() {
        if item &gt; maior {
            maior = item;
        }
    }

    maior
}

fn main() {
    let lista_numero = vec![34, 50, 25, 100, 65];

    let resultado = maior(&amp;lista_numero);
    println!(&quot;O maior nÃºmero Ã© {}&quot;, resultado);
#    assert_eq!(resultado, 100);

    let lista_numero = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let resultado = maior(&amp;lista_numero);
    println!(&quot;O maior nÃºmero Ã© {}&quot;, resultado);
#    assert_eq!(resultado, 6000);
}
</code></pre></pre>
<p><span class="caption">Listagem 10-3: CÃ³digo abstraÃ­do para encontrar o maior
numá¸¿ero em duas listas</span></p>
<p>A funÃ§Ã£o tem o parÃ¢metro, <code>list</code>, que representa qualquer corte concreto de
valores <code>i32</code> que podemos passar para uma funÃ§Ã£o. O cÃ³digo na definiÃ§Ã£o da
funÃ§Ã£o opera na representaÃ§Ã£o da <code>list</code> de qualquer <code>&amp;[i32]</code>. Quando nÃ³s
passamos a funÃ§Ã£o <code>maior</code>, o cÃ³digo Ã© executado com os valores especÃ­ficos
que nÃ³s passamos.</p>
<p>As mecÃ¢nicas que usamos da Listagem 10-2 para a Listagem 10-3 foram as
seguintes:</p>
<ol>
<li>NÃ³s notamos que havia cÃ³digo duplicado.</li>
<li>NÃ³s extraÃ­mos o cÃ³digo duplicado para o corpo da funÃ§Ã£o, e especificamos as
entradas e os valores de retorno daquele cÃ³digo na assinatura da funÃ§Ã£o.</li>
<li>NÃ³s substituÃ­mos os dois locais concretos que tinham cÃ³digo duplicado para
chamar a funÃ§Ã£o.</li>
</ol>
<p>NÃ³s podemos usar os mesmos passos usando tipos genÃ©ricos para reduzir a
duplicaÃ§Ã£o de cÃ³digo de diferentes modos em diferentes cenÃ¡rios. Do mesmo modo
que o corpo da funÃ§Ã£o agora Ã© operado em uma <code>list</code> abstrata ao invÃ©s de
valores concretos, cÃ³digos usando tipos genÃ©ricos operarÃ£o em tipos abstratos.
Os conceitos empoderando tipos genÃ©ricos sÃ£o os mesmos conceitos que vocÃª jÃ¡
conhece que empodera funÃ§Ãµes, sÃ³ que aplicado de modos diferentes.</p>
<p>E se nÃ³s tivÃ©ssemos duas funÃ§Ãµes, uma que acha o maior item em um <em>slice</em> de
valores <code>i32</code> e um que acha o maior item em um corte de valores <code>char</code>? Como
nos livrarÃ­amos dessa duplicaÃ§Ã£o? Vamos descobrir!</p>
<a class="header" href="print.html#tipos-genÃ©ricos-de-dados" id="tipos-genÃ©ricos-de-dados"><h2>Tipos GenÃ©ricos de Dados</h2></a>
<p>Usando tipos genÃ©ricos onde usualmente colocamos tipos, como em assinaturas de
funÃ§Ãµes ou estruturas, vamos criar definiÃ§Ãµes que podemos usar muitos tipos
diferentes de tipos concretos de dados. Vamos dar uma olhada em como definir
funÃ§Ãµes, structs, enums e mÃ©todos usando tipos genÃ©ricos, e ao final dessa
seÃ§Ã£o discutiremos a performance do cÃ³digo usando tipos genÃ©ricos.</p>
<a class="header" href="print.html#usando-tipos-genÃ©ricos-de-dados-em-definiÃ§Ãµes-de-funÃ§Ãµes" id="usando-tipos-genÃ©ricos-de-dados-em-definiÃ§Ãµes-de-funÃ§Ãµes"><h3>Usando Tipos GenÃ©ricos de Dados em DefiniÃ§Ãµes de FunÃ§Ãµes</h3></a>
<p>NÃ³s podemos definir funÃ§Ãµes que usam tipos genÃ©ricos na assinatura da funÃ§Ã£o
onde os tipos de dados dos parÃ¢metros e os retornos vÃ£o. Desse modo, o cÃ³digo
que escrevemos pode ser mais flexÃ­vel e pode fornecer mais funcionalidades para
os chamadores da nossa funÃ§Ã£o, e ainda diminuir duplicaÃ§Ã£o de cÃ³digo.</p>
<p>Continuando com nossa funÃ§Ã£o <code>maior</code>, a Listagem 10-4 mostra duas funÃ§Ãµes que
oferecem a mesma funcionalidade de encontrar o maior valor dado um corte. A
primeira funÃ§Ã£o Ã© a que extraÃ­mos na Listagem 10-3 que encontra o maior <code>Ã¬32</code>
em um corte. A segunda funÃ§Ã£o encontra o maior <code>char</code> em um corte:</p>
<p><span class="filename">Nome do Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn maior_i32(lista: &amp;[i32]) -&gt; i32 {
    let mut maior = list[0];

    for &amp;item in lista.iter() {
        if item &gt; maior {
            maior = item;
        }
    }

    maior
}

fn maior_char(lista: &amp;[char]) -&gt; char {
    let mut maior = lista[0];

    for &amp;item in lista.iter() {
        if item &gt; maior {
            maior = item;
        }
    }

    maior
}

fn main() {
    let lista_numero = vec![34, 50, 25, 100, 65];

    let resultado = maior_i32(&amp;lista_numero);
    println!(&quot;O maior nÃºmero {}&quot;, resultado);
#    assert_eq!(resultado, 100);

    let lista_char = vec!['y', 'm', 'a', 'q'];

    let resultado = maior_char(&amp;lista_char);
    println!(&quot;O maior char Ã© {}&quot;, resultado);
#    assert_eq!(resultado, 'y');
}
</code></pre></pre>
<p><span class="caption">Listing 10-4: Duas funÃ§Ãµes que diferem apenas em seus
nomes e nos tipos de suas assinaturas</span></p>
<p>Aqui as funÃ§Ãµes <code>maior_i32</code> e <code>maior_char</code> tem exatamente o mesmo corpo, entÃ£o
seria bom se pudÃ©ssemos transformar essas duas funÃ§Ãµes em uma e nos livrar da
duplicaÃ§Ã£o. Por sorte, nÃ³s podemos fazer isso introduzindo um parÃ¢metro de
tipo genÃ©rico!</p>
<p>Para parametrizar os tipos na assinatura de uma funÃ§Ã£o que vamos definir,
precisamos criar um nome para o tipo parÃ¢metro, assim como damos nomes para os
valores dos parÃ¢metros de uma funÃ§Ã£o. NÃ³s vamos escolher o nome <code>T</code>. Qualquer
identificador pode ser usado como um nome de tipo de parÃ¢metro, mas estamos
escolhendo <code>T</code> porque a convenÃ§Ã£o de nomes de tipos de Rust Ã© a CamelCase.
Nomes de parÃ¢metros de tipos genÃ©ricos tambÃ©m tendem a ser curtos por
convenÃ§Ã£o, e frequentemente usam apenas uma letra. A abreviatura de &quot;tipo&quot;, <code>T</code>
Ã© a escolha padrÃ£o feita por programadores Rust.</p>
<p>Quando usamos um parÃ¢metro no corpo de uma funÃ§Ã£o, nÃ³s temos que declarar o
parÃ¢metro na assinatura para que o compilador saiba o que aquele nome no corpo
significa. Similarmente, quando usamos um tipo de nome de parÃ¢metro em uma
assinatura de funÃ§Ã£o, temos que declarar o tipo de nome de parÃ¢metro antes de
usa-lo. DeclaraÃ§Ãµes de tipos de nomes vÃ£o em colchetes entre o nome da funÃ§Ã£o e
a lista de paramÃªtros.</p>
<p>A assinatura da funÃ§Ã£o da funÃ§Ã£o genÃ©rica <code>maior</code> que vamos definir se parecerÃ¡
com isto:</p>
<pre><code class="language-rust ignore">fn maior&lt;T&gt;(lista: &amp;[T]) -&gt; T {
</code></pre>
<p>NÃ³s lerÃ­amos isso como: a funÃ§Ã£o <code>maior</code> Ã© genÃ©rica sobre algum tipo <code>T</code>. Ela
tem um parÃ¢metro chamado <code>lista</code>, e o tipo de <code>lista</code> Ã© um corte dos valores
do tipo <code>T</code>. A funÃ§Ã£o <code>maior</code> retornarÃ¡ um valor do mesmo tipo <code>T</code>.</p>
<p>A listagem 10-5 mostra a definiÃ§Ã£o da funÃ§Ã£o unificada <code>maior</code> usando um tipo
genÃ©rico de dado na sua assinatura, e mostra quando nÃ³s poderemos chamar a
funÃ§Ã£o <code>maior</code> com ou um corte de valores de <code>i32</code> ou de valores <code>char</code>. Note
que esse cÃ³digo nÃ£o compilarÃ¡ ainda!</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn maior&lt;T&gt;(lista: &amp;[T]) -&gt; T {
    let mut maior = lista[0];

    for &amp;item in lista.iter() {
        if item &gt; maior {
            maior = item;
        }
    }

    maior
}

fn main() {
    let lista_numero = vec![34, 50, 25, 100, 65];

    let resultado = maior(&amp;lista_numero);
    println!(&quot;The maior number is {}&quot;, resultado);

    let lista_char = vec!['y', 'm', 'a', 'q'];

    let resultado = maior(&amp;char_lista);
    println!(&quot;O maior char e {}&quot;, resultado);
}
</code></pre>
<p><span class="caption">Listagem 10-5: Uma definiÃ§Ã£o para a funÃ§Ã£o <code>maior</code> que
usa um tipo genÃ©rico como parÃ¢metro mas nÃ£o compila ainda</span></p>
<p>Se nÃ³s tentarmos compilar o cÃ³digo agora, nÃ³s receberemos esse erro:</p>
<pre><code class="language-text">error[E0369]: binary operation `&gt;` cannot be applied to type `T`
  |
5 |         if item &gt; maior {
  |            ^^^^
  |
note: an implementation of `std::cmp::PartialOrd` might be missing for `T`
</code></pre>
<p>A nota menciona <code>std::cmp::PartialOrd</code>, que Ã© um <em>trait</em>. NÃ³s vamos falar sobre
trait na prÃ³xima sessÃ£o, mas de forma breve, o que esse erro estÃ¡ dizendo Ã© que
o corpo de <code>maior</code> nÃ£o funcionarÃ¡ para todos os possÃ­veis tipos que <code>T</code> poderia
ser; jÃ¡ que queremos comparar valores do tipo <code>T</code> no corpo, nÃ³s podemos apenas
usar tipos que sabem como ser ordenados. A biblioteca padrÃ£o definiu que o
trait <code>std::cmp::PartialOrd</code> que tipos podem implementar para habilitar
comparaÃ§Ãµes. Vamos voltar a traits e em como especificar que um tipo genÃ©rico
tenha um trait em particular na prÃ³xima sessÃ£o, mas vamos deixar isso de lado
por um momento e explorar outros lugares que podemos usar parÃ¢metros de tipos
genÃ©ricos primeiro.</p>
<a class="header" href="print.html#usando-tipos-de-dados-genÃ©ros-em-definiÃ§Ãµes-de-structs" id="usando-tipos-de-dados-genÃ©ros-em-definiÃ§Ãµes-de-structs"><h3>Usando Tipos de Dados GenÃ©ros em DefiniÃ§Ãµes de Structs</h3></a>
<p>NÃ³s podemos definir structs para usar um parÃ¢metro de tipo genÃ©rico em um ou
mais campos de um struct com a sintaxe <code>&lt;&gt;</code> tambÃ©m. A listagem 10-6 mostra a
definiÃ§Ã£o e faz uso do struct <code>Ponto</code> que contÃ©m as coordenadas <code>x</code> e <code>y</code> com
valores de qualquer tipo:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Ponto&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let inteiro = Ponto { x: 5, y: 10 };
    let float = Ponto { x: 1.0, y: 4.0 };
}
</code></pre></pre>
<p><span class="caption">Listagem 10-6: Uma struct <code>Ponto</code> contÃ©m os valores <code>x</code> e
<code>y</code> do tipo <code>T</code></span></p>
<p>A sintaxe Ã© similar a que se usa em definiÃ§Ãµes de funÃ§Ãµes usando tipos
genÃ©ricos. Primeiro, nÃ³s temos que declarar o nome do tipo de parÃ¢metro dentro
de colchetes angulares logo apÃ³s o nome da struct. EntÃ£o nÃ³s podemos usar tipos
genÃ©ricos na definiÃ§Ã£o da struct onde nÃ³s especificarÃ­amos tipos concretos de
dados.</p>
<p>Note que porque sÃ³ usamos um tipo genÃ©rico na definiÃ§Ã£o de <code>Ponto</code>, o que
estamos dizendo Ã© que o struct <code>Ponto</code> Ã© genÃ©rico sobre algum tipo <code>T</code>, e os
campos <code>x</code> e <code>y</code> sÃ£o <em>ambos</em> do mesmo tipo, qualquer que seja. Se nÃ³s tentarmos
criar uma instÃ¢ncia de um <code>Ponto</code> que possui valores de tipos diferentes, como
na Listagem 10-7, nosso cÃ³digo nÃ£o compilarÃ¡:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">struct Ponto&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let nao_funciona = Ponto { x: 5, y: 4.0 };
}
</code></pre>
<p><span class="caption">Listagem 10-7: Os campos <code>x</code> e <code>y</code> precisam ser do mesmo
tipo porque ambos tem o tipo genÃ©rico de dado <code>T</code></span></p>
<p>Se nÃ³s tentarmos compilar isso, receberemos o seguinte erro:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt;
  |
7 |     let nao_funciona = Point { x: 5, y: 4.0 };
  |                                         ^^^ expected integral variable, found
  floating-point variable
  |
  = note: expected type `{integer}`
  = note:    found type `{float}`
</code></pre>
<p>Quando atribuÃ­mos o valor de 5 para <code>x</code>, o compilador sabe que para essa
instÃ¢ncia de <code>Ponto</code> o tipo genÃ©rico <code>T</code> serÃ¡ um nÃºmero inteiro. EntÃ£o quando
especificamos 4.0 para <code>y</code>, o qual Ã© definido para ter o mesmo tipo de <code>x</code>, nÃ³s
temos um tipo de erro de incompatibilidade.</p>
<p>Se nÃ³s quisermos definir um struct de <code>Ponto</code> onde <code>x</code> e <code>y</code> tÃªm tipos
diferentes e quisermos fazer com que esses tipos sejam genÃ©ricos, nÃ³s podemos
usar parÃ¢metros mÃºltiplos de tipos genÃ©ricos. Na listagem 10-8, nÃ³s mudamos a
definiÃ§Ã£o do <code>Ponto</code> para os tipos genÃ©ricos <code>T</code> e <code>U</code>. O campo <code>x</code> Ã© do tipo
<code>T</code>, e o campo <code>y</code> do tipo <code>U</code>:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Ponto&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let ambos_inteiros = Ponto { x: 5, y: 10 };
    let ambos_floats = Ponto { x: 1.0, y: 4.0 };
    let inteiro_e_float = Ponto { x: 5, y: 4.0 };
}
</code></pre></pre>
<p><span class="caption">Listagem 10-8: Um <code>Ponto</code> genÃ©rico sobre dois tipos <code>x</code> e
<code>y</code> podem ser valores de tipos diferentes</span></p>
<p>Agora todos as instÃ¢ncias de <code>Ponto</code> sÃ£o permitidas! VocÃª pode usar quantos
parÃ¢metros de tipos genÃ©ricos em uma definiÃ§Ã£o quanto quiser, mas usar mais que
alguns comeÃ§a a tornar o cÃ³digo difÃ­cil de ler e entender. Se vocÃª chegar em um
ponto que precisa usar muitos tipos genÃ©ricos, Ã© provavelmente um sinal que seu
cÃ³digo poderia ser reestruturado e separado em partes menores.</p>
<a class="header" href="print.html#usando-tipos-de-dados-genÃ©ricos-em-definiÃ§Ãµes-de-enum" id="usando-tipos-de-dados-genÃ©ricos-em-definiÃ§Ãµes-de-enum"><h3>Usando Tipos de Dados GenÃ©ricos em DefiniÃ§Ãµes de Enum</h3></a>
<p>Similar a structs, enums podem ser definidos para conter tipos genÃ©ricos de
dados nas suas variantes. NÃ³s usamos o enum <code>Option&lt;T&gt;</code> concedido pela
biblioteca padrÃ£o no capÃ­tulo 6, e agora a definiÃ§Ã£o deve fazer mais sentido.
Vamos dar uma outra olhada:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Option&lt;T&gt; {
    Some(T),
    None,
}
#}</code></pre></pre>
<p>Em outras palavras, <code>Option&lt;T&gt;</code> Ã© um enum genÃ©rico do tipo <code>T</code>. Ele tÃªm duas
variantes: <code>Some</code>, que contÃ©m o valor do tipo <code>T</code>, e uma variante <code>None</code> que
nÃ£o contÃ©m nenhum valor. A biblioteca padrÃ£o tem que ter apenas essa deifiniÃ§Ã£o
para suportar a criaÃ§Ã£o de valores desse enum que pode conter qualquer tipo
concreto. A ideia de um &quot;um valor opcional&quot; Ã© um conceito mais abstrato que o
de um tipo especÃ­fico, e Rust nos deixa expressar esse conceito abstrato sem
muitas duplicaÃ§Ãµes.</p>
<p>Enum podem usar tipos mÃºltiplos genÃ©ricos tambÃ©m. A definiÃ§Ã£o do enum
<code>Resultado</code> que usamos no CapÃ­tulo 9 Ã© um exemplo:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Resultado&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
#}</code></pre></pre>
<p>O enum <code>Resultado</code> Ã© genÃ©rico sobre dois tipos, <code>T</code> e <code>E</code>. <code>Resultado</code> tem duas
variantes: <code>Ok</code>, que contÃ©m um valor do tipo <code>T</code>, e <code>Err</code>, que contÃ©m um valor
do tipo  <code>E</code>. Essa definiÃ§Ã£o faz com que seja conveniente usar o enum
<code>Resultado</code> em qualquer lugar que tenhamos uma operaÃ§Ã£o que possa ser bem
sucedida (e retornar um valor de algum tipo <code>T</code>) ou falhar (e retornar um erro
de algum tipo <code>E</code>). Lembre da Listagem 9-2 quando abrimos um arquivo: naquele
caso, <code>T</code> tinha o tipo <code>std::fs::File</code> quando o arquivo era aberto com sucesso
e <code>E</code> tinha o tipo <code>std::io::Error</code> quando havia problemas em abrir o arquivo.</p>
<p>Quando vocÃª reconhece situaÃ§Ãµes no seu cÃ³digo com structs mÃºltiplos ou
definiÃ§Ãµes de enum que diferem apenas nos tipos de valores que eles contÃ©m,
vocÃª pode remover a duplicata usando o mesmo processo usado na definiÃ§Ã£o de
funÃ§Ãµes para introduzir tipos genÃ©ricos.</p>
<a class="header" href="print.html#usando-tipos-genÃ©ricos-de-dados-em-definiÃ§Ãµes-de-mÃ©todos" id="usando-tipos-genÃ©ricos-de-dados-em-definiÃ§Ãµes-de-mÃ©todos"><h3>Usando Tipos GenÃ©ricos de Dados em DefiniÃ§Ãµes de MÃ©todos</h3></a>
<p>Como fizemos no CapÃ­tulo 5, nÃ³s podemos implementar mÃ©todos em estruturas e
enums que tÃªm tipos genÃ©ricos em suas definiÃ§Ãµes. A Listagem 10-9 mostra o
struct <code>Ponto&lt;T&gt;</code> que definimos na Listagem 10-6. NÃ³s, entÃ£o, definimos um
mÃ©todo chamado <code>x</code> no <code>Ponto&lt;T&gt;</code> que retorna a referÃªncia para o dado no campo
<code>x</code>:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Ponto&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Ponto&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Ponto { x: 5, y: 10 };

    println!(&quot;p.x = {}&quot;, p.x());
}
</code></pre></pre>
<p><span class="caption">Listagem 10-9: Implementando um mÃ©todo chamado <code>x</code> na
struct <code>Ponto&lt;T&gt;</code> que retornarÃ¡ uma referÃªncia para o campo <code>x</code>, que Ã© do tipo
<code>T</code>.</span></p>
<p>Note que temos que declarar <code>T</code> logo apÃ³s <code>impl</code> para usar <code>T</code> no tipo
<code>Ponto&lt;T&gt;</code>. Declarar <code>T</code> como um tipo genÃ©rico depois e <code>impl</code> Ã© como o Rust
sabe se o tipo dentro das chaves angulares em <code>Ponto</code> Ã© um tipo genÃ©rico ou um
tipo concreto. Por exemplo, nÃ³s poderÃ­amos escolher implementar mÃ©todos nas
instÃ¢ncias de <code>Ponto&lt;f32&gt;</code> ao invÃ©s nas de <code>Ponto</code> com qualquer tipo genÃ©rico.
A listagem 10-10 mostra que nÃ£o declaramos nada depois de <code>impl</code> nesse caso, jÃ¡
que estamos usanod um tipo concreto, <code>f32</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Ponto&lt;T&gt; {
#     x: T,
#     y: T,
# }
#
impl Ponto&lt;f32&gt; {
    fn distancia_da_origem(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 10-10: Construindo um bloco de <code>impl</code> que sÃ³ se
aplica a uma struct com o tipo especÃ­fico usado pelo parÃ¢metro de tipo genÃ©rico
<code>T</code></span></p>
<p>Esse cÃ³digo significa que o tipo <code>Ponto&lt;f32&gt;</code> terÃ¡ um mÃ©todo chamado
<code>distancia_da_origem</code>, e outras instÃ¢ncias do <code>Ponto&lt;T&gt;</code> onde <code>T</code> nÃ£o Ã© do tipo
<code>f32</code> nÃ£o terÃ¡ esse mÃ©todo definido. Esse mÃ©todo quÃ£o longe nosso ponto estÃ¡
das coordenadas (0.0, 0.0) e usa operaÃ§Ãµes matemÃ¡ticas que sÃ³ estÃ£o disponÃ­veis
para tipos de ponto-flutuantes.</p>
<p>ParÃ¢metros de tipos genÃ©ricos em uma definiÃ§Ã£o de struct nÃ£o sÃ£o sempre os
parÃ¢metros de tipos genÃ©ricos que vocÃª quer usar na assinatura de mÃ©todo
daquela struct. A Listagem 10-11 define um mÃ©todo <code>mistura</code> na estrutura
<code>Ponto&lt;T, U&gt;</code> da Listagem 10-8. O mÃ©todo recebe outro <code>Ponto</code> como parÃ¢metro,
que pode ter tipos diferentes de <code>self</code> <code>Ponto</code> dos quais usamos no <code>mistura</code>.
O mÃ©todo cria uma nova instÃ¢ncia de <code>Ponto</code> que possui o valor <code>x</code> de <code>self</code>
<code>Point</code> (que Ã© um tipo de <code>T</code>) e o valor de <code>y</code> passado de <code>Ponto</code> (que Ã© do
tipo <code>W</code>):</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Ponto&lt;T, U&gt; {
    x: T,
    y: U,
}

impl&lt;T, U&gt; Ponto&lt;T, U&gt; {
    fn mistura&lt;V, W&gt;(self, other: Ponto&lt;V, W&gt;) -&gt; Ponto&lt;T, W&gt; {
        Ponto {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Ponto { x: 5, y: 10.4 };
    let p2 = Ponto { x: &quot;Ola&quot;, y: 'c'};

    let p3 = p1.mistura(p2);

    println!(&quot;p3.x = {}, p3.y = {}&quot;, p3.x, p3.y);
}
</code></pre></pre>
<p><span class="caption">Listagem 10-11: MÃ©todos que usam diferentes tipos
genÃ©ricos das suas definiÃ§Ãµes de struct</span></p>
<p>No <code>main</code>, nÃ³s definimos um <code>Ponto</code> que tem um <code>i32</code> para o <code>x</code> (com o valor de
<code>5</code>) e um <code>f64</code> para <code>y</code> (com o valor de <code>10.4</code>). <code>p2</code> Ã© um <code>Ponto</code> que tem um
pedaÃ§o de string <code>x</code> (com o valor <code>&quot;Ola&quot;</code>) e um <code>char</code> para <code>y</code> (com o valor
<code>c</code>). Chamando <code>mistura</code> no <code>p1</code> com o argumento <code>p2</code> nos dÃ¡ <code>p3</code>, que terÃ¡ um
<code>i32</code> para <code>x</code>, jÃ¡ que <code>x</code> veio de <code>p1</code>. <code>p3</code> terÃ¡ um <code>char</code> para <code>y</code>, jÃ¡ que
<code>y</code> veio de <code>p2</code>. O <code>println!</code> irÃ¡ imprimir <code>p3.x = 5, p3.y = c</code>.</p>
<p>Note que os parÃ¢metro genÃ©ricos <code>T</code> e <code>U</code> sÃ£o declarados depois de <code>impl</code>, jÃ¡
que eles vÃ£o com a definiÃ§Ã£o do struct. Os parÃ¢metros genÃ©ricos <code>V</code> e <code>áº€</code> sÃ£o
declarados depois de <code>fn mistura</code>, jÃ¡ que elÃ©s sÃ³ sÃ£o relevantes para esse
mÃ©todo.</p>
<a class="header" href="print.html#desempenho-do-cÃ³digo-usando-genÃ©ricos" id="desempenho-do-cÃ³digo-usando-genÃ©ricos"><h3>Desempenho do CÃ³digo Usando GenÃ©ricos</h3></a>
<p>VocÃª pode estar lendo essa seÃ§Ã£o e imaginando se hÃ¡ um custo no tempo de
execuÃ§Ã£o para usar parÃ¢metros de tipos genÃ©ricos. Boas notÃ­cias: o modo como
Rust implementa tipos genÃ©ricos significa que seu cÃ³digo nÃ£o vai ser executado
mais devagar do que se vocÃª tivesse especificado tipos concretos ao invÃ©s de
tipos genÃ©ricos como parÃ¢metros!</p>
<p>Rust consegue fazer isso realizando <em>monomorfizaÃ§Ã£o</em> de cÃ³digo usando tipos
genÃ©ricos em tempo de compilaÃ§Ã£o. MonomorfizaÃ§Ã£o Ã© o processo de transformar
cÃ³digo genÃ©rico em cÃ³digo especÃ­fico substituindo os tipos genÃ©ricos pelos
tipos concretos que sÃ£o realmente utilizados.</p>
<p>O que o compilador faz Ã© o oposto dos passos que fizemos para criar uma funÃ§Ã£o
de tipo genÃ©rico na Listagem 10-5. O compilador olhar para todos os lugares que
o cÃ³digo genÃ©rico Ã© chamado e gera o cÃ³digo para os tipos concretos que o
cÃ³digo genÃ©rico Ã© chamado.</p>
<p>Vamos trabalhar sobre o exemplo que usa o padrÃ£o de enum <code>Option</code> da
biblioteca:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let inteiro = Some(5);
let float = Some(5.0);
#}</code></pre></pre>
<p>Quando o Rust compilar esse cÃ³digo, ele vai fazer a monomorfizaÃ§Ã£o. O
compilador lerÃ¡ os valores que foram passados para <code>Option</code> e ver que temos
dois tipos de <code>Option&lt;T&gt;</code>: um Ã© <code>i32</code>, e o outro <code>f64</code>. Assim sendo, ele
expandirÃ¡ a definiÃ§Ã£o genÃ©rica de <code>Option&lt;T&gt;</code> para <code>Option_i32</code> e <code>Option_64</code>,
substituindo a definiÃ§Ã£o genÃ©rica por definiÃ§Ãµes especÃ­ficas.</p>
<p>A versÃ£o monomorfizada do nosso cÃ³digo que o compilador gera Ã© a seguinte, com
os usos da <code>Option</code> genÃ©rica substituÃ­dos pelas definiÃ§Ãµes especÃ­ficas criadas
pelo compilador:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let inteiro = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
</code></pre></pre>
<p>NÃ³s podemos escrever cÃ³digos nÃ£o duplicados usando tipos genÃ©ricos, e Rust vai
compila-lo em cÃ³digo que especifica o tipo em cada instÃ¢ncia. Isso significa
que nÃ£o pagamos nenhum custo em tempo de processamento para usar tipos
genÃ©ricos; quando o cÃ³digo roda, ele executa do mesmo modo como executaria se
tivÃ©ssemos duplicado cada definiÃ§Ã£o particular a mÃ£o. O proccesso de
monomorfizaÃ§Ã£o Ã© o que faz os tipos genÃ©ricos de Rust serem extremamente
eficientes em tempo de processamento.</p>
<a class="header" href="print.html#traits-definindo-comportamento-compartilhado" id="traits-definindo-comportamento-compartilhado"><h2>Traits: Definindo Comportamento Compartilhado</h2></a>
<p>Traits nos permitem usar outro tipo de abstraÃ§Ã£o: eles nos permitem abstrair
sobre o comportamento que tipos tÃªm em comum. Um <em>trait</em> diz ao compilador de
Rust sobre uma funcionalidade que um tipo particular possui e pode compartilhar
com outros tipos. Em situaÃ§Ãµes onde nÃ³s usamos parÃ¢metros de tipos genÃ©ricos,
nÃ³s podemos usar <em>limites de trait</em> para especificar, em tempo de compilaÃ§Ã£o,
que o tipo genÃ©rico pode ser qualquer tipo que implementa um trait e por
conseguinte tem o comportamento que queremos usar nessa situaÃ§Ã£o.</p>
<blockquote>
<p>Nota: <em>Traits</em> sÃ£o similares a um recurso frequentemente chamado de
'interface' em outras linguagens, com algumas diferenÃ§as.</p>
</blockquote>
<a class="header" href="print.html#definindo-um-trait" id="definindo-um-trait"><h3>Definindo um Trait</h3></a>
<p>O comportamento de um tipo consiste nos mÃ©todos que podemos chamar para aquele
tipo. Tipos diferentes dividem o mesmo comportamento se podemos chamar os
mesmos mÃ©todos em todos esses tipos. DefiniÃ§Ãµes de traits sÃ£o um modo de
agrupar mÃ©todos de assinaturas juntos a fim de definir um conjunto de
comportamentos para atingir algum propÃ³sito.</p>
<p>Por exemplo, digamos que temos mÃºltiplos structs que contÃ©m vÃ¡rios tipos e
quantidades de texto: um struct <code>ArtigoDeNoticias</code>que contÃ©m uma notÃ­cia
preenchida em um lugar do mundo, e um <code>Tweet</code> que pode ter no mÃ¡ximo 140
caracteres em seu conteÃºdo alÃ©m dos metadados como se ele foi um retweet ou uma
resposta a outro tweet.</p>
<p>NÃ³s queremos fazer uma biblioteca agregadora de mÃ­dia que pode mostrar resumos
de dados que podem estar guardados em uma instÃ¢ncia de <code>ArtigoDeNoticia</code> ou
<code>Tweet</code>. O comportamento que precisamos cada struct possua Ã© que seja capaz de
ser resumido, e que nÃ³s possamos pedir pelo resumo chamando um mÃ©todo <code>resumo</code>
em uma instÃ¢ncia. A Listagem 10-12 mostra a definiÃ§Ã£o de um trait <code>Resumir</code> que
expressa esse conceito:</p>
<p><span class="filename">Nome do arquivo: lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Resumir {
    fn resumo(&amp;self) -&gt; String;
}
#}</code></pre></pre>
<p><span class="caption">Listagem 10-12: DefiniÃ§Ã£o de um trait <code>Resumir</code> que
consiste no comportamento fornecido pelo mÃ©todo <code>resumo</code></span></p>
<p>NÃ³s declaramos um trait com a palavra-chave <code>trait</code>, e entÃ£o o nome do trait,
nesse caso <code>Resumir</code>. Dentro de chaves declaramos a assinatura do mÃ©todo que
descreve o comportamento que tipos que implementam esse trait precisarÃ£o ter,
nesse caso <code>fn resumo(&amp;self) -&gt; String;</code>. Depois da assinatura do mÃ©todo ao
invÃ©s de fornecer uma implementaÃ§Ã£o dentro de chaves, nÃ³s colocamos um ponto e
vÃ­rgula. Cada tipo que implementa esse trait precisa entÃ£o fornecer seu prÃ³prio
comportamento customizado para o corpo do mÃ©todo, mas o compilador vai reforÃ§ar
que qualquer qualquer tipo que tenha o trait <code>Resumir</code> terÃ¡ o mÃ©todo <code>resumo</code>
definido para ele com esse exata assinatura.</p>
<p>Um trait pode ter vÃ¡rios mÃ©todos no seu corpo, com os mÃ©todos das assinaturas
listados um por linha e cada linha terminando com um ponto e vÃ­rgula.</p>
<a class="header" href="print.html#implementando-um-trait-em-um-tipo" id="implementando-um-trait-em-um-tipo"><h3>Implementando um Trait em um Tipo</h3></a>
<p>Agora que deifnimos o trait <code>Resumir</code>, podemos implementa-lo nos tipos do nosso
agregador de mÃ­dias que queremos que tenham esse comportamento. A Listagem
10-13 mostra uma implementaÃ§Ã£o do trait <code>Resumir</code> no struct <code>ArtigoNotÃ­cia</code> que
possui o tÃ­tulo, o autor e a localizaÃ§Ã£o para criar e retornar o valor de
<code>resumo</code>. Para o struct <code>Tweet</code>, nÃ³s escolhemos definir <code>resumo</code> como o nome de
usuÃ¡rio seguido por todo o texto do tweet, assumindo que o conteÃºdo do tweet jÃ¡
estÃ¡ limitado a 140 caracteres.</p>
<p><span class="filename">Nome do arquivo: lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub trait Resumir {
#     fn summary(&amp;self) -&gt; String;
# }
#
pub struct ArtigoDeNoticia {
    pub titulo: String,
    pub local: String,
    pub autor: String,
    pub conteudo: String,
}

impl Resumir for ArtigoDeNoticia {
    fn summary(&amp;self) -&gt; String {
        format!(&quot;{}, by {} ({})&quot;, self.titulo, self.autor, self.local)
    }
}

pub struct Tweet {
    pub nomeusuario: String,
    pub conteudo: String,
    pub resposta: bool,
    pub retweet: bool,
}

impl Resumir for Tweet {
    fn summary(&amp;self) -&gt; String {
        format!(&quot;{}: {}&quot;, self.nomeusuario, self.conteudo)
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 10-13: Implementando o trait <code>Resumir</code> nos tipos
<code>ArtigoDeNoticia</code> e <code>Tweet</code></span></p>
<p>Implementar um trait em um tipo Ã© similar a implementar mÃ©todos que nÃ£o estÃ£o
relacionados com um trait. A diferenÃ§a estÃ¡ depois de <code>impl</code>, nÃ³s colocamos o
nome do trait que queremos implementar, entÃ£o dizemos <code>for</code> e o nome do tipo
que queremos implementar. Dentro do bloco <code>impl</code>, nÃ³s colocamos as assinaturas
dos mÃ©todos que a definiÃ§Ã£o do trait definiu, mas ao invÃ©s de colocar um ponto
e vÃ­rgula depois de cada assinatura, nÃ³s colocamos chaves e preenchemos o corpo
do mÃ©todo com o comportamento especÃ­fico que queremos que os mÃ©todos dos traits
tenham para um tipo particular.</p>
<p>Uma vez que implementamos o trait, nÃ³s podemos chamar os mÃ©todos nas instÃ¢ncias
de <code>ArtigoDeNoticia</code> e <code>Tweet</code> da mesma maneira que nÃ³s chamamos mÃ©todos que nÃ£o
sÃ£o parte de um trait:</p>
<pre><code class="language-rust ignore">let tweet = Tweet {
    nomeUsuario: String::from(&quot;horse_ebooks&quot;),
    conteudo: String::from(&quot;claro, como vocÃªs provavelmente jÃ¡ sabem, 
    pessoas&quot;),
    resposta: false,
    retweet: false,
};

println!(&quot;1 novo tweet: {}&quot;, tweet.summary());
</code></pre>
<p>Isso irÃ¡ imprimir <code>1 novo tweet: claro, como vocÃªs provavelmente jÃ¡ sabem, pessoas</code></p>
<p>Note que porque nÃ³s definimos o trait <code>Resumir</code> e os tipos <code>ArtigoDeNoticia</code> e
<code>Tweet</code> todos na mesma <code>lib.rs</code> na listagem 10-13, eles estÃ£o todos no mesmo
escopo. Se essa <code>lib.rs</code> Ã© para um crate nÃ³s chamamos <code>agregador</code>, e se outra
pessoa quiser usar a funcionalidade do nosso crate e implementar o trait
<code>Resumir</code> na sua struct <code>PrevisaoTempo</code>, o cÃ³digo deles precisaria importar o
trait <code>Resumir</code> no escopo deles primeiro antes deles poderem implementÃ¡-lo,
como na Listagem 10-14:</p>
<p><span class="filename">Nome do arquivo: lib.rs</span></p>
<pre><code class="language-rust ignore">extern crate aggregator;

use aggregator::Resumir;

struct PrevisaoTempo {
    alta_temp: f64,
    baixa_temp: f64,
    chance_de_chuva: f64,
}

impl Resumir for PrevisaoTempo {
    fn resumo(&amp;self) -&gt; String {
        format!(&quot;A alta serÃ¡ de {}, e a baixa de {}. A chance de precipitaÃ§Ã£o Ã©
        {}%.&quot;, self.alta_temp, self.baixa_temp, self.chance_de_chuva)
    }
}
</code></pre>
<p><span class="caption">Listagem 10-14: Trazendo o trait <code>Resumir</code> do nosso crate
<code>aggregator</code> para o escopo de outro crate</span></p>
<p>Esse cÃ³digo tambÃ©m assume que <code>Resumir</code> Ã© um trait pÃºblico, o que Ã© verdade
porque colocamos a palavra-chave <code>pub</code> antes de <code>trait</code> na Listagem 10-12.</p>
<p>Uma restriÃ§Ã£o para se prestar atenÃ§Ã£o na implementaÃ§Ã£o de traits: nÃ³s podemos
implementar um trait em um tipo desde que o trait ou o tipo forem locais para o
nosso crate. Em outras palavras, nÃ³s nÃ£o estamos autorizados a implementar
traits externos em tipos externos. NÃ³s nÃ£o podemos implementar o trait
<code>Display</code> em <code>Vec</code>, por exemplo, jÃ¡ que ambos <code>Display</code> e <code>Vec</code> sÃ£o definidos na
biblioteca padrÃ£o. NÃ³s temos a permissÃ£o de implementar traits da biblioteca
padrÃ£o como <code>Display</code> em um tipo personalizado como <code>Tweet</code> como parte da
funcionalidade do nosso crate <code>aggregator</code>, jÃ¡ que nÃ³s jÃ¡ havÃ­amos definido
<code>Resumir</code> lÃ¡. Essa restriÃ§Ã£o Ã© parte do que Ã© chamado de a <em>regra do á¹rfÃ£o</em>,
qual vocÃª pode procurar se estiver interessado nesse tipo de teoria. De forma
curta, Ã© chamada de a regra do Ã³rfÃ£o porque o tipo pai nÃ£o estÃ¡ presente. Sem
essa regra, dois crates poderiam implementar o mesmo trait para o mesmo tipo,
e as duas implementaÃ§Ãµes entrariam em conflito: o Rust nÃ£o saberia qual
implementaÃ§Ã£o usar. Porque o Rust impÃµe a regra do Ã³rfÃ£o, os cÃ³digos de outras
pessoas nÃ£o podem quebrar seu cÃ³digo e vice e versa.</p>
<a class="header" href="print.html#implementaÃ§Ãµes-padrÃ£o" id="implementaÃ§Ãµes-padrÃ£o"><h3>ImplementaÃ§Ãµes PadrÃ£o</h3></a>
<p>As vezes Ã© Ãºtil ter um comportamento padrÃ£o pra alguns ou todos os mÃ©todos em
um trait, ao invÃ©s de fazer toda implementaÃ§Ã£o em todo tipo e definir um
comportamento personalizado. Quando implementamos o trait em um tipo
particular, nÃ³s podemos escolher manter ou sobrescrever o comportamento padrÃ£o
de cada mÃ©todo.</p>
<p>A Listagem 10-15 mostra como poderÃ­amos ter escolhido especificar uma string
padrÃ£o para o mÃ©todo <code>resumo</code> do trait <code>Resumir</code> ao invÃ©s de escolher de apenas
definir a assinatura do mÃ©todo como fizemos na Listagem 10-12:</p>
<p><span class="filename">Nome do arquivo: lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Resumir {
    fn resumo(&amp;self) -&gt; String {
        String::from(&quot;(Leia mais...)&quot;)
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 10-15: DefiniÃ§Ã£o de um trait <code>Resumir</code> com a
implementaÃ§Ã£o padrÃ£o do mÃ©todo <code>resumo</code></span></p>
<p>Se nÃ³s quisÃ©ssemos usar a implementaÃ§Ã£o padrÃ£o para resumir as instÃ¢ncias de
<code>ArtigoDeNoticia</code> ao invÃ©s de definir uma implementaÃ§Ã£o personalizada como
fizemos na Listagem 10-13, nÃ³s especificarÃ­amos um bloco <code>impl</code> vazio:</p>
<pre><code class="language-rust ignore">impl Resumir for ArtigoDeNoticia {}
</code></pre>
<p>Mesmo que nÃ£o estejamos mais escolhendo definir o mÃ©todo <code>resumo</code> diretamente
em <code>ArtigoDeNoticia</code>, jÃ¡ que o mÃ©todo <code>resumo</code> tem uma implementaÃ§Ã£o padrÃ£o e
nÃ³s especificamos que <code>ArtigoDeNoticia</code> implementa o trait <code>Resumir</code>, nÃ³s ainda
podemos chamar o mÃ©todo <code>resumo</code> em uma instÃ¢ncia de <code>ArtigoDeNoticia</code>:</p>
<pre><code class="language-rust ignore">let artigo = ArtigoDeNoticia {
    titulo: String::from(&quot;Os Penguins ganham a copa do campeonato Stanley&quot;),
    lugar: String::from(&quot;Pittsburgh, PA, USA&quot;),
    autor: String::from(&quot;Iceburgh&quot;),
    conteudo: String::from(&quot;Os Penguins de Pittsburgh sÃ£o novamente o melhor
    time de hockey da NHL.&quot;),
};

println!(&quot;Novo artigo disponÃ­vel! {}&quot;, artigo.summary());
</code></pre>
<p>Esse cÃ³digo imprime <code>Novo artigo disponÃ­vel! (Leia mais...)</code></p>
<p>Mudando o trait <code>Resumir</code> para ter uma implementaÃ§Ã£o padrÃ£o para <code>resumo</code> nÃ£o
requer que nÃ³s mudemos nada na implementaÃ§Ã£o de <code>Resumir</code> em <code>Tweet</code> na
Listagem 10-13 ou em <code>PrevisaoTempo</code> na Listagem 10-14: a sintaxe para sobrepor
uma implementaÃ§Ã£o padrÃ£o Ã© exatamente a mesma de uma sintaxe para implementar
um mÃ©todo de trait que nÃ£o tem uma implementaÃ§Ã£o padrÃ£o.</p>
<p>ImplementaÃ§Ãµes padrÃµes sÃ£o autorizadas a chamar outros mÃ©todos no mesmo trait,
mesmo se os outros mÃ©todos nÃ£o tiverem uma implementaÃ§Ã£o padrÃ£o. Desse modo, um
trait pode prover muitas funcionalidades Ãºteis e apenas requerir implementaÃ§Ãµes
para especificar uma pequena parte dele. NÃ³s poderÃ­amos escolher que o trait
<code>Resumir</code> tambÃ©m tivesse o mÃ©todo <code>resumo_autor</code> qual a implementaÃ§Ã£o Ã©
necessÃ¡ria, entÃ£o um mÃ©todo <code>resumo</code> que tem a implementaÃ§Ã£o padrÃ£o que chama
pelo mÃ©todo <code>resumo_autor</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Resumir {
    fn resumo_autor(&amp;self) -&gt; String;

    fn resumo(&amp;self) -&gt; String {
        format!(&quot;(Leia mais de {}...)&quot;, self.resumo_autor())
    }
}
#}</code></pre></pre>
<p>Para usar essa versÃ£o de <code>Resumir</code>, nÃ³s sÃ³ precisamos definir <code>resumo_autor</code>
quando nÃ³s implementamos o trait em um tipo:</p>
<pre><code class="language-rust ignore">impl Resumir for Tweet {
    fn autor_resumo(&amp;self) -&gt; String {
        format!(&quot;@{}&quot;, self.nomeusuario)
    }
}
</code></pre>
<p>Uma vez que definimos <code>resumo_autor</code>, nÃ³s podemos chamar <code>resumo</code> em instÃ¢ncias
do struct <code>Tweet</code>, e a implementaÃ§Ã£o padrÃ£o de <code>resumo</code> chamarÃ¡ a definiÃ§Ã£o de
<code>resumo_autor</code> que fornecemos.</p>
<pre><code class="language-rust ignore">let tweet = Tweet {
    nomeusuario: String::from(&quot;horse_ebooks&quot;),
    conteudo: String::from(&quot;claro, como vocÃªs provavelmente jÃ¡ sabem, 
    pessoas&quot;),
    resposta: false,
    retweet: false,
};

println!(&quot;1 novo tweet: {}&quot;, tweet.resumo());
</code></pre>
<p>Isso irÃ¡ imprimir <code>1 novo tweet: (Leia mais de @horse_ebooks...)</code>.</p>
<p>Note que nÃ£o Ã© possÃ­vel chamar a implementaÃ§Ã£o padrÃ£o de uma implementaÃ§Ã£o
primordial.</p>
<a class="header" href="print.html#limites-de-traits" id="limites-de-traits"><h3>Limites de traits</h3></a>
<p>Agora que definimos traits e os implementamos em tipos, podemos usar traits com
parÃ¢metros de tipos genÃ©ricos. Podemos restringir tipos genÃ©ricos para que ao
invÃ©s de serem qualquer tipo, o compilador tenha certeza que o tipo estarÃ¡
limitado a aqueles tipos que implementam um trait em particular e por
consequÃªncia tenham o comportamento que precisamos que os tipos tenham. Isso Ã©
chamado de especificar os <em>limites dos traits</em> em um tipo genÃ©rico.</p>
<p>Por exemplo, na Listagem 10-13, nÃ³s implementamos o trait <code>Resumir</code> nos tipos
<code>ArtigoDeNoticia</code> e <code>Tweet</code>. NÃ³s podemos definir uma funÃ§Ã£o <code>notificar</code> que chama
o mÃ©todo <code>resumo</code> no seu parÃ¢metro <code>item</code>, que Ã© do tipo genÃ©rico <code>T</code>. Para
ser possÃ­vel chamar <code>resumo</code> em <code>item</code> sem receber um erro, podemos usar os
limites de traits em <code>T</code> para especificar que <code>item</code> precisa ser de um tipo que
implementa o trait <code>Resumir</code>:</p>
<pre><code class="language-rust ignore">pub fn notificar&lt;T: Resumir&gt;(item: T) {
    println!(&quot;NotÃ­cias de Ãºltima hora! {}&quot;, item.resumo());
}
</code></pre>
<p>Limites de traits vÃ£o juntos com a declaraÃ§Ã£o de um parÃ¢metro de tipo genÃ©rico,
depois de uma vÃ­rgula e entre colchetes angulares. Por causa do limite de trait
em  <code>T</code>, nÃ³s podemos chamar <code>notificar</code> e passar qualquer instÃ¢ncia de
<code>ArtigoDeNoticia</code> ou <code>Tweet</code>. O cÃ³digo externo da Listagem 10-14 que estÃ¡
usando nosso crate <code>aggregator</code> pode chamar nossa funÃ§Ã£o <code>notificar</code> e passar
uma instÃ¢ncia de <code>PrevisaoTempo</code>, jÃ¡ que <code>Resumir</code> Ã© implementado para
<code>PrevisaoTempo</code> tambÃ©m. O cÃ³digo que chama <code>notificar</code> com qualquer outro tipo,
como uma <code>String</code> ou um <code>i32</code>, nÃ£o compilarÃ¡, jÃ¡ que esses tipos nÃ£o
implementam <code>Resumir</code>.</p>
<p>NÃ³s podemos especificar mÃºltiplos limites de traits em um tipo genÃ©rico usando
<code>+</code>. Se nÃ³s precisÃ¡ssemos ser capazes de usar mostrar formataÃ§Ã£o no tipo <code>T</code> em
uma funÃ§Ã£o assim como no mÃ©todo <code>resumo</code>, nÃ³s podemos usar os limites de trait
<code>T: Resumir + Mostrar</code>. Isso signifca que <code>T</code> pode ser qualquer tipo que
implemente ambos <code>Resumir</code> e <code>Mostrar</code>.</p>
<p>Para funÃ§Ãµes que tÃªm mÃºltiplos parÃ¢metros de tipos genÃ©ricos, cada tipo
genÃ©rico tem seu prÃ³prio limite de trait. Especificar muitas informaÃ§Ãµes de
limites de trait dentro de chaves angulares entre o nome de uma funÃ§Ã£o e sua
lista de parÃ¢metros pode tornar o cÃ³digo difÃ­cil de ler, entÃ£o hÃ¡ uma sintaxe
alternativa para especificar limites de traits que nos permite movÃª-los para
uma clÃ¡usula depois da assinatura da funÃ§Ã£o. EntÃ£o ao invÃ©s de:</p>
<pre><code class="language-rust ignore">fn alguma_funcao&lt;T: Mostrar + Clone, U: Clone + Debug&gt;(t: T, u: U) -&gt; i32 {
</code></pre>
<p>NÃ³s podemos escrever isso com uma clÃ¡usula de <code>where</code>:</p>
<pre><code class="language-rust ignore">fn alguma_funcao&lt;T, U&gt;(t: T, u: U) -&gt; i32
    where T: Display + Clone,
          U: Clone + Debug
{
</code></pre>
<p>Isso Ã© menos confuso e faz a assinatura da funÃ§Ã£o ficar mais parecida Ã  uma
funÃ§Ã£o sem ter vÃ¡rios limites de trait, nela o nome da funÃ§Ã£o, a lista de
parÃ¢metros, e o tipo de retorno estÃ£o mais prÃ³ximos.</p>
<a class="header" href="print.html#consertando-a-funÃ§Ã£o-maior-com-limites-de-traits" id="consertando-a-funÃ§Ã£o-maior-com-limites-de-traits"><h3>Consertando a FunÃ§Ã£o <code>maior</code> com Limites de Traits</h3></a>
<p>EntÃ£o qualquer hora que vocÃª queira usar um comportamento definido por um trait
em um tipo genÃ©rico, vocÃª precisa especificar aquele trait nos limites dos
parÃ¢metros dos tipos genÃ©ricos. Agora podemos consertar a definiÃ§Ã£o da funÃ§Ã£o
<code>maior</code> que usa um parÃ¢metro de tipo genÃ©rico da Listagem 10-5! Quando deixamos
esse cÃ³digo de lado, nÃ³s recebemos esse erro:</p>
<pre><code class="language-text">error[E0369]: binary operation `&gt;` cannot be applied to type `T`
  |
5 |         if item &gt; maior {
  |            ^^^^
  |
note: an implementation of `std::cmp::PartialOrd` might be missing for `T`
</code></pre>
<p>No corpo de <code>maior</code> nÃ³s querÃ­amos ser capazes de comparar dois valores de tipo
<code>T</code> usando o operador maior-que. Esse operador Ã© definido com o mÃ©todo padrÃ£o
na biblioteca padrÃ£o de trait <code>std::cmp::PartialOrd</code>. EntÃ£o para que possamos
usar o operador maior-que, precisamos especificar <code>PartialOrd</code> nos limites do
trait  para <code>T</code> para que a funÃ§Ã£o <code>maior</code> funcione em partes de qualquer tipo
que possa ser comparada. NÃ£o precisamos trazer <code>PartialOrd</code> para o escopo
porque estÃ¡ no prelÃºdio.</p>
<pre><code class="language-rust ignore">fn maior&lt;T: PartialOrd&gt;(list: &amp;[T]) -&gt; T {
</code></pre>
<p>Se tentarmos compilar isso, receberemos diferentes erros:</p>
<pre><code class="language-text">error[E0508]: cannot move out of type `[T]`, a non-copy array
 --&gt; src/main.rs:4:23
  |
4 |     let mut maior = list[0];
  |         -----------   ^^^^^^^ cannot move out of here
  |         |
  |         hint: to prevent move, use `ref maior` or `ref mut maior`

error[E0507]: cannot move out of borrowed content
 --&gt; src/main.rs:6:9
  |
6 |     for &amp;item in list.iter() {
  |         ^----
  |         ||
  |         |hint: to prevent move, use `ref item` or `ref mut item`
  |         cannot move out of borrowed content
</code></pre>
<p>A chave para esse erro Ã© <code>cannot move out of type [T], a non-copy array</code>. Com
nossas versÃµes nÃ£o genÃ©ricas da funÃ§Ã£o <code>maior</code>, nÃ³s estÃ¡vamos apenas tentando
encontrar o maior <code>i32</code> ou <code>char</code>. Como discutimos no CapÃ­tulo 4, tipos como o
<code>i32</code> e <code>char</code> que tÃªm um tamanho conhecido podem ser armazenados na pilha,
entÃ£o eles implementam o trait <code>Copia</code>. Quando mudamos a funÃ§Ã£o <code>maior</code> para
ser genÃ©rica, agora Ã© possÃ­vel que o parÃ¢metro <code>list</code> poderia ter tipos nele
que nÃ£o implementam o trait <code>Copia</code>, o que significa que nÃ£o serÃ­amos capazes
de mover o valor para fora de <code>list[0]</code> para a variÃ¡vel <code>maior</code>.</p>
<p>Se quisermos ser capazes de chamar esse cÃ³digo com tipos que sÃ£o <code>Copia</code>, nÃ³s
podemos adicionar <code>Copia</code> para os limites de trait de <code>T</code>! A Listagem 10-16
mostra o cÃ³digo completo de uma funÃ§Ã£o <code>maior</code> genÃ©rica que compilarÃ¡ desde que
os tipos dos valores nessa parte que passamos para <code>maior</code> implementem ambos os
traits <code>PartialOrd</code> e <code>Copia</code>, como <code>i32</code> e <code>char</code>:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn maior&lt;T: PartialOrd + Copy&gt;(list: &amp;[T]) -&gt; T {
    let mut maior = list[0];

    for &amp;item in list.iter() {
        if item &gt; maior {
            maior = item;
        }
    }

    maior
}

fn main() {
    let lista_numero = vec![34, 50, 25, 100, 65];

    let result = maior(&amp;lista_numero);
    println!(&quot;O maior nÃºmero Ã© {}&quot;, result);

    let lista_char = vec!['y', 'm', 'a', 'q'];

    let result = maior(&amp;lista_char);
    println!(&quot;O maior char Ã© {}&quot;, result);
}
</code></pre></pre>
<p><span class="caption">Listagem 10-16: Uma definiÃ§Ã£o funcional da funÃ§Ã£o <code>maior</code>
que funciona em qualquer tipo genÃ©rico que implementa os traits <code>PartialOrd</code> e
<code>Copia</code></span></p>
<p>Se nÃ£o quisermos restringir nossa funÃ§Ã£o <code>maior</code> para apenas tipos que
implementam o trait <code>Copia</code>, podemos especificar que <code>T</code> tem o limite de trait
<code>Clone</code> ao invÃ©s de <code>Copia</code> e clonar cada valor na parte quando quisermos que a
funÃ§Ã£o <code>maior</code> tenha domÃ­nio. Usando a funÃ§Ã£o <code>clone</code> significa que
potencialmente estamos fazendo mais alocaÃ§Ãµes no heap, porÃ©m, e alocaÃ§Ãµes no
heap podem ser vagarosas se estivermos trabalhando com grande quantidade de
dados. Outro jeito que podemos implementar <code>maior</code> Ã© para a funÃ§Ã£o retornar uma
referÃªncia ao valor de <code>T</code> em uma parte. Se retornarmos o tipo de retorno para
ser <code>&amp;T</code> ao invÃ©s de <code>T</code> e mudar o corpo da funÃ§Ã£o para retornar uma
referÃªncia, nÃ£o precisarÃ­amos usar os limites de traits <code>Clone</code> ou <code>Copia</code> e
nÃ³s nÃ£o estarÃ­amos fazendo nenhuma alocaÃ§Ã£o de heap.
Tente implementar essas soluÃ§Ãµes alternativas vocÃª mesmo!</p>
<a class="header" href="print.html#usando-limites-de-trait-para-implementar-mÃ©todos-condicionalmente" id="usando-limites-de-trait-para-implementar-mÃ©todos-condicionalmente"><h3>Usando Limites de Trait para Implementar MÃ©todos Condicionalmente</h3></a>
<p>Usando um limite de trait com um bloco <code>impl</code> que usa parÃ¢metros de tipos
genÃ©ricos podemos implementar mÃ©todos condicionalmente apenas para tipos que
implementam os traits especÃ­ficos. Por exemplo, o tipo <code>Par&lt;T&gt;</code> na listagem
10-17 sempre implementa o mÃ©todo <code>novo</code>, mas <code>Par&lt;T&gt;</code> implementa apenas o
<code>cmp_display</code> se seu tipo interno <code>T</code> implementa o trait <code>PartialOrd</code> que
permite a comparaÃ§Ã£o e do trait <code>Display</code> que permite a impressÃ£o:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fmt::Display;

struct Par&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Par&lt;T&gt; {
    fn novo(x: T, y: T) -&gt; Self {
        Self {
            x,
            y,
        }
    }
}

impl&lt;T: Display + PartialOrd&gt; Par&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!(&quot;O maior membro Ã© x = {}&quot;, self.x);
        } else {
            println!(&quot;O maior membro Ã© y = {}&quot;, self.y);
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 10-17: Implementa mÃ©todos condicionalmente em um
tipo genÃ©rico dependendo dos limites de trait</span></p>
<p>Podemos tambÃ©m condicionalmente implementar um trait para qualquer tipo que
implementa um trait. ImplementaÃ§Ãµes de trait de qualquer tipo que satisfazem os
limites de trait sÃ£o chamadas de <em>implementaÃ§Ãµes cobertores</em>, e sÃ£o
extesivamente utilizadas na biblioteca padrÃ£o de Rust. Por exemplo, a
biblioteca padrÃ£o implementa o trait <code>Display</code>. Esse bloco <code>impl</code> se parece com
este cÃ³digo:</p>
<pre><code class="language-rust ignore">impl&lt;T: Display&gt; ToString for T {
    // --snip--
}
</code></pre>
<p>Porque a biblioteca padrÃ£o tem essa implementaÃ§Ã£o cobertor, podemos chamar
o mÃ©todo <code>to_string</code> definido pelo tipo <code>ToString</code> em qualquer tipo que
implemente o trait <code>Display</code>. Por exemplo, nÃ³s podemos transformar inteiros em
seus correspondentes valores de <code>String</code> do seguinte modo, jÃ¡ que inteiros
implementam <code>Display</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = 3.to_string();
#}</code></pre></pre>
<p>ImplementaÃ§Ãµes cobertor aparecem na documentaÃ§Ã£o para traits na seÃ§Ã£o
&quot;Implementadores&quot;.</p>
<p>Traits e limites de traits nos deixam escrever cÃ³digo que usam parÃ¢metros de
tipos genÃ©ricos para reduzir a duplicaÃ§Ã£o, mas ainda sim especificam para o
compilador exatamente qual o comportamento que nosso cÃ³digo precisa que o tipo
genÃ©rico tenha. Porque demos a informaÃ§Ã£o do limite de trait para o compilador,
ele pode checar que todos os tipos concretos usados no nosso cÃ³digo
proporcionam o comportamento correto. Em linguagens dinamicamente tipadas, se
nÃ³s tentÃ¡ssemos chamar um mÃ©todo em um tipo que nÃ£o implementamos, nÃ³s
receberÃ­amos um erro em tempo de execuÃ§Ã£o. O Rust move esses erros para o temp
de compilaÃ§Ã£o para que possamos ser forÃ§ados a resolver os problemas antes que
nosso cÃ³digo seja capaz de rodar. AlÃ©m disso, nÃ³s nÃ£o temos que escrever cÃ³digo
que checa o comportamento em tempo de execuÃ§Ã£o jÃ¡ que jÃ¡ checamos em tempo de
compilaÃ§Ã£o, o que melhora o desempenho comparado com outras linguagens sem ter
que abrir mÃ£o da flexibilidade de tipos genÃ©ricos.</p>
<p>HÃ¡ outro tipo de tipos genÃ©ricos que estamos usando sem nem ao menos perceber
chamados <em>lifetimes</em>. Em vez de nos ajudar a garantir que um tipo tenha o
comportamento que precisamos, lifetimes nos ajudam a garantir que as
referÃªncias sÃ£o vÃ¡lidas tanto quanto precisam ser. Vamos aprender como
lifetimes fazem isso.</p>
<a class="header" href="print.html#validating-references-with-lifetimes" id="validating-references-with-lifetimes"><h2>Validating References with Lifetimes</h2></a>
<p>Quandos falamos sobre referÃªcias no CapÃ­tulo 4, nÃ³s deixamos de fora um detalhe
importante: toda referÃªncia em Rust tem um <em>lifetime</em>, que Ã© o escopo no qual
aquela referÃªncia Ã© vÃ¡lida. A maior parte das vezes tempos de vida sÃ£o implÃ­citos e
inferidos, assim como a maior parte do tempo tipos sÃ£o inferidos. Similarmente
quando temos que anotar tipos porque mÃºltiplos tipos sÃ£o possÃ­veis, hÃ¡ casos em
que os tempos de vida das referÃªncias poderiam estar relacionados de alguns modos
diferentes, entÃ£o Rust precisa que nÃ³s anotemos as relaÃ§Ãµes usando parÃ¢metros
genÃ©ricos de tempo de vida para que ele tenha certeza que as referÃªnciais reais
usadas em tempo de execuÃ§Ã£o serÃ£o definitivamente vÃ¡lidas.</p>
<p>Sim, Ã© um pouco incomum, e serÃ¡ diferente de ferramentas que vocÃª usou em
outras linguagens de programaÃ§Ã£o. Tempos de vida sÃ£o, de alguns jeitos, a
caracterÃ­stica mais distinta de Rust.</p>
<p>Tempos de vida sÃ£o um tÃ³pico grande que nÃ£o poderÃ£o ser cobertos inteiramente
nesse capÃ­tulo, entÃ£o nÃ³s vamos cobrir algumas formas comuns que vocÃª pode
encontrar a sintaxe de tempo de vida nesse capÃ­tulo para que vocÃª se
familiarize com os conceitos. O CapÃ­tulo 19 conterÃ¡ informaÃ§Ãµes mais avanÃ§adas
sobre tudo que tempos de vida podem fazer.</p>
<a class="header" href="print.html#tempos-de-vida-previnem-referÃªncias-soltas" id="tempos-de-vida-previnem-referÃªncias-soltas"><h3>Tempos de Vida Previnem ReferÃªncias Soltas</h3></a>
<p>O principal alvo de lifetimes Ã© prevenir referÃªncias soltas, quais fazem com
que o programa referencie dados quais nÃ³s nÃ£o estamos querendo referenciar.
Considere o programa na Listagem 10-18, com um escopo exterior e um interior.
O escopo exterior declara uma variÃ¡vel chamada <code>r</code> com nenhum valor inicial, e
o escopo interior declara uma variÃ¡vel chamada <code>x</code> com o valor inicial de 5.
Dentro do escopo interior, nÃ³s tentamos estabelecer o valor de <code>r</code> como uma
referÃªncia para <code>x</code>. EntÃ£o, o escopo interior acaba, e nÃ³s tentamos imprimir o
valor de <code>r</code>:</p>
<pre><code class="language-rust ignore">{
    let r;

    {
        let x = 5;
        r = &amp;x;
    }

    println!(&quot;r: {}&quot;, r);
}
</code></pre>
<p><span class="caption">Listagem 10-18: Uma tentativa de usar uma refÃªncia cujo
valor saiu de escopo</span></p>
<blockquote>
<a class="header" href="print.html#variÃ¡veis-nÃ£o-inicializadas-nÃ£o-podem-ser-usadas" id="variÃ¡veis-nÃ£o-inicializadas-nÃ£o-podem-ser-usadas"><h4>VariÃ¡veis NÃ£o Inicializadas NÃ£o Podem Ser Usadas</h4></a>
<p>Os prÃ³ximos exemplos declaram vaÅ•iÃ¡veis sem darem a elas um valor inicial,
entÃ£o o nome da variÃ¡vel existe no escopo exterior. Isso pode parecer um
conflito com Rust nÃ£o ter null. No entanto, se tentarmos usar uma variÃ¡vel
antes de atribuir um valor a ela, nÃ³s teremos um erro em tempo de compilaÃ§Ã£o.
Tente!</p>
</blockquote>
<p>Quando compilarmos esse cÃ³digo, nÃ³s teremos um erro:</p>
<pre><code class="language-text">error: `x` does not live long enough
   |
6  |         r = &amp;x;
   |              - borrow occurs here
7  |     }
   |     ^ `x` dropped here while still borrowed
...
10 | }
   | - borrowed value needs to live until here
</code></pre>
<p>A variÃ¡vel <code>x</code> nÃ£o &quot;vive o suficiente&quot;. Por que nÃ£o? Bem, <code>x</code> vai sair de
escopo quando passarmos pela chaves na linha 7, terminando o escopo interior.
Mas <code>r</code> Ã© vÃ¡lida para o escopo exterior; seu escopo Ã© maior e dizemos que ela
&quot;vive mais tempo&quot;. Se Rust permitisse que esse cÃ³digo funcionasse, <code>r</code> estaria
fazendo uma referÃªncia Ã  memÃ³ria que foi desalocada quando <code>x</code> saiu de escopo,
e qualquer coisa que tentÃ¡ssemos fazer com <code>r</code> nÃ£o funcionaria corretamente.
EntÃ£o como o Rust determina que esse cÃ³digo nÃ£o deve ser permitido?</p>
<a class="header" href="print.html#o-verificador-de-emprÃ©stimos" id="o-verificador-de-emprÃ©stimos"><h4>O Verificador de EmprÃ©stimos</h4></a>
<p>A parte do compilador chamada de <em>verificador de emprÃ©stimos</em> compara escopos
para determinar que todos os emprÃ©stimos sÃ£o vÃ¡lidos. A Listagem 10-19 mostra o
mesmo exemplo da Listagem 10-18 com anotaÃ§Ãµes mostrando os tempos de vida das
variÃ¡veis.</p>
<pre><code class="language-rust ignore">{
    let r;         // -------+-- 'a
                   //        |
    {              //        |
        let x = 5; // -+-----+-- 'b
        r = &amp;x;    //  |     |
    }              // -+     |
                   //        |
    println!(&quot;r: {}&quot;, r); // |
                   //        |
                   // -------+
}
</code></pre>
<p><span class="caption">Listagem 10-19: AnotaÃ§Ãµes de tempos de vida de <code>r</code> e <code>x</code>,
chamadas de <code>a</code> e <code>b</code> respectivamente</span></p>
<p>NÃ³s anotamos o tempo de vida de <code>r</code> com <code>a</code> e o tempo de vida de <code>x</code> com <code>b</code>.
Como vocÃª pode ver, o bloco interior de <code>'b</code> Ã© bem menor que o bloco de tempo
de vida do exterior <code>'a'</code>. Em tempo de compilaÃ§Ã£o, o Rust compara o tamanho dos
dois tempos de vida e vÃª que <code>r</code> tem um tempo de vida de <code>'a</code>, mas que ele se
refere a um objeto com um tempo de vida <code>'b</code>. O programa Ã© rejeitado porque o
tempo de vida de <code>'b</code> Ã© mais curto que o tempo de vida de <code>'a</code>: o sujeito da
referÃªncia nÃ£o vive tanto quanto a referÃªncia.</p>
<p>Vamos olhar para o exemplo na Listagem 10-20 que nÃ£o tenta fazer uma referÃªncia
solta e compila sem nenhum erro:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    let x = 5;            // -----+-- 'b
                          //      |
    let r = &amp;x;           // --+--+-- 'a
                          //   |  |
    println!(&quot;r: {}&quot;, r); //   |  |
                          // --+  |
}                         // -----+
#}</code></pre></pre>
<p><span class="caption">Listagem 10-20: Uma referÃªncia vÃ¡lida porque os dados tÃªm
um tempo de vida maior do que o da referÃªncia</span></p>
<p>Aqui, <code>x</code> tem o tempo de vida de <code>'b</code>, que nesse caso tem um tempo de vida
maior que o de <code>'a</code>. Isso quer dizer que <code>r</code> pode referenciar <code>x</code>: o Rust sabe
que a referÃªncia em <code>r</code> serÃ¡ sempre vÃ¡lida enquanto <code>x</code> for vÃ¡lido.</p>
<p>Agora que mostramos onde os tempos de vida de referÃªncias estÃ£o em um exemplo
concreto e discutimos como Rust analisa tempos de vida para garantir que
referÃªncias sempre serÃ£o vÃ¡lidas, vamos falar sobre tempos de vidas genÃ©ricos
de parÃ¢metros e retornar valores no contexto das funÃ§Ãµes.</p>
<a class="header" href="print.html#tempos-de-vida-gÃ©nericos-em-funÃ§Ãµes" id="tempos-de-vida-gÃ©nericos-em-funÃ§Ãµes"><h3>Tempos de Vida GÃ©nericos em FunÃ§Ãµes</h3></a>
<p>Vamos escrever uma funÃ§Ã£o que retornarÃ¡ a mais longa de dois cortes de string.
NÃ³s queremos ser capazes de chamar essa funÃ§Ã£o passando para ela dois cortes
de strings, e queremos que retorne uma string. O cÃ³digo na Listagem 10-21
deve imprimir <code>A string mais longa Ã© abcd</code> uma vez que tivermos implementado a
funÃ§Ã£o <code>maior</code>:</p>
<p><span class="filename">Nome do Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let string1 = String::from(&quot;abcd&quot;);
    let string2 = &quot;xyz&quot;;

    let resultado = maior(string1.as_str(), string2);
    println!(&quot;A string mais longa Ã© {}&quot;, resultado);
}
</code></pre>
<p><span class="caption">Listagem 10-21: Uma funÃ§Ã£o <code>main</code> que chama pela funÃ§Ã£o
<code>maior</code> para achar a mais longa entre duas strings</span></p>
<p>Note que queremos que a funÃ§Ã£o pegue cortes de string (que sÃ£o referÃªncias,
como falamos no CapÃ­tulo 4) jÃ¡ que nÃ£o queremos que a funÃ§Ã£o <code>maior</code> tome posse
de seus argumentos. NÃ³s queremos que uma funÃ§Ã£o seja capaz de aceitar cortes de
uma <code>String</code> (que Ã© o tipo de variÃ¡vel <code>string1</code>) assim como literais de string
(que Ã© o que a variÃ¡vel <code>strin2</code> contÃ©m).</p>
<p>Recorra Ã  seÃ§Ã£o do CapÃ­tulo 4 &quot;Cortes de Strings como ParÃ¢metros&quot; para mais
discussÃµes sobre porque esses sÃ£o os argumentos que queremos.</p>
<p>Se tentarmos implementar a funÃ§Ã£o <code>maior</code> como mostrado na Listagem 10-22 ela
nÃ£o vai compilar:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn maior(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre>
<p><span class="caption">Listagem 10-22: Uma implementaÃ§Ã£o da funÃ§Ã£o <code>maior</code> que
retorna o mais longo de dois cortes de string, mas ele nÃ£o compila ainda</span></p>
<p>Ao invÃ©s disso recebemos o seguinte erro que fala sobre tempos de vida:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
   |
1  | fn maior(x: &amp;str, y: &amp;str) -&gt; &amp;str {
   |                                 ^ expected lifetime parameter
   |
   = help: this function's return type contains a borrowed value, but the
   signature does not say whether it is borrowed from `x` or `y`
</code></pre>
<p>O texto de ajuda estÃ¡ nos dizendo que o tipo de retorno precisa de um parÃ¢metro
de tempo de vida genÃ©rico nele porque o Rust nÃ£o pode dizer se a referÃªncia que
estÃ¡ sendo retornada se refere a <code>x</code> ou <code>y</code>. Atualmente, nÃ³s tambÃ©m nÃ£o
sabemos, jÃ¡ que o bloco <code>if</code> no corpo dessa funÃ§Ã£o retorna uma referÃªncia para
<code>x</code> e o bloco <code>else</code> retorna uma referÃªncia para <code>y</code>!</p>
<p>Enquanto estamos definindo essa funÃ§Ã£o, nÃ£o sabemos os valores concretos que
serÃ£o passados para essa funÃ§Ã£o, entÃ£o nÃ£o sabemos se o caso <code>if</code> ou o caso
<code>else</code> serÃ¡ executado. NÃ³s tambÃ©m nÃ£o sabemos os tempos de vida concretos das
referÃªncias que serÃ£o passadas, entÃ£o nÃ£o podemos olhar para esses escopos como
fizemos nas Listagem 10-19 e 10-20 afim de determinar que a referÃªncia que
retornaremos sempre serÃ¡ vÃ¡lida. O verificador de emprÃ©stimos nÃ£o consegue
determinar isso tambÃ©m porque nÃ£o sabe como os tempos de vida de <code>x</code> e <code>y</code> se
relacionam com o tempo de vida do valor de retorno. NÃ³s vamos adicionar
parÃ¢metros genÃ©ricos de tempo de vida que definirÃ£o a relaÃ§Ã£o entre as
referÃªncias para que o verificador de emprÃ©stimos possa fazer sua anÃ¡lise.</p>
<a class="header" href="print.html#sintaxe-de-anotaÃ§Ã£o-de-tempo-de-vida" id="sintaxe-de-anotaÃ§Ã£o-de-tempo-de-vida"><h3>Sintaxe de AnotaÃ§Ã£o de Tempo de Vida</h3></a>
<p>AnotaÃ§Ãµes de tempo de vida nÃ£o mudam quanto tempo qualquer uma das referÃªncias
envolvidas viverÃ£o. Do mesmo modo que funÃ§Ãµes podem aceitar qualquer tipo de
assinatura que especifica um parÃ¢metro de tipo genÃ©rico, funÃ§Ãµes podem aceitar
referÃªncias com qualquer tempo de vida quando a assinatura especificar um
parÃ¢metro genÃ©rico de tempo de vida. O que anotaÃ§Ãµes de tempo de vida fazem Ã©
relacionar os tempos de vida de mÃºltiplas referÃªncias uns com os outros.</p>
<p>AnotaÃ§Ãµes de tempo de vida tem uma sintaxe levemente incomum: os nomes dos
parÃ¢metros de tempos de vida precisam comeÃ§ar com uma apÃ³strofe <code>'</code>. Os nomes
dos parÃ¢metros dos tempos de vida sÃ£o usualmente todos em caixa baixa, e como
tipos genÃ©ricos, seu nome usualmente sÃ£o bem curtos. <code>'a</code> Ã© o nome que a maior
parte das pessoas usam por padrÃ£o. ParÃ¢metros de anotaÃ§Ãµes de tempos de vida
vÃ£o depois do <code>&amp;</code> de uma referÃªncia, e um espaÃ§o separa a anotaÃ§Ã£o de tempo de
vida do tipo da referÃªncia.</p>
<p>Aqui vÃ£o alguns exemplos: nÃ³s temos uma referÃªncia para um <code>i32</code> sem um
parÃ¢metro tempo de vida, uma referÃªncia para um <code>i32</code> que tem um parÃ¢metro de
tempo de vida chamado <code>'a</code>:</p>
<pre><code class="language-rust ignore">&amp;i32        // uma referÃªncia
&amp;'a i32     // uma referÃªncia com um tempo de vida explÃ­cito
&amp;'a mut i32 // uma referÃªncia mutÃ¡vel com um tempo de vida explÃ­cito
</code></pre>
<p>Uma anotaÃ§Ã£o de tempo de vida por si sÃ³ nÃ£o tem muito significado: anotaÃ§Ãµes de
tempos de vida dizem ao Rust como os parÃ¢metros genÃ©ricos de tempos de vida de
mÃºltiplas referÃªncias se relacionam uns com os outros. Se tivermos uma funÃ§Ã£o
com o parÃ¢metro <code>primeiro</code> que Ã© uma referÃªncia para um <code>i32</code> que tem um tempo
de vida de <code>'a</code>, e a funÃ§Ã£o tem outro parÃ¢metro chamado <code>segundo</code> que Ã© outra
referÃªncia para um <code>i32</code> que tambÃ©m possui um tempo de vida <code>'a</code>, essas duas
anotaÃ§Ãµes de tempo de vida com o mesmo nome indicam que as referÃªncias
<code>primeiro</code> e <code>segundo</code> precisam ambas viver tanto quanto o mesmo tempo de vida
genÃ©rico.</p>
<a class="header" href="print.html#anotaÃ§Ãµes-de-tempo-de-vida-em-assinaturas-de-funÃ§Ãµes" id="anotaÃ§Ãµes-de-tempo-de-vida-em-assinaturas-de-funÃ§Ãµes"><h3>AnotaÃ§Ãµes de Tempo de Vida em Assinaturas de FunÃ§Ãµes</h3></a>
<p>Vamos olhar para anotaÃ§Ãµes de tempo de vida no contexto da funÃ§Ã£o <code>maior</code> que
estamos trabalhando. Assim como parÃ¢metros de tipos genÃ©ricos, parÃ¢metros de
tempos de vida genÃ©ricos precisam ser declarados dentro de colchetes angulares
entre o nome da funÃ§Ã£o e a lista de parÃ¢metros. A limitanÃ§Ã£o que queremos
dar ao Rust Ã© que para as referÃªncias nos parÃ¢metros e o valor de retorno devem
ter o mesmo tempo de vida, o qual nomearemos <code>'a</code> e adicionaremos para cada uma
das referÃªncias como mostrado na Listagem 10-23:</p>
<p><span class="filename">Nome do Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn maior&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 10-23: A definiÃ§Ã£o da funÃ§Ã£o <code>maior</code> especifica
todas as referÃªncias na assinatura como tendo o mesmo tempo de vida, <code>'a</code></span></p>
<p>Isso compilarÃ¡ e produzirÃ¡ o resultado que queremos quando usada com a funÃ§Ã£o
<code>main</code> na Listagem 10-21.</p>
<p>A assinatura de funÃ§Ã£o agora diz que pra algum tempo de vida <code>'a</code>, a funÃ§Ã£o
receberÃ¡ dois parÃ¢metros, ambos serÃ£o cortes de string que vivem pelo menos
tanto quanto o tempo de vida <code>'a</code>. A funÃ§Ã£o retornarÃ¡ um corte de string que
tambÃ©m vai durar tanto quanto o tempo de vida <code>'a</code>. Esse Ã© o contrato que
estamos dizendo ao Rust que queremos garantir.</p>
<p>Especificando os parÃ¢metros de tempo de vida nessa assinatura de funÃ§Ã£o, nÃ£o
estamos modificando os tempos de vida de quaisquer valores passados ou
retornados, mas estamos dizendo que quaisqueres valores que nÃ£o concordem com
esse contrato devem ser rejeitados pelo verificador de emprÃ©stimos. Essa funÃ§Ã£o
nÃ£o sabe (ou nÃ£o precisa saber) exatamente quanto tempo <code>x</code> e <code>y</code> vÃ£o viver,
apenas precisa saber que existe algum escopo que pode ser substituÃ­do por <code>'a</code>
que irÃ¡ satisfazer essa assinatura.</p>
<p>Quando estiver anotando tempos de vidas em funÃ§Ãµes, as anotaÃ§Ãµes vÃ£o na
assinatura da funÃ§Ã£o, e nÃ£o no cÃ³digo no corpo da funÃ§Ã£o. Isso acontece porque
o Rust consegue analisar o cÃ³digo dentro da funÃ§Ã£o sem nenhuma ajuda, mas
quando uma funÃ§Ã£o tem referÃªncias para ou de cÃ³digos de fora daquela funÃ§Ã£o,
os tempos de vida dos argumentos ou os valores de retorno poderÃ£o ser
diferentes cada vez que a funÃ§Ã£o Ã© chamada. Isso seria incrivelmente custoso e
frequentemente impossÃ­vel para o Rust descobrir. Nesse caso, precisamos anotar
os tempos de vida nÃ³s mesmos.</p>
<p>Quando referÃªncias concretas sÃ£o passadas para <code>maior</code>, o tempo de vida
concreto que Ã© substituÃ­do por <code>'a</code> Ã© a parte do escopo de <code>x</code> que sobrepÃµe o
escopo de <code>y</code>. JÃ¡ que escopos sempre se aninham, outra maneira de dizer isso Ã©
que o tempo de vida genÃ©rico <code>'a</code> terÃ¡ um tempo de vida concreto igual ao menor
dos tempos de vida de <code>x</code> e <code>y</code>. Porque nÃ³s anotamos a referÃªncia retornada com
o mesmo parÃ¢metro <code>'a</code>, a referÃªncia retornada serÃ¡ portanto garantida de ser
vÃ¡lida tanto quanto for o tempo de vida mais curto de <code>x</code> e <code>y</code>.</p>
<p>Vamos ver como isso restringe o uso da funÃ§Ã£o <code>maior</code> passando referÃªncias que
tem diferentes tempos de vida concretos. A Listagem 10-25 Ã© um exemplo direto
que deve corresponder suas intuiÃ§Ãµes de qualquer linguagem: <code>string1</code> Ã© vÃ¡lida
atÃ© o final do escopo exterior, <code>strin2</code> Ã© vÃ¡lida atÃ© o final do escopo, a
<code>string2</code> Ã© vÃ¡lida atÃ© o final do escopo interior. Com o verificador de
emprÃ©stimos aprovando esse cÃ³digo; ele vai compilar e imprimir
<code>A string mais longa Ã©</code>:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn maior&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
#     if x.len() &gt; y.len() {
#         x
#     } else {
#         y
#     }
# }
#
fn main() {
    let string1 = String::from(&quot;a string longa Ã© longa&quot;);

    {
        let string2 = String::from(&quot;xyz&quot;);
        let resultado = maior(string1.as_str(), string2.as_str());
        println!(&quot;A string mais longa Ã© {}&quot;, resultado);
    }
}
</code></pre></pre>
<p><span class="caption">Listagem 10-24: Usando a funÃ§Ã£o <code>maior</code> com referÃªncias
para valores de <code>String</code> que tem tempos de vida concretos diferentes</span></p>
<p>Em seguida, vamos tentar um exemplo que vai mostrar que o tempo de vida da
referÃªncia em <code>resultado</code> precisa ser o menor dos tempos de vida dos dois
argumentos. NÃ³s vamos mover a declaraÃ§Ã£o da variÃ¡vel <code>resultado</code> para fora do
escopo interior, mas deixar a atribuiÃ§Ã£o do valor para a variÃ¡vel <code>resultado</code>
dentro do escopo com <code>string2</code>. Em seguida, vamos mover o <code>println!</code> que usa o
<code>resultado</code> fora do escopo interior, depois que ele terminou. O cÃ³digo na
Listagem 10-25 nÃ£o compilarÃ¡:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let string1 = String::from(&quot;a string longa Ã© longa&quot;);
    let resultado;
    {
        let string2 = String::from(&quot;xyz&quot;);
        resultado = longest(string1.as_str(), string2.as_str());
    }
    println!(&quot;A string mais longa Ã© {}&quot;, resultado);
}
</code></pre>
<p><span class="caption">Listagem 10-25: A tentativa de usar <code>resultado</code> depois
que <code>string2</code> saiu de escopo nÃ£o compilarÃ¡</span></p>
<p>Se tentarmos compilar isso, receberemos esse erro:</p>
<pre><code class="language-text">error: `string2` does not live long enough
   |
6  |         resultadod = longest(string1.as_str(), string2.as_str());
   |                                            ------- borrow occurs here
7  |     }
   |     ^ `string2` dropped here while still borrowed
8  |     println!(&quot;The longest string is {}&quot;, result);
9  | }
   | - borrowed value needs to live until here
</code></pre>
<p>O erro estÃ¡ dizendo que para <code>resultado</code> ser vÃ¡lido para <code>println!</code>, a
<code>string2</code> teria que ser vÃ¡lida atÃ© o final do escopo exterior. Rust sabe disso
porque nÃ³s anotamos os tempos de vida dos parÃ¢metros da funÃ§Ã£o e retornamos
valores com o mesmo parÃ¢metro do tempo de vida, <code>'a</code>.</p>
<p>NÃ³s podemos olhar para esse cÃ³digo como humanos e ver que a <code>string1</code> Ã© mais
longa, e portanto <code>resultado</code> conterÃ¡ a referÃªncia para a <code>string1</code>. Porque a
<code>string1</code> nÃ£o saiu de escopo ainda, a referÃªncia para <code>string1</code> ainda serÃ¡
vÃ¡lida para o <code>println!</code>. No entanto, o que dissemos ao Rust com os parÃ¢metros
de tempo de vida Ã© que o tempo de vida da referÃªncia retornado pela funÃ§Ã£o
<code>maior</code> Ã© o mesmo que o menor dos tempos de vida das referÃªncias passadas.
Portanto, o verificador de emprÃ©stimos nÃ£o permite o cÃ³digo da Listagem 10-25
como possÃ­vel jÃ¡ que tem um referÃªncia invÃ¡lida.</p>
<p>Tente fazer mais alguns experimentos que variam os valores e os tempos de vidas
das referÃªncias passadas para a funÃ§Ã£o <code>maior</code> e como a referÃªncia retornada Ã©
usada. Crie hipÃ³teses sobre seus experimentos se eles vÃ£o passar pelo
verificador de emprÃ©stimos ou nÃ£o antes de vocÃª compilar, e entÃ£o cheque para
ver se vocÃª estÃ¡ certo!</p>
<a class="header" href="print.html#pensando-em-termos-de-tempos-de-vida" id="pensando-em-termos-de-tempos-de-vida"><h3>Pensando em Termos de Tempos de Vida</h3></a>
<p>O modo exato de especificar parÃ¢metros de tempos de vida depende do que sua
funÃ§Ã£o estÃ¡ fazendo. Por exemplo, se mudaramos a implementaÃ§Ã£o da funÃ§Ã£o
<code>maior</code> para sempre retornar o primeiro argumento ao invÃ©s do corte de string
mais longo, nÃ£o precisarÃ­amos especificar um tempo de vida no parÃ¢metro <code>y</code>.
Este cÃ³digo compila:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;'a str {
    x
}
#}</code></pre></pre>
<p>Nesse exemplo, especificamos o tempo de vida do parÃ¢metro <code>'a</code> para o parÃ¢metro
<code>x</code> e o tipo de retorno, mas, nÃ£o para o parÃ¢metro <code>y</code>, jÃ¡ que o tempo de vida
de <code>y</code> nÃ£o tem qualquer relaÃ§Ã£o com o tempo de vida <code>x</code> ou o valor retornado.</p>
<p>Quando retornarmos uma referÃªncia de um uma funÃ§Ã£o, o parÃ¢metro de tempo de
vida para o tipo de retorno precisa combinar o parÃ¢metro do tempo de vida de um
dos argumentos. Se a referÃªncia retornada <em>nÃ£o</em> refere a nenhum dos argumentos,
a Ãºnica outra possibilidade Ã© que refira a um valor criado dentro da funÃ§Ã£o, o
que seria uma referÃªncia solta jÃ¡ que o valor sairÃ¡ de escopo no fim da funÃ§Ã£o.
Considere essa tentativa da funÃ§Ã£o <code>maior</code> que nÃ£o compilarÃ¡:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn maior&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
    let resultado = String::from(&quot;string muito longa&quot;);
    resultado.as_str()
}
</code></pre>
<p>Mesmo especificando um parÃ¢metro de tempo de vida <code>'a</code> para o tipo de retorno,
essa implementaÃ§Ã£o falha em compilar porque o valor de retorno do tempo de vida
nÃ£o Ã© relacionado com o tempo de vida dos parÃ¢metros de forma alguma. Esta Ã© a
mensagem de erro que recebemos:</p>
<pre><code class="language-text">error: `resultado` does not live long enough
  |
3 |     resultado.as_str()
  |     ^^^^^^ does not live long enough
4 | }
  | - borrowed value only lives until here
  |
note: borrowed value must be valid for the lifetime 'a as defined on the block
at 1:44...
  |
1 | fn maior&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
  |                                             ^
</code></pre>
<p>O problema Ã© que <code>resultado</code> sairÃ¡ de escopo e serÃ¡ limpo no final da funÃ§Ã£o
<code>maior</code>, e estamos tentando retornar uma referÃªncia para <code>resultado</code> da funÃ§Ã£o.
NÃ£o hÃ¡ nenhum modo que possamos especificar parÃ¢metros de tempo de vida que
mudariam uma referÃªncia solta, e o Rust nÃ£o nos deixarÃ¡ criar uma referÃªncia
solta. Nesse caso, a melhor soluÃ§Ã£o seria retornar um tipo de dado com posse
ao invÃ©s de uma referÃªncia de modo que a funÃ§Ã£o chamadora Ã© entÃ£o responsÃ¡vel
por limpar o valor.</p>
<p>Em Ãºltima anÃ¡lise, a sintaxe de tempo de vida Ã© sobre conectar tempos de vida
de vÃ¡rios argumentos e retornar valores de funÃ§Ãµes. Uma vez que estÃ£o
conectados, o Rust tem informaÃ§Ã£o o suficiente para permitir operaÃ§Ãµes seguras
de memÃ³ria e nÃ£o permitir operaÃ§Ãµes que criariam ponteiros soltos ou outro tipo
de violaÃ§Ã£o Ã  seguranÃ§a da memÃ³ria.</p>
<a class="header" href="print.html#anotaÃ§Ãµes-de-tempo-de-vida-em-definiÃ§Ãµes-de-struct" id="anotaÃ§Ãµes-de-tempo-de-vida-em-definiÃ§Ãµes-de-struct"><h3>AnotaÃ§Ãµes de Tempo de Vida em DefiniÃ§Ãµes de Struct</h3></a>
<p>AtÃ© agora, nÃ³s sÃ³ definimos structs para conter tipos com posse. Ã‰ possÃ­vel
para structs manter referÃªncias, mas precisamos adicionar anotaÃ§Ãµes de tempo de
vida em todas as referÃªncias na definiÃ§Ã£o do struct. A Listagem 10-26 tem a
struct chamada <code>ExcertoImportante</code> que contÃ©m um corte de string:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct ExcertoImportante&lt;'a&gt; {
    parte: &amp;'a str,
}

fn main() {
    let romance = String::from(&quot;Chame-me Ishmael. HÃ¡ alguns anos...&quot;);
    let primeira_sentenca = romance.split('.')
        .next()
        .expect(&quot;NÃ£o pÃ´de achar um '.'&quot;);
    let i = ImportantExcerpt { parte: primeira_sentenca };
}
</code></pre></pre>
<p><span class="caption">Listagem 10-26: Um struct que contÃ©m uma referÃªncia,
entÃ£o sua definiÃ§Ã£o precisa de uma anotaÃ§Ã£o de tempo de vida</span></p>
<p>Esse struct tem um campo, <code>parte</code>, que contÃ©m um corte de string, que Ã© uma
referÃªncia. Assim como tipos genÃ©ricos de dados, temos que declarar o nome do
parÃ¢metro genÃ©rico de tempo de vida dentro de colchetes angulares depois do
nome do struct para que possamos usar o parÃ¢metro de tempo de vida no corpo da
definiÃ§Ã£o do struct.</p>
<p>A funÃ§Ã£o <code>main</code> cria uma instÃ¢ncia da struct <code>ExcertoImportante</code> que contÃ©m uma
referÃªncia pra a primeira sentenÃ§a da <code>String</code> com posse da variÃ¡vel <code>romance</code>.</p>
<a class="header" href="print.html#elisÃ£o-de-tempo-de-vida" id="elisÃ£o-de-tempo-de-vida"><h3>ElisÃ£o de Tempo de Vida</h3></a>
<p>Nessa seÃ§Ã£o, nÃ³s aprendemos que toda referÃªncia tem um tempo de vida, e nÃ³s
precisamos especificar os parÃ¢metros dos tempos de vida para funÃ§Ãµes ou
estruturas que usam referÃªncias. No entanto, no CapÃ­tulo 4 nÃ³s tÃ­nhamos a
funÃ§Ã£o na seÃ§Ã£o &quot;Cortes de Strings&quot;, mostradas novamente na Listagem 10-27, que
compilam sem anotaÃ§Ãµes de tempo de vida:</p>
<p><span class="filename">Nome do arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn primeira_palavra(s: &amp;str) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
#}</code></pre></pre>
<p><span class="caption">Listagem 10-27: Uma funÃ§Ã£o definida no CapÃ­tulo 4 que
compila sem anotaÃ§Ãµes de tempo de vida, mesmo o parÃ¢metro e o tipo de retorno
sendo referÃªncias</span></p>
<p>A razÃ£o pela qual essa funÃ§Ã£o compila sem anotaÃ§Ãµes de tempo de vida Ã©
histÃ³rica: em versÃµes mais antigas de pre Rust-1.0, isso nÃ£o teria compilado.
Toda referÃªncia precisava de um tempo de vida explÃ­cito. Naquele tempo, a
assinatura da funÃ§Ã£o teria sido escrita da seguinte forma:</p>
<pre><code class="language-rust ignore">fn primeira_palavra&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
</code></pre>
<p>Depois de escrever muito cÃ³digo em Rust, o time de Rust descobriu que os
programadores de Rust estavam digitando as mesmas anotaÃ§Ãµes de tempo de vida
de novo e de novo. Essas situaÃ§Ãµes eram previsÃ­veis e seguiam alguns padrÃµes
determinÃ­sticos. O time de Rust programou esses padrÃµes no compilador de cÃ³digo
de Rust para que o verificador de emprÃ©stimos pode inferir os tempos de vida
dessas situaÃ§Ãµes sem forÃ§ar o programador adicionar essas anotaÃ§Ãµes
explicitamente.</p>
<p>NÃ³s mencionamos essa parte da histÃ³ria de Rust porque Ã© inteiramente possÃ­vel
que mais padrÃµes determinÃ­sticos surgirÃ£o e serÃ£o adicionado ao compilador. No
futuro, atÃ© menos anotaÃ§Ãµes de tempo de vida serÃ£o necessÃ¡rias.</p>
<p>Os padrÃµes programados nas anÃ¡lises de referÃªncia de Rust sÃ£o chamados de
<em>regras de elisÃ£o de tempo de vida</em>. Essas nÃ£o sÃ£o regras para o programador
seguir; as regras sÃ£o um conjunto de casos particular que o compilador irÃ¡
considerar, e se seu cÃ³digo se encaixa nesses casos, vocÃª nÃ£o precisa escrever
os tempos de vida explicitamente.</p>
<p>As regras de elisÃ£o nÃ£o fornecem total inferÃªncia:  se o Rust aplicar as regras
de forma determinÃ­stica ainda podem haver ambiguidades como quais tempos
de vida as referÃªncias restantes deveriam ter. Nesse caso, o compilador darÃ¡ um
erro que pode ser solucionado adicionando anotaÃ§Ãµes de tempo de vida que
correspondem com as suas intenÃ§Ãµes para como as referÃªncias se relacionam umas
com as outras.</p>
<p>Primeiro, algumas definiÃ§Ãµes: Tempos de vida em parÃ¢metros de funÃ§Ãµes ou
mÃ©todos sÃ£o chamadas <em>tempos de vida de entrada</em>, e tempos de vida em valores
de retorno sÃ£o chamados de <em>tempos de vida de saÃ­da</em>.</p>
<p>Agora, as regras que o compilador usa para descobrir quais referÃªncias de
tempos de vidas tÃªm quando nÃ£o hÃ¡ anotaÃ§Ãµes explÃ­citas. A primeira regra se
aplica a tempos de vida de entrada, e a segunda regra se aplica a tempos de
vida de saÃ­da. Se o compilador chega no fim das trÃªs regras e ainda hÃ¡
referÃªncias que ele nÃ£o consegue descobrir tempos de vida, o compilador irÃ¡
parar com um erro.</p>
<ol>
<li>
<p>Cada parÃ¢metro que Ã© uma referÃªncia tem seu prÃ³prio parÃ¢metro de tempo de
vida. Em outras palavras, uma funÃ§Ã£o com um parÃ¢metro tem um parÃ¢metro de
tempo de vida: <code>fn foo&lt;'a&gt;(x: &amp;'a i32)</code>, uma funÃ§Ã£o com dois argumentos
recebe dois parÃ¢metros de tempo de vida separados:
<code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)</code>, e assim por diante.</p>
</li>
<li>
<p>Se hÃ¡ exatamente uma entrada de parÃ¢metro de tempo de vida, aquele tempo de
vida Ã© atribuÃ­do para todos os parÃ¢metros de saÃ­da do tempo de vida:
<code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code>.</p>
</li>
<li>
<p>Se hÃ¡ mÃºltiplas entradas de parÃ¢metros de tempo de vida, mas uma delas Ã©
<code>&amp;self</code> ou <code>&amp;mut self</code> porque Ã© um mÃ©todo, entÃ£o o tempo de vida de <code>self</code> Ã©
atribuÃ­do para todos os parÃ¢metro de tempo de vida de saÃ­da. Isso melhora a
escrita de mÃ©todos</p>
</li>
</ol>
<p>Vamos fingir que somos o compilador e aplicamos essas regras para descobrir
quais os tempos de vida das referÃªncias na assinatura da funÃ§Ã£o
<code>primeira_palavra</code> na Listagem 10-27. A assinatura comeÃ§a sem nenhum tempo de
vida associado com as referÃªncias:</p>
<pre><code class="language-rust ignore">fn primeira_palavra(s: &amp;str) -&gt; &amp;str {
</code></pre>
<p>EntÃ£o nÃ³s (como o compilador) aplicamos a primeira regra, que diz que cada
parÃ¢metro tem sem prÃ³prio tempo de vida. NÃ³s vamos chama-lo de <code>'a</code> como Ã©
usual, entÃ£o agora a assinatura Ã©:</p>
<pre><code class="language-rust ignore">fn primeira_palavra&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;str {
</code></pre>
<p>Ã€ segunda regra, que se aplica porque existe apenas um tempo de vida. A
segunda regra diz que o tempo de vida de um parÃ¢metro de entrada Ã© atribuÃ­do
a um tempo de vida de saÃ­da, entÃ£o agora a assinatura Ã©:</p>
<pre><code class="language-rust ignore">fn primeira_palavra&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
</code></pre>
<p>Agora todas as referÃªncias nessa assinatura de funÃ§Ã£o possuem tempos de vida, e
o compilador pode continuar sua anÃ¡lise sem precisar que o programador anote os
tempos de vida na assinatura dessa funÃ§Ã£o.</p>
<p>Vamos fazer outro exemplo, dessa vez com a funÃ§Ã£o <code>maior</code> que nÃ£o tinha
parÃ¢metros de tempo de vida quando comeÃ§amos a trabalhar com ela na Listagem
10-22:</p>
<pre><code class="language-rust ignore">fn maior(x: &amp;str, y: &amp;str) -&gt; &amp;str {
</code></pre>
<p>Fingindo que somos o compilador novamente, vamos aplicar a primeira regra: cada
parÃ¢metro tem seu prÃ³prio tempo de vida. Dessa vez temos dois parÃ¢metros, entÃ£o
temos dois tempos de vida:</p>
<pre><code class="language-rust ignore">fn maior&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;str {
</code></pre>
<p>Olhando para a segunda regra, ela nÃ£o se aplica jÃ¡ que hÃ¡ mais de uma entrada
de tempo de vida. Olhando para a terceira regra, ela tambÃ©m nÃ£o se aplica
porque isso Ã© uma funÃ§Ã£o e nÃ£o um mÃ©todo, entÃ£o nenhum dos parÃ¢metros sÃ£o
<code>self</code>. EntÃ£o, acabaram as regras, mas nÃ£o descobrimos qual Ã© o tempo de vida
do tipo de retorno. Ã‰ por isso que recebemos um erro quando tentamos
compilar o cÃ³digo da Listagem 10-22: o compilador usou as regras de elisÃ£o de
tempo de vida que sabia, mas ainda sim nÃ£o conseguiu descobrir todos os tempos
de vida das referÃªncias na assinatura.</p>
<p>Porque a terceira regra sÃ³ se aplica em assinaturas de mÃ©todos, vamos olhar
tempos de vida nesse contexto agora, e ver porque a terceira regra significa
que nÃ£o temos que anotar tempos de vida em assinaturas de mÃ©todos muito
frequentemente.</p>
<a class="header" href="print.html#anotaÃ§Ãµes-de-tempo-de-vida-em-definiÃ§Ãµes-de-mÃ©todos" id="anotaÃ§Ãµes-de-tempo-de-vida-em-definiÃ§Ãµes-de-mÃ©todos"><h3>AnotaÃ§Ãµes de Tempo de Vida em DefiniÃ§Ãµes de MÃ©todos</h3></a>
<p>Quando implementamos mÃ©todos em uma struct com tempos de vida, a sintaxe Ã©
novamente a mesma da de parÃ¢metros de tipos genÃ©ricos que mostramos na Listagem
10-11: o lugar que parÃ¢metros de tempos de vida sÃ£o declarados e usados depende
se o parÃ¢metro de tempo de vida Ã© relacionado aos campos do struct ou aos
argumentos dos mÃ©todos e dos valores de retorno.</p>
<p>Nomes de tempos de vida para campos de estruturas sempre precisam ser
declarados apÃ³s a palavra-chave <code>impl</code> e entÃ£o usadas apÃ³s o nome da struct,
jÃ¡ que esses tempos de vida sÃ£o partes do tipo da struct.</p>
<p>Em assinaturas de mÃ©todos dentro do bloco <code>impl</code>, as referÃªncias podem estar
amarradas Ã s referÃªncias de tempo de vida nos campos de struct, ou elas podem
ser independentes. AlÃ©m disso, as regras de elisÃ£o de tempo de vida
constantemente fazem com que anotaÃ§Ãµes nÃ£o sejam necessÃ¡rias em assinaturas de
mÃ©todos. Vamos ver alguns exemplos usando a struct chamada <code>ExcertoImportante</code>
que definimos na Listagem 10-26.</p>
<p>Primeiro, aqui hÃ¡ um mÃ©todo chamado <code>level</code>. O Ãºnico parÃ¢metro Ã© uma referÃªncia
para <code>self</code>, e o valor de retorno Ã© apenas um <code>i32</code>, nÃ£o uma referÃªncia para
nada:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct ExcertoImportante&lt;'a&gt; {
#     part: &amp;'a str,
# }
#
impl&lt;'a&gt; ExcertoImportante&lt;'a&gt; {
    fn level(&amp;self) -&gt; i32 {
        3
    }
}
#}</code></pre></pre>
<p>A declaraÃ§Ã£o do parÃ¢metro de tempo de vida depois de <code>impl</code> e uso depois do
tipo de nome Ã© obrigatÃ³rio, mas nÃ³s nÃ£o necessariamente precisamos de anotar o
tempo de vida da referÃªncia <code>self</code> por causa da primeira regra da elisÃ£o.</p>
<p>Aqui vai um exemplo onde a terceira regra da elisÃ£o de tempo de vida se aplica:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct ExcertoImportante&lt;'a&gt; {
#     part: &amp;'a str,
# }
#
impl&lt;'a&gt; ExcertoImportante&lt;'a&gt; {
    fn anuncio_e_parte_de_retorno(&amp;self, anuncio: &amp;str) -&gt; &amp;str {
        println!(&quot;AtenÃ§Ã£o por favor: {}&quot;, anuncio);
        self.part
    }
}
#}</code></pre></pre>
<p>HÃ¡ dois tempos de vida de entrada, entÃ£o o Rust aplica a primeira regra de
elisÃ£o de tempos de vida e dÃ¡ ambos ao <code>&amp;self</code> e ao <code>anuncio</code> seus prÃ³prios
tempos de vida. EntÃ£o, porque um dos parÃ¢metros Ã© <code>self</code>, o tipo de retorno
tem o tempo de vida de <code>&amp;self</code> e todos os tempos de vida foram contabilizados.</p>
<a class="header" href="print.html#o-tempo-de-vida-estÃ¡tico" id="o-tempo-de-vida-estÃ¡tico"><h3>O Tempo de Vida EstÃ¡tico</h3></a>
<p>HÃ¡ <em>um</em> tipo especial de tempo de vida que precisamos discutir: <code>'static</code>. O
tempo de vida <code>static</code> Ã© a duraÃ§Ã£o completa do programa. Todos os literais de
string tÃªm um tempo de vida <code>static</code>, o qual podemos escolher anotar como o
seguinte:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s: &amp;'static str = &quot;Eu tenho um tempo de vida estÃ¡tico.&quot;;
#}</code></pre></pre>
<p>O texto dessa string Ã© guardado diretamente no binÃ¡rio do seu programa e o
binÃ¡rio do seu programa estÃ¡ sempre disponÃ­vel. Logo, o tempo de vida de todas
as literais de string Ã© <code>'static</code>.</p>
<p>VocÃª pode ver sugestÃµes de usar o tempo de vida <code>'static</code> em uma mensagem de
ajuda de erro, mas antes de especificar <code>'static</code> como o tempo de vida para uma
referÃªncia, pense sobre se a referÃªncia que vocÃª tem Ã© uma que vive todo o
tempo de vida do seu programa ou nÃ£o (ou mesmo se vocÃª quer que ele viva tanto,
se poderia). Na maior parte do tempo, o problÃ©ma no cÃ³digo Ã© uma tentativa de
criar uma referÃªncia solta ou uma incompatibilidade dos tempos de vida
disponÃ­veis, e a soluÃ§Ã£o Ã© consertar esses problemas, nÃ£o especificar um tempo
de vida <code>'static</code>.</p>
<a class="header" href="print.html#parÃ¢metros-de-tipos-genÃ©ricos-limites-de-trais-e-tempos-de-vida-juntos" id="parÃ¢metros-de-tipos-genÃ©ricos-limites-de-trais-e-tempos-de-vida-juntos"><h3>ParÃ¢metros de Tipos GenÃ©ricos, Limites de Trais e Tempos de Vida Juntos</h3></a>
<p>Vamos rapidamente olhar para a sintaxe de especificar parÃ¢metros de tipos
genÃ©ricos, limites de traits e tempos de vida todos em uma funÃ§Ã£o!</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fmt::Display;

fn maior_com_um_anuncio&lt;'a, T&gt;(x: &amp;'a str, y: &amp;'a str, ann: T) -&gt; &amp;'a str
    where T: Display
{
    println!(&quot;AnÃºncio! {}&quot;, ann);
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
#}</code></pre></pre>
<p>Essa Ã© a funÃ§Ã£o <code>maior</code> da Listagem 10-23 que retorna a maior de dois cortes de
string, mas com um argumento extra chamado <code>ann</code>. O tipo de <code>ann</code> Ã© o tipo
genÃ©rico <code>T</code>, que pode ser preenchido por qualquer tipo que implemente o trait
<code>Display</code> como estÃ¡ especificado na clÃ¡usula <code>where</code>. Esse argumento extra serÃ¡
impresso antes da funÃ§Ã£o comparar os comprimentos dos cortes de string, que Ã©
porque o trait de <code>Display</code> possui um limite. Porque tempos de vida sÃ£o um tipo
genÃ©rico, a declaraÃ§Ã£o de ambos os parÃ¢metros de tempo de vida <code>'a</code> e o tipo
genÃ©rico <code>T</code> vÃ£o na mesma lista com chaves angulares depois do nome da funÃ§Ã£o.</p>
<a class="header" href="print.html#sumÃ¡rio-1" id="sumÃ¡rio-1"><h2>SumÃ¡rio</h2></a>
<p>NÃ³s cobrimos vÃ¡rias coisas nesse capÃ­tulo! Agora que vocÃª sabe sobre parÃ¢metros
de tipos genÃ©ricos, traits e limites de traits, e parÃ¢metros genÃ©ricos de tempo
de vida, vocÃª estÃ¡ pronto para escrever cÃ³digo que nÃ£o Ã© duplicado mas pode ser
usado em muitas situaÃ§Ãµes. ParÃ¢metros de tipos genÃ©ricos significam que o
cÃ³digo pode ser aplicado a diferentes tipos. Traits e limites de traits
garantem que mesmo que os tipos sejam genÃ©ricos, esses tipos terÃ£o o
comportamento que o cÃ³digo precisa. RelaÃ§Ãµes entre tempos de vida de
referÃªncias especificadas por anotaÃ§Ãµes de tempo de vida garantem que esse
cÃ³digo flexÃ­vel nÃ£o terÃ¡ referÃªncias soltas. E tudo isso acontece em tempo de
compilaÃ§Ã£o para que a performace em tempo de execuÃ§Ã£o nÃ£o seja afetada!</p>
<p>Acredite ou nÃ£o, hÃ¡ ainda mais para aprender nessas Ã¡reas: CapÃ­tulo 17
discutirÃ¡ objetos de trait, que sÃ£o outro modo de usar traits. O CapÃºtulo 19
vai cobrir cenÃ¡rios mais complexos envolvendo anotaÃ§Ãµes de tempo de vida. O
CapÃ­tulo 20 vai tratar de alguns tipos avanÃ§ados de caracterÃ­sticas do sistema.
Em seguida, porÃ©m, vamos falar sobre como escrever testes em Rust para que
possamos ter certeza que nosso cÃ³digo usando todas essas caracterÃ­sticas estÃ¡
funcionando do jeito que queremos!</p>
<a class="header" href="print.html#testing" id="testing"><h1>Testing</h1></a>
<a class="header" href="print.html#writing-tests" id="writing-tests"><h1>Writing tests</h1></a>
<a class="header" href="print.html#running-tests" id="running-tests"><h1>Running tests</h1></a>
<a class="header" href="print.html#test-organization" id="test-organization"><h1>Test Organization</h1></a>
<a class="header" href="print.html#um-projeto-de-es-criando-um-programa-de-linha-de-comando" id="um-projeto-de-es-criando-um-programa-de-linha-de-comando"><h1>Um projeto de E/S: Criando um Programa de Linha de Comando</h1></a>
<p>Este capÃ­tulo Ã© um recapitulaÃ§Ã£o de muitas habilidades que vocÃª aprendeu atÃ© agora e uma
exploraÃ§Ã£o de mais alguns recursos da biblioteca padrÃ£o. Vamos construir uma
ferramenta que interage com arquivo de entrada/saÃ­da em linha de comando para praticar alguns dos
conceitos de Rust que vocÃª tem a disposiÃ§Ã£o.</p>
<p>A velocidade, a seguranÃ§a, a saÃ­da <em>binary-Ãºnico</em> e o suporte multi-plataforma de Rust
fazem dela uma linguagem ideal para a criaÃ§Ã£o de ferramentas de linha de comando. Assim,
para nosso projeto, criaremos nossa prÃ³pria versÃ£o da ferramenta clÃ¡ssica de linha de comando <code>grep</code>
(<strong>g</strong>lobally search a <strong>r</strong>egular <strong>e</strong>xpression and <strong>p</strong>rint). No caso de uso mais simples,
o <code>grep</code> procura um arquivo especificado para uma string especificada. Para fazer isso, o <code>grep</code>
toma como argumento um nome de arquivo e uma string, e entÃ£o lÃª o arquivo e localiza linhas naquele
arquivo que contÃ©m o argumento string. Em seguida, imprime essas linhas.</p>
<p>Ao longo do caminho, mostraremos como fazer com que nossa ferramenta de linha de comando use recursos do
terminal que muitas ferramentas de linha de comando usam. Leremos o valor de uma
variÃ¡vel de ambiente para permitir ao usuÃ¡rio configurar o comportamento de nossa ferramenta.
TambÃ©m imprimiremos na saÃ­da de console de erro padrÃ£o (<code>stderr</code>) em vez da
saÃ­da padrÃ£o (<code>stdout</code>), por exemplo, o usuÃ¡rio pode redirecionar saÃ­da de sucesso
para um arquivo enquanto ainda estÃ¡ vendo mensagens de erro na tela.</p>
<p>Um membro da comunidade One Rust, Andrew Gallant, jÃ¡ criou uma versÃ£o completa
, e muito rÃ¡pida do <code>grep</code>, chamada <code>ripgrep</code>. Em comparaÃ§Ã£o, nossa
versÃ£o do <code>grep</code> serÃ¡ bastante simples, mas este capÃ­tulo lhe darÃ¡ alguns dos
conhecimento bÃ¡sicos que vocÃª precisa para entender um projeto real como
<code>ripgrep</code>.</p>
<p>Nosso projeto <code>grep</code> combinarÃ¡ uma sÃ©rie de conceitos que vocÃª aprendeu atÃ© agora:</p>
<ul>
<li>Organizar cÃ³digo (usando o que aprendeu em mÃ³dulos, CapÃ­tulo 7)</li>
<li>Usando vetores e strings (coleÃ§Ãµes, CapÃ­tulo 8)</li>
<li>Erros de manipulaÃ§Ã£o (CapÃ­tulo 9)</li>
<li>Usando traits e lifetimes, quando apropriado (CapÃ­tulo 10)</li>
<li>Escrevendo testes (CapÃ­tulo 11)</li>
</ul>
<p>TambÃ©m apresentamos brevemente closures, iteraÃ§Ãµes e trait objects, que
os capÃ­tulos 13 e 17 abordarÃ£o em detalhes.</p>
<a class="header" href="print.html#aceitando-argumentos-em-linha-de-comando" id="aceitando-argumentos-em-linha-de-comando"><h2>Aceitando Argumentos em Linha de Comando</h2></a>
<p>Vamos criar um novo projeto usando, como sempre, <code>cargo new</code>. Chamaremos o nosso projeto
<code>minigrep</code> para distingui-lo da ferramenta<code>grep</code> que vocÃª jÃ¡ pode ter
no seu sistema.</p>
<pre><code class="language-text">$ cargo new --bin minigrep
     Created binary (application) `minigrep` project
$ cd minigrep
</code></pre>
<p>A primeira tarefa Ã© fazer que <code>minigrep</code> aceite seus dois argumentos de linha de comando: o
nome de arquivo e uma string para procurar. Ou seja, queremos ser capazes de administrar o nosso
programa com <code>cargo run</code>, uma string para procurar e um caminho para um arquivo onde serÃ¡ feira a
procura, dessa forma:</p>
<pre><code class="language-text">$ cargo run searchstring example-filename.txt
</code></pre>
<p>Neste momento, o programa gerado por <code>cargo new</code> nÃ£o pode processar os argumentos que nÃ³s
passamos. No entanto, algumas bibliotecas existentes no <a href="https://crates.io/">Crates.io</a>
que podem  nos ajudar a escrever um programa que aceite argumentos na linha de comando, mas
como vocÃª estÃ¡ aprendendo esses conceitos, vamos implementar essa capacidade
nÃ³s mesmos.</p>
<a class="header" href="print.html#lendo-os-valores-do-argumento" id="lendo-os-valores-do-argumento"><h3>Lendo os Valores do Argumento</h3></a>
<p>Para garantir que <code>minigrep</code> seja capaz de ler os valores dos argumentos da linha de comando, nÃ³s
precisamos de uma funÃ§Ã£o fornecida na biblioteca padrÃ£o do Rust, que Ã©
<code>std::env::args</code>. Esta funÃ§Ã£o retorna um <em>iterador</em> da linha de comando
com os argumentos que foram passados Ã  <code>minigrep</code>. Ainda nÃ£o discutimos iteradores
(nÃ³s os cobrimos totalmente no CapÃ­tulo 13), mas por enquanto vocÃª sÃ³ precisa saber dois
detalhes sobre iteradores: os iteradores produzem uma sÃ©rie de valores, e podemos chamar
a funÃ§Ã£o <code>collect</code> em um iterador para transformÃ¡-lo em uma coleÃ§Ã£o, como um
vetor, contendo todos os elementos que o iterador produz.</p>
<p>Use o cÃ³digo na Listagem 12-1 para permitir que seu programa <code>minigrep</code> leia qualquer
argumento da linha de comando passados para ele e depois colete os valores em um vetor:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    println!(&quot;{:?}&quot;, args);
}
</code></pre></pre>
<p><span class="caption">Listagem 12-1: Coletando os argumentos da linha de comando
um vetor e imprimindo-os</span></p>
<p>Primeiro, trazemos o mÃ³dulo <code>std::env</code> para o escopo com uma declaraÃ§Ã£o <code>use</code>, entÃ£o nÃ³s
podemos usar a funÃ§Ã£o <code>args</code>. Observe que a funÃ§Ã£o <code>std::env::args</code> Ã©
aninhada em dois nÃ­veis de mÃ³dulos. Como discutimos no CapÃ­tulo 7, nos casos em que
a funÃ§Ã£o desejada estÃ¡ aninhada em mais de um mÃ³dulo, Ã© convenÃ§Ã£o
trazer o mÃ³dulo pai para o escopo em vez da funÃ§Ã£o. Como resultado, nÃ³s
podemos facilmente usar outras funÃ§Ãµes de <code>std::env</code>. TambÃ©m Ã© menos ambÃ­guo que
adicionar <code>use std::env::args</code> e depois chamando a funÃ§Ã£o com apenas <code>args</code>
porque <code>args</code> pode ser facilmente confundido com uma funÃ§Ã£o definida no
mÃ³dulo atual.</p>
<blockquote>
<a class="header" href="print.html#a-funÃ§Ã£o-args-e-unicode-invÃ¡lido" id="a-funÃ§Ã£o-args-e-unicode-invÃ¡lido"><h3>A FunÃ§Ã£o <code>args</code> e Unicode InvÃ¡lido</h3></a>
<p>Note que <code>std::env::args</code> emitirÃ¡ pÃ¢nico se algum argumento contiver cÃ³digo
Unicode invÃ¡lido. Se o seu programa precisar aceitar argumentos que sejam
Unicode invÃ¡lidos , use <code>std::env::args_os</code> em vez disso. Essa funÃ§Ã£o retorna valores <code>OsString</code>
em vez de valores <code>String</code>. NÃ³s escolhemos usar <code>std::env::args</code> aqui
por simplicidade, porque os valores de <code>OsString</code> diferem por plataforma e sÃ£o mais
complexo para trabalhar do que os valores de <code>String</code>.</p>
</blockquote>
<p>Na primeira linha do <code>main</code>, chamamos <code>env::args</code>, e usamos <code>collect</code> imediatamente
para transformar o iterador em um vetor contendo todos os valores produzidos pelo
iterador. Podemos usar a funÃ§Ã£o <code>collect</code> para criar muitos tipos de
coleÃ§Ãµes, entÃ£o nÃ³s explicitamente anotamos o tipo de <code>args</code> para especificar que nÃ³s
queremos um vetor de strings. Embora raramente precisemos anotar tipos em
Rust, <code>collect</code> Ã© uma funÃ§Ã£o que muitas vezes vocÃª precisa anotar, porque Rust
nÃ£o Ã© capaz de inferir o tipo de coleÃ§Ã£o que deseja.</p>
<p>Finalmente, imprimimos o vetor usando o formatador de debug, <code>:?</code>. Vamos tentar executar
o cÃ³digo sem argumentos e depois com dois argumentos:</p>
<pre><code class="language-text">$ cargo run
--snip--
[&quot;target/debug/minigrep&quot;]

$ cargo run needle haystack
--snip--
[&quot;target/debug/minigrep&quot;, &quot;needle&quot;, &quot;haystack&quot;]
</code></pre>
<p>Observe que o primeiro valor no vetor Ã© <code>&quot;target/debug/minigrep&quot;</code>, que
Ã© o nome do nosso binÃ¡rio. Isso corresponde ao comportamento da lista de argumentos em
C, permitindo que os programas usem o nome pelo qual eles foram invocados em sua execuÃ§Ã£o.
Geralmente, Ã© conveniente ter acesso ao nome do programa, caso desejemos imprimi-lo em mensagens ou
alterar o comportamento do programa com base no alias da linha de comando que foi usado
para chamar o programa. Mas, para os fins deste capÃ­tulo, vamos ignorÃ¡-lo e salvar apenas
os dois argumentos que precisamos.</p>
<a class="header" href="print.html#salvando-os-valores-do-argumento-em-variÃ¡veis" id="salvando-os-valores-do-argumento-em-variÃ¡veis"><h3>Salvando os Valores do Argumento em VariÃ¡veis</h3></a>
<p>Imprimir o valor do vetor de argumentos ilustra que o programa Ã©
capaz de acessar os valores especificados como argumentos da linha de comando. Agora precisamos
salvar os valores dos dois argumentos nas variÃ¡veis para que possamos usar esses valores
durante o resto do programa. Fazemos isso na Listagem 12-2:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let query = &amp;args[1];
    let filename = &amp;args[2];

    println!(&quot;Searching for {}&quot;, query);
    println!(&quot;In file {}&quot;, filename);
}
</code></pre></pre>
<p><span class="caption">Listagem 12-2: Criando variÃ¡veis para guardar o argumento de consulta
e argumento do nome do arquivo</span></p>
<p>Como vimos quando imprimimos o vetor, o nome do programa ocupa o primeiro
valor no vetor em <code>args[0]</code>, entÃ£o estamos comeÃ§ando no Ã­ndice <code>1</code>. O primeiro
argumento <code>minigrep</code> Ã© a string que estamos procurando, entÃ£o colocamos uma
referÃªncia ao primeiro argumento na variÃ¡vel <code>query</code>. O segundo argumento
serÃ¡ o nome do arquivo, entÃ£o colocamos uma referÃªncia ao segundo argumento no
variÃ¡vel <code>filename</code>.</p>
<p>Imprimimos temporariamente os valores dessas variÃ¡veis para provar que o cÃ³digo funciona
como pretendemos. Vamos executar este programa novamente com os argumentos <code>test</code>
e <code>sample.txt</code>:</p>
<pre><code class="language-text">$ cargo run test sample.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep test sample.txt`
Searching for test
In file sample.txt
</code></pre>
<p>Ã“timo, o programa estÃ¡ funcionando! Os valores dos argumentos que precisamos estÃ£o sendo
salvos nas variÃ¡veis certas. Mais tarde, adicionaremos algum tratamento de erro para lidar
com certas situaÃ§Ãµes errÃ´neas potenciais, como quando o usuÃ¡rio nÃ£o fornece
argumentos; por enquanto, ignoraremos essa situaÃ§Ã£o, e trabalharemos na adiÃ§Ã£o das
funcinalidades de leitura dos arquivos.</p>
<a class="header" href="print.html#lendo-um-arquivo" id="lendo-um-arquivo"><h2>Lendo um Arquivo</h2></a>
<p>Agora vamos adicionar funcionalidades para ler o arquivo que Ã© especificado no
argumento <code>filename</code> da linha de comando. Primeiro, precisamos de um arquivo de amostra para testÃ¡-lo:
o melhor tipo de arquivo a ser usado para garantir que o <code>minigrep</code> esteja funcionando Ã© um ,com uma
pequena quantidade de texto, em vÃ¡rias linhas com algumas palavras repetidas. Listagem 12-3
tem um poema de Emily Dickinson que funcionarÃ¡ bem! Crie um arquivo chamado
<em>poem.txt</em> no diretÃ³rio raiz do seu projeto e entre com o poema â€œIâ€™m Nobody!
Who are you?â€</p>
<p><span class="filename">Arquivo: poem.txt</span></p>
<pre><code class="language-text">Iâ€™m nobody! Who are you?
Are you nobody, too?
Then thereâ€™s a pair of us â€” donâ€™t tell!
Theyâ€™d banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p><span class="caption">Listagem 12-3: Um poema de Emily Dickinson farÃ¡ um bom
caso de teste.</span></p>
<p>Com o texto no lugar, edite <em>src/main.rs</em> e adicione o cÃ³digo para abrir o arquivo, como
mostrado na Listagem 12-4:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::env;
use std::fs::File;
use std::io::prelude::*;

fn main() {
#     let args: Vec&lt;String&gt; = env::args().collect();
#
#     let query = &amp;args[1];
#     let filename = &amp;args[2];
#
#     println!(&quot;Searching for {}&quot;, query);
    // --snip--
    println!(&quot;In file {}&quot;, filename);

    let mut f = File::open(filename).expect(&quot;file not found&quot;);

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents)
        .expect(&quot;something went wrong reading the file&quot;);

    println!(&quot;With text:\n{}&quot;, contents);
}
</code></pre></pre>
<p><span class="caption">Listagem 12-4: Leitura do conteÃºdo do arquivo especificado
pelo segundo argumento</span></p>
<p>Primeiro, adicionamos mais instruÃ§Ãµes <code>use</code> para trazer partes relevantes da
biblioteca padrÃ£o: precisamos de <code>std::fs::File</code> para lidar com arquivos, e
<code>std::io::prelude::*</code> contÃ©m vÃ¡rios traits Ãºteis para fazer E/S, incluindo
arquivo de E/S. Da mesma forma que Rust tem um prelÃºdio geral que traz certos
tipos e funÃ§Ãµes no escopo automaticamente, o mÃ³dulo <code>std::io</code> possui o seu prÃ³prio
prelÃºdio de tipos e funÃ§Ãµes comuns que vocÃª precisarÃ¡ ao trabalhar com E/S. Ao contrÃ¡rio
do prelÃºdio padrÃ£o, devemos adicionar explicitamente uma instruÃ§Ã£o <code>use</code> para o prelÃºdio
de <code>std::io</code>.</p>
<p>Em <code>main</code>, adicionamos trÃªs declaraÃ§Ãµes: primeiro, recebemos um identificador mutÃ¡vel para o
arquivo chamando a funÃ§Ã£o <code>File::open</code> e transmitindo o valor da
variÃ¡vel <code>filename</code>. Em segundo lugar, criamos uma variÃ¡vel chamada <code>contents</code> e configuramos
para uma <code>String</code> mutÃ¡vel e vazia. Isso manterÃ¡ o conteÃºdo do arquivo depois que nÃ³s
lÃª-lo. Terceiro, chamamos <code>read_to_string</code> no nosso arquivo e passamos um
referÃªncia mutÃ¡vel para <code>contents</code> como argumento.</p>
<p>ApÃ³s essas linhas, adicionamos novamente uma declaraÃ§Ã£o temporÃ¡ria <code>println!</code> que
imprime o valor do <code>contents</code> depois que o arquivo Ã© lido, para que possamos verificar que o
o programa estÃ¡ funcionando atÃ© o momento.</p>
<p>Vamos executar este cÃ³digo com qualquer string como o primeiro argumento da linha de comando (porque
ainda nÃ£o implementamos a parte de pesquisa) e o arquivo <em>poem.txt</em> como o
segundo argumento:</p>
<pre><code class="language-text">$ cargo run the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
Iâ€™m nobody! Who are you?
Are you nobody, too?
Then thereâ€™s a pair of us â€” donâ€™t tell!
Theyâ€™d banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p>Ã“timo! O cÃ³digo lÃª e, em seguida, imprime o conteÃºdo do arquivo. Mas o cÃ³digo tem
algumas falhas. A funÃ§Ã£o <code>main</code> tem mÃºltiplas responsabilidades: geralmente,
as funÃ§Ãµes sÃ£o mais claras e fÃ¡ceis de manter se cada funÃ§Ã£o for responsÃ¡vel
por apenas uma idÃ©ia. O outro problema Ã© que tambÃ©m nÃ£o estamos lidando com erros,
como poderÃ­am ser. O programa ainda Ã© pequeno, entÃ£o essas falhas nÃ£o sÃ£o um grande problema,
mas Ã  medida que o programa cresce, serÃ¡ mais difÃ­cil consertÃ¡-los de forma elegante. Ã‰ uma boa
pratica comeÃ§ar a refatoraÃ§Ã£o no inÃ­cio do desenvolvimento de um programa, porque sÃ£o
muito mais fÃ¡ceis de refatorar quantidades menores de cÃ³digo. Vamos fazer isso depois.</p>
<a class="header" href="print.html#refatoraÃ§Ã£o-para-melhorar-a-modularidade-e-o-tratamento-de-erros" id="refatoraÃ§Ã£o-para-melhorar-a-modularidade-e-o-tratamento-de-erros"><h2>RefatoraÃ§Ã£o para Melhorar a Modularidade e o Tratamento de Erros</h2></a>
<p>Para melhorar o nosso programa, repararemos quatro problemas que tÃªm a ver com a
estrutura do programa e como ele estÃ¡ tratando possÃ­veis erros.</p>
<p>Primeiro, a nossa funÃ§Ã£o <code>main</code> agora executa duas tarefas: analisa argumentos e
abre arquivos. Para uma funÃ§Ã£o tÃ£o pequena, este nÃ£o Ã© um grande problema. No entanto, se
continuamos a desenvolver o nosso programa dentro de <code>main</code>, o nÃºmero de tarefas separadas que
a funÃ§Ã£o <code>main</code> manipula aumentarÃ£o. Com uma funÃ§Ã£o ganhando responsabilidades,
torna-se mais difÃ­cil de raciocinar, mais difÃ­cil de testar e mais difÃ­cil de mudar
sem quebrar uma das suas partes. Ã‰ melhor separar a funcionalidade para que cada
funÃ§Ã£o seja responsÃ¡vel por uma tarefa.</p>
<p>Esta questÃ£o tambÃ©m se liga ao segundo problema: embora <code>query</code> e <code>filename</code>
sejam variÃ¡veis de configuraÃ§Ã£o para o nosso programa, variÃ¡veis como <code>f</code> e <code>contents</code>
sÃ£o usadas para executar a lÃ³gica do programa. Quanto maior o <code>main</code> se torna, mais
variÃ¡veis precisamos trazer no escopo; quanto mais variÃ¡veis temos no escopo,
mais difÃ­cil serÃ¡ acompanhar o objetivo de cada uma. Ã‰ melhor agrupar
as variÃ¡veis de configuraÃ§Ã£o em uma estrutura para tornar claro seu objetivo.</p>
<p>O terceiro problema Ã© que usamos <code>expect</code> para imprimir uma mensagem de erro, ao
abrir um arquivo, falha, mas a mensagem de erro apenas imprime <code>file not found</code>.
Abrir um arquivo pode falhar de vÃ¡rias maneiras, alÃ©m do arquivo faltando: como
exemplo, o arquivo pode existir, mas talvez nÃ£o possamos ter permissÃ£o para abri-lo.
Agora, se estivermos nessa situaÃ§Ã£o, imprimirÃ­amos a mensagem de erro <code>file not found</code>
que daria ao usuÃ¡rio a informaÃ§Ã£o errada!</p>
<p>O quarto problema, usamos <code>expect</code> repetidamente para lidar com diferentes erros, e se o usuÃ¡rio
executa o nosso programa sem especificar argumentos suficientes, eles terÃ£o erros <code>index out of bounds</code> do Rust, que nÃ£o explica claramente o problema. Seria
melhor se todo o cÃ³digo de tratamento de erros estiver em um sÃ³ lugar para futuros mantenedores
terem apenas um lugar para consultar, no cÃ³digo, se a lÃ³gica de tratamento de erros precisar de
mudanÃ§a. Ter todo o cÃ³digo de tratamento de erros em um sÃ³ lugar tambÃ©m assegurarÃ¡ que
estamos imprimindo mensagens que serÃ£o significativas para nossos usuÃ¡rios finais.</p>
<p>Vamos abordar esses quatro problemas refatorando nosso projeto.</p>
<a class="header" href="print.html#separaÃ§Ã£o-de-responsabilidades-para-projetos-binÃ¡rios" id="separaÃ§Ã£o-de-responsabilidades-para-projetos-binÃ¡rios"><h3>SeparaÃ§Ã£o de Responsabilidades para Projetos BinÃ¡rios</h3></a>
<p>O problema organizacional da atribuiÃ§Ã£o de responsabilidade por mÃºltiplas tarefas para
a funÃ§Ã£o <code>main</code> Ã© comum a muitos projetos binÃ¡rios. Como resultado, a comunidade Rust
desenvolveu um tipo de processo de orientaÃ§Ã£o para dividir as
responsabilidades de um programa binÃ¡rio quando <code>main</code> comeÃ§a a ficar grande. O processo tem
as seguintes etapas:</p>
<ul>
<li>
<p>Divida seu programa em um <em>main.rs</em> e um <em>lib.rs</em>, e mova a lÃ³gica
do seu programa para <em>lib.rs</em>.</p>
</li>
<li>
<p>Enquanto sua lÃ³gica de anÃ¡lise de linha de comando Ã© pequena, ela pode permanecer em <em>main.rs</em>.</p>
</li>
<li>
<p>Quando a lÃ³gica de anÃ¡lise de linha de comando comeÃ§a a ficar complicada, extraia
de <em>main.rs</em> e mova para <em>lib.rs</em>.</p>
</li>
<li>
<p>As responsabilidades que permanecem na funÃ§Ã£o <code>main</code> depois desse processo
deve estar limitado a:</p>
<ul>
<li>Chamar a lÃ³gica de anÃ¡lise de linha de comando com os valores do argumento</li>
<li>Ajustar qualquer outra configuraÃ§Ã£o</li>
<li>Chamando uma funÃ§Ã£o <code>run</code> em <em>lib.rs</em></li>
<li>ManipulaÃ§Ã£o do erro se <code>run</code> retornar um erro</li>
</ul>
</li>
</ul>
<p>Esse padrÃ£o Ã© sobre separar responsabilidades: <em>main.rs</em> lida com a execuÃ§Ã£o do
programa e <em>lib.rs</em> lida com toda a lÃ³gica da tarefa em questÃ£o. Porque nÃ³s
nÃ£o podemos testar diretamente a funÃ§Ã£o <code>main</code>, esta estrutura nos permite testar toda
lÃ³gica do programa, movendo-a para funÃ§Ãµes em <em>lib.rs</em>. O Ãºnico cÃ³digo que
permanece em <em>main.rs</em> serÃ¡ pequeno o suficiente para verificar se estÃ¡ correto com
uma leitura rÃ¡pida. Vamos retrabalhar o nosso programa seguindo este processo.</p>
<a class="header" href="print.html#extraindo-o-parseador-de-argumento" id="extraindo-o-parseador-de-argumento"><h4>Extraindo o Parseador de Argumento</h4></a>
<p>Vamos extrair a funcionalidade de anÃ¡lise de argumentos de <code>main</code> para <em>src/lib.rs</em>.
A listagem 12-5 mostra o novo inÃ­cio do <code>main</code> que chama uma nova
funÃ§Ã£o <code>parse_config</code>, que iremos definir em <em>src/main.rs</em> por enquanto.</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let (query, filename) = parse_config(&amp;args);

    // --snip--
}

fn parse_config(args: &amp;[String]) -&gt; (&amp;str, &amp;str) {
    let query = &amp;args[1];
    let filename = &amp;args[2];

    (query, filename)
}
</code></pre>
<p><span class="caption">Listagem 12-5: Extraindo uma funÃ§Ã£o <code>parse_config</code> de
<code>main</code></span></p>
<p>Ainda estamos coletando os argumentos da linha de comando em um vetor, mas em vez de
atribuir o valor do argumento no Ã­ndice <code>1</code> para a variÃ¡vel <code>query</code> e o
valor do argumento no Ã­ndice <code>2</code> para a variÃ¡vel <code>filename</code> dentro da funÃ§Ã£o <code>main</code>
, passamos todo o vetor para a funÃ§Ã£o <code>parse_config</code>. A
funÃ§Ã£o <code>parse_config</code> mantÃ©m a lÃ³gica que determina qual argumento
vai em qual variÃ¡vel e passa os valores de volta para <code>main</code>. Ainda criamos
as variÃ¡veis <code>query</code> e <code>filename</code> no <code>main</code>, mas <code>main</code> nÃ£o tem mais a
responsabilidade de determinar como os argumentos e as variÃ¡veis da linha de comando
correspondem.</p>
<p>Essa retrabalho pode parecer um exagero para o nosso pequeno programa, mas estamos refatorando
em pequenos passos incrementais. Depois de fazer essa alteraÃ§Ã£o, execute o programa novamente para
verificar se a anÃ¡lise do argumento ainda funciona. Ã‰ bom verificar seu progresso
constantemente, porque isso irÃ¡ ajudÃ¡-lo a identificar a causa dos problemas quando eles
ocorrerem.</p>
<a class="header" href="print.html#agrupando-valores-de-configuraÃ§Ã£o" id="agrupando-valores-de-configuraÃ§Ã£o"><h4>Agrupando Valores de ConfiguraÃ§Ã£o</h4></a>
<p>Podemos dar outro pequeno passo para melhorar ainda mais a funÃ§Ã£o <code>parse_config</code>.
No momento, estamos retornando uma tupla, mas depois quebramos imediatamente a tupla
em partes individuais novamente. Este Ã© um sinal de que talvez nÃ£o tenhamos
a abstraÃ§Ã£o certa ainda.</p>
<p>Outro indicador que mostra que hÃ¡ espaÃ§o para melhoria Ã© a parte <code>config</code>
de <code>parse_config</code>, o que implica que os dois valores que retornamos estÃ£o relacionados e
ambos sÃ£o parte de um valor de configuraÃ§Ã£o. Atualmente, nÃ£o estamos transmitindo esse
significado na estrutura dos dados, que nÃ£o sejam o agrupamento dos dois valores em um
tupla: podemos colocar os dois valores em uma estrutura e dar a cada uma das estruturas
um nome significativo. Isso facilitarÃ¡ os futuros mantenedores
deste cÃ³digo para entender como os diferentes valores se relacionam entre si e
qual Ã© o propÃ³sito deles.</p>
<blockquote>
<p>Nota: algumas pessoas chamam este anti-padrÃ£o de usar valores primitivos quando um
tipo complexo seria mais apropriado <em>primitive obsession</em> (obsessÃ£o primitiva).</p>
</blockquote>
<p>A Listagem 12-6 mostra a adiÃ§Ã£o de uma estrutura chamada <code>Config</code> definida para ter
campos chamados <code>query</code> e <code>filename</code>. TambÃ©m mudamos a funÃ§Ã£o <code>parse_config</code>
para retornar uma instÃ¢ncia da estrutura <code>Config</code> e atualizamos <code>main</code> para usar
os campos struct em vez de ter variÃ¡veis separadas:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic"># use std::env;
# use std::fs::File;
#
fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = parse_config(&amp;args);

    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    let mut f = File::open(config.filename).expect(&quot;file not found&quot;);

    // --snip--
}

struct Config {
    query: String,
    filename: String,
}

fn parse_config(args: &amp;[String]) -&gt; Config {
    let query = args[1].clone();
    let filename = args[2].clone();

    Config { query, filename }
}
</code></pre></pre>
<p><span class="caption">Listagem 12-6: Refatorando <code>parse_config</code> para retornar uma
instÃ¢ncia de uma struct <code>Config</code></span></p>
<p>A assinatura do <code>parse_config</code> agora indica que ele retorna um valor <code>Config</code>.
No corpo de <code>parse_config</code>, onde costumÃ¡vamos retornar trechos de strings com
referÃªncia a valores <code>String</code> em <code>args</code>, agora definimos <code>Config</code> para conter valores
<code>String</code> owned. A variÃ¡vel <code>args</code> em <code>main</code> Ã© o owner do argumento de
valores e estÃ¡ apenas permitindo que a funÃ§Ã£o <code>parse_config</code> os empreste (borrow), o que significa
que violaremos as regras de borrow do Rust se o <code>Config</code> tentasse se apropriar (ownership) dos
valores em <code>args</code>.</p>
<p>Podemos gerenciar os dados <code>String</code> de vÃ¡rias maneiras diferentes, mas o
mais fÃ¡cil, embora ineficiente, o caminho Ã© chamar o mÃ©todo <code>clone</code> nos
valores. Isso farÃ¡ uma cÃ³pia completa dos dados para a instÃ¢ncia <code>Config</code>
, que leva mais tempo e memÃ³ria do que armazenar uma referÃªncia Ã  string de
dados. No entanto, a clonagem dos dados tambÃ©m torna nosso cÃ³digo muito direto
porque nÃ£o precisamos administrar as vidas das referÃªncias; nessa
circunstÃ¢ncia, desistir de um pouco de desempenho para ganhar simplicidade Ã© uma coisa que vale a pena
a troca.</p>
<blockquote>
<a class="header" href="print.html#os-prÃ³s-e-contras-de-usar-clone" id="os-prÃ³s-e-contras-de-usar-clone"><h3>Os PrÃ³s e Contras de Usar <code>clone</code></h3></a>
<p>Existe uma tendÃªncia entre muitos Rustaceos para evitar o uso de <code>clone</code> para consertar
problemas de ownership devido ao seu custo de tempo de execuÃ§Ã£o. No CapÃ­tulo 13, vocÃª aprenderÃ¡
como usar mÃ©todos mais eficientes neste tipo de situaÃ§Ã£o. Mas por agora,
Ã© bom copiar algumas strings para continuar a fazer progresso porque iremos
fazer essas cÃ³pias apenas uma vez, e nosso nome de arquivo e seqÃ¼Ãªncia de consulta sÃ£o muito
pequenos. Ã‰ melhor ter um programa de trabalho que seja um pouco ineficiente do que
tentar hiper-optimizar o cÃ³digo na sua primeira passagem. Ã€ medida que vocÃª se torna mais experiente
com Rust, serÃ¡ mais fÃ¡cil comeÃ§ar com a soluÃ§Ã£o mais eficiente, mas para
agora, Ã© perfeitamente aceitÃ¡vel chamar <code>clone</code>.</p>
</blockquote>
<p>Atualizamos <code>main</code> para que ele coloque a instÃ¢ncia de <code>Config</code> retornada por
<code>parse_config</code> em uma variÃ¡vel chamada <code>config</code>, e atualizamos o cÃ³digo
anteriormente usado para as variÃ¡veis separadas <code>query</code> e <code>filename</code> para que ele agora
,em vez disso, use os campos na estrutura <code>Config</code>.</p>
<p>Agora, nosso cÃ³digo transmite mais claramente que <code>query</code> e <code>filename</code> estÃ£o relacionados, e
seu objetivo Ã© configurar como o programa funcionarÃ¡. Qualquer cÃ³digo que use
esses valores sabem encontrÃ¡-los na instÃ¢ncia <code>config</code> nos campos nomeados
para esse propÃ³sito.</p>
<a class="header" href="print.html#criando-um-construtor-para-config" id="criando-um-construtor-para-config"><h4>Criando um Construtor para <code>Config</code></h4></a>
<p>AtÃ© agora, nÃ³s extraÃ­mos a lÃ³gica responsÃ¡vel por analisar os argumentos da linha de
comando de <code>main</code> e colocÃ¡-los na funÃ§Ã£o <code>parse_config</code>, o que nos ajudou a ver que os
valores <code>query</code> e <code>filename</code> estavam relacionados e essa relaÃ§Ã£o deve ser transmitida
em nosso cÃ³digo. NÃ³s entÃ£o adicionamos uma estrutura <code>Config</code> para nomear o propÃ³sito
relacionado de <code>query</code> e <code>filename</code>, e para poder retornar os nomes dos valores como
nomes de campos struct a partir da funÃ§Ã£o <code>parse_config</code>.</p>
<p>EntÃ£o, agora que a finalidade da funÃ§Ã£o <code>parse_config</code> Ã© criar uma instÃ¢ncia <code>Config</code>
, podemos alterar <code>parse_config</code> de ser uma funÃ§Ã£o simples para um
funÃ§Ã£o denominada <code>new</code> que estÃ¡ associada Ã  estrutura <code>Config</code>. Fazendo essa
mudanÃ§a tornarÃ¡ o cÃ³digo mais idiomÃ¡tico: podemos criar instÃ¢ncias de tipos na
biblioteca padrÃ£o, como <code>String</code>, chamando <code>String::new</code>, e
mudando <code>parse_config</code> para uma funÃ§Ã£o <code>new</code> associada a <code>Config</code>, iremos
ser capazes de criar instÃ¢ncias de <code>Config</code> chamando <code>Config::new</code>. Listagem 12-7
mostra as mudanÃ§as que precisamos fazer:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic"># use std::env;
#
fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args);

    // --snip--
}

# struct Config {
#     query: String,
#     filename: String,
# }
#
// --snip--

impl Config {
    fn new(args: &amp;[String]) -&gt; Config {
        let query = args[1].clone();
        let filename = args[2].clone();

        Config { query, filename }
    }
}
</code></pre></pre>
<p><span class="caption">Listagem 12-7: Alterar <code>parse_config</code> para
<code>Config::new</code></span></p>
<p>Atualizamos <code>main</code> onde estÃ¡vamos chamando <code>parse_config</code> para, em vez disso, chamar
<code>Config::new</code>. Alteramos o nome de <code>parse_config</code> para <code>new</code> e movemos para
dentro de um bloco <code>impl</code>, que associa a funÃ§Ã£o <code>new</code> a <code>Config</code>. Experimente
compilar este cÃ³digo novamente para garantir que ele funciona.</p>
<a class="header" href="print.html#consertando-o-tratamento-de-erros" id="consertando-o-tratamento-de-erros"><h3>Consertando o Tratamento de Erros</h3></a>
<p>Agora vamos trabalhar em consertar o nosso tratamento de erros. Lembre-se de que tentar acessar
os valores no vetor <code>args</code> no Ã­ndice <code>1</code> ou no Ã­ndice <code>2</code> causarÃ¡ pÃ¢nico no programa se
o vetor contiver menos de trÃªs itens. Tente executar o programa sem argumentos; Isso parecerÃ¡ assim:</p>
<pre><code class="language-text">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep`
thread 'main' panicked at 'index out of bounds: the len is 1
but the index is 1', src/main.rs:29:21
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>A linha <code>index out of bounds: the len is 1 but the index is 1</code> Ã© uma mensagem de erro
destinada aos programadores. Isso nÃ£o ajudarÃ¡ os usuÃ¡rios finais a entender o que
aconteceu e o que eles deveriam fazer a respeito disso. Vamos consertar isso agora.</p>
<a class="header" href="print.html#melhorando-a-mensagem-de-erro" id="melhorando-a-mensagem-de-erro"><h4>Melhorando a Mensagem de Erro</h4></a>
<p>Na Listagem 12-8, adicionamos uma verificaÃ§Ã£o na funÃ§Ã£o <code>new</code> que verificarÃ¡ que o
pedaÃ§o Ã© longo o suficiente antes de acessar os Ã­ndices <code>1</code> e <code>2</code>. Se o pedaÃ§o nÃ£o for
suficientemente longo, o programa gera um pÃ¢nico e exibe uma mensagem de erro melhor do que a
mensagem <code>index out of bounds</code>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">// --snip--
fn new(args: &amp;[String]) -&gt; Config {
    if args.len() &lt; 3 {
        panic!(&quot;not enough arguments&quot;);
    }
    // --snip--
</code></pre>
<p><span class="caption">Listagem 12-8: Adicionando uma verificaÃ§Ã£o para o nÃºmero de
argumentos</span></p>
<p>Este cÃ³digo Ã© semelhante Ã  funÃ§Ã£o <code>Guess::new</code> que escrevemos na Listagem 9-9 onde
chamamos <code>panic!</code> quando o argumento <code>value</code> estava fora do alcance vÃ¡lido de
valores. Em vez de verificar uma variedade de valores aqui, estamos checando que o
comprimento de <code>args</code> Ã© pelo menos <code>3</code> e o resto da funÃ§Ã£o pode operar sob
o pressuposto de que essa condiÃ§Ã£o foi cumprida. Se <code>args</code> tiver menos de trÃªs
itens, essa condiÃ§Ã£o serÃ¡ verdadeira, e chamamos a macro <code>panic!</code> para terminar o
programa imediatamente.</p>
<p>Com estas poucas linhas de cÃ³digo adicionais em <code>new</code>, vamos executar o programa sem nenhum
argumento novamente para ver como o erro parece agora:</p>
<pre><code class="language-text">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep`
thread 'main' panicked at 'not enough arguments', src/main.rs:30:12
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>Este resultado Ã© melhor: agora temos uma mensagem de erro razoÃ¡vel. No entanto, nÃ³s tambÃ©m
temos informaÃ§Ãµes estranhas que nÃ£o queremos dar aos nossos usuÃ¡rios. Talvez usando
a tÃ©cnica que usamos na Lista 9-9 nÃ£o Ã© a melhor para usar aqui: uma chamada para
<code>panic!</code> Ã© mais apropriado para um problema de programaÃ§Ã£o e nÃ£o um problema de uso
, conforme discutido no CapÃ­tulo 9. Em vez disso, podemos usar outra tÃ©cnica que vocÃª
aprendeu no CapÃ­tulo 9 - retornando um <code>Result</code> que indica sucesso
ou um erro.</p>
<a class="header" href="print.html#retornando-um-result-de-um-new-em-vez-de-chamar-panic" id="retornando-um-result-de-um-new-em-vez-de-chamar-panic"><h4>Retornando um <code>Result</code> de um <code>new</code> Em vez de Chamar <code>panic!</code></h4></a>
<p>Em vez disso, podemos retornar um valor <code>Result</code> que conterÃ¡ uma instÃ¢ncia <code>Config</code> em
caso bem-sucedido e descreverÃ¡ o problema no caso de erro. Quando
<code>Config::new</code> estÃ¡ se comunicando com <code>main</code>, podemos usar o tipo <code>Result</code> para
sinalizar que nÃ£o houve problema. EntÃ£o podemos mudar <code>main</code> para converter uma variante <code>Err</code>
em um erro mais prÃ¡tico para os nossos usuÃ¡rios sem os demais textos
sobre <code>thread 'main'</code> e <code>RUST_BACKTRACE</code> que uma chamada para <code>panic!</code> causa.</p>
<p>A Listagem 12-9 mostra as mudanÃ§as que precisamos fazer para o valor de retorno de
<code>Config::new</code> e o corpo da funÃ§Ã£o necessÃ¡ria para retornar um <code>Result</code>. Note
que isso nÃ£o compilarÃ¡ atÃ© que atualizemos <code>main</code> tambÃ©m, o que faremos na
prÃ³xima listagem:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">impl Config {
    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        Ok(Config { query, filename })
    }
}
</code></pre>
<p><span class="caption">Listagem 12-9: Retornando um <code>Result</code> de
<code>Config::new</code></span></p>
<p>Nossa funÃ§Ã£o <code>new</code> agora retorna um<code>Result</code> com uma instÃ¢ncia <code>Config</code> no caso de sucesso
e um <code>&amp;'static str</code> no caso de erro. Lembre-se da seÃ§Ã£o â€œThe Static Lifetimeâ€ no capÃ­tulo 10
que <code>&amp; 'static str</code> Ã© o tipo de string literal, que Ã© o nosso tipo de mensagem de erro por enquanto.</p>
<p>Fizemos duas mudanÃ§as no corpo da funÃ§Ã£o <code>new</code>: em vez de chamar
<code>panic!</code> quando o usuÃ¡rio nÃ£o passa argumentos suficientes, agora devolvemos um valor <code>Err</code>
, e nÃ³s wrapped (embalamos) o valor de retorno <code>Config</code> em um <code>Ok</code>. Estas alteraÃ§Ãµes
fazem com que a funÃ§Ã£o esteja conforme a sua nova assinatura de tipo.</p>
<p>Retornar um valor <code>Err</code> de <code>Config::new</code> permite que a funÃ§Ã£o <code>main</code>
lide com o valor <code>Result</code> retornado da funÃ§Ã£o <code>new</code> e saia do processo
de forma mais limpa no caso de erro.</p>
<a class="header" href="print.html#chamando-confignew-e-manipulaÃ§Ã£o-de-erros" id="chamando-confignew-e-manipulaÃ§Ã£o-de-erros"><h4>Chamando <code>Config::new</code> e ManipulaÃ§Ã£o de Erros</h4></a>
<p>Para lidar com o caso de erro e imprimir uma mensagem amigÃ¡vel, precisamos atualizar
<code>main</code> para lidar com o <code>Result</code> sendo retornado por <code>Config::new</code>, conforme mostrado na
Listagem 12-10. TambÃ©m assumiremos a responsabilidade de sair da linha de comando
com um cÃ³digo de erro diferente de zero do <code>panic!</code> e implementÃ¡-lo manualmente.
O status de saÃ­da diferente de zero, Ã© uma convenÃ§Ã£o para sinalizar o processo que chamou nosso
programa que, o programa saiu com um estado de erro.</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::process;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        println!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    // --snip--
</code></pre>
<p><span class="caption">Listagem 12-10: Se ao criar um <code>Config</code> falha, saimos
com um cÃ³digo de erro</span></p>
<p>Nesta lista, usamos um mÃ©todo que nÃ£o abordamos antes:
<code>unwrap_or_else</code>, que estÃ¡ definido em <code>Result &lt;T, E&gt;</code> pela biblioteca padrÃ£o.
Usar <code>unwrap_or_else</code> nos permite definir algum erro personalizado, nÃ£o-<code>panic!</code> de
manipulaÃ§Ã£o. Se o <code>Result</code> for um valor <code>Ok</code>, o comportamento deste mÃ©todo Ã© semelhante
a <code>unwrap</code>: ele retorna o valor interno <code>Ok</code>. No entanto, se o valor
Ã© um valor <code>Err</code>, este mÃ©todo chama o cÃ³digo na <em>closure</em>, que Ã© uma
funÃ§Ã£o anÃ´nima que definimos e passamos como um argumento para <code>unwrap_or_else</code>. NÃ³s
entraremos em detalhes sobre closures no CapÃ­tulo 13. Por enquanto, vocÃª precisa apenas saber
que <code>unwrap_or_else</code> passarÃ¡ o valor interno do <code>Err</code>, que neste
caso Ã© a string estÃ¡tica <code>not enough arguments</code> que adicionamos na Listagem 12-9,
para o nosso closure no argumento <code>err</code> que aparece entre os pipes verticais.
O cÃ³digo no closure pode entÃ£o usar o valor <code>err</code> quando ele Ã© executado.</p>
<p>Adicionamos uma nova linha de <code>use</code> para importar <code>process</code> da biblioteca padrÃ£o.
O cÃ³digo na closure que serÃ¡ executado no caso de erro sÃ£o apenas duas linhas: nÃ³s
imprimos o valor de <code>err</code> e depois chamamos <code>process::exit</code>. A funÃ§Ã£o <code>process::exit</code>
interromperÃ¡ o programa imediatamente e retornarÃ¡ o nÃºmero que foi
passado como o cÃ³digo de status de saÃ­da. Isso Ã© semelhante ao manuseio baseado no <code>panic!</code>
que usamos na Listagem 12-8, mas jÃ¡ nÃ£o obtemos todos os resultados extras. Vamos tentar
isto:</p>
<pre><code class="language-text">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48 secs
     Running `target/debug/minigrep`
Problem parsing arguments: not enough arguments
</code></pre>
<p>Ã“timo! Este resultado Ã© muito mais amigÃ¡vel para os nossos usuÃ¡rios.</p>
<a class="header" href="print.html#extraindo-a-lÃ³gica-do-main" id="extraindo-a-lÃ³gica-do-main"><h3>Extraindo a LÃ³gica do <code>main</code></h3></a>
<p>Agora que terminamos de refatorar a anÃ¡lise da configuraÃ§Ã£o, voltemos
a lÃ³gica do programa. Como afirmamos em â€œSeparaÃ§Ã£o de Responsabilidades para
Projetos BinÃ¡riosâ€, vamos extrair uma funÃ§Ã£o chamada <code>run</code> que irÃ¡ armazenar toda a lÃ³gica
atualmente na funÃ§Ã£o <code>main</code> que nÃ£o estÃ¡ envolvida com a configuraÃ§Ã£o ou
manipulaÃ§Ã£o de erros. Quando terminarmos, <code>main</code> serÃ¡ conciso e
fÃ¡cil de verificar por inspeÃ§Ã£o, e poderemos fazer testes para todas as
outras lÃ³gicas.</p>
<p>Listagem 12-11 mostra a funÃ§Ã£o extraÃ­da <code>run</code>. Por enquanto, estamos apenas fazendo
a pequena melhoria incremental da extraÃ§Ã£o da funÃ§Ã£o. Ainda estamos
definindo a funÃ§Ã£o em <em>src/main.rs</em>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    // --snip--

    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    run(config);
}

fn run(config: Config) {
    let mut f = File::open(config.filename).expect(&quot;file not found&quot;);

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents)
        .expect(&quot;something went wrong reading the file&quot;);

    println!(&quot;With text:\n{}&quot;, contents);
}

// --snip--
</code></pre>
<p><span class="caption">Listagem 12-11: Extraindo uma funÃ§Ã£o <code>run</code> contendo o
resto da lÃ³gica do programa</span></p>
<p>A funÃ§Ã£o <code>run</code> agora contÃ©m toda a lÃ³gica restante de <code>main</code>, comeÃ§ando
por ler o arquivo. A funÃ§Ã£o <code>run</code> pega a instÃ¢ncia <code>Config</code> como um
argumento.</p>
<a class="header" href="print.html#retornando-erros-da-funÃ§Ã£o-run" id="retornando-erros-da-funÃ§Ã£o-run"><h4>Retornando Erros da FunÃ§Ã£o <code>run</code></h4></a>
<p>Com a lÃ³gica do programa restante separada na funÃ§Ã£o <code>run</code>, podemos
melhorar o tratamento de erros, como fizemos com <code>Config::new</code> na Listagem 12-9.
Em vez de permitir que o programa entre em pÃ¢nico ao chamar <code>expect</code>, a funÃ§Ã£o <code>run</code>
retornarÃ¡ um <code>Result&lt;T, E&gt;</code> quando algo der errado. Isso permitirÃ¡
nos permitirÃ¡ consolidar ainda mais na lÃ³gica principal a manipulaÃ§Ã£o de erros em uma
maneira fÃ¡cil de usar. A Listagem 12-12 mostra as mudanÃ§as que precisamos fazer para a
assinatura e corpo de <code>run</code>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::error::Error;

// --snip--

fn run(config: Config) -&gt; Result&lt;(), Box&lt;Error&gt;&gt; {
    let mut f = File::open(config.filename)?;

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents)?;

    println!(&quot;With text:\n{}&quot;, contents);

    Ok(())
}
</code></pre>
<p><span class="caption">Listagem 12-12: Alterar a funÃ§Ã£o <code>run</code> para retornar
<code>Result</code></span></p>
<p>NÃ³s fizemos trÃªs mudanÃ§as significativas aqui. Primeiro, mudamos o tipo de retorno
da funÃ§Ã£o <code>run</code> para <code>Result&lt;(), Box&lt;Error&gt;&gt;</code>. Esta funÃ§Ã£o anteriormente
devolveu o tipo de unidade, <code>()</code>, e nÃ³s mantemos isso como o valor retornado <code>Ok</code> no
caso.</p>
<p>Para o tipo de erro, usamos o <em>trait object</em> <code>Box&lt;Error&gt;</code> (e nÃ³s trouxemos
<code>std::error::Error</code> no escopo com uma instruÃ§Ã£o <code>use</code> na parte superior). Vamos cobrir
objetos trait no CapÃ­tulo 17. Por enquanto, apenas saiba que <code>Box&lt;Error&gt;</code> significa que
a funÃ§Ã£o retornarÃ¡ um tipo que implemente o trait <code>Error</code>, mas nÃ£o temos
que especificar qual tipo em particular o valor de retorno serÃ¡. Isso nos dÃ¡
flexibilidade para retornar valores de erro que podem ser de diferentes tipos em diferentes
casos de erro.</p>
<p>Em segundo lugar, removemos as chamadas para <code>expect</code> em favor de <code>?</code>, como falamos sobre
isso no CapÃ­tulo 9. Ao invÃ©s de <code>panic!</code> em um erro, <code>?</code> retornarÃ¡ o valor do erro
a partir da funÃ§Ã£o atual para que o chamador lide com ele.</p>
<p>Em terceiro lugar, a funÃ§Ã£o <code>run</code> agora retorna um valor <code>Ok</code> no caso de sucesso. NÃ³s
declaramos o tipo de sucesso da funÃ§Ã£o <code>run</code> como <code>()</code> na assinatura, que
significa que precisamos wrap (envolver) o valor do tipo de unidade no valor <code>Ok</code>. Esta sintaxe <code>Ok(())</code>
pode parecer um pouco estranha no inÃ­cio, mas usar <code>()</code> como este Ã© o
maneira idiomÃ¡tica de indicar que chamamos <code>run</code> para seus efeitos colaterais somente;
ele nÃ£o retorna o valor que precisamos.</p>
<p>Quando vocÃª executa este cÃ³digo, ele compilarÃ¡, mas exibirÃ¡ um aviso:</p>
<pre><code class="language-text">warning: unused `std::result::Result` which must be used
  --&gt; src/main.rs:18:5
   |
18 |     run(config);
   |     ^^^^^^^^^^^^
= note: #[warn(unused_must_use)] on by default
</code></pre>
<p>Rust nos diz que nosso cÃ³digo ignorou o valor <code>Result</code> e o valor de <code>Result</code>
pode indicar que ocorreu um erro. Mas nÃ£o estamos checando para ver se ocorreu ou
nÃ£o o erro, e o compilador nos lembra que provavelmente querÃ­amos
tratar algum cÃ³digo de erros aqui! Vamos corrigir esse problema agora.</p>
<a class="header" href="print.html#manipulaÃ§Ã£o-de-erros-retornados-de-run-em-main" id="manipulaÃ§Ã£o-de-erros-retornados-de-run-em-main"><h4>ManipulaÃ§Ã£o de Erros Retornados de <code>run</code> em <code>main</code></h4></a>
<p>Verificamos erros e lidaremos com eles usando uma tÃ©cnica semelhante Ã  nossa
manipulaÃ§Ã£o de erros com <code>Config::new</code> na Listagem 12-10, mas com umas
diferenÃ§as:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    // --snip--

    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    if let Err(e) = run(config) {
        println!(&quot;Application error: {}&quot;, e);

        process::exit(1);
    }
}
</code></pre>
<p>Usamos <code>if let</code> em vez de <code>unwrap_or_else</code> para verificar se <code>run</code> retorna um valor
<code>Err</code> e chama <code>process::exit(1)</code> se o fizer. A funÃ§Ã£o <code>run</code> nÃ£o retorna
um valor que queremos <code>unwrap</code> da mesma forma que <code>Config::new</code>
retorna a instÃ¢ncia <code>Config</code>. Porque <code>run</code> retorna <code>()</code> no caso de sucesso,
nÃ³s sÃ³ nos preocupamos em detectar um erro, por isso nÃ£o precisamos de <code>unwrap_or_else</code> para
devolver o valor unwrapped porque seria apenas <code>()</code>.</p>
<p>Os corpos das funÃ§Ãµes <code>if let</code> e <code>unwrap_or_else</code> sÃ£o os mesmos em
ambos os casos: imprimimos o erro e saÃ­mos.</p>
<a class="header" href="print.html#dividindo-o-cÃ³digo-em-uma-crate-de-biblioteca" id="dividindo-o-cÃ³digo-em-uma-crate-de-biblioteca"><h3>Dividindo o CÃ³digo em uma Crate de Biblioteca</h3></a>
<p>O nosso projeto <code>minigrep</code> parece estar bem atÃ© agora! Agora vamos dividir o
<em>src/main.rs</em> e colocar algum cÃ³digo no arquivo <em>src/lib.rs</em> para que possamos testÃ¡-lo
em um arquivo <em>src/main.rs</em> com menos responsabilidades.</p>
<p>Vamos mover todo o cÃ³digo que nÃ£o Ã© da funÃ§Ã£o <code>main</code> de  <em>src/main.rs</em> para
<em>src/lib.rs</em>:</p>
<ul>
<li>A definiÃ§Ã£o de funÃ§Ã£o <code>run</code></li>
<li>As instruÃ§Ãµes relevantes <code>use</code></li>
<li>A definiÃ§Ã£o de <code>Config</code></li>
<li>A definiÃ§Ã£o da funÃ§Ã£o <code>Config::new</code></li>
</ul>
<p>O conteÃºdo de <em>src/lib.rs</em> deve ter as assinaturas mostradas na Listagem 12-13
(omitimos o corpo das funÃ§Ãµes por brevidade). Observe que isso nÃ£o irÃ¡
compilar atÃ© modificar o <em>src/main.rs</em> na listagem depois desta:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">use std::error::Error;
use std::fs::File;
use std::io::prelude::*;

pub struct Config {
    pub query: String,
    pub filename: String,
}

impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --snip--
    }
}

pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;Error&gt;&gt; {
    // --snip--
}
</code></pre>
<p><span class="caption">Listagem 12-13: movendo <code>Config</code> e <code>run</code> para
<em>src/lib.rs</em></span></p>
<p>NÃ³s fizemos um uso liberal do <code>pub</code> aqui: no <code>Config</code>, seus campos e seu mÃ©todo <code>new</code>
, e na funÃ§Ã£o <code>run</code>. Agora temos uma crate de biblioteca que tem uma
API pÃºblica que podemos testar!</p>
<p>Agora, precisamos trazer o cÃ³digo que nÃ³s movemos para <em>src/lib.rs</em> no escopo da
crate binÃ¡ria em <em>src/main.rs</em>, conforme mostrado na Listagem 12-14:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate minigrep;

use std::env;
use std::process;

use minigrep::Config;

fn main() {
    // --snip--
    if let Err(e) = minigrep::run(config) {
        // --snip--
    }
}
</code></pre>
<p><span class="caption">Listagem 12-14: Trazendo a crate <code>minigrep</code> para o
escopo de <em>src/main.rs</em></span></p>
<p>Para colocar a crate de biblioteca na crate binÃ¡ria, usamos <code>extern crate minigrep</code>. Em seguida, adicionaremos uma linha <code>use minigrep::Config</code> para trazer para o
escopo o tipo <code>Config</code>, e iremos prefixar a funÃ£o <code>run</code> com o nome da nossa crate. Agora
todas as funcionalidades devem estar conectadas e devem funcionar. Execute o programa com
<code>cargo run</code> e verifique se tudo funciona corretamente.</p>
<p>Ufa! Isso foi trabalhoso, mas nÃ³s nos preparamos para o sucesso no
futuro. Agora Ã© muito mais fÃ¡cil lidar com erros, e nÃ³s fizemos o cÃ³digo mais
modular. Quase todo o nosso trabalho serÃ¡ feito em <em>src/lib.rs</em> a partir daqui.</p>
<p>Vamos aproveitar desta nova recÃ©m-descoberta modularidade para fazer algo que seria
difÃ­cil com o cÃ³digo antigo, mas Ã© fÃ¡cil com o novo cÃ³digo: nÃ³s iremos
escreva alguns testes!</p>
<a class="header" href="print.html#desenvolvendo-a-biblioteca-de-funcionalidades-com-desenvolvimento-guiado-por-testes" id="desenvolvendo-a-biblioteca-de-funcionalidades-com-desenvolvimento-guiado-por-testes"><h2>Desenvolvendo a Biblioteca de Funcionalidades com Desenvolvimento Guiado por Testes</h2></a>
<p>Agora que extraÃ­mos a lÃ³gica em <em>src/lib.rs</em> e deixamos o argumento de
coleta e tratamento de erros em <em>src/main.rs</em>, Ã© muito mais fÃ¡cil escrever testes
para nosso cÃ³digo da funcionalidade principal. Podemos chamar funÃ§Ãµes diretamente com
vÃ¡rios argumentos e verificar valores de retorno sem ter que chamar o nosso binÃ¡rio
da linha de comando. Sinta-se livre para escrever alguns testes para
as funÃ§Ãµes <code>Config::new</code> e <code>run</code> por sua conta.</p>
<p>Nesta seÃ§Ã£o, adicionaremos a lÃ³gica de busca ao programa <code>minigrep</code>
usando o processo Desenvolvimento Guiado por Testes (Test Driven Development (TDD)).
Nessa tÃ©cnica de desenvolvimento de software, segue estas etapas:</p>
<ol>
<li>Escreva um teste que falha e execute-o, para certificar-se de que ele falha pelo motivo
Â Â Â  esperado por vocÃª.</li>
<li>Escreva ou modifique o cÃ³digo apenas o suficiente para fazer passar no teste.</li>
<li>Refatore o cÃ³digo que vocÃª acabou de adicionar ou alterou e certifique-se de que os testes
Â Â Â  continuam a passar.</li>
<li>Repita a partir do passo 1!</li>
</ol>
<p>Este processo Ã© apenas uma das muitas maneiras de escrever software, mas o TDD pode ajudar a conduzir
design de cÃ³digo tambÃ©m. Escrevendo o teste antes de escrever o cÃ³digo que faz o
teste passar, ajuda a manter uma alta cobertura de teste ao longo do processo.</p>
<p>Testaremos a implementaÃ§Ã£o da funcionalidade que realmente farÃ¡
a busca da string de consulta no conteÃºdo do arquivo, e produzir uma lista de
linhas que correspondem Ã  consulta. Vamos adicionar essa funcionalidade em uma funÃ§Ã£o chamada
<code>search</code>.</p>
<a class="header" href="print.html#escrevendo-um-teste-de-falha" id="escrevendo-um-teste-de-falha"><h3>Escrevendo um Teste de Falha</h3></a>
<p>Porque nÃ£o precisamos mais deles, vamos remover as instruÃ§Ãµes <code>println!</code> de
<em>src/lib.rs</em> e <em>src/main.rs</em> que costumÃ¡vamos verificar o comportamento do programa.
EntÃ£o, em <em>src/lib.rs</em>, adicionaremos um mÃ³dulo <code>test</code> com uma funÃ§Ã£o de teste, como nÃ³s
fizemos no CapÃ­tulo 11. A funÃ§Ã£o de teste especifica o comportamento que queremos
para a funÃ§Ã£o <code>search</code> tenha: receberÃ¡ os parÃ¢metros da consulta e o texto para realizar a
consulta, e retornarÃ¡ apenas as linhas do texto que contÃ©m a consulta.
A Listagem 12-15 mostra esse teste, que ainda nÃ£o compilarÃ¡:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
#      vec![]
# }
#
#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn one_result() {
        let query = &quot;duct&quot;;
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.&quot;;

        assert_eq!(
            vec![&quot;safe, fast, productive.&quot;],
            search(query, contents)
        );
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 12-15: Criando um teste de falha para a funÃ§Ã£o <code>search</code>
que desejamos ter</span></p>
<p>Este teste procura a string â€œductâ€. O texto que estamos procurando contÃ©m trÃªs
linhas, apenas uma das quais contÃ©m â€œduct.â€ Afirmamos que o valor retornado
a partir da funÃ§Ã£o <code>search</code> contÃ©m apenas a linha que esperamos.</p>
<p>NÃ£o somos capazes de executar este teste e vÃª-lo falhar porque o teste nem mesmo
compila: a funÃ§Ã£o <code>search</code> ainda nÃ£o existe! EntÃ£o, agora vamos adicionar cÃ³digo apenas o suficiente
para obter a compilaÃ§Ã£o do teste, e executar, adicionando uma definiÃ§Ã£o da funÃ§Ã£o <code>search</code>
que sempre retorna um vetor vazio, como mostrado na Listagem 12-16. EntÃ£o
o teste deve compilar e falhar porque um vetor vazio nÃ£o corresponde a um vetor
contendo a linha <code>&quot;safe, fast, productive.&quot;</code>.</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    vec![]
}
#}</code></pre></pre>
<p><span class="caption">Listagem 12-16: Definindo apenas o suficiente da funÃ§Ã£o <code>search</code>
para que nosso teste compile</span></p>
<p>Observe que precisamos de uma lifetime explÃ­cita <code>'a</code> definida na assinatura do
<code>search</code> e usada com o argumento <code>contents</code> e o valor de retorno. Lembre-se no
CapÃ­tulo 10 que os parÃ¢metros de lifetime especificam qual o lifetime do argumento
conectado ao lifetime do valor de retorno. Neste caso, indicamos que
o vetor retornado deve conter pedaÃ§os de string que fazem referÃªncia a pedaÃ§os do
argumento <code>contents</code> (em vez do argumento <code>query</code>).</p>
<p>Em outras palavras, dizemos ao Rust que os dados retornados pela funÃ§Ã£o <code>search</code>
irÃ¡ viver enquanto os dados passarem para a funÃ§Ã£o <code>search</code> no
argumento de <code>contents</code>. Isso Ã© importante! Os dados referenciados <em>por</em> um pedaÃ§o precisa
ser vÃ¡lido para que a referÃªncia seja vÃ¡lida; se o compilador assume que estamos fazendo
pedaÃ§os de string de <code>query</code> em vez de <code>contents</code>, ele farÃ¡ sua verificaÃ§Ã£o de seguranÃ§a
incorretamente.</p>
<p>Se esquecermos as anotaÃ§Ãµes de lifetime e tentarmos compilar esta funÃ§Ã£o, iremos
obter este erro:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt; src/lib.rs:5:51
  |
5 | pub fn search(query: &amp;str, contents: &amp;str) -&gt; Vec&lt;&amp;str&gt; {
  |                                                   ^ expected lifetime
parameter
  |
  = help: this function's return type contains a borrowed value, but the
  signature does not say whether it is borrowed from `query` or `contents`
</code></pre>
<p>Rust nÃ£o consegue saber qual dos dois argumentos que precisamos, entÃ£o precisamos informar
isto. Porque <code>contents</code> Ã© o argumento que contÃ©m todo o nosso texto e nÃ³s
queremos retornar as partes desse texto que combinam, sabemos que o <code>contents</code> Ã© o
argumento que deve ser conectado ao valor de retorno usando a sintaxe de lifetime.</p>
<p>Outras linguagens de programaÃ§Ã£o nÃ£o exigem que vocÃª conecte argumentos para retornar
valores na assinatura, por isso, embora isso possa parecer estranho, ele ficarÃ¡
mais fÃ¡cil ao longo do tempo. VocÃª pode querer comparar este exemplo com a seÃ§Ã£o â€œValidando
ReferÃªncias com Lifetimesâ€ no CapÃ­tulo 10.</p>
<p>Agora vamos executar o teste:</p>
<pre><code class="language-text">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
--warnings--
    Finished dev [unoptimized + debuginfo] target(s) in 0.43 secs
     Running target/debug/deps/minigrep-abcabcabc

running 1 test
test test::one_result ... FAILED

failures:

---- test::one_result stdout ----
        thread 'test::one_result' panicked at 'assertion failed: `(left ==
right)`
left: `[&quot;safe, fast, productive.&quot;]`,
right: `[]`)', src/lib.rs:48:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.


failures:
    test::one_result

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Ã“timo, o teste falha, exatamente como esperÃ¡vamos. Vamos fazer o teste passar!</p>
<a class="header" href="print.html#escrevendo-cÃ³digo-para-passar-no-teste" id="escrevendo-cÃ³digo-para-passar-no-teste"><h3>Escrevendo CÃ³digo para Passar no Teste</h3></a>
<p>Atualmente, nosso teste estÃ¡ falhando porque sempre devolvemos um vetor vazio. Para consertar
isso Ã© preciso implementar <code>search</code>, nosso programa precisa seguir essas etapas:</p>
<ul>
<li>Iterar atravÃ©s de cada linha do conteÃºdo.</li>
<li>Verificar se a linha contÃ©m nossa string de consulta.</li>
<li>Se a tiver, adicione-a Ã  lista de valores que estamos retornando.</li>
<li>Se nÃ£o, nÃ£o faÃ§a nada.</li>
<li>Retorna a lista de resultados que correspondem.</li>
</ul>
<p>Vamos trabalhar em cada passo, comeÃ§ando por iterar atravÃ©s de linhas.</p>
<a class="header" href="print.html#iterar-atravÃ©s-de-linhas-com-o-mÃ©todo-lines" id="iterar-atravÃ©s-de-linhas-com-o-mÃ©todo-lines"><h4>Iterar AtravÃ©s de Linhas com o MÃ©todo <code>lines</code></h4></a>
<p>Rust tem um mÃ©todo Ãºtil para lidar com a iteraÃ§Ã£o linha-a-linha de strings,
convenientemente chamado <code>lines</code>, que funciona como mostrado na Listagem 12-17. Observe que isso
ainda nÃ£o compilarÃ¡:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        // faÃ§a algo com line
    }
}
</code></pre>
<p><span class="caption">Listagem 12-17: Iterando para cada linha em <code>contents</code>
</span></p>
<p>O mÃ©todo <code>lines</code> retorna um iterador. Vamos falar sobre iteradores em profundidade no
CapÃ­tulo 13, mas lembre-se de que vocÃª viu essa maneira de usar um iterador na Listagem
3-4, onde usamos um loop <code>for</code> com um iterador para executar algum cÃ³digo em cada item
de uma coleÃ§Ã£o.</p>
<a class="header" href="print.html#pesquisando-cada-linha-para-a-consulta" id="pesquisando-cada-linha-para-a-consulta"><h4>Pesquisando Cada Linha para a Consulta</h4></a>
<p>Em seguida, verificamos se a linha atual contÃ©m nossa string de consulta.
Felizmente, as strings possuem um mÃ©todo Ãºtil chamado <code>contains</code> que faz isso para
nÃ³s! Adicione uma chamada ao mÃ©todo <code>contains</code> na funÃ§Ã£o <code>search</code>, conforme mostrado na
Listagem 12-18. Observe que isso ainda nÃ£o compilarÃ¡ ainda:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        if line.contains(query) {
            // do something with line
        }
    }
}
</code></pre>
<p><span class="caption">Listagem 12-18: Adicionando funcionalidade para ver se
a linha contÃ©m a string na <code>query</code></span></p>
<a class="header" href="print.html#armazenamento-de-linhas-correspondentes" id="armazenamento-de-linhas-correspondentes"><h4>Armazenamento de Linhas Correspondentes</h4></a>
<p>NÃ³s tambÃ©m precisamos de uma maneira de armazenar as linhas que contÃªm nossa string de consulta. Por isso,
podemos fazer um vetor mutÃ¡vel antes do loop <code>for</code> e chamar o mÃ©todo <code>push</code>
para armazenar uma <code>line</code> no vetor. ApÃ³s o loop <code>for</code>, devolvemos o vetor, como
mostrado na Listagem 12-19:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
</code></pre>
<p><span class="caption">Listagem 12-19: Armazenando as linhas que combinam para que possamos
devolvÃª-las</span></p>
<p>Agora, a funÃ§Ã£o <code>search</code> deve retornar apenas as linhas que contÃªm<code>query</code>,
e nosso teste deve passar. Vamos executar o teste:</p>
<pre><code class="language-text">$ cargo test
--snip--
running 1 test
test test::one_result ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Nosso teste passou, entÃ£o sabemos que funciona!</p>
<p>Neste ponto, poderÃ­amos considerar oportunidades de refatorar
a implementaÃ§Ã£o da funÃ§Ã£o de pesquisa, mantendo os testes passando para
a mesma funcionalidade. O cÃ³digo na funÃ§Ã£o de pesquisa nÃ£o Ã© muito ruim,
mas nÃ£o tira proveito de algumas caracterÃ­sticas Ãºteis dos iteradores. Iremos
voltar para este exemplo no CapÃ­tulo 13, onde exploraremos iteradores em detalhes
e veremos como melhorÃ¡-lo.</p>
<a class="header" href="print.html#usando-a-funÃ§Ã£o-search-na-funÃ§Ã£orun" id="usando-a-funÃ§Ã£o-search-na-funÃ§Ã£orun"><h4>Usando a FunÃ§Ã£o <code>search</code> na FunÃ§Ã£o<code>run</code></h4></a>
<p>Agora que a funÃ§Ã£o <code>search</code> estÃ¡ funcionando e testada, precisamos chamar <code>search</code>
da nossa funÃ§Ã£o <code>run</code>. Precisamos passar o valor <code>config.query</code> e o
<code>contents</code> que <code>run</code> lÃª do arquivo para a funÃ§Ã£o <code>search</code>. EntÃ£o, <code>run</code>
irÃ¡ imprimir cada linha retornada de <code>search</code>:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;Error&gt;&gt; {
    let mut f = File::open(config.filename)?;

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents)?;

    for line in search(&amp;config.query, &amp;contents) {
        println!(&quot;{}&quot;, line);
    }

    Ok(())
}
</code></pre>
<p>Ainda estamos usando um loop <code>for</code> para retornar cada linha de <code>search</code> e imprimi-lo.</p>
<p>Agora, todo o programa deve funcionar! Vamos tentar, primeiro, com uma palavra que
deve retornar exatamente uma linha do poema de Emily Dickinson, â€œfrogâ€:</p>
<pre><code class="language-text">$ cargo run frog poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.38 secs
     Running `target/debug/minigrep frog poem.txt`
How public, like a frog
</code></pre>
<p>Legal! Agora vamos tentar uma palavra que combine vÃ¡rias linhas, como â€œbodyâ€:</p>
<pre><code class="language-text">$ cargo run body poem.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep body poem.txt`
Iâ€™m nobody! Who are you?
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>E, finalmente, vamos nos certificar de que nÃ£o recebemos nenhuma linha quando buscamos uma
palavra que nÃ£o estÃ¡ em qualquer lugar no poema, como â€œmonomorphizationâ€:</p>
<pre><code class="language-text">$ cargo run monomorphization poem.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep monomorphization poem.txt`
</code></pre>
<p>Excelente! NÃ³s construÃ­mos nossa prÃ³pria mini versÃ£o de uma ferramenta clÃ¡ssica e aprendemos muito
sobre como estruturar aplicativos. TambÃ©m aprendemos um pouco sobre a entrada de arquivos
e saÃ­da, lifetimes, teste e anÃ¡lise de linha de comando.</p>
<p>Para completar este projeto, brevemente demonstraremos como trabalhar com
variÃ¡veis de ambiente e como imprimir em erro padrÃ£o, ambos
Ãºteis quando vocÃª estÃ¡ escrevendo programas de linha de comando.</p>
<a class="header" href="print.html#trabalhando-com-variÃ¡veis-de-ambiente" id="trabalhando-com-variÃ¡veis-de-ambiente"><h2>Trabalhando com VariÃ¡veis de Ambiente</h2></a>
<p>Melhoraremos <code>minigrep</code> adicionando um recurso extra: uma opÃ§Ã£o para
pesquisa insensÃ­vel Ã s letras maiÃºsculas ou minÃºsculas, que o usuÃ¡rio poderÃ¡ ativar atravÃ©s de
variÃ¡vel de ambiente. PoderÃ­amos fazer deste recurso uma opÃ§Ã£o de linha de comando e exigir que
os usuÃ¡rios entram cada vez que eles querem que ele se aplique, mas, em vez disso, usaremos um
variÃ¡vel de ambiente. Isso permite que nossos usuÃ¡rios estabeleÃ§am a variÃ¡vel de ambiente
uma vez e todas as suas buscas sÃ£o insensÃ­veis Ã s maiÃºsculas e minÃºsculas naquela sessÃ£o do terminal.</p>
<a class="header" href="print.html#escrevendo-um-teste-de-falha-para-a-funÃ§Ã£o-search-insensÃ­vel-a-maiÃºsculas-e-minÃºsculas" id="escrevendo-um-teste-de-falha-para-a-funÃ§Ã£o-search-insensÃ­vel-a-maiÃºsculas-e-minÃºsculas"><h3>Escrevendo um Teste de Falha para a FunÃ§Ã£o <code>search</code> insensÃ­vel a MaiÃºsculas e MinÃºsculas</h3></a>
<p>Queremos adicionar uma nova funÃ§Ã£o <code>search_case_insensitive</code> que chamaremos quando
a variÃ¡vel de ambiente estiver ativada. Seguiremos com o processo TDD, entÃ£o
o primeiro passo Ã© novamente escrever um teste de falha. Vamos adicionar um novo teste para a
nova funÃ§Ã£o <code>search_case_insensitive</code> e renomear nosso antigo teste de
<code>one_result</code> para <code>case_sensitive</code> de forma a esclarecer as diferenÃ§as entre os dois
testes, conforme mostrado na Listagem 12-20:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn case_sensitive() {
        let query = &quot;duct&quot;;
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.
Duct tape.&quot;;

        assert_eq!(
            vec![&quot;safe, fast, productive.&quot;],
            search(query, contents)
        );
    }

    #[test]
    fn case_insensitive() {
        let query = &quot;rUsT&quot;;
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.
Trust me.&quot;;

        assert_eq!(
            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
            search_case_insensitive(query, contents)
        );
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 12-20: Adicionando um novo teste de falha para a
funÃ§Ã£o insensÃ­vel Ã  maiÃºsculas e minÃºsculas que estamos prestes a adicionar</span></p>
<p>Note que tambÃ©m editamos o <code>contents</code> do antigo teste. Adicionamos uma nova linha
com o texto <code>â€œDuct tapeâ€</code> usando um D maiÃºsculo que nÃ£o deve corresponder Ã  consulta
â€œductâ€ quando procuramos de forma sensÃ­vel Ã  maiÃºsculas e minÃºsculas. Alterando o teste antigo
desta forma, ajuda a garantir que nÃ£o quebramos acidentalmente a diferenciaÃ§Ã£o de maiÃºsculas e minÃºsculas
na funcionalidade de pesquisa que jÃ¡ implementamos. Este teste deve passar agora
e deve continuar a passar enquanto trabalhamos na pesquisa insensÃ­vel Ã  maiÃºsculas e minÃºsculas.</p>
<p>O novo teste para a pesquisa insensÃ­vel usa â€œrUsTâ€ para sua consulta. Na funÃ§Ã£o
<code>search_case_insensitive</code> que estamos prestes a adicionar, a consulta â€œrUsTâ€ deve
combinar a linha que contÃ©m â€œRust:â€ com um R maiÃºsculo e tambÃ©m a linha â€œTrust
me.â€, embora ambos tenham uma caixa (maiÃºsculas e minÃºsculas) diferente da consulta. Este Ã© o nosso teste de
falha, e ele nÃ£o compilarÃ¡ porque ainda nÃ£o definimos a
funÃ§Ã£o <code>search_case_insensitive</code>. Sinta-se livre para adicionar uma implementaÃ§Ã£o
que sempre retorna um vetor vazio, semelhante Ã  forma como fizemos para a funÃ§Ã£o <code>search</code>
na Listagem 12-16 para ver a compilaÃ§Ã£o e o teste falhar.</p>
<a class="header" href="print.html#implementando-a-funÃ§Ã£o-search_case_insensitive" id="implementando-a-funÃ§Ã£o-search_case_insensitive"><h3>Implementando a FunÃ§Ã£o <code>search_case_insensitive</code></h3></a>
<p>A funÃ§Ã£o <code>search_case_insensitive</code>, mostrada na Listagem 12-21, serÃ¡ quase
o mesmo que a funÃ§Ã£o <code>search</code>. A Ãºnica diferenÃ§a Ã© que vamos forÃ§ar minÃºsculas
para <code>query</code> e para cada <code>line</code>, qualquer que seja o caso dos argumentos de entrada,
eles serÃ£o sempre minÃºsculos quando verificamos se a linha contÃ©m a consulta:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn search_case_insensitive&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let query = query.to_lowercase();
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.to_lowercase().contains(&amp;query) {
            results.push(line);
        }
    }

    results
}
#}</code></pre></pre>
<p><span class="caption">Listagem 12-21: Definindo a funÃ§Ã£o <code>search_case_insensitive</code>
para forÃ§ar caixa baixa na consulta antes de comparÃ¡-las</span></p>
<p>Primeiro, caixa baixa na string <code>query</code> e a armazenamos em uma variÃ¡vel sombreada com
o mesmo nome. Chamar <code>to_lowercase</code> na consulta Ã© necessÃ¡rio, portanto, nÃ£o importa
se a consulta do usuÃ¡rio Ã© â€œrustâ€, â€œRUSTâ€, â€œRustâ€, ou â€œrUsTâ€, trataremos a
consulta como se fosse â€œrustâ€ sendo insensÃ­vel ao caso.</p>
<p>Note que <code>query</code> Ã© agora uma <code>String</code> ao invÃ©s de um fatia de string, porque chamar
<code>to_lowercase</code> cria novos dados em vez de referenciar dados existentes. Suponha que
a consulta Ã© â€œrUsTâ€, por exemplo: essa fatia de string nÃ£o contÃ©m minÃºsculas
â€œuâ€ ou â€œtâ€ para nÃ³s usarmos, entÃ£o temos que alocar uma nova <code>String</code> contendo
â€œrustâ€. Quando passamos <code>query</code> como um argumento para o mÃ©todo <code>contains</code> agora, nÃ³s
precisamos adicionar um ampersand (&amp;) porque a assinatura de <code>contains</code> Ã© definida para
uma fatia de string.</p>
<p>Em seguida, adicionamos uma chamada a <code>to_lowercase</code> em cada <code>line</code> antes de verificarmos se
contÃ©m <code>query</code> para passar para caixa baixa em todos os caracteres. Agora que convertemos <code>line</code>
e <code>query</code> para letras minÃºsculas, encontraremos correspondÃªncias, nÃ£o importa qual seja o caso da
consulta.</p>
<p>Vamos ver se esta implementaÃ§Ã£o passa nos testes:</p>
<pre><code class="language-text">running 2 tests
test test::case_insensitive ... ok
test test::case_sensitive ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Ã“timo! Eles passaram. Agora, vamos chamar a nova funÃ§Ã£o <code>search_case_insensitive</code>
da funÃ§Ã£o <code>run</code>. Primeiro, adicionaremos uma opÃ§Ã£o de configuraÃ§Ã£o ao
<code>Config</code> struct para alternar entre pesquisa sensÃ­vel a maiÃºsculas e minÃºsculas.
Adicionar esse campo causarÃ¡ erros no compilador, jÃ¡ que nÃ£o estamos inicializando
o campo em nenhum lugar:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Config {
    pub query: String,
    pub filename: String,
    pub case_sensitive: bool,
}
#}</code></pre></pre>
<p>Note que nÃ³s adicionamos o campo <code>case_sensitive</code> que contÃ©m um Booleano. Em seguida nÃ³s
precisamos da funÃ§Ã£o <code>run</code> para verificar o valor do campo <code>case_sensitive</code> e usÃ¡-la
para decidir se devemos chamar a funÃ§Ã£o <code>search</code> ou a
funÃ§Ã£o <code>search_case_insensitive</code>, conforme mostrado na Listagem 12-22. Note que isso ainda
nÃ£o irÃ¡ compilar ainda:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::error::Error;
# use std::fs::File;
# use std::io::prelude::*;
#
# fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
#      vec![]
# }
#
# fn search_case_insensitive&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
#      vec![]
# }
#
# struct Config {
#     query: String,
#     filename: String,
#     case_sensitive: bool,
# }
#
pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;Error&gt;&gt; {
    let mut f = File::open(config.filename)?;

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents)?;

    let results = if config.case_sensitive {
        search(&amp;config.query, &amp;contents)
    } else {
        search_case_insensitive(&amp;config.query, &amp;contents)
    };

    for line in results {
        println!(&quot;{}&quot;, line);
    }

    Ok(())
}
#}</code></pre></pre>
<p><span class="caption">Listagem 12-22: Chamando  <code>search</code> ou
<code>search_case_insensitive</code> baseado no valor em <code>config.case_sensitive</code></span></p>
<p>Finalmente, precisamos verificar a variÃ¡vel de ambiente. As funÃ§Ãµes para
trabalhar com variÃ¡veis de ambiente estÃ£o no mÃ³dulo <code>env</code> na biblioteca padrÃ£o
, por isso queremos trazer esse mÃ³dulo para o escopo com uma linha <code>use std::env;</code>
no topo de <em>src/lib.rs</em>. EntÃ£o vamos usar o mÃ©todo <code>var</code> do mÃ³dulo <code>env</code>
para verificar uma variÃ¡vel de ambiente chamada <code>CASE_INSENSITIVE</code>, conforme
na Listagem 12-23:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::env;
# struct Config {
#     query: String,
#     filename: String,
#     case_sensitive: bool,
# }

// --snip--

impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        let case_sensitive = env::var(&quot;CASE_INSENSITIVE&quot;).is_err();

        Ok(Config { query, filename, case_sensitive })
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 12-23: Checando por uma variÃ¡vel de ambiente chamada
<code>CASE_INSENSITIVE</code></span></p>
<p>Aqui, criamos uma nova variÃ¡vel <code>case_sensitive</code>. Para definir seu valor, chamamos a
funÃ§Ã£o <code>env::var</code> e passamos o nome da variÃ¡vel de ambiente <code>CASE_INSENSITIVE</code>
. O mÃ©todo <code>env::var</code> retorna um <code>Result</code> que serÃ¡ o sucesso
variante <code>Ok</code> que contÃ©m o valor da variÃ¡vel de ambiente se a
variÃ¡vel de ambiente estÃ¡ definida. Ele retornarÃ¡ a variante <code>Err</code> se a
variÃ¡vel de ambiente nÃ£o estÃ¡ definida.</p>
<p>Estamos usando o mÃ©todo <code>is_err</code> no <code>Result</code> para verificar se Ã© um erro
e, portanto, nÃ£o definido, o que significa que <em>deveria</em> fazer uma pesquisa sensÃ­vel a maiÃºsculas e minÃºsculas. Se
a variÃ¡vel de ambiente <code>CASE_INSENSITIVE</code> estÃ¡ configurada para qualquer coisa,<code>is_err</code> irÃ¡
retornar false e realizarÃ¡ uma pesquisa sem distinÃ§Ã£o entre maiÃºsculas e minÃºsculas. NÃ³s nÃ£o nos importamos com
o <em>valor</em> da variÃ¡vel de ambiente, apenas se estÃ¡ definido ou nÃ£o,
estamos verificando <code>is_err</code> em vez de <code>unwrap</code>, <code>expect</code> ou qualquer um dos outros
mÃ©todos que vimos em <code>Result</code>.</p>
<p>NÃ³s passamos o valor na variÃ¡vel <code>case_sensitive</code> para a instÃ¢ncia <code>Config</code>
na funÃ§Ã£o <code>run</code> pode ler esse valor e decidir se deve chamar <code>search</code> ou
<code>search_case_insensitive</code> conforme implementamos na Listagem 12-22.</p>
<p>Vamos tentar! Primeiro, executaremos nosso programa sem o conjunto de variÃ¡veis
de ambiente e com a consulta â€œtoâ€, que deve corresponder a qualquer linha que contenha
a palavra â€œtoâ€ em todas as letras minÃºsculas:</p>
<pre><code class="language-text">$ cargo run to poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>Parece que isso ainda funciona! Agora, vamos executar o programa com <code>CASE_INSENSITIVE</code>
definido como <code>1</code> mas com a mesma consulta â€œtoâ€; devemos pegar linhas que contenham â€œtoâ€
que possam ter letras maiÃºsculas:</p>
<pre><code class="language-text">$ CASE_INSENSITIVE=1 cargo run to poem.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p>Se vocÃª estiver usando o PowerShell, precisarÃ¡ definir a variÃ¡vel de ambiente e
executar o programa em dois comandos em vez de um:</p>
<pre><code class="language-text">$ $env.CASE_INSENSITIVE=1
$ cargo run to poem.txt
</code></pre>
<p>Excelente, tambÃ©m temos linhas contendo â€œToâ€! Nosso programa <code>minigrep</code> agora pode fazer
busca insensÃ­vel a maiÃºsculas e minÃºsculas controlada por uma variÃ¡vel de ambiente. Agora vocÃª
sabe como gerenciar as opÃ§Ãµes definidas usando argumentos de linha de comando ou variÃ¡veis de ambiente!</p>
<p>Alguns programas permitem argumentos <em>and</em> variÃ¡veis de ambiente para a mesma
configuraÃ§Ã£o. Nesses casos, os programas decidem que um ou outro tenham
precedÃªncia. Para outro exercÃ­cio por conta prÃ³pria, tente controlar o caso
insensibilidade atravÃ©s de um argumento de linha de comando ou uma variÃ¡vel de ambiente
. Decida se o argumento da linha de comando ou a variÃ¡vel de ambiente
deve ter precedÃªncia se o programa for executado com um conjunto para diferenciaÃ§Ã£o de maiÃºsculas e minÃºsculas
ou um conjunto para maiÃºsculas e minÃºsculas insensÃ­vel.</p>
<p>O mÃ³dulo <code>std::env</code> contÃ©m muitos mais recursos Ãºteis para lidar com
variÃ¡veis de ambiente: confira sua documentaÃ§Ã£o para ver o que estÃ¡ disponÃ­vel.</p>
<a class="header" href="print.html#escrevendo-mensagens-de-erro-para-erro-padrÃ£o-em-vez-de-saÃ­da-padrÃ£o" id="escrevendo-mensagens-de-erro-para-erro-padrÃ£o-em-vez-de-saÃ­da-padrÃ£o"><h2>Escrevendo Mensagens de Erro para Erro PadrÃ£o em Vez de SaÃ­da PadrÃ£o</h2></a>
<p>No momento, estamos escrevendo toda a nossa saÃ­da para o terminal usando a funÃ§Ã£o
<code>println!</code>. A maioria dos terminais fornece dois tipos de saÃ­da: <em>saÃ­da padrÃ£o</em>
(<code>stdout</code>) para informaÃ§Ãµes gerais e <em>erro padrÃ£o</em> (<code>stderr</code>) para mensagens
de erro. Essa distinÃ§Ã£o permite que os usuÃ¡rios escolham direcionar a saÃ­da
bem-sucedida de um programa para um arquivo, mas ainda imprimir mensagens de erro na tela.</p>
<p>A funÃ§Ã£o <code>println!</code> sÃ³ Ã© capaz de imprimir na saÃ­da padrÃ£o, entÃ£o temos
que usar outra coisa para imprimir em erro padrÃ£o.</p>
<a class="header" href="print.html#verificando-onde-os-erros-sÃ£o-escritos" id="verificando-onde-os-erros-sÃ£o-escritos"><h3>Verificando Onde os Erros sÃ£o Escritos</h3></a>
<p>Primeiro, vamos observar como o conteÃºdo impresso por <code>minigrep</code> estÃ¡ sendo
gravado na saÃ­da padrÃ£o, incluindo as mensagens de erro que desejamos gravar
no erro padrÃ£o. Faremos isso redirecionando o fluxo de saÃ­da padrÃ£o para um arquivo e,
ao mesmo tempo, causando um erro intencionalmente. NÃ£o redirecionamos o fluxo de
erros padrÃ£o, portanto, qualquer conteÃºdo enviado ao erro padrÃ£o continuarÃ¡ sendo exibido na tela.</p>
<p>Espera-se que os programas de linha de comando enviem mensagens de erro para o fluxo erro padrÃ£o
, para que ainda possamos ver mensagens de erro na tela, mesmo se redirecionarmos o fluxo
de saÃ­da padrÃ£o para um arquivo. Nosso programa nÃ£o estÃ¡ bem comportado: estamos prestes a ver
que ele salva a saÃ­da da mensagem de erro em um arquivo!</p>
<p>A maneira de demonstrar este comportamento Ã© rodando o programa com <code>&gt;</code> e o
nome do arquivo, <em>output.txt</em>, para o qual queremos redirecionar o fluxo de saÃ­da padrÃ£o.
NÃ£o passamos nenhum argumento, o que deve causar um erro:</p>
<pre><code class="language-text">$ cargo run &gt; output.txt
</code></pre>
<p>A sintaxe <code>&gt;</code> diz ao shell para gravar o conteÃºdo da saÃ­da padrÃ£o para
<em>output.txt</em> em vez da tela. NÃ³s nÃ£o vimos a mensagem de erro que estÃ¡vamos
esperando impresso na tela, o que significa que deve ter acabado no
arquivo. Isto Ã© o que o <em>output.txt</em> contÃ©m:</p>
<pre><code class="language-text">Problem parsing arguments: not enough arguments
</code></pre>
<p>Sim, nossa mensagem de erro estÃ¡ sendo impressa na saÃ­da padrÃ£o. Ã‰ muito mais
Ãºtil que mensagens de erro como essa sejam impressas no erro padrÃ£o e que somente
os dados de uma execuÃ§Ã£o bem-sucedida acabem no arquivo quando redirecionamos a
saÃ­da padrÃ£o dessa maneira. NÃ³s vamos mudar isso.</p>
<a class="header" href="print.html#imprimindo-erros-em-padrÃ£o-de-erros" id="imprimindo-erros-em-padrÃ£o-de-erros"><h3>Imprimindo Erros em PadrÃ£o de Erros</h3></a>
<p>Usaremos o cÃ³digo da Listagem 12-24 para alterar a forma como as mensagens de erro sÃ£o impressas.
Por causa da refatoraÃ§Ã£o que fizemos anteriormente neste capÃ­tulo, todo o cÃ³digo que
imprime mensagens de erro estÃ¡ em uma funÃ§Ã£o, <code>main</code>. A biblioteca padrÃ£o fornece a
macro <code>eprintln!</code> que imprime no fluxo de erro padrÃ£o, entÃ£o vamos alterar os dois
locais que estÃ¡vamos chamando <code>println!</code> para imprimir erros para usar <code>eprintln!</code>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        eprintln!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    if let Err(e) = minigrep::run(config) {
        eprintln!(&quot;Application error: {}&quot;, e);

        process::exit(1);
    }
}
</code></pre>
<p><span class="caption">Listagem 12-24: Escrevendo mensagens de erro para o erro padrÃ£o
em vez da saÃ­da padrÃ£o usando o <code>eprintln!</code></span></p>
<p>Depois de alterar <code>println!</code> para <code>eprintln!</code>, vamos executar o programa novamente
da mesma forma, sem argumentos e redirecionando a saÃ­da padrÃ£o com <code>&gt;</code>:</p>
<pre><code class="language-text">$ cargo run &gt; output.txt
Problem parsing arguments: not enough arguments
</code></pre>
<p>Agora vemos o erro na tela e o <em>output.txt</em> nÃ£o contÃ©m nada, que Ã© o
comportamento esperado dos programas de linha de comando.</p>
<p>Vamos executar o programa novamente com argumentos que nÃ£o causam erro, mas ainda
redirecionamos a saÃ­da padrÃ£o para um arquivo, da seguinte forma:</p>
<pre><code class="language-text">$ cargo run to poem.txt &gt; output.txt
</code></pre>
<p>NÃ£o veremos nenhuma saÃ­da para o terminal e <em>output.txt</em> conterÃ¡ nossos
resultados:</p>
<p><span class="filename">Arquivo: output.txt</span></p>
<pre><code class="language-text">Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>Isso demonstra que agora estamos usando a saÃ­da padrÃ£o para saÃ­da bem-sucedida e
erro padrÃ£o para saÃ­da de erro, apropriadamente.</p>
<a class="header" href="print.html#resumo-6" id="resumo-6"><h2>Resumo</h2></a>
<p>Neste capÃ­tulo, recapitulamos alguns dos principais conceitos que vocÃª aprendeu atÃ© agora
e abordamos como realizar operaÃ§Ãµes de E/S comuns em um contexto Rust. Usando argumentos
de linha de comando, arquivos, variÃ¡veis de ambiente e a macro <code>eprintln!</code> para
erros de impressÃ£o, vocÃª estÃ¡ preparado para escrever aplicativos de linha de comando. Usando
os conceitos dos capÃ­tulos anteriores, seu cÃ³digo serÃ¡ bem organizado, armazenarÃ¡ dados de forma
eficaz nas estruturas de dados apropriadas, tratarÃ¡ erros com precisÃ£o e serÃ¡ bem testado.</p>
<p>Em seguida, exploraremos alguns recursos do Rust que foram influenciados por linguagens
funcionais: closures e iteradores.</p>
<a class="header" href="print.html#functional-language-features-in-rust" id="functional-language-features-in-rust"><h1>Functional Language Features in Rust</h1></a>
<a class="header" href="print.html#closures" id="closures"><h1>Closures</h1></a>
<a class="header" href="print.html#iterators" id="iterators"><h1>Iterators</h1></a>
<a class="header" href="print.html#improving-our-io-project" id="improving-our-io-project"><h1>Improving our I/O Project</h1></a>
<a class="header" href="print.html#performance" id="performance"><h1>Performance</h1></a>
<a class="header" href="print.html#more-about-cargo-and-cratesio" id="more-about-cargo-and-cratesio"><h1>More about Cargo and Crates.io</h1></a>
<a class="header" href="print.html#release-profiles" id="release-profiles"><h1>Release Profiles</h1></a>
<a class="header" href="print.html#publishing-a-crate-to-cratesio" id="publishing-a-crate-to-cratesio"><h1>Publishing a Crate to Crates.io</h1></a>
<a class="header" href="print.html#cargo-workspaces" id="cargo-workspaces"><h1>Cargo Workspaces</h1></a>
<a class="header" href="print.html#installing-binaries-from-cratesio-with-cargo-install" id="installing-binaries-from-cratesio-with-cargo-install"><h1>Installing Binaries from Crates.io with <code>cargo install</code></h1></a>
<a class="header" href="print.html#extending-cargo-with-custom-commands" id="extending-cargo-with-custom-commands"><h1>Extending Cargo with Custom Commands</h1></a>
<a class="header" href="print.html#ponteiros-inteligentes-smart-pointers" id="ponteiros-inteligentes-smart-pointers"><h1>Ponteiros Inteligentes (Smart Pointers)</h1></a>
<p>Um <em>ponteiro</em> Ã© um conceito geral para uma variÃ¡vel que contÃ©m um endereÃ§o de
memÃ³ria. Esse endereÃ§o se refere a, ou &quot;aponta para&quot;, algum outro dado. O tipo
mais comum de ponteiro em Rust Ã© a referÃªncia, sobre a qual vocÃª aprendeu no
CapÃ­tulo 4. ReferÃªncias sÃ£o indicadas pelo sÃ­mbolo <code>&amp;</code>, e pegam emprestado o
valor para o qual apontam. Elas nÃ£o tÃªm nenhuma outra habilidade senÃ£o
referir-se a dados. AlÃ©m disso, elas nÃ£o tÃªm nenhum custo adicional e sÃ£o o tipo
de ponteiro que usamos com maior frequÃªncia.</p>
<p><em>Ponteiros inteligentes</em> (<em>smart pointers</em>), por outro lado, sÃ£o estruturas de
dados que agem como um ponteiro mas tambÃ©m tÃªm metadados e habilidades
adicionais. O conceito de ponteiros inteligentes nÃ£o Ã© exclusivo do Rust: ele
teve origem no C++ e tambÃ©m existe em outras linguagens. No Rust, os diferentes
ponteiros inteligentes definidos na biblioteca padrÃ£o proveem funcionalidades
alÃ©m daquelas providas pelas referÃªncias. Um exemplo que vamos explorar neste
capÃ­tulo Ã© o tipo de ponteiro inteligente de <em>contagem de referÃªncias</em>
(<em>reference counting</em>). Esse ponteiro lhe permite ter mÃºltiplos possuidores de
um dado. Ele mantÃ©m registro do nÃºmero de possuidores e, quando nÃ£o resta
nenhum, cuida de limpar o dado.</p>
<p>Em Rust, onde temos os conceitos de posse (<em>ownership</em>) e emprÃ©stimo
(<em>borrowing</em>), uma diferenÃ§a adicional entre referÃªncias e ponteiros
inteligentes Ã© que referÃªncias sÃ£o ponteiros que apenas <em>pegam emprestados</em> os
dados; em contraste, em muitos casos, ponteiros inteligentes <em>tÃªm posse</em> dos
dados aos quais apontam.</p>
<p>NÃ³s jÃ¡ encontramos alguns ponteiros inteligentes neste livro, como <code>String</code> e
<code>Vec&lt;T&gt;</code> no CapÃ­tulo 8, apesar de nÃ£o os termos chamado de ponteiros
inteligentes naquele momento. Ambos esses tipos contam como ponteiros
inteligentes porque eles tÃªm posse de uma parte da memÃ³ria e permitem que vocÃª a
manipule. Eles tambÃ©m tÃªm metadados (como sua capacidade) e habilidades extras
ou garantias (como a garantia que <code>String</code> dÃ¡ de que seus dados serÃ£o sempre
UTF-8 vÃ¡lido).</p>
<p>Ponteiros inteligentes normalmente sÃ£o implementados usando structs. A
caracterÃ­stica que distingue um ponteiro inteligente de uma struct qualquer Ã©
que ele implementa as traits <code>Deref</code> e <code>Drop</code>. A trait <code>Deref</code> permite que uma
instÃ¢ncia da struct do ponteiro inteligente se comporte como uma referÃªncia.
Assim podemos escrever cÃ³digo que funcione tanto com referÃªncias quanto com
ponteiros inteligentes. A trait <code>Drop</code> nos permite personalizar o cÃ³digo que Ã©
executado quando uma instÃ¢ncia do smart pointer sai de escopo. Neste capÃ­tulo,
discutiremos ambas as traits e demonstraremos porque sÃ£o importantes para
ponteiros inteligentes.</p>
<p>Dado que os ponteiros inteligentes sÃ£o um padrÃ£o de projeto (<em>design pattern</em>)
usado com frequÃªncia em Rust, este capÃ­tulo nÃ£o irÃ¡ cobrir todo ponteiro
inteligente que existe. Muitas bibliotecas tÃªm seus prÃ³prios ponteiros
inteligentes, e vocÃª pode atÃ© mesmo criar seus prÃ³prios. NÃ³s vamos cobrir os
ponteiros inteligentes mais comuns na biblioteca padrÃ£o:</p>
<ul>
<li><code>Box&lt;T&gt;</code>, para alocar valores no heap</li>
<li><code>Rc&lt;T&gt;</code>, um tipo com contagem de referÃªncias que permite posse mÃºltipla</li>
<li><code>Ref&lt;T&gt;</code> e <code>RefMut&lt;T&gt;</code>, acessados atravÃ©s de <code>RefCell&lt;T&gt;</code>, um tipo que aplica
as regras de emprÃ©stimo em tempo de execuÃ§Ã£o em vez de em tempo de compilaÃ§Ã£o</li>
</ul>
<p>AlÃ©m disso, vamos cobrir a pattern de <em>mutabilidade interior</em> (<em>interior
mutability</em>), onde um tipo imutÃ¡vel expÃµe uma API para modificar um valor
interno. TambÃ©m vamos discutir <em>ciclos de referÃªncias</em>: como eles podem vazar
memÃ³ria e como evitÃ¡-los.</p>
<p>Mergulhemos!</p>
<a class="header" href="print.html#boxt-aponta-para-dados-no-heap-e-tem-tamanho-conhecido" id="boxt-aponta-para-dados-no-heap-e-tem-tamanho-conhecido"><h2><code>Box&lt;T&gt;</code> Aponta para Dados no Heap e Tem Tamanho Conhecido</h2></a>
<p>O ponteiro inteligente mais simples Ã© um <em>box</em> (literalmente, &quot;caixa&quot;), cujo
tipo Ã© escrito <code>Box&lt;T&gt;</code>. <em>Boxes</em> (plural de <em>box</em>) lhe permitem armazenar dados
no heap em vez de na pilha. O que fica na pilha Ã© o ponteiro para o dado no
heap. Confira o CapÃ­tulo 4 para rever a diferenÃ§a entre pilha e heap.</p>
<p>Boxes nÃ£o tÃªm custo adicional de desempenho alÃ©m de armazenar dados no heap em
vez de na pilha. Mas eles tambÃ©m nÃ£o tÃªm muitas habilidades a mais. VocÃª irÃ¡
usÃ¡-los mais comumente nestas situaÃ§Ãµes:</p>
<ul>
<li>Quando vocÃª tem um tipo cujo tamanho nÃ£o Ã© possÃ­vel saber em tempo de
compilaÃ§Ã£o, e vocÃª quer usar um valor desse tipo em um contexto que precisa
saber um tamanho exato;</li>
<li>Quando vocÃª tem uma quantidade grande de dados e vocÃª quer transferir a posse
mas garantir que os dados nÃ£o serÃ£o copiados quando vocÃª o fizer;</li>
<li>Quando vocÃª quer possuir um valor e sÃ³ se importa se Ã© um tipo que implementa
uma trait especÃ­fica, em vez de saber o tipo concreto.</li>
</ul>
<p>Vamos demonstrar a primeira situaÃ§Ã£o nesta seÃ§Ã£o. Mas antes disso, vamos falar
um pouco mais sobre as outras duas situaÃ§Ãµes: no segundo caso, transferir posse
de uma quantidade grande de dados pode levar muito tempo porque os dados sÃ£o
copiados de um lado para o outro na pilha. Para melhorar o desempenho nessa
situaÃ§Ã£o, podemos armazenar essa quantidade grande de dados no heap em um box.
Assim, apenas uma quantidade pequena de dados referentes ao ponteiro Ã© copiada
na pilha, e os dados em si ficam em um lugar sÃ³ no heap. O terceiro caso Ã©
conhecido como um <em>objeto de trait</em> (<em>trait object</em>), e o CapÃ­tulo 17 dedica uma
seÃ§Ã£o inteira somente a esse tÃ³pico. EntÃ£o o que vocÃª aprender aqui vocÃª irÃ¡
aplicar de novo no CapÃ­tulo 17!</p>
<a class="header" href="print.html#usando-um-boxt-para-armazenar-dados-no-heap" id="usando-um-boxt-para-armazenar-dados-no-heap"><h3>Usando um <code>Box&lt;T&gt;</code> para Armazenar Dados no Heap</h3></a>
<p>Antes de discutirmos esse caso de uso para o <code>Box&lt;T&gt;</code>, vamos cobrir a sintaxe e
como interagir com valores armazenados dentro de um <code>Box&lt;T&gt;</code>.</p>
<p>A Listagem 15-1 mostra como usar um box para armazenar um valor <code>i32</code> no heap:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let b = Box::new(5);
    println!(&quot;b = {}&quot;, b);
}
</code></pre></pre>
<p><span class="caption">Listagem 15-1: Armazenando um valor <code>i32</code> no heap usando
um box</span></p>
<p>NÃ³s definimos a variÃ¡vel <code>b</code> como tendo o valor de um <code>Box</code> que aponta para o
valor <code>5</code>, que estÃ¡ alocado no heap. Esse programa irÃ¡ imprimir <code>b = 5</code>; nesse
caso, podemos acessar o dado no box de um jeito similar ao que usarÃ­amos se esse
dado estivesse na pilha. Da mesma forma que com qualquer valor possuÃ­do, quando
um box sai de escopo, como o <code>b</code> no fim da <code>main</code>, ele Ã© desalocado. A
desalocaÃ§Ã£o acontece para o box (armazenado na pilha) e para os dados aos quais
ele aponta (armazenados no heap).</p>
<p>Colocar um Ãºnico valor no heap nÃ£o Ã© muito Ãºtil, entÃ£o vocÃª normalmente nÃ£o vai
usar boxes sozinhos desse jeito. Ter valores como um Ãºnico <code>i32</code> na pilha, onde
sÃ£o armazenados por padrÃ£o, Ã© mais apropriado para a maioria das situaÃ§Ãµes.
Vamos dar uma olhada em um caso onde o box nos possibilita definir tipos que nÃ£o
poderÃ­amos definir sem ele.</p>
<a class="header" href="print.html#boxes-possibilitam-tipos-recursivos" id="boxes-possibilitam-tipos-recursivos"><h3>Boxes Possibilitam Tipos Recursivos</h3></a>
<p>Em tempo de compilaÃ§Ã£o, o Rust precisa saber quanto espaÃ§o um tipo ocupa. Um
<em>tipo recursivo</em> (<em>recursive type</em>), onde um valor pode ter como parte de si
mesmo outro valor do mesmo tipo, Ã© um tipo cujo tamanho nÃ£o se pode saber em
tempo de compilaÃ§Ã£o. Como esse aninhamento de valores poderia em teoria
continuar infinitamente, o Rust nÃ£o sabe quanto espaÃ§o um valor de um tipo
recursivo precisa. PorÃ©m, boxes tÃªm um tamanho conhecido, entÃ£o podemos ter
tipos recursivos inserindo um box em sua definiÃ§Ã£o.</p>
<p>Vamos explorar a <em>lista ligada</em> (<em>cons list</em>), que Ã© um tipo de dados comum em
linguagens de programaÃ§Ã£o funcional, como um exemplo de tipo recursivo. O tipo
para lista ligada que vamos definir Ã© bem bÃ¡sico exceto pela recursÃ£o; portanto,
os conceitos no exemplo que vamos trabalhar vÃ£o ser Ãºteis sempre que vocÃª se
encontrar em situaÃ§Ãµes mais complexas envolvendo tipos recursivos.</p>
<a class="header" href="print.html#mais-informaÃ§Ãµes-sobre-a-cons-list" id="mais-informaÃ§Ãµes-sobre-a-cons-list"><h4>Mais InformaÃ§Ãµes sobre a Cons List</h4></a>
<p>A <em>cons list</em> Ã© uma estrutura de dados que vem da linguagem de programaÃ§Ã£o Lisp
e seus dialetos. Em Lisp, a funÃ§Ã£o <code>cons</code> (abreviaÃ§Ã£o de &quot;construction
function&quot;, funÃ§Ã£o de construÃ§Ã£o) constrÃ³i um novo par a partir de seus dois
argumentos, que geralmente sÃ£o um valor Ãºnico e um outro par. Esses pares
contendo pares formam uma lista.</p>
<p>O conceito da funÃ§Ã£o cons acabou se tornando parte do jargÃ£o mais geral de
programaÃ§Ã£o funcional: &quot;to cons x onto y&quot; (&quot;consar&quot; x em y, grosso modo) em
inglÃªs informalmente significa construir uma nova instÃ¢ncia de um par, colocando
o elemento x no comeÃ§o desse novo par, seguido pelo par y.</p>
<p>Cada item em uma cons list contÃ©m dois elementos: o valor do item atual e o
prÃ³ximo item. O Ãºltimo item na lista contÃ©m apenas um valor chamado de <code>Nil</code>,
sem um prÃ³ximo item. Uma cons list Ã© produzida chamando-se recursivamente a
funÃ§Ã£o <code>cons</code>. O nome canÃ´nico que denota o caso base da recursÃ£o Ã© <code>Nil</code>. Note
que isso nÃ£o Ã© o mesmo que o conceito de &quot;null&quot; ou &quot;nil&quot; visto no CapÃ­tulo 6,
que Ã© um valor invÃ¡lido ou ausente.</p>
<p>Apesar de linguagens de programaÃ§Ã£o funcionais usarem cons lists frequentemente,
essa nÃ£o Ã© uma estrutura de dados muito usada em Rust. Na maioria das vezes em
que vocÃª tem uma lista de itens em Rust, <code>Vec&lt;T&gt;</code> Ã© uma escolha melhor. Outros
tipos recursivos <em>sÃ£o</em> Ãºteis em diversas situaÃ§Ãµes. Mas comeÃ§ando com a cons
list, podemos explorar como boxes nos permitem definir um tipo recursivo sem
muita distraÃ§Ã£o.</p>
<p>A Listagem 15-2 contÃ©m uma definiÃ§Ã£o de um enum para a cons list. Note que este
cÃ³digo nÃ£o compila ainda porque o tipo <code>List</code> nÃ£o tem um tamanho conhecido, como
demonstraremos:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">enum List {
    Cons(i32, List),
    Nil,
}
</code></pre>
<p><span class="caption">Listagem 15-2: A primeira tentativa de definir um enum
para representar uma estrutura de dados <em>cons list</em> de valores <code>i32</code> </span></p>
<blockquote>
<p>Nota: estamos implementando uma cons list que guarda apenas valores <code>i32</code> para
os propÃ³sitos deste exemplo. PoderÃ­amos tÃª-la implementado usando tipos
genÃ©ricos, conforme discutimos no CapÃ­tulo 10, para definir um tipo cons list
que poderia armazenar valores de qualquer tipo.</p>
</blockquote>
<p>A listagem 15-3 mostra como fica o uso do tipo <code>List</code> para armazenar a lista
<code>1, 2, 3</code>.</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">use List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}
</code></pre>
<p><span class="caption">Listagem 15-3: Usando o enum <code>List</code> para armazenar a lista
<code>1, 2, 3</code></span></p>
<p>O primeiro valor <code>Cons</code> contÃ©m <code>1</code> e outro valor <code>List</code>. Esse valor <code>List</code> Ã©
outro <code>Cons</code> que contÃ©m <code>2</code> e outro valor <code>List</code>. Esse valor <code>List</code> Ã© mais um
<code>Cons</code> que contÃ©m 3 e um valor <code>List</code>, que finalmente Ã© <code>Nil</code>, a variante nÃ£o
recursiva que sinaliza o final da lista.</p>
<p>Se tentarmos compilar o cÃ³digo na listagem 15-3, receberemos o erro mostrado na
listagem 15-4:</p>
<pre><code class="language-text">erro[E0072]: tipo recursivo `List` tem tamanho infinito
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^ tipo recursivo tem tamanho infinito
2 |     Cons(i32, List),
  |               ----- recursivo sem indireÃ§Ã£o
  |
  = ajuda: insira indireÃ§Ã£o (ex.: um `Box`, `Rc` ou `&amp;`) em algum lugar para
  tornar `List` representÃ¡vel
</code></pre>
<p><span class="caption">Listagem 15-4: O erro que recebemos quando tentamos
definir um enum recursivo</span></p>
<p>O erro diz que esse tipo &quot;tem tamanho infinito&quot;. A razÃ£o Ã© que nÃ³s definimos
<code>List</code> com uma variante que Ã© recursiva: ela contÃ©m um outro valor de si mesma
diretamente. Como resultado, o Rust nÃ£o consegue determinar quanto espaÃ§o ele
precisa para armazenar um valor <code>List</code>. Vamos analizar por partes por que
recebemos esse erro: primeiro, vamos ver como o Rust decide quanto espaÃ§o
precisa para armazenar o valor de um tipo <em>nÃ£o</em> recursivo.</p>
<a class="header" href="print.html#computando-o-tamanho-de-um-tipo-nÃ£o-recursivo" id="computando-o-tamanho-de-um-tipo-nÃ£o-recursivo"><h4>Computando o Tamanho de um Tipo NÃ£o Recursivo</h4></a>
<p>Recorde o enum <code>Mensagem</code> que definimos na Listagem 6-2 quando discutimos
definiÃ§Ãµes de enums no CapÃ­tulo 6:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Mensagem {
    Sair,
    Mover { x: i32, y: i32 },
    Escrever(String),
    MudarCor(i32, i32, i32),
}
#}</code></pre></pre>
<p>Para determinar quanto espaÃ§o alocar para um valor <code>Mensagem</code>, o Rust percorre
cada variante para ver qual precisa de mais espaÃ§o. O Rust vÃª que
<code>Mensagem::Sair</code> nÃ£o precisa de nenhum espaÃ§o, <code>Mensagem::Mover</code> precisa de
espaÃ§o suficiente para armazenar dois valores <code>i32</code>, e assim por diante. Como
apenas uma variante serÃ¡ usada, o mÃ¡ximo de espaÃ§o de que um valor <code>Mensagem</code>
vai precisar Ã© o espaÃ§o que levaria para armazenar a maior de suas variantes.</p>
<p>Contraste isso com o que acontece quando o Rust tenta determinar quanto espaÃ§o Ã©
necessÃ¡rio para um tipo recursivo como o enum <code>List</code> na Listagem 15-2. O
compilador comeÃ§a olhando a variante <code>Cons</code>, que contÃ©m um valor do tipo <code>i32</code> e
um valor do tipo <code>List</code>. Portanto, <code>Cons</code> precisa de uma quantidade de espaÃ§o
igual ao tamanho de um <code>i32</code> mais o tamanho de um <code>List</code>. Para determinar de
quanta memÃ³ria o tipo <code>List</code> precisa, o compilador olha para suas variantes,
comeÃ§ando com a <code>Cons</code>. A variante <code>Cons</code> contÃ©m um valor do tipo <code>i32</code> e um
valor do tipo <code>List</code>, e esse processo continua infinitamente, conforme mostra a
Figura 15-1:</p>
<p><img alt="Uma cons list infinita" src="img/trpl15-01.svg" class="center"
style="width: 50%;" /></p>
<p><span class="caption">Figura 15-1: Uma <code>List</code> infinita feita de infinitas
variantes <code>Cons</code></span></p>
<a class="header" href="print.html#usando-boxt-para-conseguir-um-tipo-recursivo-de-tamanho-conhecido" id="usando-boxt-para-conseguir-um-tipo-recursivo-de-tamanho-conhecido"><h4>Usando <code>Box&lt;T&gt;</code> para Conseguir um Tipo Recursivo de Tamanho Conhecido</h4></a>
<p>Como o Rust nÃ£o consegue descobrir quanto espaÃ§o alocar para tipos definidos
recursivamente, o compilador dÃ¡ o erro na Listagem 15-4. Mas o erro inclui esta
Ãºtil sugestÃ£o:</p>
<pre><code class="language-text">  = ajuda: insira indireÃ§Ã£o (ex.: um `Box`, `Rc` ou `&amp;`) em algum lugar para
  tornar `List` representÃ¡vel
</code></pre>
<p>Nessa sugestÃ£o, &quot;indireÃ§Ã£o&quot; significa que, em vez de armazenar um valor
diretamente, devemos mudar a estrutura de dados para armazenar um ponteiro para
o valor.</p>
<p>Como um <code>Box&lt;T&gt;</code> Ã© um ponteiro, o Rust sempre sabe de quanto espaÃ§o ele precisa:
o tamanho de um ponteiro nÃ£o muda dependendo da quantidade de dados para a qual
ele aponta. Isso significa que podemos colocar um <code>Box&lt;T&gt;</code> dentro da variante
<code>Cons</code> em vez de outro valor <code>List</code> diretamente. O <code>Box&lt;T&gt;</code> vai apontar para o
prÃ³ximo valor <code>List</code>, que vai estar no heap em vez de dentro da variante <code>Cons</code>.
Conceitualmente, ainda temos uma lista, criada de listas &quot;contendo&quot; outras
listas, mas essa implementaÃ§Ã£o agora Ã© mais como os itens estando um do lado do
outro do que um dentro do outro.</p>
<p>Podemos mudar a definiÃ§Ã£o do enum <code>List</code> na Listagem 15-2 e o uso de <code>List</code> na
Listagem 15-3 para o cÃ³digo na Listagem 15-5, que compila:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use List::{Cons, Nil};

fn main() {
    let list = Cons(1,
        Box::new(Cons(2,
            Box::new(Cons(3,
                Box::new(Nil))))));
}
</code></pre></pre>
<p><span class="caption">Listagem 15-5: DefiniÃ§Ã£o de <code>List</code> que usa <code>Box&lt;T&gt;</code> para
ter um tamanho conhecido</span></p>
<p>A variante <code>Cons</code> vai precisar do tamanho de um <code>i32</code> mais o espaÃ§o para
armazenar os dados do ponteiro box. A variante <code>Nil</code> nÃ£o armazena nenhum valor,
entÃ£o ela precisa de menos espaÃ§o que a variante <code>Cons</code>. Agora sabemos que
qualquer valor <code>List</code> irÃ¡ ocupar o tamanho de um <code>i32</code> mais o tamanho dos dados
de um ponteiro box. Usando um box, nÃ³s quebramos a cadeia recursiva, infinita,
para que o compilador pudesse determinar o espaÃ§o que ele precisa para
armarzenar um valor <code>List</code>. A Figura 15-2 mostra como ficou a variante <code>Cons</code>
agora:</p>
<p><img alt="Uma lista de Cons infinita" src="img/trpl15-02.svg" class="center" /></p>
<p><span class="caption">Figura 15-2: Um <code>List</code> que nÃ£o tem tamanho infinito porque
<code>Cons</code> contÃ©m um <code>Box</code></span></p>
<p>Boxes apenas proveem a indireÃ§Ã£o e a alocaÃ§Ã£o no heap; eles nÃ£o tÃªm nenhuma
outra habilidade especial, como as que vamos ver nos outros tipos de ponteiros
inteligentes. Eles tambÃ©m nÃ£o tÃªm nenhum dos custos adicionais de desempenho que
essas habilidades demandam, entÃ£o eles podem ser Ãºteis em casos como o da cons
list onde a indireÃ§Ã£o Ã© a Ãºnica funcionalidade de que precisamos. No CapÃ­tulo
17 tambÃ©m vamos ver mais casos de uso para as boxes.</p>
<p>O tipo <code>Box&lt;T&gt;</code> Ã© um ponteiro inteligente porque ele implementa a trait <code>Deref</code>,
o que permite que valores <code>Box&lt;T&gt;</code> sejam usados como referÃªncias. Quando um
valor <code>Box&lt;T&gt;</code> sai de escopo, os dados do heap para os quais o box aponta tambÃ©m
sÃ£o liberados porque o tipo implementa a trait <code>Drop</code>. Vamos explorar essas duas
traits em mais detalhe. Elas serÃ£o ainda mais importantes para a funcionalidade
provida pelos outros ponteiros inteligentes que vamos discutir no resto deste
capÃ­tulo.</p>
<a class="header" href="print.html#tratando-ponteiros-inteligentes-como-referÃªncias-normais-com-a-trait-deref" id="tratando-ponteiros-inteligentes-como-referÃªncias-normais-com-a-trait-deref"><h2>Tratando Ponteiros Inteligentes como ReferÃªncias Normais com a Trait <code>Deref</code></h2></a>
<p>Implementar a trait <code>Deref</code> nos permite personalizar o comportamento do
<em>operador de desreferÃªncia</em> (<em>dereference operator</em>), <code>*</code> (que Ã© diferente do
operador de multiplicaÃ§Ã£o ou de glob). Implementando a <code>Deref</code> de tal modo que o
ponteiro inteligente possa ser tratado como uma referÃªncia normal, podemos
escrever cÃ³digo que opere sobre referÃªncias e usar esse cÃ³digo com ponteiros
inteligentes tambÃ©m.</p>
<p>Primeiro vamos ver como o <code>*</code> funciona com referÃªncias normais, e entÃ£o vamos
tentar definir nosso prÃ³prio tipo a la <code>Box&lt;T&gt;</code> e ver por que o <code>*</code> nÃ£o funciona
como uma referÃªncia no nosso tipo recÃ©m-criado. Vamos explorar como a trait
<code>Deref</code> torna possÃ­vel aos ponteiros inteligentes funcionarem de um jeito
similar a referÃªncias. E entÃ£o iremos dar uma olhada na funcionalidade de
<em>coerÃ§Ã£o de desreferÃªncia</em> (<em>deref coercion</em>) e como ela nos permite trabalhar
tanto com referÃªncias quanto com ponteiros inteligentes.</p>
<a class="header" href="print.html#seguindo-o-ponteiro-atÃ©-o-valor-com-" id="seguindo-o-ponteiro-atÃ©-o-valor-com-"><h3>Seguindo o Ponteiro atÃ© o Valor com <code>*</code></h3></a>
<p>Uma referÃªncia normal Ã© um tipo de ponteiro, e um jeito de pensar sobre um
ponteiro Ã© como uma seta atÃ© um valor armazenado em outro lugar. Na Listagem
15-6, nÃ³s criamos uma referÃªncia a um valor <code>i32</code> e em seguida usamos o operador
de desreferÃªncia para seguir a referÃªncia atÃ© o dado:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 5;
    let y = &amp;x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre></pre>
<p><span class="caption">Listagem 15-6: Usando o operador de desreferÃªncia para
seguir uma referÃªncia a um valor <code>i32</code></span></p>
<p>A variÃ¡vel <code>x</code> contÃ©m um valor <code>i32</code>, <code>5</code>. NÃ³s setamos <code>y</code> igual a uma
referÃªncia a <code>x</code>. Podemos conferir (coloquialmente, &quot;assertar&quot;) que <code>x</code> Ã© igual
a <code>5</code>. Contudo, se queremos fazer uma asserÃ§Ã£o sobre o valor em <code>y</code>, temos que
usar <code>*y</code> para seguir a referÃªncia atÃ© o valor ao qual <code>y</code> aponta (por isso
&quot;desreferÃªncia&quot;). Uma vez que desreferenciamos <code>y</code>, temos acesso ao valor
inteiro ao qual <code>y</code> aponta para podermos comparÃ¡-lo com <code>5</code>.</p>
<p>Se em vez disso tentÃ¡ssemos escrever <code>assert_eq!(5, y);</code>, receberÃ­amos este erro
de compilaÃ§Ã£o:</p>
<pre><code class="language-text">erro[E0277]: a trait bound `{integer}: std::cmp::PartialEq&lt;&amp;{integer}&gt;` nÃ£o foi
satisfeita
 --&gt; src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^^ nÃ£o posso comparar `{integer}` com `&amp;{integer}`
  |
  = ajuda: a trait `std::cmp::PartialEq&lt;&amp;{integer}&gt;` nÃ£o estÃ¡ implementada para
  `{integer}`
</code></pre>
<p>Comparar um nÃºmero com uma referÃªncia a um nÃºmero nÃ£o Ã© permitido porque eles
sÃ£o de tipos diferentes. Devemos usar <code>*</code> para seguir a referÃªncia atÃ© o valor
ao qual ela estÃ¡ apontando.</p>
<a class="header" href="print.html#usando-boxt-como-uma-referÃªncia" id="usando-boxt-como-uma-referÃªncia"><h3>Usando <code>Box&lt;T&gt;</code> como uma ReferÃªncia</h3></a>
<p>Podemos reescrever o cÃ³digo na Listagem 15-6 para usar um <code>Box&lt;T&gt;</code> em vez de uma
referÃªncia, e o operador de desreferÃªncia vai funcionar do mesmo jeito que na
Listagem 15-7:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre></pre>
<p><span class="caption">Listagem 15-7: Usando o operador de desreferÃªncia em um
<code>Box&lt;i32&gt;</code></span></p>
<p>A Ãºnica diferenÃ§a entre a Listagem 15-7 e a Listagem 15-6 Ã© que aqui nÃ³s setamos
<code>y</code> para ser uma instÃ¢ncia de um box apontando para o valor em <code>x</code> em vez de uma
referÃªncia apontando para o valor de <code>x</code>. Na Ãºltima asserÃ§Ã£o, podemos usar o
operador de desreferÃªncia para seguir o ponteiro do box do mesmo jeito que
fizemos quando <code>y</code> era uma referÃªncia. A seguir, vamos explorar o que tem de
especial no <code>Box&lt;T&gt;</code> que nos permite usar o operador de desreferÃªncia, criando
nosso prÃ³prio tipo box.</p>
<a class="header" href="print.html#definindo-nosso-prÃ³prio-ponteiro-inteligente" id="definindo-nosso-prÃ³prio-ponteiro-inteligente"><h3>Definindo Nosso PrÃ³prio Ponteiro Inteligente</h3></a>
<p>Vamos construir um smart pointer parecido com o tipo <code>Box&lt;T&gt;</code> fornecido pela
biblioteca padrÃ£o para vermos como ponteiros inteligentes, por padrÃ£o, se
comportam diferente de referÃªncias. Em seguida, veremos como adicionar a
habilidade de usar o operador de desreferÃªncia.</p>
<p>O tipo <code>Box&lt;T&gt;</code> no fim das contas Ã© definido como uma struct-tupla (<em>tuple
struct</em>) de um elemento, entÃ£o a Listagem 15-8 define um tipo <code>MeuBox&lt;T&gt;</code> da
mesma forma. TambÃ©m vamos definir uma funÃ§Ã£o <code>new</code> como a definida no <code>Box&lt;T&gt;</code>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct MeuBox&lt;T&gt;(T);

impl&lt;T&gt; MeuBox&lt;T&gt; {
    fn new(x: T) -&gt; MeuBox&lt;T&gt; {
        MeuBox(x)
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 15-8: Definindo um tipo <code>MeuBox&lt;T&gt;</code></span></p>
<p>Definimos um struct chamado <code>MeuBox</code> e declaramos um parÃ¢metro genÃ©rico <code>T</code>,
porque queremos que nosso tipo contenha valores de qualquer tipo. O tipo
<code>MeuBox</code> Ã© uma struct-tupla de um elemento do tipo <code>T</code>. A funÃ§Ã£o <code>MeuBox::new</code>
recebe um argumento do tipo <code>T</code> e retorna uma instÃ¢ncia de <code>MeuBox</code> que contÃ©m o
valor passado.</p>
<p>Vamos tentar adicionar a funÃ§Ã£o <code>main</code> da Listagem 15-7 Ã  Listagem 15-8 e
alterÃ¡-la para usar o tipo <code>MeuBox&lt;T&gt;</code> que definimos em vez de <code>Box&lt;T&gt;</code>. O
cÃ³digo na Listagem 15-9 nÃ£o irÃ¡ compilar porque o Rust nÃ£o sabe como
desreferenciar <code>MeuBox</code>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let x = 5;
    let y = MeuBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre>
<p><span class="caption">Listagem 15-9: Tentando usar o <code>MeuBox&lt;T&gt;</code> do mesmo jeito
que usamos referÃªncias e o <code>Box&lt;T&gt;</code></span></p>
<p>Aqui estÃ¡ o erro de compilaÃ§Ã£o resultante:</p>
<pre><code class="language-text">erro[E0614]: tipo `MeuBox&lt;{integer}&gt;` nÃ£o pode ser desreferenciado
  --&gt; src/main.rs:14:19
   |
14 |     assert_eq!(5, *y);
   |                   ^^
</code></pre>
<p>Nosso tipo <code>MeuBox&lt;T&gt;</code> nÃ£o pode ser desreferenciado porque nÃ£o implementamos
essa habilidade nele. Para habilitar desreferenciamento com o operador <code>*</code>,
temos que implementar a trait <code>Deref</code>.</p>
<a class="header" href="print.html#implementando-a-trait-deref-para-tratar-um-tipo-como-uma-referÃªncia" id="implementando-a-trait-deref-para-tratar-um-tipo-como-uma-referÃªncia"><h3>Implementando a Trait <code>Deref</code> para Tratar um Tipo como uma ReferÃªncia</h3></a>
<p>Conforme discutimos no CapÃ­tulo 10, para implementar uma trait, precisamos
prover implementaÃ§Ãµes para os mÃ©todos exigidos por ela. A trait <code>Deref</code>,
disponibilizada pela biblioteca padrÃ£o, requer que implementemos um mÃ©todo
chamado <code>deref</code> que pega emprestado <code>self</code> e retorna uma referÃªncia para os
dados internos. A Listagem 15-10 contÃ©m uma implementaÃ§Ã£o de <code>Deref</code> que
agrega Ã  definiÃ§Ã£o de <code>MeuBox</code>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::ops::Deref;

# struct MeuBox&lt;T&gt;(T);
impl&lt;T&gt; Deref for MeuBox&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        &amp;self.0
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 15-10: Implementando <code>Deref</code> no
<code>MeuBox&lt;T&gt;</code></span></p>
<p>A sintaxe <code>type Target = T;</code> define um tipo associado para a trait <code>Deref</code> usar.
Tipos associados sÃ£o um jeito ligeiramente diferente de declarar um parÃ¢metro
genÃ©rico, mas vocÃª nÃ£o precisa se preocupar com eles por ora; iremos cobri-los
em mais detalhe no CapÃ­tulo 19.</p>
<p>NÃ³s preenchemos o corpo do mÃ©todo <code>deref</code> com <code>&amp;self.0</code> para que <code>deref</code> retorne
uma referÃªncia ao valor que queremos acessar com o operador <code>*</code>. A funÃ§Ã£o <code>main</code>
na Listagem 15-9 que chama <code>*</code> no valor <code>MeuBox&lt;T&gt;</code> agora compila e as asserÃ§Ãµes
passam!</p>
<p>Sem a trait <code>Deref</code>, o compilador sÃ³ consegue desreferenciar referÃªncias <code>&amp;</code>. O
mÃ©todo <code>deref</code> dÃ¡ ao compilador a habilidade de tomar um valor de qualquer tipo
que implemente <code>Deref</code> e chamar o mÃ©todo <code>deref</code> para pegar uma referÃªncia <code>&amp;</code>,
que ele sabe como desreferenciar.</p>
<p>Quando entramos <code>*y</code> na Listagem 15-9, por trÃ¡s dos panos o Rust na verdade
rodou este cÃ³digo:</p>
<pre><code class="language-rust ignore">*(y.deref())
</code></pre>
<p>O Rust substitui o operador <code>*</code> com uma chamada ao mÃ©todo <code>deref</code> e em seguida
uma desreferÃªncia comum, de modo que nÃ³s programadores nÃ£o precisamos pensar
sobre se temos ou nÃ£o que chamar o mÃ©todo <code>deref</code>. Essa funcionalidade do Rust
nos permite escrever cÃ³digo que funcione identicamente quando temos uma
referÃªncia comum ou um tipo que implementa <code>Deref</code>.</p>
<p>O fato de o mÃ©todo <code>deref</code> retornar uma referÃªncia ao valor, e a desreferÃªncia
comum fora dos parÃªnteses em <code>*(y.deref())</code> ainda ser necessÃ¡ria, Ã© devido ao
sistema de posse (<em>ownership</em>). Se o mÃ©todo <code>deref</code> retornasse o valor
diretamente em vez de uma referÃªncia ao valor, o valor seria movido para fora do
<code>self</code>. NÃ³s nÃ£o queremos tomar posse do valor interno do <code>MeuBox&lt;T&gt;</code> neste e na
maioria dos casos em que usamos o operador de desreferÃªncia.</p>
<p>Note que o <code>*</code> Ã© substituÃ­do por uma chamada ao mÃ©todo <code>deref</code> e entÃ£o uma
chamada ao <code>*</code> apenas uma vez, cada vez que digitamos um <code>*</code> no nosso cÃ³digo.
Como a substituiÃ§Ã£o do <code>*</code> nÃ£o entra em recursÃ£o infinita, nÃ³s terminamos com o
dado do tipo <code>i32</code>, que corresponde ao <code>5</code> em <code>assert_eq!</code> na Listagem 15-9.</p>
<a class="header" href="print.html#coerÃ§Ãµes-de-desreferÃªncia-implÃ­citas-com-funÃ§Ãµes-e-mÃ©todos" id="coerÃ§Ãµes-de-desreferÃªncia-implÃ­citas-com-funÃ§Ãµes-e-mÃ©todos"><h3>CoerÃ§Ãµes de DesreferÃªncia ImplÃ­citas com FunÃ§Ãµes e MÃ©todos</h3></a>
<p><em>CoerÃ§Ã£o de desreferÃªncia</em> (<em>deref coercion</em>) Ã© uma conveniÃªncia que o Rust
aplica a argumentos de funÃ§Ãµes e mÃ©todos. A coerÃ§Ã£o de desreferÃªncia converte
uma referÃªncia a um tipo que implementa <code>Deref</code> em uma referÃªncia a um tipo ao
qual a <code>Deref</code> pode converter o tipo original. A coerÃ§Ã£o de desreferÃªncia
acontece automaticamente quando passamos uma referÃªncia ao valor de um tipo
especÃ­fico como argumento a uma funÃ§Ã£o ou mÃ©todo e esse tipo nÃ£o corresponde ao
tipo do parÃ¢metro na definiÃ§Ã£o da funÃ§Ã£o ou mÃ©todo. Uma sequÃªncia de chamadas ao
mÃ©todo <code>deref</code> converte o tipo que providenciamos no tipo que o parÃ¢metro exige.</p>
<p>A coerÃ§Ã£o de desreferÃªncia foi adicionada ao Rust para que programadores
escrevendo chamadas a mÃ©todos e funÃ§Ãµes nÃ£o precisassem adicionar tantas
referÃªncias e desreferÃªncias explÃ­citas com <code>&amp;</code> e <code>*</code>. A funcionalidade de
coerÃ§Ã£o de desreferÃªncia tambÃ©m nos permite escrever mais cÃ³digo que funcione
tanto com referÃªncias quanto com ponteiros inteligentes.</p>
<p>Para ver a coerÃ§Ã£o de desreferÃªncia em aÃ§Ã£o, vamos usar o tipo <code>MeuBox&lt;T&gt;</code> que
definimos na Listagem 15-8 e tambÃ©m a implementaÃ§Ã£o de <code>Deref</code> que adicionamos
na Listagem 15-10. A Listagem 15-11 mostra a definiÃ§Ã£o de uma funÃ§Ã£o que tem um
parÃ¢metro do tipo string slice:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn ola(nome: &amp;str) {
    println!(&quot;OlÃ¡, {}!&quot;, nome);
}
#}</code></pre></pre>
<p><span class="caption">Listagem 15-11: Uma funÃ§Ã£o <code>ola</code> que tem um parÃ¢metro
<code>nome</code> do tipo <code>&amp;str</code></span></p>
<p>Podemos chamar a funÃ§Ã£o <code>ola</code> passando uma string slice como argumento, por
exemplo <code>ola(&quot;Rust&quot;);</code>. A coerÃ§Ã£o de desreferÃªncia torna possÃ­vel chamar <code>ola</code>
com uma referÃªncia a um valor do tipo <code>MeuBox&lt;String&gt;</code>, como mostra a Listagem
15-12:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># use std::ops::Deref;
#
# struct MeuBox&lt;T&gt;(T);
#
# impl&lt;T&gt; MeuBox&lt;T&gt; {
#     fn new(x: T) -&gt; MeuBox&lt;T&gt; {
#         MeuBox(x)
#     }
# }
#
# impl&lt;T&gt; Deref for MeuBox&lt;T&gt; {
#     type Target = T;
#
#     fn deref(&amp;self) -&gt; &amp;T {
#         &amp;self.0
#     }
# }
#
# fn ola(name: &amp;str) {
#     println!(&quot;OlÃ¡, {}!&quot;, name);
# }
#
fn main() {
    let m = MeuBox::new(String::from(&quot;Rust&quot;));
    ola(&amp;m);
}
</code></pre></pre>
<p><span class="caption">Listagem 15-12: Chamando <code>ola</code> com uma referÃªncia a um
valor <code>MeuBox&lt;String&gt;</code>, o que sÃ³ funciona por causa da coerÃ§Ã£o de
desreferÃªncia</span></p>
<p>Aqui estamos chamando a funÃ§Ã£o <code>ola</code> com o argumento <code>&amp;m</code>, que Ã© uma referÃªncia
a um valor <code>MeuBox&lt;String&gt;</code>. Como implementamos a trait <code>Deref</code> em <code>MeuBox&lt;T&gt;</code>
na Listagem 15-10, o Rust pode transformar <code>&amp;MeuBox&lt;String&gt;</code> em <code>&amp;String</code>
chamando <code>deref</code>. A biblioteca padrÃ£o provÃª uma implementaÃ§Ã£o de <code>Deref</code> para
<code>String</code> que retorna uma string slice, documentada na API de <code>Deref</code>. O Rust
chama <code>deref</code> de novo para transformar o <code>&amp;String</code> em <code>&amp;str</code>, que corresponde Ã 
definiÃ§Ã£o da funÃ§Ã£o <code>ola</code>.</p>
<p>Se o Rust nÃ£o implementasse coerÃ§Ã£o de desreferÃªncia, terÃ­amos que escrever o
cÃ³digo na Listagem 15-13 em vez do cÃ³digo na Listagem 15-12 para chamar <code>ola</code>
com um valor do tipo <code>&amp;MeuBox&lt;String&gt;</code>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># use std::ops::Deref;
#
# struct MeuBox&lt;T&gt;(T);
#
# impl&lt;T&gt; MeuBox&lt;T&gt; {
#     fn new(x: T) -&gt; MeuBox&lt;T&gt; {
#         MeuBox(x)
#     }
# }
#
# impl&lt;T&gt; Deref for MeuBox&lt;T&gt; {
#     type Target = T;
#
#     fn deref(&amp;self) -&gt; &amp;T {
#         &amp;self.0
#     }
# }
#
# fn ola(name: &amp;str) {
#     println!(&quot;OlÃ¡, {}!&quot;, name);
# }
#
fn main() {
    let m = MeuBox::new(String::from(&quot;Rust&quot;));
    ola(&amp;(*m)[..]);
}
</code></pre></pre>
<p><span class="caption">Listagem 15-13: O cÃ³digo que terÃ­amos que escrever se o
Rust nÃ£o tivesse coerÃ§Ã£o de desreferÃªncia</span></p>
<p>O <code>(*m)</code> desreferencia o <code>MeuBox&lt;String&gt;</code> em uma <code>String</code>. EntÃ£o o <code>&amp;</code> e o
<code>[..]</code> obtÃªm uma string slice da <code>String</code> que Ã© igual Ã  string inteira para
corresponder Ã  assinatura de <code>ola</code>. O cÃ³digo sem coerÃ§Ã£o de desreferÃªncia Ã© mais
difÃ­cil de ler, escrever e entender com todos esses sÃ­mbolos envolvidos. A
coerÃ§Ã£o de desreferÃªncia permite que o Rust lide com essas conversÃµes
automaticamente para nÃ³s.</p>
<p>Quando a trait <code>Deref</code> estÃ¡ definida para os tipos envolvidos, o Rust analisa os
tipos e usa <code>Deref::deref</code> tantas vezes quanto necessÃ¡rio para chegar a uma
referÃªncia que corresponda ao tipo do parÃ¢metro. O nÃºmero de vezes que
<code>Deref::deref</code> precisa ser inserida Ã© resolvido em tempo de compilaÃ§Ã£o, entÃ£o
nÃ£o existe nenhuma penalidade em tempo de execuÃ§Ã£o para tomar vantagem da
coerÃ§Ã£o de desreferÃªncia.</p>
<a class="header" href="print.html#como-a-coerÃ§Ã£o-de-desreferÃªncia-interage-com-a-mutabilidade" id="como-a-coerÃ§Ã£o-de-desreferÃªncia-interage-com-a-mutabilidade"><h3>Como a CoerÃ§Ã£o de DesreferÃªncia Interage com a Mutabilidade</h3></a>
<p>De modo semelhante a como usamos a trait <code>Deref</code> para redefinir <code>*</code> em
referÃªncias imutÃ¡veis, o Rust provÃª uma trait <code>DerefMut</code> para redefinir <code>*</code> em
referÃªncias mutÃ¡veis.</p>
<p>O Rust faz coerÃ§Ã£o de desreferÃªncia quando ele encontra tipos e implementaÃ§Ãµes
de traits em trÃªs casos:</p>
<ul>
<li>De <code>&amp;T</code> para <code>&amp;U</code> quando <code>T: Deref&lt;Target=U&gt;</code>;</li>
<li>De <code>&amp;mut T</code> para <code>&amp;mut U</code> quando <code>T: DerefMut&lt;Target=U&gt;</code>;</li>
<li>De <code>&amp;mut T</code> para <code>&amp;U</code> quando <code>T: Deref&lt;Target=U&gt;</code>.</li>
</ul>
<p>Os primeiros dois casos sÃ£o o mesmo exceto pela mutabilidade. O primeiro caso
afirma que se vocÃª tem uma <code>&amp;T</code>, e <code>T</code> implementa <code>Deref</code> para algum tipo <code>U</code>,
vocÃª pode obter um <code>&amp;U</code> de maneira transparente. O segundo caso afirma que a
mesma coerÃ§Ã£o de desreferÃªncia acontece para referÃªncias mutÃ¡veis.</p>
<p>O terceiro caso Ã© mais complicado: o Rust tambÃ©m irÃ¡ coagir uma referÃªncia
mutÃ¡vel a uma imutÃ¡vel. Mas o contrÃ¡rio <em>nÃ£o</em> Ã© possÃ­vel: referÃªncias imutÃ¡veis
nunca serÃ£o coagidas a referÃªncias mutÃ¡veis. Por causa das regras de emprÃ©stimo,
se vocÃª tem uma referÃªncia mutÃ¡vel, ela deve ser a Ãºnica referÃªncia Ã queles
dados (caso contrÃ¡rio, o programa nÃ£o compila). Converter uma referÃªncia mutÃ¡vel
a uma imutÃ¡vel nunca quebrarÃ¡ as regras de emprÃ©stimo. Converter uma referÃªncia
imutÃ¡vel a uma mutÃ¡vel exigiria que houvesse apenas uma referÃªncia imutÃ¡vel
Ã queles dados, e as regras de emprÃ©stimo nÃ£o garantem isso. Portanto, o Rust nÃ£o
pode assumir que converter uma referÃªncia imutÃ¡vel a uma mutÃ¡vel seja possÃ­vel.</p>
<a class="header" href="print.html#a-trait-drop-roda-cÃ³digo-durante-a-limpeza" id="a-trait-drop-roda-cÃ³digo-durante-a-limpeza"><h2>A Trait <code>Drop</code> Roda CÃ³digo durante a Limpeza</h2></a>
<p>A segunda trait de importÃ¢ncia para a pattern de ponteiros inteligentes Ã© a
<code>Drop</code>, que nos permite personalizar o que acontece quando um valor estÃ¡ prestes
a sair de escopo. NÃ³s podemos prover uma implementaÃ§Ã£o da trait <code>Drop</code> para
qualquer tipo, e o cÃ³digo que especificarmos pode ser usado para liberar
recursos como arquivos ou conexÃµes de rede. Estamos introduzindo <code>Drop</code> no
contexto de ponteiros inteligentes porque a funcionalidade da trait <code>Drop</code> Ã©
usada quase sempre quando estamos implementando ponteiros inteligentes. Por
exemplo, o <code>Box&lt;T&gt;</code> customiza <code>Drop</code> para desalocar o espaÃ§o no heap para o qual
o box aponta.</p>
<p>Em algumas linguagens, a pessoa que estÃ¡ programando deve chamar cÃ³digo para
liberar memÃ³ria ou recursos toda vez que ela termina de usar uma instÃ¢ncia de um
ponteiro inteligente. Se ela esquece, o sistema pode ficar sobrecarregado e
falhar. No Rust, podemos especificar que um pedaÃ§o especÃ­fico de cÃ³digo deva ser
rodado sempre que um valor sair de escopo, e o compilador irÃ¡ inserir esse
cÃ³digo automaticamente. Assim, nÃ£o precisamos cuidadosamente colocar cÃ³digo de
limpeza em todos os lugares de um programa em que uma instÃ¢ncia de um tipo
especÃ­fico deixa de ser usada, e ainda assim nÃ£o vazaremos recursos!</p>
<p>Para especificar o cÃ³digo que vai rodar quando um valor sair de escopo, nÃ³s
implementamos a trait <code>Drop</code>. A trait <code>Drop</code> requer que implementemos um mÃ©todo
chamado <code>drop</code> que recebe uma referÃªncia mutÃ¡vel de <code>self</code>. Para ver quando o
Rust chama <code>drop</code>, vamos implementar <code>drop</code> com declaraÃ§Ãµes de <code>println!</code> por
ora.</p>
<p>A Listagem 15-14 mostra uma struct <code>CustomSmartPointer</code>
(&quot;PonteiroInteligentePersonalizado&quot;) cuja Ãºnica funcionalidade Ã© que ela irÃ¡
imprimir <code>Destruindo CustomSmartPointer!</code> quando a instÃ¢ncia sair de escopo.
Este exemplo demonstra quando o Rust roda a funÃ§Ã£o <code>drop</code>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&amp;mut self) {
        println!(&quot;Destruindo CustomSmartPointer com dados `{}`!&quot;, self.data);
    }
}

fn main() {
    let c = CustomSmartPointer { data: String::from(&quot;alocado primeiro&quot;) };
    let d = CustomSmartPointer { data: String::from(&quot;alocado por Ãºltimo&quot;) };
    println!(&quot;CustomSmartPointers criados.&quot;);
}
</code></pre></pre>
<p><span class="caption">Listagem 15-14: Uma struct <code>CustomSmartPointer</code> que
implementa a trait <code>Drop</code> onde colocarÃ­amos nosso cÃ³digo de limpeza</span></p>
<p>A trait <code>Drop</code> Ã© incluÃ­da no prelÃºdio, entÃ£o nÃ£o precisamos importÃ¡-la. NÃ³s
implementamos a trait <code>Drop</code> no <code>CustomSmartPointer</code> e providenciamos uma
implementaÃ§Ã£o para o mÃ©todo <code>drop</code> que chama <code>println!</code>. O corpo da funÃ§Ã£o
<code>drop</code> Ã© onde vocÃª colocaria qualquer que fosse a lÃ³gica que vocÃª gostaria que
rodasse quando uma instÃ¢ncia do seu tipo for sair de escopo. Aqui estamos
imprimindo um texto para demonstrar o momento em que o Rust chama <code>drop</code>.</p>
<p>Na <code>main</code>, nÃ³s criamos duas instÃ¢ncias do <code>CustomSmartPointer</code> e entÃ£o
imprimimos <code>CustomSmartPointers criados.</code>. No final da <code>main</code>, nossas instÃ¢ncias
de <code>CustomSmartPointer</code> sairÃ£o de escopo, e o Rust irÃ¡ chamar o cÃ³digo que
colocamos no mÃ©todo <code>drop</code>, imprimindo nossa mensagem final. Note que nÃ£o
tivemos que chamar o mÃ©todo <code>drop</code> explicitamente.</p>
<p>Quando rodarmos esse programa, veremos a seguinte saÃ­da:</p>
<pre><code class="language-text">CustomSmartPointers criados.
Destruindo CustomSmartPointer com dados `alocado por Ãºltimo`!
Destruindo CustomSmartPointer com dados `alocado primeiro`!
</code></pre>
<p>O Rust chamou automaticamente <code>drop</code> para nÃ³s quando nossa instÃ¢ncia saiu de
escopo, chamando o cÃ³digo que especificamos. VariÃ¡veis sÃ£o destruÃ­das na ordem
contrÃ¡ria Ã  de criaÃ§Ã£o, entÃ£o <code>d</code> foi destruÃ­da antes de <code>c</code>. Esse exemplo serve
apenas para lhe dar um guia visual de como o mÃ©todo <code>drop</code> funciona, mas
normalmente vocÃª especificaria o cÃ³digo de limpeza que o seu tipo precisa rodar
em vez de imprimir uma mensagem.</p>
<a class="header" href="print.html#destruindo-um-valor-cedo-com-stdmemdrop" id="destruindo-um-valor-cedo-com-stdmemdrop"><h3>Destruindo um Valor Cedo com <code>std::mem::drop</code></h3></a>
<p>Infelizmente, nÃ£o Ã© simples desabilitar a funcionalidade automÃ¡tica de <code>drop</code>.
Desabilitar o <code>drop</code> normalmente nÃ£o Ã© necessÃ¡rio; o ponto todo da trait <code>Drop</code>
Ã© que isso seja feito automaticamente. Mas ocasionalmente, vocÃª pode querer
limpar um valor cedo. Um exemplo Ã© quando usamos ponteiros inteligentes que
gerenciam locks: vocÃª pode querer forÃ§ar o mÃ©todo <code>drop</code> que libera o lock a
rodar para que outro cÃ³digo no mesmo escopo possa adquiri-lo. O Rust nÃ£o nos
deixa chamar o mÃ©todo <code>drop</code> da trait <code>Drop</code> manualmente; em vez disso, temos
que chamar a funÃ§Ã£o <code>std::mem::drop</code> disponibilizada pela biblioteca padrÃ£o se
queremos forÃ§ar um valor a ser destruÃ­do antes do fim de seu escopo.</p>
<p>Vamos ver o que acontece quando tentamos chamar o mÃ©todo <code>drop</code> da trait <code>Drop</code>
manualmente, modificando a funÃ§Ã£o <code>main</code> da Listagem 15-14, conforme mostra a
Listagem 15-15:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let c = CustomSmartPointer { data: String::from(&quot;algum dado&quot;) };
    println!(&quot;CustomSmartPointer criado.&quot;);
    c.drop();
    println!(&quot;CustomSmartPointer destruÃ­do antes do fim da main.&quot;);
}
</code></pre>
<p><span class="caption">Listagem 15-15: Tentando chamar o mÃ©todo <code>drop</code> da trait <code>Drop</code> manualmente para limpar cedo</span></p>
<p>Quando tentamos compilar esse cÃ³digo, recebemos este erro:</p>
<pre><code class="language-text">erro[E0040]: uso explÃ­cito de mÃ©todo destrutor
  --&gt; src/main.rs:14:7
   |
14 |     c.drop();
   |       ^^^^ chamadas explÃ­citas a destrutores nÃ£o sÃ£o permitidas
</code></pre>
<p>Essa mensagem de erro afirma que nÃ£o nos Ã© permitido chamar explicitamente
<code>drop</code>. A mensagem de erro usa o termo <em>destrutor</em>, que Ã© um termo geral de
programaÃ§Ã£o para uma funÃ§Ã£o que limpa uma instÃ¢ncia. Um <em>destrutor</em> Ã© anÃ¡logo a
um <em>construtor</em>, que cria uma instÃ¢ncia. A funÃ§Ã£o <code>drop</code> em Rust Ã© um destrutor
especÃ­fico.</p>
<p>O Rust nÃ£o nos deixa chamar <code>drop</code> explicitamente porque o <code>drop</code> ainda seria
chamado no valor ao final da <code>main</code>. Isso seria um erro de <em>liberaÃ§Ã£o dupla</em>
(<em>double free</em>) porque o Rust estaria tentando limpar o mesmo valor duas vezes.</p>
<p>NÃ³s nÃ£o podemos desabilitar a inserÃ§Ã£o automÃ¡tica do <code>drop</code> quando um valor sai
de escopo, e tambÃ©m nÃ£o podemos chamar o mÃ©todo <code>drop</code> explicitamente. EntÃ£o, se
precisamos forÃ§ar um valor a ser limpo antes, podemos usar a funÃ§Ã£o
<code>std::mem::drop</code>.</p>
<p>A funÃ§Ã£o <code>std::mem::drop</code> Ã© diferente do mÃ©todo <code>drop</code> na trait <code>Drop</code>. NÃ³s a
chamamos passando como argumento o valor que queremos forÃ§ar a ser destruÃ­do
cedo. Essa funÃ§Ã£o estÃ¡ no prelÃºdio, entÃ£o podemos modificar a <code>main</code> na Listagem
15-14 para chamar a funÃ§Ã£o <code>drop</code>, como mostra a Listagem 15-16:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># struct CustomSmartPointer {
#     data: String,
# }
#
# impl Drop for CustomSmartPointer {
#     fn drop(&amp;mut self) {
#         println!(&quot;Destruindo CustomSmartPointer!&quot;);
#     }
# }
#
fn main() {
    let c = CustomSmartPointer { data: String::from(&quot;algum dado&quot;) };
    println!(&quot;CustomSmartPointer criado.&quot;);
    drop(c);
    println!(&quot;CustomSmartPointer destruÃ­do antes do final da main.&quot;);
}
</code></pre></pre>
<p><span class="caption">Listagem 15-16: Chamando <code>std::mem::drop</code> para destruir um
valor explicitamente antes que ele saia de escopo</span></p>
<p>Rodar esse cÃ³digo irÃ¡ imprimir o seguinte:</p>
<pre><code class="language-text">CustomSmartPointer criado.
Destruindo CustomSmartPointer com dados `algum dado`!
CustomSmartPointer destruÃ­do antes do final da main.
</code></pre>
<p>O texto <code>Destruindo CustomSmartPointer com dados `algum dado`!</code> Ã© impresso
entre o texto <code>CustomSmartPointer criado.</code> e <code>CustomSmartPointer destruÃ­do antes do final da main.</code>, mostrando que o mÃ©todo <code>drop</code> Ã© chamado para destruir o <code>c</code>
naquele ponto.</p>
<p>Podemos usar o cÃ³digo especificado em uma implementaÃ§Ã£o da trait <code>Drop</code> de
vÃ¡rias maneiras para tornar a limpeza conveniente e segura: por exemplo,
poderÃ­amos usÃ¡-lo para criar nosso prÃ³prio alocador de memÃ³ria! Com a trait
<code>Drop</code> e o sistema de posse do Rust, nÃ£o temos que lembrar de fazer a limpeza
porque o Rust faz isso automaticamente.</p>
<p>TambÃ©m nÃ£o temos que nos preocupar em acidentalmente limpar valores ainda em uso
porque isso causaria um erro de compilaÃ§Ã£o: o sistema de posse que garante que
as referÃªncias sÃ£o sempre vÃ¡lidas tambÃ©m garante que o <code>drop</code> Ã© chamado apenas
uma vez quando o valor nÃ£o estÃ¡ mais sendo usado.</p>
<p>Agora que examinamos o <code>Box&lt;T&gt;</code> e alguma caracterÃ­sticas de ponteiros
inteligentes, vamos dar uma olhada em alguns outros ponteiros inteligentes
definidos na biblioteca padrÃ£o.</p>
<a class="header" href="print.html#rct-o-ponteiro-inteligente-com-contagem-de-referÃªncias" id="rct-o-ponteiro-inteligente-com-contagem-de-referÃªncias"><h2><code>Rc&lt;T&gt;</code>, o Ponteiro Inteligente com Contagem de ReferÃªncias</h2></a>
<p>Na maioria dos casos, a posse Ã© clara: vocÃª sabe exatamente qual variÃ¡vel tem
posse de um dado valor. Contudo, hÃ¡ casos onde um Ãºnico valor pode ter mÃºltiplos
possuidores. Por exemplo, em uma estrutura de dados em grafo, mÃºltiplas arestas
podem apontar para o mesmo vÃ©rtice, e esse vÃ©rtice Ã© conceitualmente possuÃ­do
por todas as arestas que apontam para ele. Um vÃ©rtice nÃ£o deveria ser liberado a
nÃ£o ser que ele nÃ£o tenha mais arestas apontando para ele.</p>
<p>Para permitir posse mÃºltipla, o Rust tem um tipo chamado <code>Rc&lt;T&gt;</code>. Seu nome Ã© uma
abreviaÃ§Ã£o para <em>reference counting</em> (<em>contagem de referÃªncias</em>) que, como o
nome diz, mantÃ©m registro do nÃºmero de referÃªncias a um valor para saber se ele
ainda estÃ¡ em uso ou nÃ£o. Se hÃ¡ zero referÃªncias a um valor, ele pode ser
liberado sem que nenhuma referÃªncia se torne invÃ¡lida.</p>
<p>Imagine o <code>Rc&lt;T&gt;</code> como uma TV numa sala de famÃ­lia. Quando uma pessoa entra para
assistir Ã  TV, ela a liga. Outros podem entrar na sala e assistir Ã  TV. Quando a
Ãºltima pessoa sai da sala, ela desliga a TV porque essa nÃ£o estÃ¡ mais em uso. Se
alguÃ©m desligasse a TV enquanto outros ainda estÃ£o assistindo, haveria revolta
entre os telespectadores restantes!</p>
<p>NÃ³s usamos o tipo <code>Rc&lt;T&gt;</code> quando queremos alocar algum dado no heap para que
mÃºltiplas partes do nosso programa o leiam, e nÃ£o conseguimos determinar em
tempo de compilaÃ§Ã£o qual parte irÃ¡ terminar de usar o dado por Ãºltimo. Se
soubÃ©ssemos qual parte terminaria por Ãºltimo, poderÃ­amos simplesmente tornar
aquela parte a possuidora do dado e as regras normais de posse aplicadas em
tempo de compilaÃ§Ã£o teriam efeito.</p>
<p>Note que o <code>Rc&lt;T&gt;</code> serve apenas para cenÃ¡rios de thread Ãºnica. Quando
discutirmos concorrÃªncia no CapÃ­tulo 16, cobriremos como fazer contagem de
referÃªncias em programas com mÃºltiplas threads.</p>
<a class="header" href="print.html#usando-rct-para-compartilhar-dados" id="usando-rct-para-compartilhar-dados"><h3>Usando <code>Rc&lt;T&gt;</code> para Compartilhar Dados</h3></a>
<p>Vamos retornar ao nosso exemplo de <em>cons list</em> da Listagem 15-5. Lembre-se de
que a definimos usando o <code>Box&lt;T&gt;</code>. Desta vez, vamos criar duas listas que
compartilham ambas a posse de uma terceira lista, o que conceitualmente vai se
parecer com a Figura 15-3:</p>
<p><img alt="Duas listas que compartilham a posse de uma terceira lista" src="img/trpl15-03.svg" class="center" /></p>
<p><span class="caption">Figura 15-3: Duas listas, <code>b</code> e <code>c</code>, compartilhando posse
de uma terceira lista, <code>a</code></span></p>
<p>Vamos criar a lista <code>a</code> que contÃ©m 5 e depois 10. EntÃ£o criaremos mais duas
listas: <code>b</code>, que comeÃ§a com 3 e <code>c</code>, que comeÃ§a com 4. Ambas as listas <code>b</code> e <code>c</code>
irÃ£o entÃ£o continuar na lista <code>a</code> contendo 5 e 10. Em outras palavras, ambas as
listas irÃ£o compartilhar a primeira lista contendo 5 e 10.</p>
<p>Tentar implementar esse cenÃ¡rio usando nossa definiÃ§Ã£o de <code>List</code> com <code>Box&lt;T&gt;</code>
nÃ£o irÃ¡ funcionar, como mostra a Listagem 15-17:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use List::{Cons, Nil};

fn main() {
    let a = Cons(5,
        Box::new(Cons(10,
            Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}
</code></pre>
<p><span class="caption">Listagem 15-17: Demonstrando que nÃ£o Ã© possÃ­vel termos
duas listas usando <code>Box&lt;T&gt;</code> que tentam compartilhar posse de uma terceira
lista</span></p>
<p>Quando compilamos esse cÃ³digo, recebemos este erro:</p>
<pre><code class="language-text">erro[E0382]: uso de valor movido: `a`
  --&gt; src/main.rs:13:30
   |
12 |     let b = Cons(3, Box::new(a));
   |                              - valor movido para cÃ¡
13 |     let c = Cons(4, Box::new(a));
   |                              ^ valor usado aqui depois de movido
   |
   = nota: o valor Ã© movido porque `a` tem tipo `List`, que nÃ£o implementa
   a trait `Copy`
</code></pre>
<p>As variantes <code>Cons</code> tÃªm posse dos dados que elas contÃªm, entÃ£o quando criamos a
lista <code>b</code>, <code>a</code> Ã© movida para dentro de <code>b</code>, e <code>b</code> toma posse de <code>a</code>. EntÃ£o,
quando tentamos usar <code>a</code> de novo na criaÃ§Ã£o de <code>c</code>, nÃ£o somos permitidos porque
<code>a</code> foi movida.</p>
<p>PoderÃ­amos mudar a definiÃ§Ã£o de <code>Cons</code> para guardar referÃªncias, mas aÃ­ terÃ­amos
que especificar parÃ¢metros de tempo de vida (<em>lifetime parameters</em>). Fazendo
isso, estarÃ­amos especificando que cada elemento da lista devesse viver por pelo
menos tanto tempo quanto a lista inteira. O <em>verificador de emprÃ©stimo</em> (<em>borrow
checker</em>) nÃ£o nos deixaria compilar <code>let a = Cons(10, &amp;Nil);</code>, por exemplo,
porque o valor temporÃ¡rio <code>Nil</code> seria destruÃ­do antes que <code>a</code> pudesse receber
uma referÃªncia a ele.</p>
<p>Em vez disso, vamos mudar nossa definiÃ§Ã£o de <code>List</code> para usar o <code>Rc&lt;T&gt;</code> no lugar
do <code>Box&lt;T&gt;</code>, como mostra a Listagem 15-18. Cada variante <code>Cons</code> agora vai conter
um valor e um <code>Rc&lt;T&gt;</code> apontando para uma <code>List</code>. Quando criarmos <code>b</code>, em vez de
tomar posse de <code>a</code>, iremos clonar o <code>Rc&lt;List&gt;</code> que <code>a</code> estÃ¡ segurando, o que
aumenta o nÃºmero de referÃªncias de uma para duas e permite com que <code>a</code> e
<code>b</code>compartilhem posse dos dados naquele <code>Rc&lt;List&gt;</code>. TambÃ©m vamos clonar <code>a</code>
quando criarmos <code>c</code>, o que aumenta o nÃºmero de referÃªncias de duas para trÃªs.
Cada vez que chamarmos <code>Rc::clone</code>, a contagem de referÃªncias ao valor dentro do
<code>Rc&lt;List&gt;</code> irÃ¡ aumentar, e ele nÃ£o serÃ¡ liberado atÃ© que haja zero referÃªncias a
ele:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

use List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&amp;a));
    let c = Cons(4, Rc::clone(&amp;a));
}
</code></pre></pre>
<p><span class="caption">Listagem 15-18: Uma definiÃ§Ã£o de <code>List</code> que usa o
<code>Rc&lt;T&gt;</code></span></p>
<p>Precisamos adicionar uma declaraÃ§Ã£o <code>use</code> para trazer o <code>Rc&lt;T&gt;</code> ao escopo porque
ele nÃ£o estÃ¡ no prelÃºdio. Na <code>main</code>, criamos a lista contendo 5 e 10 e a
armazenamos em um novo <code>Rc&lt;List&gt;</code> em <code>a</code>. EntÃ£o quando criamos <code>b</code> e <code>c</code>,
chamamos a funÃ§Ã£o <code>Rc::clone</code> e passamos uma referÃªncia ao <code>Rc&lt;List&gt;</code> em <code>a</code>
como argumento.</p>
<p>PoderÃ­amos ter chamado <code>a.clone()</code> em vez de <code>Rc::clone(&amp;a)</code>, mas a convenÃ§Ã£o do
Rust Ã© usar <code>Rc::clone</code> neste caso. A implementaÃ§Ã£o de <code>Rc::clone</code> nÃ£o faz uma
cÃ³pia profunda de todos os dados como faz a implementaÃ§Ã£o de <code>clone</code> da maioria
dos tipos. A chamada a <code>Rc::clone</code> apenas incrementa a contagem de referÃªncias,
o que nÃ£o leva muito tempo. CÃ³pias profundas de dados podem levar muito tempo.
Usando <code>Rc::clone</code> para a contagem de referÃªncias, podemos distinguir
visualmente entre os clones de cÃ³pia profunda e os clones que incrementam a
contagem de referÃªncias. Quando estivermos procurando problemas de desempenho no
cÃ³digo, precisamos apenas considerar os clones de cÃ³pia profunda e podemos
ignorar as chamadas a <code>Rc::clone</code>.</p>
<a class="header" href="print.html#clonar-um-rct-aumenta-a-contagem-de-referÃªncias" id="clonar-um-rct-aumenta-a-contagem-de-referÃªncias"><h3>Clonar um <code>Rc&lt;T&gt;</code> Aumenta a Contagem de ReferÃªncias</h3></a>
<p>Vamos mudar nosso exemplo de trabalho na Listagem 15-18 para podermos ver a
contagem de referÃªncias mudando conforme criamos e destruÃ­mos referÃªncias ao
<code>Rc&lt;List&gt;</code> em <code>a</code>.</p>
<p>Na Listagem 15-19, vamos mudar a <code>main</code> para que tenha um escopo interno em
volta da lista <code>c</code>; assim poderemos ver como a contagem de referÃªncias muda
quando <code>c</code> sai de escopo. Em cada ponto do programa onde a contagem de
referÃªncias muda, iremos imprimir seu valor, que podemos obter chamando a funÃ§Ã£o
<code>Rc::strong_count</code>. Essa funÃ§Ã£o se chama <code>strong_count</code> (<em>contagem das
referÃªncias fortes</em>) em vez de <code>count</code> (<em>contagem</em>) porque o tipo <code>Rc&lt;T&gt;</code> tambÃ©m
tem uma <code>weak_count</code> (<em>contagem das referÃªncias fracas</em>); veremos para que a
<code>weak_count</code> Ã© usada na seÃ§Ã£o &quot;Evitando Ciclos de ReferÃªncias&quot;.</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># enum List {
#     Cons(i32, Rc&lt;List&gt;),
#     Nil,
# }
#
# use List::{Cons, Nil};
# use std::rc::Rc;
#
fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!(&quot;contagem depois de criar a = {}&quot;, Rc::strong_count(&amp;a));
    let b = Cons(3, Rc::clone(&amp;a));
    println!(&quot;contagem depois de criar b = {}&quot;, Rc::strong_count(&amp;a));
    {
        let c = Cons(4, Rc::clone(&amp;a));
        println!(&quot;contagem depois de criar c = {}&quot;, Rc::strong_count(&amp;a));
    }
    println!(&quot;contagem depois que c sai de escopo = {}&quot;, Rc::strong_count(&amp;a));
}
</code></pre></pre>
<p><span class="caption">Listagem 15-19: Imprimindo a contagem de
referÃªncias</span></p>
<p>Esse cÃ³digo imprime o seguinte:</p>
<pre><code class="language-text">contagem depois de criar a = 1
contagem depois de criar b = 2
contagem depois de criar c = 3
contagem depois que c sai de escopo = 2
</code></pre>
<p>Podemos ver que o <code>Rc&lt;List&gt;</code> em <code>a</code> tem uma contagem de referÃªncias inicial de
um; depois, cada vez que chamamos <code>clone</code>, a contagem aumenta em um. Quando <code>c</code>
sai de escopo, a contagem diminui em um. NÃ³s nÃ£o temos que chamar uma funÃ§Ã£o
para decrementar a contagem de referÃªncias como temos que fazer com a
<code>Rc::clone</code> para incrementÃ¡-la: a implementaÃ§Ã£o da trait <code>Drop</code> diminui a
contagem automaticamente quando um valor <code>Rc&lt;T&gt;</code> sai de escopo.</p>
<p>O que nÃ£o conseguimos ver nesse exemplo Ã© que quando <code>b</code> e depois <code>a</code> saem de
escopo no final da <code>main</code>, a contagem se torna 0, e o <code>Rc&lt;List&gt;</code> Ã©
liberado por completo nesse ponto. O uso do <code>Rc&lt;T&gt;</code> permite que um Ãºnico valor
tenha mÃºltiplos possuidores, e a contagem garante que o valor permaneÃ§a vÃ¡lido
enquanto algum dos possuidores ainda existir.</p>
<p>Por funcionar com referÃªncias imutÃ¡veis, o <code>Rc&lt;T&gt;</code> nos permite compartilhar
dados entre diversas partes do nosso programa <em>apenas para leitura</em>. Se o
<code>Rc&lt;T&gt;</code> nos deixasse ter mÃºltiplas referÃªncias mutÃ¡veis tambÃ©m, nÃ³s poderÃ­amos
violar uma das regras de emprÃ©stimo discutidas no CapÃ­tulo 4: mÃºltiplos
emprÃ©stimos mutÃ¡veis do mesmo lugar podem causar corridas de dados (<em>data
races</em>) e inconsistÃªncias. Mas conseguir modificar dados Ã© muito Ãºtil! Na
prÃ³xima seÃ§Ã£o, discutiremos a pattern de mutabilidade interior (<em>interior
mutability</em>) e o tipo <code>RefCell&lt;T&gt;</code> que podemos usar junto com um <code>Rc&lt;T&gt;</code> para
trabalhar com essa restriÃ§Ã£o de imutabilidade.</p>
<a class="header" href="print.html#refcellt-e-a-pattern-de-mutabilidade-interior" id="refcellt-e-a-pattern-de-mutabilidade-interior"><h2><code>RefCell&lt;T&gt;</code> e a Pattern de Mutabilidade Interior</h2></a>
<p><em>Mutabilidade interior</em> (<em>interior mutability</em>) Ã© uma design pattern em Rust que
lhe permite modificar um dado mesmo quando hÃ¡ referÃªncias imutÃ¡veis a ele:
normalmente, esta aÃ§Ã£o Ã© proibida pelas regras de emprÃ©stimo. Para fazer isso, a
pattern usa cÃ³digo <code>unsafe</code> (<em>inseguro</em>) dentro de uma estrutura de dados para
dobrar as regras normais do Rust que governam mutaÃ§Ã£o e emprÃ©stimo. NÃ³s ainda
nÃ£o cobrimos cÃ³digo unsafe; faremos isso no CapÃ­tulo 19. Podemos usar tipos que
usam a pattern de mutabilidade interior quando podemos garantir que as regras de
emprÃ©stimo serÃ£o seguidas em tempo de execuÃ§Ã£o, ainda que o compilador nÃ£o o
possa garantir. O cÃ³digo <code>unsafe</code> envolvido Ã© entÃ£o embrulhado em uma API safe,
e o tipo exterior permanece imutÃ¡vel.</p>
<p>Para explorar este conceito, vamos ver o tipo <code>RefCell&lt;T&gt;</code> que segue a pattern
de mutabilidade interior.</p>
<a class="header" href="print.html#aplicando-regras-de-emprÃ©stimo-em-tempo-de-execuÃ§Ã£o-com-o-refcellt" id="aplicando-regras-de-emprÃ©stimo-em-tempo-de-execuÃ§Ã£o-com-o-refcellt"><h3>Aplicando Regras de EmprÃ©stimo em Tempo de ExecuÃ§Ã£o com o <code>RefCell&lt;T&gt;</code></h3></a>
<p>Diferente do <code>Rc&lt;T&gt;</code>, o tipo <code>RefCell&lt;T&gt;</code> representa posse Ãºnica sobre o dado
que ele contÃ©m. EntÃ£o o que torna o <code>RefCell&lt;T&gt;</code> diferente de um tipo como o
<code>Box&lt;T&gt;</code>? Lembre-se das regras de emprÃ©stimo que vocÃª aprendeu no CapÃ­tulo 4:</p>
<ul>
<li>Em qualquer momento, vocÃª pode ter <em>um dos</em> mas nÃ£o ambos os seguintes: uma
Ãºnica referÃªncia mutÃ¡vel <em>ou</em> qualquer nÃºmero de referÃªncias imutÃ¡veis;</li>
<li>ReferÃªncias devem sempre ser vÃ¡lidas.</li>
</ul>
<p>Com referÃªncias e com o <code>Box&lt;T&gt;</code>, as invariantes das regras de emprÃ©stimo sÃ£o
aplicadas em tempo de compilaÃ§Ã£o. Com o <code>RefCell&lt;T&gt;</code>, essas invariantes sÃ£o
aplicadas <em>em tempo de execuÃ§Ã£o</em>. Com referÃªncias, se vocÃª quebra essas regras,
vocÃª recebe um erro de compilaÃ§Ã£o. Com o <code>RefCell&lt;T&gt;</code>, se vocÃª quebrar essas
regras, seu programa irÃ¡ sofrer um <code>panic!</code> e terminar.</p>
<p>As vantagens de checar as regras de emprÃ©stimo em tempo de compilaÃ§Ã£o sÃ£o que
erros sÃ£o pegos mais cedo no processo de desenvolvimento, e nÃ£o hÃ¡ nenhum custo
de desempenho de execuÃ§Ã£o porque toda a anÃ¡lise Ã© completada de antemÃ£o. Por
esses motivos, checar as regras de emprÃ©stimo em tempo de compilaÃ§Ã£o Ã© a melhor
opÃ§Ã£o na maioria dos casos, e por isso este Ã© o padrÃ£o do Rust.</p>
<p>A vantagem de checar as regras de emprÃ©stimo em tempo de execuÃ§Ã£o,
alternativamente, Ã© que certos cenÃ¡rios <em>memory-safe</em> (<em>seguros em termos de
memÃ³ria</em>) sÃ£o entÃ£o permitidos, ao passo que seriam proibidos pelas checagens em
tempo de compilaÃ§Ã£o. A anÃ¡lise estÃ¡tica, como a do compilador Rust, Ã©
inerentemente conservadora. Algumas propriedades do programa sÃ£o impossÃ­veis de
detectar analisando o cÃ³digo: o exemplo mais famoso Ã© o Problema da Parada, que
estÃ¡ alÃ©m do escopo deste livro mas Ã© um tÃ³pico interessante para pesquisa.</p>
<p>Como algumas anÃ¡lises sÃ£o impossÃ­veis, se o compilador Rust nÃ£o consegue se
assegurar que o cÃ³digo obedece Ã s regras de posse, ele pode rejeitar um programa
correto; neste sentido, ele Ã© conservador. Se o Rust aceitasse um programa
incorreto, os usuÃ¡rios nÃ£o poderiam confiar nas garantias que ele faz. Se, por
outro lado, o Rust rejeita um programa correto, o programador terÃ¡ alguma
inconveniÃªncia, mas nada catastrÃ³fico pode acontecer. O tipo <code>RefCell&lt;T&gt;</code> Ã© Ãºtil
quando vocÃª tem certeza que seu cÃ³digo segue as regras de emprÃ©stimo, mas o
compilador Ã© incapaz de entender e garantir isso.</p>
<p>Assim como o <code>Rc&lt;T&gt;</code>, o <code>RefCell&lt;T&gt;</code> Ã© apenas para uso em cenÃ¡rios de thread
Ãºnica e lhe darÃ£o um erro de compilaÃ§Ã£o se vocÃª tentar usÃ¡-lo em um contexto de
mÃºltiplas threads. Falaremos sobre como obter a funcionalidade de um
<code>RefCell&lt;T&gt;</code> em um programa multithread no CapÃ­tulo 16.</p>
<p>Aqui estÃ¡ uma recapitulaÃ§Ã£o das razÃµes para escolher o <code>Box&lt;T&gt;</code>, o <code>Rc&lt;T&gt;</code> ou o
<code>RefCell&lt;T&gt;</code>:</p>
<ul>
<li>O <code>Rc&lt;T&gt;</code> permite mÃºltiplos possuidores do mesmo dado; <code>Box&lt;T&gt;</code> e <code>RefCell&lt;T&gt;</code>
tÃªm possuidores Ãºnicos.</li>
<li>O <code>Box&lt;T&gt;</code> permite emprÃ©stimos imutÃ¡veis ou mutÃ¡veis checados em tempo de
compilaÃ§Ã£o; o <code>Rc&lt;T&gt;</code> permite apenas emprÃ©stimos imutÃ¡veis em tempo de
compilaÃ§Ã£o; o <code>RefCell&lt;T&gt;</code> permite emprÃ©stimos imutÃ¡veis ou mutÃ¡veis checados
em tempo de execuÃ§Ã£o.</li>
<li>Como o <code>RefCell&lt;T&gt;</code> permite emprÃ©stimos mutÃ¡veis checados em tempo de
execuÃ§Ã£o, nÃ³s podemos modificar o valor dentro de um <code>RefCell&lt;T&gt;</code> mesmo quando
o <code>RefCell&lt;T&gt;</code> Ã© imutÃ¡vel.</li>
</ul>
<p>Modificar o valor dentro de um valor imutÃ¡vel Ã© a pattern de <em>mutabilidade
interior</em>. Vamos dar uma olhada em uma situaÃ§Ã£o em que a mutabilidade interior Ã©
Ãºtil e examinar como ela Ã© possÃ­vel.</p>
<a class="header" href="print.html#mutabilidade-interior-um-emprÃ©stimo-mutÃ¡vel-de-um-valor-imutÃ¡vel" id="mutabilidade-interior-um-emprÃ©stimo-mutÃ¡vel-de-um-valor-imutÃ¡vel"><h3>Mutabilidade Interior: Um EmprÃ©stimo MutÃ¡vel de um Valor ImutÃ¡vel</h3></a>
<p>Uma consequÃªncia das regras de emprÃ©stimo Ã© que quando temos um valor imutÃ¡vel,
nÃ³s nÃ£o podemos pegÃ¡-lo emprestado mutavelmente. Por exemplo, este cÃ³digo nÃ£o
compila:</p>
<pre><code class="language-rust ignore">fn main() {
    let x = 5;
    let y = &amp;mut x;
}
</code></pre>
<p>Quando tentamos compilar este cÃ³digo, recebemos o seguinte erro:</p>
<pre><code class="language-text">erro[E0596]: nÃ£o posso pegar emprestado a variÃ¡vel local imutÃ¡vel `x` como
mutÃ¡vel
 --&gt; src/main.rs:3:18
  |
2 |     let x = 5;
  |         - considere mudar isto para `mut x`
3 |     let y = &amp;mut x;
  |                  ^ nÃ£o posso pegar emprestado mutavelmente
</code></pre>
<p>Contudo, hÃ¡ situaÃ§Ãµes em que seria Ãºtil para um valor modificar a si mesmo em
seus mÃ©todos, mas continuar parecendo imutÃ¡vel para cÃ³digo externo. CÃ³digo fora
dos mÃ©todos do valor nÃ£o teriam como modificÃ¡-lo. Usar o <code>RefCell&lt;T&gt;</code> Ã© um jeito
de obter a habilidade de ter mutabilidade interior. Mas o <code>RefCell&lt;T&gt;</code> nÃ£o dÃ¡ a
volta nas regras de emprÃ©stimo por completo: o borrow checker no compilador
permite esta mutabilidade interior, e as regras de emprÃ©stimo sÃ£o em vez disso
checadas em tempo de execuÃ§Ã£o. Se violarmos as regras, receberemos um <code>panic!</code>
em vez de um erro de compilaÃ§Ã£o.</p>
<p>Vamos trabalhar com um exemplo prÃ¡tico onde podemos usar o <code>RefCell&lt;T&gt;</code> para
modificar um valor imutÃ¡vel e ver por que isto Ã© Ãºtil.</p>
<a class="header" href="print.html#um-caso-de-uso-para-a-mutabilidade-interior-objetos-simulados" id="um-caso-de-uso-para-a-mutabilidade-interior-objetos-simulados"><h4>Um Caso de Uso para a Mutabilidade Interior: Objetos Simulados</h4></a>
<p>Um <em>dublÃª de teste</em> (<em>test double</em>) Ã© um conceito geral de programaÃ§Ã£o para um
tipo usado no lugar de outro durante os testes. <em>Objetos simulados</em> (<em>mock
objects</em>) sÃ£o tipos especÃ­ficos de dublÃªs de teste que registram o que acontece
durante o teste para que possamos confirmar que as aÃ§Ãµes corretas aconteceram.</p>
<p>Rust nÃ£o tem objetos da mesma forma que outras linguagens, e nÃ£o tem
funcionalidade de objetos simulados embutida na biblioteca padrÃ£o como algumas
outras linguagens. Contudo, certamente podemos criar uma struct que serve os
mesmos propÃ³sitos que um objeto simulado.</p>
<p>Eis o cenÃ¡rio que vamos testar: vamos criar uma biblioteca que acompanha um
valor contra um valor mÃ¡ximo e envia mensagens com base em quÃ£o prÃ³ximo do valor
mÃ¡ximo o valor atual estÃ¡. Esta biblioteca pode ser usada para acompanhar a cota
de um usuÃ¡rio para o nÃºmero de chamadas de API que ele tem direito a fazer, por
exemplo.</p>
<p>Nossa biblioteca irÃ¡ prover somente a funcionalidade de acompanhar quÃ£o perto do
mÃ¡ximo um valor estÃ¡ e o que as mensagens deveriam ser em quais momentos. As
aplicaÃ§Ãµes que usarem nossa biblioteca terÃ£o a responsabilidade de prover o
mecanismo para enviar as mensagens: a aplicaÃ§Ã£o pode pÃ´r a mensagem na prÃ³pria
aplicaÃ§Ã£o, enviar um email, uma mensagem de texto, ou alguma outra coisa. A
biblioteca nÃ£o precisa saber deste detalhe. Tudo que ela precisa Ã© de algo que
implemente uma trait que iremos prover chamada <code>Mensageiro</code>. A
Listagem 15-20 mostra o cÃ³digo da biblioteca:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Mensageiro {
    fn enviar(&amp;self, msg: &amp;str);
}

pub struct AvisaLimite&lt;'a, T: 'a + Mensageiro&gt; {
    mensageiro: &amp;'a T,
    valor: usize,
    max: usize,
}

impl&lt;'a, T&gt; AvisaLimite&lt;'a, T&gt;
    where T: Mensageiro {
    pub fn new(mensageiro: &amp;T, max: usize) -&gt; AvisaLimite&lt;T&gt; {
        AvisaLimite {
            mensageiro,
            valor: 0,
            max,
        }
    }

    pub fn set_valor(&amp;mut self, valor: usize) {
        self.valor = valor;

        let porcentagem_do_max = self.valor as f64 / self.max as f64;

        if porcentagem_do_max &gt;= 0.75 &amp;&amp; porcentagem_do_max &lt; 0.9 {
            self.mensageiro.enviar(&quot;Aviso: VocÃª usou mais de 75% da sua cota!&quot;);
        } else if porcentagem_do_max &gt;= 0.9 &amp;&amp; porcentagem_do_max &lt; 1.0 {
            self.mensageiro.enviar(&quot;Aviso urgente: VocÃª usou mais de 90% da sua cota!&quot;);
        } else if porcentagem_do_max &gt;= 1.0 {
            self.mensageiro.enviar(&quot;Erro: VocÃª excedeu sua cota!&quot;);
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 15-20: Uma biblioteca para acompanhar quÃ£o perto
do mÃ¡ximo um valor estÃ¡ e avisar quando o valor estÃ¡ em certos nÃ­veis</span></p>
<p>Uma parte importante deste cÃ³digo Ã© que a trait <code>Mensageiro</code> tem um mÃ©todo
chamado <code>enviar</code> que recebe uma referÃªncia imutÃ¡vel a <code>self</code> e o texto da
mensagem. Esta Ã© a interface que nosso objeto simulado precisa ter. A outra
parte importante Ã© que queremos testar o comportamento do mÃ©todo <code>set_valor</code> no
<code>AvisaLimite</code>. Podemos mudar o que passamos para o parÃ¢metro <code>valor</code>, mas o
<code>set_valor</code> nÃ£o retorna nada sobre o qual possamos fazer asserÃ§Ãµes. Queremos
poder dizer que se criarmos um <code>AvisaLimite</code> com algo que implemente a trait
<code>Mensageiro</code> e um valor especÃ­fico de <code>max</code>, quando passarmos diferentes nÃºmeros
para o <code>valor</code>, o mensageiro receberÃ¡ o comando para enviar as mensagens
apropriadas.</p>
<p>Precisamos de um objeto simulado que, em vez de enviar um email ou mensagem de
texto quando chamarmos <code>enviar</code>, irÃ¡ apenas registrar as mensagens que recebeu
para enviar. Podemos criar uma nova instÃ¢ncia do objeto simulado, criar um
<code>AvisaLimite</code> que use o objeto simulado, chamar o mÃ©todo <code>set_valor</code> no
<code>AvisaLimite</code>, e entÃ£o verificar se o objeto simulado tem as mensagens que
esperamos. A Listagem 15-21 mostra uma tentativa de implementar um objeto
simulado para fazer exatamente isto, mas que o borrow checker nÃ£o permite:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    use super::*;

    struct MensageiroSimulado {
        mensagens_enviadas: Vec&lt;String&gt;,
    }

    impl MensageiroSimulado {
        fn new() -&gt; MensageiroSimulado {
            MensageiroSimulado { mensagens_enviadas: vec![] }
        }
    }

    impl Mensageiro for MensageiroSimulado {
        fn enviar(&amp;self, mensagem: &amp;str) {
            self.mensagens_enviadas.push(String::from(mensagem));
        }
    }

    #[test]
    fn envia_uma_mensagem_de_aviso_de_acima_de_75_porcento() {
        let mensageiro_simulado = MensageiroSimulado::new();
        let mut avisa_limite = AvisaLimite::new(&amp;mensageiro_simulado, 100);

        avisa_limite.set_valor(80);

        assert_eq!(mensageiro_simulado.mensagens_enviadas.len(), 1);
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 15-21: Uma tentativa de implementar um
<code>MensageiroSimulado</code> que nÃ£o Ã© permitida pelo borrow checker</span></p>
<p>Este cÃ³digo de teste define uma struct <code>MensageiroSimulado</code> que tem um campo
<code>mensagens_enviadas</code> com um <code>Vec</code> de valores <code>String</code> para registrar as
mensagens que ele recebe para enviar. TambÃ©m definimos uma funÃ§Ã£o associada
<code>new</code> para facilitar a criaÃ§Ã£o de novos valores <code>MensageiroSimulado</code> que comeÃ§am
com uma lista vazia de mensagens. EntÃ£o implementamos a trait <code>Mensageiro</code> para
o <code>MensageiroSimulado</code> para que possamos passar um <code>MensageiroSimulado</code> a um
<code>AvisaLimite</code>. Na definiÃ§Ã£o do mÃ©todo <code>enviar</code>, nÃ³s pegamos a mensagem passada
como parÃ¢metro e a armazenamos na lista <code>mensagens_enviadas</code> do
<code>MensageiroSimulado</code>.</p>
<p>No teste, estamos testando o que acontece quando o <code>AvisaLimite</code> recebe o
comando para setar o <code>valor</code> para algo que Ã© mais do que 75 porcento do valor
<code>max</code>. Primeiro, criamos um novo <code>MensageiroSimulado</code>, que irÃ¡ comeÃ§ar com uma
lista vazia de mensagens. EntÃ£o criamos um novo <code>AvisaLimite</code> e lhe damos uma
referÃªncia ao novo <code>MensageiroSimulado</code> e um valor <code>max</code> de 100. NÃ³s chamamos o
mÃ©todo <code>set_valor</code> no <code>AvisaLimite</code> com um valor de 80, que Ã© mais do que 75
porcento de 100. EntÃ£o conferimos se a lista de mensagens que o
<code>MensageiroSimulado</code> estÃ¡ registrando agora tem uma mensagem nela.</p>
<p>Entretanto, hÃ¡ um problema neste teste, conforme abaixo:</p>
<pre><code class="language-text">erro[E0596]: nÃ£o posso pegar emprestado o campo imutÃ¡vel
             `self.mensagens_enviadas` como mutÃ¡vel
  --&gt; src/lib.rs:52:13
   |
51 |         fn send(&amp;self, message: &amp;str) {
   |                 ----- use `&amp;mut self` aqui para tornÃ¡-lo mutÃ¡vel
52 |             self.sent_messages.push(String::from(message));
   |             ^^^^^^^^^^^^^^^^^^ nÃ£o posso pegar emprestado mutavelmente um
                                    campo imutÃ¡vel
</code></pre>
<p>NÃ£o podemos modificar o <code>MensageiroSimulado</code> para registrar as mensagens porque
o mÃ©todo <code>enviar</code> recebe uma referÃªncia imutÃ¡vel a <code>self</code>. TambÃ©m nÃ£o podemos
seguir a sugestÃ£o do texto de erro e usar <code>&amp;mut self</code> em vez disso porque a
assinatura de <code>enviar</code> nÃ£o corresponderia Ã  assinatura na definiÃ§Ã£o da trait
<code>Mensageiro</code> (fique Ã  vontade para tentar e ver qual mensagem de erro vocÃª
recebe).</p>
<p>Esta Ã© uma situaÃ§Ã£o em que a mutabilidade interior pode ajudar! Vamos armazenas
as <code>mensagens_enviadas</code> dentro de um <code>RefCell&lt;T&gt;</code>, e entÃ£o o mÃ©todo <code>enviar</code>
poderÃ¡ modificar <code>mensagens_enviadas</code> para armazenar as mensagens que jÃ¡ vimos.
A Listagem 15-22 mostra como fica isto:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MensageiroSimulado {
        mensagens_enviadas: RefCell&lt;Vec&lt;String&gt;&gt;,
    }

    impl MensageiroSimulado {
        fn new() -&gt; MensageiroSimulado {
            MensageiroSimulado { mensagens_enviadas: RefCell::new(vec![]) }
        }
    }

    impl Mensageiro for MensageiroSimulado {
        fn enviar(&amp;self, mensagem: &amp;str) {
            self.mensagens_enviadas.borrow_mut().push(String::from(mensagem));
        }
    }

    #[test]
    fn envia_uma_mensagem_de_aviso_de_acima_de_75_porcento() {
        // --snip--
#         let mensageiro_simulado = MensageiroSimulado::new();
#         let mut avisa_limite = AvisaLimite::new(&amp;mensageiro_simulado, 100);
#         avisa_limite.set_valor(75);

        assert_eq!(mensageiro_simulado.mensagens_enviadas.borrow().len(), 1);
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 15-22: Usando <code>RefCell&lt;T&gt;</code> para modificar um
valor interno enquanto o valor externo Ã© considerado imutÃ¡vel</span></p>
<p>O campo <code>mensagens_enviadas</code> agora Ã© do tipo <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> em vez de
<code>Vec&lt;String&gt;</code>. Na funÃ§Ã£o <code>new</code>, nÃ³s criamos uma nova instÃ¢ncia de
<code>RefCell&lt;Vec&lt;String&gt;&gt;</code> em torno do vetor vazio.</p>
<p>Para a implementaÃ§Ã£o do mÃ©todo <code>enviar</code>, o primeiro parÃ¢metro ainda Ã© um
emprÃ©stimo imutÃ¡vel de <code>self</code>, que corresponde Ã  definiÃ§Ã£o da trait. NÃ³s
chamamos <code>borrow_mut</code> no <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> em <code>self.mensagens_enviadas</code>
para obter uma referÃªncia mutÃ¡vel ao valor dentro do <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>, que
Ã© o vetor. EntÃ£o podemos chamar <code>push</code> na referÃªncia mutÃ¡vel ao vetor para
registrar as mensagens enviadas durante o teste.</p>
<p>A Ãºltima mudanÃ§a que temos que fazer Ã© na asserÃ§Ã£o: para ver quantos itens estÃ£o
no vetor interno, chamamos <code>borrow</code> no <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> para obter uma
referÃªncia imutÃ¡vel ao vetor.</p>
<p>Agora que vocÃª viu como usar o <code>RefCell&lt;T&gt;</code>, vamos nos aprofundar em como ele
funciona!</p>
<a class="header" href="print.html#o-refcellt-registra-emprÃ©stimos-em-tempo-de-execuÃ§Ã£o" id="o-refcellt-registra-emprÃ©stimos-em-tempo-de-execuÃ§Ã£o"><h4>O <code>RefCell&lt;T&gt;</code> Registra EmprÃ©stimos em Tempo de ExecuÃ§Ã£o</h4></a>
<p>Quando estamos criando referÃªncias imutÃ¡veis e mutÃ¡veis, usamos as sintaxes <code>&amp;</code>
e <code>&amp;mut</code>, respectivamente. Com o <code>RefCell&lt;T&gt;</code>, usamos os mÃ©todos <code>borrow</code> e
<code>borrow_mut</code>, que sÃ£o parte da API safe que pertence ao <code>RefCell&lt;T&gt;</code>. O mÃ©todo
<code>borrow</code> retorna o ponteiro inteligente <code>Ref&lt;T&gt;</code>, e o <code>borrow_mut</code> retorna o
ponteiro inteligente <code>RefMut&lt;T&gt;</code>. Ambos os tipos implementam <code>Deref</code>, entÃ£o
podemos tratÃ¡-los como referÃªncias normais.</p>
<p>O tipo <code>RefCell&lt;T&gt;</code> mantÃ©m registro de quantos ponteiros inteligentes <code>Ref&lt;T&gt;</code> e
<code>RefMut&lt;T&gt;</code> estÃ£o atualmente ativos. Cada vez que chamamos <code>borrow</code>, o
<code>RefCell&lt;T&gt;</code> aumenta seu contador de quantos emprÃ©stimos imutÃ¡veis estÃ£o ativos.
Quando um valor <code>Ref&lt;T&gt;</code> sai de escopo, o contador de emprÃ©stimos imutÃ¡veis
diminui em um. Assim como as regras de emprÃ©stimo em tempo de compilaÃ§Ã£o, o
<code>RefCell&lt;T&gt;</code> nos permite ter vÃ¡rios emprÃ©stimos imutÃ¡veis ou um emprÃ©stimo
mutÃ¡vel em um dado momento.</p>
<p>Se tentarmos violar estas regras, em vez de receber um erro do compilador como
irÃ­amos com referÃªncias, a implementaÃ§Ã£o de <code>RefCell&lt;T&gt;</code> chamarÃ¡ <code>panic!</code> em
tempo de execuÃ§Ã£o. A Listagem 15-23 mostra uma modificaÃ§Ã£o da implementaÃ§Ã£o do
<code>enviar</code> da Listagem 15-22. Estamos deliberadamente tentando criar dois
emprÃ©stimos mutÃ¡veis ativos para o mesmo escopo para ilustrar que o <code>RefCell&lt;T&gt;</code>
nos impede de fazer isto em tempo de execuÃ§Ã£o:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Mensageiro for MensageiroSimulado {
    fn enviar(&amp;self, mensagem: &amp;str) {
        let mut emprestimo_um = self.mensagens_enviadas.borrow_mut();
        let mut emprestimo_dois = self.mensagens_enviadas.borrow_mut();

        emprestimo_um.push(String::from(mensagem));
        emprestimo_dois.push(String::from(mensagem));
    }
}
</code></pre>
<p><span class="caption">Listagem 15-23: Criando duas referÃªncias mutÃ¡veis no mesmo
escopo para ver que o <code>RefCell&lt;T&gt;</code> irÃ¡ &quot;entrar em pÃ¢nico&quot; (i.e., executar
<code>panic!</code>)</span></p>
<p>NÃ³s criamos uma variÃ¡vel <code>emprestimo_um</code> para o ponteiro inteligente <code>RefMut&lt;T&gt;</code>
retornado por <code>borrow_mut</code>. EntÃ£o criamos outro emprÃ©stimo mutÃ¡vel da mesma
forma na variÃ¡vel <code>emprestimo_dois</code>. Isto resulta em duas referÃªncias mutÃ¡veis
no mesmo escopo, o que nÃ£o Ã© permitido. Quando rodarmos os testes para nossa
biblioteca, o cÃ³digo na Listagem 15-23 irÃ¡ compilar sem nenhum erro, mas o teste
irÃ¡ falhar:</p>
<pre><code class="language-text">---- tests::envia_uma_mensagem_de_aviso_de_acima_de_75_porcento stdout ----
    thread 'tests::envia_uma_mensagem_de_aviso_de_acima_de_75_porcento' entrou
    em pÃ¢nico em
    'jÃ¡ emprestado: BorrowMutError', src/libcore/result.rs:906:4
nota: Rode com `RUST_BACKTRACE=1` para um backtrace.
</code></pre>
<p>Note como o cÃ³digo entrou em pÃ¢nico com a mensagem <code>jÃ¡ emprestado: BorrowMutError</code>. Ã‰ assim que o <code>RefCell&lt;T&gt;</code> lida com violaÃ§Ãµes das regras de
emprÃ©stimo em tempo de execuÃ§Ã£o.</p>
<p>Pegar erros de emprÃ©stimo em tempo de execuÃ§Ã£o em vez de em tempo de compilaÃ§Ã£o
significa encontrar defeitos no nosso cÃ³digo mais tarde no processo de
desenvolvimento, e possivelmente nem mesmo atÃ© que nosso cÃ³digo jÃ¡ tenha sido
implantado em produÃ§Ã£o. AlÃ©m disso, nosso cÃ³digo irÃ¡ incorrer em uma pequena
penalidade de desempenho de execuÃ§Ã£o como resultado de manter registro dos
emprÃ©stimos em tempo de execuÃ§Ã£o em vez de compilaÃ§Ã£o. Ainda assim, usar o
<code>RefCell&lt;T&gt;</code> nos torna possÃ­vel escrever um objeto simulado que pode se
modificar para registrar as mensagens que ele jÃ¡ viu enquanto o usamos em um
contexto onde apenas valores imutÃ¡veis sÃ£o permitidos. Podemos usar o
<code>RefCell&lt;T&gt;</code>, apesar de seus trade-offs, para obter mais funcionalidade do que
referÃªncias regulares nos dÃ£o.</p>
<a class="header" href="print.html#conseguindo-mÃºltiplos-possuidores-de-dados-mutÃ¡veis-pela-combinaÃ§Ã£o-de-rct-e-refcellt" id="conseguindo-mÃºltiplos-possuidores-de-dados-mutÃ¡veis-pela-combinaÃ§Ã£o-de-rct-e-refcellt"><h3>Conseguindo MÃºltiplos Possuidores de Dados MutÃ¡veis pela CombinaÃ§Ã£o de <code>Rc&lt;T&gt;</code> e <code>RefCell&lt;T&gt;</code></h3></a>
<p>Um jeito comum de usar o <code>RefCell&lt;T&gt;</code> Ã© em combinaÃ§Ã£o com o <code>Rc&lt;T&gt;</code>. Lembre-se
de que o <code>Rc&lt;T&gt;</code> nos permite ter mÃºltiplos possuidores de algum dado, mas ele sÃ³
nos permite acesso imutÃ¡vel a esse dado. Se temos um <code>Rc&lt;T&gt;</code> que contÃ©m um
<code>RefCell&lt;T&gt;</code>, podemos ter um valor que pode ter mÃºltiplos possuidores <em>e</em> que
podemos modificar!</p>
<p>Por exemplo, lembre-se da cons list na Listagem 15-18 onde usamos o <code>Rc&lt;T&gt;</code> para
nos permitir que mÃºltiplas listas compartilhassem posse de outra lista. Como o
<code>Rc&lt;T&gt;</code> guarda apenas valores imutÃ¡veis, nÃ³s nÃ£o podemos modificar nenhum dos
valores na lista uma vez que os criamos. Vamos adicionar o <code>RefCell&lt;T&gt;</code> para
ganhar a habilidade de mudar os valores nas listas. A Listagem 15-24 mostra que,
usando um <code>RefCell&lt;T&gt;</code> na definiÃ§Ã£o do <code>Cons</code>, podemos modificar o valor
armazenado em todas as listas:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}

use List::{Cons, Nil};
use std::rc::Rc;
use std::cell::RefCell;

fn main() {
    let valor = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&amp;valor), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(6)), Rc::clone(&amp;a));
    let c = Cons(Rc::new(RefCell::new(10)), Rc::clone(&amp;a));

    *valor.borrow_mut() += 10;

    println!(&quot;a depois = {:?}&quot;, a);
    println!(&quot;b depois = {:?}&quot;, b);
    println!(&quot;c depois = {:?}&quot;, c);
}
</code></pre></pre>
<p><span class="caption">Listagem 15-24: Usando <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> para criar uma
<code>List</code> que podemos modificar</span></p>
<p>NÃ³s criamos um valor que Ã© uma instÃ¢ncia de <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> e o armazenamos
em uma variÃ¡vel chamada <code>valor</code> para que possamos acessÃ¡-lo diretamente mais
tarde. EntÃ£o criamos uma <code>List</code> em <code>a</code> com uma variante <code>Cons</code> que guarda
<code>valor</code>.</p>
<p>NÃ³s embrulhamos a lista <code>a</code> em um <code>Rc&lt;T&gt;</code> para que, quando criarmos as listas
<code>b</code> e <code>c</code>, elas possam ambas se referir a <code>a</code>, que Ã© o que fizemos na Listagem
15-18.</p>
<p>Depois de criarmos as listas em <code>a</code>, <code>b</code> e <code>c</code>, adicionamos 10 ao valor em
<code>valor</code>. Fazemos isto chamando <code>borrow_mut</code> em <code>valor</code>, o que usa a
funcionalidade de desreferÃªncia automÃ¡tica que discutimos no CapÃ­tulo 5 (veja a
seÃ§Ã£o &quot;Onde estÃ¡ o operador <code>-&gt;</code>?&quot;) para desreferenciar o <code>Rc&lt;T&gt;</code> ao valor
interno <code>RefCell&lt;T&gt;</code>. O mÃ©todo <code>borrow_mut</code> retorna um ponteiro inteligente
<code>RefMut&lt;T&gt;</code> no qual usamos o operador de desreferÃªncia e modificamos o valor
interno.</p>
<p>Quando imprimimos <code>a</code>, <code>b</code> e <code>c</code>, podemos ver que todos eles tÃªm o valor
modificado de 15 em vez de 5:</p>
<pre><code class="language-text">a depois = Cons(RefCell { value: 15 }, Nil)
b depois = Cons(RefCell { value: 6 }, Cons(RefCell { value: 15 }, Nil))
c depois = Cons(RefCell { value: 10 }, Cons(RefCell { value: 15 }, Nil))
</code></pre>
<p>Esta tÃ©cnica Ã© bem bacana! Usando um <code>RefCell&lt;T&gt;</code>, temos uma <code>List</code>
exteriormente imutÃ¡vel. Mas podemos usar os mÃ©todos no <code>RefCell&lt;T&gt;</code> que dÃ£o
acesso a sua mutabilidade interior para que possamos modificar nossos dados
quando precisarmos. As checagens em tempo de execuÃ§Ã£o das regras de emprÃ©stimo
nos protegem de corridas de dados, e Ã s vezes vale a pena trocar um pouco de
velocidade por esta flexibilidade nas nossas estruturas de dados.</p>
<p>A biblioteca padrÃ£o tem outros tipos que proveem mutabilidade interior, como o
<code>Cell&lt;T&gt;</code>, que Ã© parecido, exceto que em vez de dar referÃªncias ao valor
interno, o valor Ã© copiado para dentro e para fora do <code>Cell&lt;T&gt;</code>. Tem tambÃ©m o
<code>Mutex&lt;T&gt;</code>, que oferece mutabilidade interior que Ã© segura de usar entre
threads; vamos discutir seu uso no CapÃ­tulo 16. Confira a documentaÃ§Ã£o da
biblioteca padrÃ£o para mais detalhes sobre as diferenÃ§as entre estes tipos.</p>
<a class="header" href="print.html#ciclos-de-referÃªncias-podem-vazar-memÃ³ria" id="ciclos-de-referÃªncias-podem-vazar-memÃ³ria"><h2>Ciclos de ReferÃªncias Podem Vazar MemÃ³ria</h2></a>
<p>As garantias de seguranÃ§a de memÃ³ria do Rust tornam <em>difÃ­cil</em> mas nÃ£o impossÃ­vel
acidentalmente criar memÃ³ria que nunca Ã© liberada (conhecida como um <em>vazamento
de memÃ³ria</em>, ou <em>memory leak</em>). O Rust garante em tempo de compilaÃ§Ã£o que nÃ£o
haverÃ¡ corridas de dados, mas nÃ£o garante a prevenÃ§Ã£o de vazamentos de memÃ³ria
por completo da mesma forma, o que significa que vazamentos de memÃ³ria sÃ£o
<em>memory safe</em> em Rust. Podemos ver que o Rust permite vazamentos de memÃ³ria
usando <code>Rc&lt;T&gt;</code> e <code>RefCell&lt;T&gt;</code>: Ã© possÃ­vel criar referÃªncias onde os itens se
referem uns aos outros em um ciclo. Isso cria vazamentos de memÃ³ria porque a
contagem de referÃªncias de cada item no ciclo nunca chegarÃ¡ a 0, e os valores
nunca serÃ£o destruÃ­dos.</p>
<a class="header" href="print.html#criando-um-ciclo-de-referÃªncias" id="criando-um-ciclo-de-referÃªncias"><h3>Criando um Ciclo de ReferÃªncias</h3></a>
<p>Vamos dar uma olhada em como um ciclo de referÃªncias poderia acontecer e como
preveni-lo, comeÃ§ando com a definiÃ§Ã£o do enum <code>List</code> e um mÃ©todo <code>tail</code>
(<em>cauda</em>) na Listagem 15-25:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<!-- A fn main escondida (primeira linha) estÃ¡ aqui para desabilitar o wrapping
automÃ¡tico em uma fn main que os doc tests fazem; o `use List` falha se esta
listagem Ã© colocada dentro de uma main -->
<pre><pre class="playpen"><code class="language-rust"># fn main() {}
use std::rc::Rc;
use std::cell::RefCell;
use List::{Cons, Nil};

#[derive(Debug)]
enum List {
    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
    Nil,
}

impl List {
    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
        match *self {
            Cons(_, ref item) =&gt; Some(item),
            Nil =&gt; None,
        }
    }
}
</code></pre></pre>
<p><span class="caption">Listagem 15-25: Uma definiÃ§Ã£o de cons list que contÃ©m um
<code>RefCell&lt;T&gt;</code> para que possamos modificar ao que se refere uma variante
<code>Cons</code></span></p>
<p>Estamos usando outra variaÃ§Ã£o da definiÃ§Ã£o de <code>List</code> da Listagem 15-5. O segundo
elemento na variante <code>Cons</code> agora Ã© um <code>RefCell&lt;Rc&lt;List&gt;&gt;</code>, o que significa que
em vez de ter a habilidade de modificar o valor <code>i32</code> como fizemos na Listagem
15-24, queremos modificar a <code>List</code> Ã  qual a variante <code>Cons</code> estÃ¡ apontando.
TambÃ©m estamos adicionando um mÃ©todo <code>tail</code> para nos facilitar o acesso ao
segundo item quando tivermos uma variante <code>Cons</code>.</p>
<p>Na Listagem 15-26, estamos adicionando uma funÃ§Ã£o <code>main</code> que usa as definiÃ§Ãµes
da Listagem 15-25. Este cÃ³digo cria uma lista em <code>a</code> e uma lista em <code>b</code> que
aponta para a lista em <code>a</code>, e depois modifica a lista em <code>a</code> para apontar para
<code>b</code>, o que cria um ciclo de referÃªncias. Temos declaraÃ§Ãµes de <code>println!</code> ao
longo do caminho para mostrar quais sÃ£o as contagens de referÃªncias em vÃ¡rios
pontos do processo:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># use List::{Cons, Nil};
# use std::rc::Rc;
# use std::cell::RefCell;
# #[derive(Debug)]
# enum List {
#     Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
#     Nil,
# }
#
# impl List {
#     fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
#         match *self {
#             Cons(_, ref item) =&gt; Some(item),
#             Nil =&gt; None,
#         }
#     }
# }
#
fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!(&quot;a: contagem de referÃªncias inicial = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;a: prÃ³ximo item = {:?}&quot;, a.tail());

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&amp;a))));

    println!(&quot;a: contagem de referÃªncias depois da criaÃ§Ã£o de b = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;b: contagem de referÃªncias inicial = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;b: prÃ³ximo item = {:?}&quot;, b.tail());

    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::clone(&amp;b);
    }

    println!(&quot;b: contagem de referÃªncias depois de mudar a = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;a: contagem de referÃªncias depois de mudar a = {}&quot;, Rc::strong_count(&amp;a));

    // Descomente a prÃ³xima linha para ver que temos um ciclo; ela irÃ¡
    // estourar a pilha
    // println!(&quot;a: prÃ³ximo item = {:?}&quot;, a.tail());
}
</code></pre></pre>
<p><span class="caption">Listagem 15-26: Criando um ciclo de referÃªncias de dois
valores <code>List</code> apontando um para o outro</span></p>
<p>NÃ³s criamos uma instÃ¢ncia de <code>Rc&lt;List&gt;</code> segurando um valor <code>List</code> na variÃ¡vel
<code>a</code> com a lista inicial de <code>5, Nil</code>. EntÃ£o criamos uma instÃ¢ncia de <code>Rc&lt;List&gt;</code>
segurando outro valor <code>List</code> na variÃ¡vel <code>b</code> que contÃ©m o valor 10 e aponta para
a lista em <code>a</code>.</p>
<p>NÃ³s modificamos <code>a</code> para que aponte para <code>b</code> em vez de <code>Nil</code>, o que cria um
ciclo. Fazemos isso usando o mÃ©todo <code>tail</code> para obter uma referÃªncia ao
<code>RefCell&lt;Rc&lt;List&gt;&gt;</code> em <code>a</code>, a qual colocamos na variÃ¡vel <code>link</code>. EntÃ£o usamos o
mÃ©todo <code>borrow_mut</code> no <code>RefCell&lt;Rc&lt;List&gt;&gt;</code> para modificar o valor interno: de um
<code>Rc&lt;List&gt;</code> que guarda um valor <code>Nil</code> para o <code>Rc&lt;List&gt;</code> em <code>b</code>.</p>
<p>Quando rodamos esse cÃ³digo, mantendo o Ãºltimo <code>println!</code> comentado por ora,
obtemos esta saÃ­da:</p>
<pre><code class="language-text">a: contagem de referÃªncias inicial = 1
a: prÃ³ximo item = Some(RefCell { value: Nil })
a: contagem de referÃªncias depois da criaÃ§Ã£o de b = 2
b: contagem de referÃªncias inicial = 1
b: prÃ³ximo item = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
b: contagem de referÃªncias depois de mudar a = 2
a: contagem de referÃªncias depois de mudar a = 2
</code></pre>
<p>A contagem de referÃªncias das instÃ¢ncias de <code>Rc&lt;List&gt;</code> em ambos <code>a</code> e <code>b</code> Ã© 2
depois que mudamos a lista em <code>a</code> para apontar para <code>b</code>. No final da <code>main</code>, o
Rust tentarÃ¡ destruir <code>b</code> primeiro, o que diminuirÃ¡ em 1 a contagem em cada uma
das instÃ¢ncias de <code>Rc&lt;List&gt;</code> em <code>a</code> e <code>b</code>.</p>
<p>Contudo, como a variÃ¡vel <code>a</code> ainda estÃ¡ se referindo ao <code>Rc&lt;List&gt;</code> que estava em
<code>b</code>, ele terÃ¡ uma contagem de 1 em vez de 0, entÃ£o a memÃ³ria que ele tem no heap
nÃ£o serÃ¡ destruÃ­da. A memÃ³ria irÃ¡ ficar lÃ¡ com uma contagem de 1, para sempre.
Para visualizar esse ciclo de referÃªncias, criamos um diagrama na Figura 15-4:</p>
<p><img alt="Ciclo de referÃªncias de listas" src="img/trpl15-04.svg" class="center"
/></p>
<p><span class="caption">Figura 15-4: Um ciclo de referÃªncias das listas <code>a</code> e <code>b</code>
apontando uma para a outra</span></p>
<p>Se vocÃª descomentar o Ãºltimo <code>println!</code> e rodar o programa, o Rust tentarÃ¡
imprimir esse ciclo com <code>a</code> apontando para <code>b</code> apontando para <code>a</code> e assim por
diante atÃ© estourar a pilha.</p>
<p>Nesse exemplo, logo depois que criamos o ciclo de referÃªncias, o programa
termina. As consequÃªncias desse ciclo nÃ£o sÃ£o muito graves. Se um programa mais
complexo aloca um monte de memÃ³ria em um ciclo e nÃ£o a libera por muito tempo,
ele acaba usando mais memÃ³ria do que precisa e pode sobrecarregar o sistema,
fazendo com que fique sem memÃ³ria disponÃ­vel.</p>
<p>Criar ciclos de referÃªncias nÃ£o Ã© fÃ¡cil de fazer, mas tambÃ©m nÃ£o Ã© impossÃ­vel.
Se vocÃª tem valores <code>RefCell&lt;T&gt;</code> que contÃªm valores <code>Rc&lt;T&gt;</code> ou combinaÃ§Ãµes
aninhadas de tipos parecidas, com mutabilidade interior e contagem de
referÃªncias, vocÃª deve se assegurar de que nÃ£o estÃ¡ criando ciclos; vocÃª nÃ£o
pode contar com o Rust para pegÃ¡-los. Criar ciclos de referÃªncias seria um erro
de lÃ³gica no seu programa, e vocÃª deve usar testes automatizados, revisÃµes de
cÃ³digo e outras prÃ¡ticas de desenvolvimento de software para minimizÃ¡-los.</p>
<p>Outra soluÃ§Ã£o para evitar ciclos de referÃªncias Ã© reorganizar suas estruturas de
dados para que algumas referÃªncias expressem posse e outras nÃ£o. Assim, vocÃª
pode ter ciclos feitos de algumas relaÃ§Ãµes de posse e algumas relaÃ§Ãµes de nÃ£o
posse, e apenas as relaÃ§Ãµes de posse afetam se um valor pode ou nÃ£o ser
destruÃ­do. Na Listagem 15-25, nÃ³s sempre queremos que as variantes <code>Cons</code>
possuam sua lista, entÃ£o reorganizar a estrutura de dados nÃ£o Ã© possÃ­vel. Vamos
dar uma olhada em um exemplo usando grafos feitos de vÃ©rtices pais e vÃ©rtices
filhos para ver quando relaÃ§Ãµes de nÃ£o posse sÃ£o um jeito apropriado de evitar
ciclos de referÃªncias.</p>
<a class="header" href="print.html#prevenindo-ciclos-de-referÃªncia-transforme-um-rct-em-um-weakt" id="prevenindo-ciclos-de-referÃªncia-transforme-um-rct-em-um-weakt"><h3>Prevenindo Ciclos de ReferÃªncia: Transforme um <code>Rc&lt;T&gt;</code> em um <code>Weak&lt;T&gt;</code></h3></a>
<p>AtÃ© agora, demonstramos que chamar <code>Rc::clone</code> aumenta a <code>strong_count</code>
(<em>contagem de referÃªncias fortes</em>) de uma instÃ¢ncia <code>Rc&lt;T&gt;</code>, e que a instÃ¢ncia
<code>Rc&lt;T&gt;</code> sÃ³ Ã© liberada se sua <code>strong_count</code> Ã© 0. TambÃ©m podemos criar uma
<em>referÃªncia fraca</em> (<em>weak reference</em>) ao valor dentro de uma instÃ¢ncia <code>Rc&lt;T&gt;</code>
chamando <code>Rc::downgrade</code> e passando-lhe uma referÃªncia ao <code>Rc&lt;T&gt;</code>. Quando
chamamos <code>Rc::downgrade</code>, nÃ³s obtemos um ponteiro inteligente do tipo <code>Weak&lt;T&gt;</code>.
Em vez de aumentar em 1 a <code>strong_count</code> na instÃ¢ncia <code>Rc&lt;T&gt;</code>, chamar
<code>Rc::downgrade</code> aumenta em 1 a <code>weeak_count</code> (<em>contagem de referÃªncias fracas</em>).
O tipo <code>Rc&lt;T&gt;</code> usa a <code>weak_count</code> para registrar quantas referÃªncias <code>Weak&lt;T&gt;</code>
existem, parecido com a <code>strong_count</code>. A diferenÃ§a Ã© que a <code>weak_count</code> nÃ£o
precisa ser 0 para a instÃ¢ncia <code>Rc&lt;T&gt;</code> ser destruÃ­da.</p>
<p>ReferÃªncias fortes sÃ£o o modo como podemos compartilhar posse de uma instÃ¢ncia
<code>Rc&lt;T&gt;</code>. ReferÃªncias fracas nÃ£o expressam uma relaÃ§Ã£o de posse. Elas nÃ£o irÃ£o
causar um ciclo de referÃªncias porque qualquer ciclo envolvendo algumas
referÃªncias fracas serÃ¡ quebrado uma vez que a contagem de referÃªncias fortes
dos valores envolvidos for 0.</p>
<p>Como o valor ao qual o <code>Weak&lt;T&gt;</code> faz referÃªncia pode ter sido destruÃ­do, para
fazer qualquer coisa com ele, precisamos nos assegurar de que ele ainda exista.
Fazemos isso chamando o mÃ©todo <code>upgrade</code> na instÃ¢ncia <code>Weak&lt;T&gt;</code>, o que nos
retornarÃ¡ uma <code>Option&lt;Rc&lt;T&gt;&gt;</code>. Iremos obter um resultado de <code>Some</code> se o valor do
<code>Rc&lt;T&gt;</code> ainda nÃ£o tiver sido destruÃ­do e um resultado de <code>None</code> caso ele jÃ¡
tenha sido destruÃ­do. Como o <code>upgrade</code> retorna uma <code>Option&lt;T&gt;</code>, o Rust irÃ¡
garantir que lidemos com ambos os casos <code>Some</code> e <code>None</code>, e nÃ£o haverÃ¡ um
ponteiro invÃ¡lido.</p>
<p>Como exemplo, em vez de usarmos uma lista cujos itens sabem apenas a respeito do
prÃ³ximo item, iremos criar uma Ã¡rvore cujos itens sabem sobre seus itens filhos
<em>e</em> sobre seus itens pais.</p>
<a class="header" href="print.html#criando-uma-estrutura-de-dados-em-Ãrvore-um-vertice-com-vÃ©rtices-filhos" id="criando-uma-estrutura-de-dados-em-Ãrvore-um-vertice-com-vÃ©rtices-filhos"><h4>Criando uma Estrutura de Dados em Ãrvore: Um <code>Vertice</code> com VÃ©rtices Filhos</h4></a>
<p>Para comeÃ§ar, vamos construir uma Ã¡rvore com vÃ©rtices que saibam apenas sobre
seus vÃ©rtices filhos. Iremos criar uma estrutura chamada <code>Vertice</code> que contenha
seu prÃ³prio valor <code>i32</code>, alÃ©m de referÃªncias para seus valores filhos do tipo
<code>Vertice</code>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::rc::Rc;
use std::cell::RefCell;

#[derive(Debug)]
struct Vertice {
    valor: i32,
    filhos: RefCell&lt;Vec&lt;Rc&lt;Vertice&gt;&gt;&gt;,
}
#}</code></pre></pre>
<p>Queremos que um <code>Vertice</code> tenha posse de seus filhos, e queremos compartilhar
essa posse com variÃ¡veis para que possamos acessar cada <code>Vertice</code> da Ã¡rvore
diretamente. Para fazer isso, definimos os itens do <code>Vec&lt;T&gt;</code> para serem valores
do tipo <code>Rc&lt;Vertice&gt;</code>. TambÃ©m queremos modificar quais vÃ©rtices sÃ£o filhos de
outro vÃ©rtice, entÃ£o temos um <code>RefCell&lt;T&gt;</code> em <code>filhos</code> em volta do
<code>Vec&lt;Rc&lt;Vertice&gt;&gt;</code>.</p>
<p>Em seguida, iremos usar nossa definiÃ§Ã£o de struct e criar uma instÃ¢ncia de
<code>Vertice</code> chamada <code>folha</code> com o valor 3 e nenhum filho, e outra instÃ¢ncia
chamada <code>galho</code> com o valor 5 e <code>folha</code> como um de seus filhos, como mostra a
Listagem 15-27:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># use std::rc::Rc;
# use std::cell::RefCell;
#
# #[derive(Debug)]
# struct Vertice {
#     valor: i32,
#     filhos: RefCell&lt;Vec&lt;Rc&lt;Vertice&gt;&gt;&gt;,
# }
#
fn main() {
    let folha = Rc::new(Vertice {
        valor: 3,
        filhos: RefCell::new(vec![]),
    });

    let galho = Rc::new(Vertice {
        valor: 5,
        filhos: RefCell::new(vec![Rc::clone(&amp;folha)]),
    });
}
</code></pre></pre>
<p><span class="caption">Listagem 15-27: Criando um vÃ©rtice <code>folha</code> sem filhos e um
vÃ©rtice <code>galho</code> com <code>folha</code> como um de seus filhos</span></p>
<p>NÃ³s clonamos o <code>Rc&lt;Vertice&gt;</code> em <code>folha</code> e armazenamos o resultado em <code>galho</code>, o
que significa que o <code>Vertice</code> em <code>folha</code> agora tem dois possuidores: <code>folha</code> e
<code>galho</code>. Podemos ir de <code>galho</code> para <code>folha</code> atravÃ©s de <code>galho.filhos</code>, mas nÃ£o
temos como ir de <code>folha</code> para <code>galho</code>. O motivo Ã© que <code>folha</code> nÃ£o tem referÃªncia
a <code>galho</code> e nÃ£o sabe que eles estÃ£o relacionados. Queremos que <code>folha</code> saiba que
<code>galho</code> Ã© seu pai. Faremos isso em seguida.</p>
<a class="header" href="print.html#adicionando-uma-referÃªncia-de-um-filho-para-o-seu-pai" id="adicionando-uma-referÃªncia-de-um-filho-para-o-seu-pai"><h4>Adicionando uma ReferÃªncia de um Filho para o Seu Pai</h4></a>
<p>Para tornar o vÃ©rtice filho ciente de seu pai, precisamos adicionar um campo
<code>pai</code> a nossa definiÃ§Ã£o da struct <code>Vertice</code>. O problema Ã© decidir qual deveria
ser o tipo de <code>pai</code>. Sabemos que ele nÃ£o pode conter um <code>Rc&lt;T&gt;</code> porque isso
criaria um ciclo de referÃªncias com <code>folha.pai</code> apontando para <code>galho</code> e
<code>galho.filhos</code> apontando para <code>folha</code>, o que faria com que seus valores de
<code>strong_count</code> nunca chegassem a 0.</p>
<p>Pensando sobre as relaÃ§Ãµes de outra forma, um vÃ©rtice pai deveria ter posse de
seus filhos: se um vÃ©rtice pai Ã© destruÃ­do, seus vÃ©rtices filhos tambÃ©m deveriam
ser. Entretanto, um filho nÃ£o deveria ter posse de seu pai: se destruirmos um
vÃ©rtice filho, o pai ainda deveria existir. Esse Ã© um caso para referÃªncias
fracas!</p>
<p>EntÃ£o em vez de <code>Rc&lt;T&gt;</code>, faremos com que o tipo de <code>pai</code> use <code>Weak&lt;T&gt;</code>, mais
especificamente um <code>RefCell&lt;Weak&lt;Vertice&gt;&gt;</code>. Agora nossa definiÃ§Ã£o da struct
<code>Vertice</code> fica assim:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::rc::{Rc, Weak};
use std::cell::RefCell;

#[derive(Debug)]
struct Vertice {
    valor: i32,
    pai: RefCell&lt;Weak&lt;Vertice&gt;&gt;,
    filhos: RefCell&lt;Vec&lt;Rc&lt;Vertice&gt;&gt;&gt;,
}
#}</code></pre></pre>
<p>Agora um vÃ©rtice pode se referir a seu vÃ©rtice pai, mas nÃ£o tem posse dele. Na
Listagem 15-28, atualizamos a <code>main</code> com essa nova definiÃ§Ã£o para que o vÃ©rtice
<code>folha</code> tenha um jeito de se referir a seu pai, <code>galho</code>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># use std::rc::{Rc, Weak};
# use std::cell::RefCell;
#
# #[derive(Debug)]
# struct Vertice {
#     valor: i32,
#     pai: RefCell&lt;Weak&lt;Vertice&gt;&gt;,
#     filhos: RefCell&lt;Vec&lt;Rc&lt;Vertice&gt;&gt;&gt;,
# }
#
fn main() {
    let folha = Rc::new(Vertice {
        valor: 3,
        pai: RefCell::new(Weak::new()),
        filhos: RefCell::new(vec![]),
    });

    println!(&quot;pai de folha = {:?}&quot;, folha.pai.borrow().upgrade());

    let galho = Rc::new(Vertice {
        valor: 5,
        pai: RefCell::new(Weak::new()),
        filhos: RefCell::new(vec![Rc::clone(&amp;folha)]),
    });

    *folha.pai.borrow_mut() = Rc::downgrade(&amp;galho);

    println!(&quot;pai de folha = {:?}&quot;, folha.pai.borrow().upgrade());
}
</code></pre></pre>
<p><span class="caption">Listagem 15-28: Um vÃ©rtice <code>folha</code> com uma referÃªncia
<code>Weak</code> a seu vÃ©rtice pai <code>galho</code></span></p>
<p>Criar o vÃ©rtice <code>folha</code> Ã© semelhante a como o criamos na Listagem 15-27, com
exceÃ§Ã£o do campo <code>pai</code>: <code>folha</code> comeÃ§a sem um pai, entÃ£o criamos uma instÃ¢ncia
nova e vazia de uma referÃªncia <code>Weak&lt;Vertice&gt;</code>.</p>
<p>Nesse ponto, quando tentamos obter uma referÃªncia ao pai de <code>folha</code> usando o
mÃ©todo <code>upgrade</code>, recebemos um valor <code>None</code>. Vemos isso na saÃ­da do primeiro
comando <code>println!</code>:</p>
<pre><code class="language-text">pai de folha = None
</code></pre>
<p>Quando criamos o vÃ©rtice <code>galho</code>, ele tambÃ©m tem uma nova referÃªncia
<code>Weak&lt;Vertice&gt;</code> no campo <code>pai</code>, porque <code>galho</code> nÃ£o tem um vÃ©rtice pai. NÃ³s ainda
temos <code>folha</code> como um dos filhos de <code>galho</code>. Uma vez que temos a instÃ¢ncia de
<code>Vertice</code> em <code>galho</code>, podemos modificar <code>folha</code> para lhe dar uma referÃªncia
<code>Weak&lt;Vertice&gt;</code> a seu pai. Usamos o mÃ©todo <code>borrow_mut</code> do
<code>RefCell&lt;Weak&lt;Vertice&gt;&gt;</code> no campo <code>pai</code> de <code>folha</code>, e entÃ£o usamos a funÃ§Ã£o
<code>Rc::downgrade</code> para criar uma referÃªncia <code>Weak&lt;Vertice&gt;</code> a <code>galho</code> a partir do
<code>Rc&lt;Vertice&gt;</code> em <code>galho</code>.</p>
<p>Quando imprimimos o pai de <code>folha</code> de novo, dessa vez recebemos uma variante
<code>Some</code> contendo <code>galho</code>: agora <code>folha</code> tem acesso a seu pai! Quando imprimimos
<code>folha</code>, nÃ³s tambÃ©m evitamos o ciclo que eventualmente terminou em um estouro de
pilha como o que tivemos na Listagem 15-26: as referÃªncias <code>Weak&lt;Vertice&gt;</code> sÃ£o
impressas como <code>(Weak)</code>:</p>
<pre><code class="language-text">pai de folha = Some(Vertice { valor: 5, pai: RefCell { valor: (Weak) },
filhos: RefCell { valor: [Vertice { valor: 3, pai: RefCell { valor: (Weak) },
filhos: RefCell { valor: [] } }] } })
</code></pre>
<p>A falta de saÃ­da infinita indica que esse cÃ³digo nÃ£o criou um ciclo de
referÃªncias. TambÃ©m podemos perceber isso olhando para os valores que obtemos ao
chamar <code>Rc::strong_count</code> e <code>Rc::weak_count</code>.</p>
<a class="header" href="print.html#visualizando-mudanÃ§as-a-strong_count-e-weak_count" id="visualizando-mudanÃ§as-a-strong_count-e-weak_count"><h4>Visualizando MudanÃ§as a <code>strong_count</code> e <code>weak_count</code></h4></a>
<p>Para ver como os valores de <code>strong_count</code> e <code>weak_count</code> das instÃ¢ncias de
<code>Rc&lt;Vertice&gt;</code> mudam, vamos criar um novo escopo interno e mover a criaÃ§Ã£o de
<code>galho</code> para dentro dele. Fazendo isso, podemos ver o que acontece quando
<code>galho</code> Ã© criado e depois destruÃ­do quando sai de escopo. As modificaÃ§Ãµes sÃ£o
mostradas na Listagem 15-29:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># use std::rc::{Rc, Weak};
# use std::cell::RefCell;
#
# #[derive(Debug)]
# struct Vertice {
#     valor: i32,
#     pai: RefCell&lt;Weak&lt;Vertice&gt;&gt;,
#     filhos: RefCell&lt;Vec&lt;Rc&lt;Vertice&gt;&gt;&gt;,
# }
#
fn main() {
    let folha = Rc::new(Vertice {
        valor: 3,
        pai: RefCell::new(Weak::new()),
        filhos: RefCell::new(vec![]),
    });

    println!(
        &quot;folha: fortes = {}, fracas = {}&quot;,
        Rc::strong_count(&amp;folha),
        Rc::weak_count(&amp;folha),
    );

    {
        let galho = Rc::new(Vertice {
            valor: 5,
            pai: RefCell::new(Weak::new()),
            filhos: RefCell::new(vec![Rc::clone(&amp;folha)]),
        });

        *folha.pai.borrow_mut() = Rc::downgrade(&amp;galho);

        println!(
            &quot;galho: fortes = {}, fracas = {}&quot;,
            Rc::strong_count(&amp;galho),
            Rc::weak_count(&amp;galho),
        );

        println!(
            &quot;folha: fortes = {}, fracas = {}&quot;,
            Rc::strong_count(&amp;folha),
            Rc::weak_count(&amp;folha),
        );
    }

    println!(&quot;pai de folha = {:?}&quot;, folha.pai.borrow().upgrade());
    println!(
        &quot;folha: fortes = {}, fracas = {}&quot;,
        Rc::strong_count(&amp;folha),
        Rc::weak_count(&amp;folha),
    );
}
</code></pre></pre>
<p><span class="caption">Listagem 15-29: Criando <code>galho</code> em um escopo interno e
examinando contagens de referÃªncias fortes e fracas</span></p>
<p>Depois que <code>folha</code> Ã© criada, seu <code>Rc&lt;Vertice&gt;</code> tem uma <em>strong count</em> de 1 e uma
<em>weak count</em> de 0. Dentro do escopo interno, criamos <code>galho</code> e o associamos a
<code>folha</code>. Nesse ponto, quando imprimimos as contagens, o <code>Rc&lt;Vertice&gt;</code> em <code>galho</code>
tem uma strong count de 1 e uma weak count de 1 (porque <code>folha.pai</code> aponta para
<code>galho</code> com uma <code>Weak&lt;Vertice&gt;</code>). Quando imprimirmos as contagens de <code>folha</code>,
veremos que ela terÃ¡ uma strong count de 2, porque <code>galho</code> agora tem um clone do
<code>Rc&lt;Vertice&gt;</code> de <code>folha</code> armazenado em <code>galho.filhos</code>, mas ainda terÃ¡ uma weak
count de 0.</p>
<p>Quando o escopo interno termina, <code>galho</code> sai de escopo e a strong count do
<code>Rc&lt;Vertice&gt;</code> diminui para 0, e entÃ£o seu <code>Vertice</code> Ã© destruÃ­do. A weak count de
1 por causa de <code>folha.pai</code> nÃ£o tem nenhuma influÃªncia sobre se <code>Vertice</code> Ã©
destruÃ­do ou nÃ£o, entÃ£o nÃ£o temos nenhum vazamento de memÃ³ria!</p>
<p>Se tentarmos acessar o pai de <code>folha</code> depois do fim do escopo, receberemos
<code>None</code> de novo. No fim do programa, o <code>Rc&lt;Vertice&gt;</code> em <code>folha</code> tem uma strong
count de 1 e uma weak count de 0, porque a variÃ¡vel <code>folha</code> agora Ã© de novo a
Ãºnica referÃªncia ao <code>Rc&lt;Vertice&gt;</code>.</p>
<p>Toda a lÃ³gica que gerencia as contagens e a destruiÃ§Ã£o de valores faz parte de
<code>Rc&lt;T&gt;</code> e <code>Weak&lt;T&gt;</code> e suas implementaÃ§Ãµes da trait <code>Drop</code>. Ao especificarmos na
definiÃ§Ã£o de <code>Vertice</code> que a relaÃ§Ã£o de um filho para o seu pai deva ser uma
referÃªncia <code>Weak&lt;T&gt;</code>, somos capazes de ter vÃ©rtices pai apontando para para
vÃ©rtices filho e vice-versa sem criar ciclos de referÃªncia e vazamentos de
memÃ³ria.</p>
<a class="header" href="print.html#resumo-7" id="resumo-7"><h2>Resumo</h2></a>
<p>Esse capÃ­tulo cobriu como usar ponteiros inteligentes para fazer garantias e
trade-offs diferentes daqueles que o Rust faz por padrÃ£o com referÃªncias
normais. O tipo <code>Box&lt;T&gt;</code> tem um tamanho conhecido e aponta para dados alocados
no heap. O tipo <code>Rc&lt;T&gt;</code> mantÃ©m registro do nÃºmero de referÃªncias a dados no
heap, para que eles possam ter mÃºltiplos possuidores. O tipo <code>RefCell&lt;T&gt;</code> com
sua mutabilidade interior nos dÃ¡ um tipo que podemos usar quando precisamos de
um tipo imutÃ¡vel mas precisamos mudar um valor interno ao tipo; ele tambÃ©m
aplica as regras de emprÃ©stimo em tempo de execuÃ§Ã£o em vez de em tempo de
compilaÃ§Ã£o.</p>
<p>TambÃ©m foram discutidas as traits <code>Deref</code> e <code>Drop</code> que tornam possÃ­vel muito da
funcionalidade dos ponteiros inteligentes. Exploramos ciclos de referÃªncias que
podem causar vazamentos de memÃ³ria e como preveni-los usando <code>Weak&lt;T&gt;</code>.</p>
<p>Se esse capÃ­tulo tiver aguÃ§ado seu interesse e vocÃª quiser implementar seus
prÃ³prios ponteiros inteligentes, dÃª uma olhada no &quot;Rustnomicon&quot; em
<em>https://doc.rust-lang.org/stable/nomicon/</em> para mais informaÃ§Ã£o Ãºtil.</p>
<p>Em seguida, conversaremos sobre concorrÃªncia em Rust. VocÃª irÃ¡ atÃ© aprender
sobre alguns novos ponteiros inteligentes.</p>
<a class="header" href="print.html#concurrency" id="concurrency"><h1>Concurrency</h1></a>
<a class="header" href="print.html#rust-Ã©-uma-linguagem-orientada-a-objetos" id="rust-Ã©-uma-linguagem-orientada-a-objetos"><h1>Rust Ã© uma linguagem orientada a objetos?</h1></a>
<p>A programaÃ§Ã£o orientada a objetos (POO) Ã© uma maneira de modelar programas. Objetos vieram
da Simula nos anos 60. Esses objetos influenciaram a arquitetura de programaÃ§Ã£o de
Alan Kay, onde os objetos passam mensagens uns aos outros. Ele criou o termo
programaÃ§Ã£o orientada a objetos em 1967 para descrever essa arquitetura. Muitas
definiÃ§Ãµes concorrentes descrevem o que Ã© POO; algumas definiÃ§Ãµes classificariam
Rust como orientada a objetos, mas outras definiÃ§Ãµes nÃ£o. Nesse capÃ­tulo, iremos
explorar certas caracterÃ­sticas que sÃ£o comumente consideradas orientda a objetos
e como essas caracterÃ­sticas se traduzem no Rust. EntÃ£o, mostraremos
como implementar um padrÃ£o de design orientado a objetos em Rust e discutir as
vantagens de fazer versus implementar uma soluÃ§Ã£o usando alguns
pontos fortes do Rust.</p>
<a class="header" href="print.html#-o-que-significa-orientado-a-objetos" id="-o-que-significa-orientado-a-objetos"><h1>ğŸ‡§ğŸ‡· O que significa orientado a objetos?</h1></a>
<a class="header" href="print.html#usando-objetos-trait-que-permitem-valores-de-tipos-diferentes" id="usando-objetos-trait-que-permitem-valores-de-tipos-diferentes"><h2>Usando objetos trait que permitem valores de tipos diferentes</h2></a>
<p>No CapÃ­tulo 8, mencionamos que uma limitaÃ§Ã£o dos vetores Ã© que eles apenas podem
armazenar elementos do mesmo tipo. Criamos uma soluÃ§Ã£o alternativa na Listagem 8-10, onde
definimos um enum chamado <code>SpreadsheetCell</code> que tinha variantes para conter inteiros, flutuantes
e texto. Isso significa que poderiamos armazenar diferentes tipos de dados em cada cÃ©lula e
ainda ter um vetor que representasse uma linha de cÃ©lulas. Isso Ã© uma soluÃ§Ã£o Ã³tima
quando nossos itens intercambiÃ¡veis sÃ£o um conjunto fixo de tipos que sabemos
quando nosso cÃ³digo Ã© compilado.</p>
<p>No entanto, algumas vezes queremos que nosso usuÃ¡rio de biblioteca seja capaz de estender o conjunto de
tipos que sÃ£o vÃ¡lidos em uma situaÃ§Ã£o especÃ­fica. Para mostrar como podemos alcanÃ§ar
isso, criaremos um exemplo de ferramenta de interface grÃ¡fica (GUI) que interage
atravÃ©s de uma lista de itens, chamando um mÃ©todo <code>desenhar</code> em cada um para desenhÃ¡-lo
na tela - uma tÃ©cnica comum para ferramentas GUI. Criaremos uma crate chamada
<code>gui</code> que contÃ©m a estrutura da biblioteca GUI. Essa crate pode incluir
alguns tipos para as pessoas usarem, como um <code>Button</code> ou <code>TextField</code>. AlÃ©m disso,
usuÃ¡rios de <code>gui</code>vÃ£o querer criar seus prÃ³prios tipos que podem ser desenhados: por
exemplo, um programados pode adicionar uma <code>Image</code> e outro pode adicionar um
<code>SelectBox</code>.</p>
<p>NÃ£o implementamos uma biblioteca grÃ¡fica completa para esse exemplo, mas mostraremos
como as peÃ§as se encaixariam. No momento de escrever a biblioteca, nÃ£o podemos
saber e definir todos os tipos que outros programadores podem querer criar. Mas sabemos
que <code>gui</code> precisa manter o controle de diferentes valores de diferentes tipos e ele
precisa chamar o mÃ©todo <code>desenhar</code> em cada um desses diferentes tipos de valores. NÃ£o
Ã© necessÃ¡rio saber exatamente o que acontecerÃ¡ quando chamarmos o mÃ©todo <code>desenhar</code>,
apenas que o valor tera este mÃ©todo disponÃ­vel para executarmos.</p>
<p>Para fazer isso em uma linguagem com heranÃ§a, podemos definir uma classe chamada
<code>Component</code> que possui um mÃ©todo chamado <code>desenhar</code>. As outras classes, como as
<code>Button</code>, <code>Image</code> e <code>SelectBox</code>, herdam de <code>Component</code> e, assim,
herdam o mÃ©todo <code>desenhar</code>. Cada uma pode sobrescrever o mÃ©todo <code>desenhar</code> para definir
seu comportamento prÃ³prio, mas o framework poderia tratar todos esses tipos se
eles fossem instÃ¢ncias de <code>Component</code> e chamar <code>desenhar</code> neles. Mas como Rust
nÃ£o tem heranÃ§a, precisamos de outra maneira para estruturar a biblioteca <code>gui</code> para
perminir que os usuÃ¡rios o estendam com novos tipos.</p>
<a class="header" href="print.html#definindo-um-trait-para-componentes-comuns" id="definindo-um-trait-para-componentes-comuns"><h3>Definindo um Trait para componentes comuns</h3></a>
<p>Para implementar o comportamento que queremos que <code>gui</code> tenha, definiremos um trait chamado
<code>Draw</code> que terÃ¡ um mÃ©todo chamado <code>desenhar</code>. EntÃ£o podemos definir um vetor
que tenha um <em>objeto trait</em>. Um objeto trait aponta para uma instÃ¢ncia de um tipo que
implmenta o trait que especificamos. Criamos um objeto trait especificando alguns
tipos de ponteiros, como uma referÃªncia <code>&amp;</code> ou um ponteiro <code>Box&lt;T&gt;</code> e
especificando um trait relevante (falaremos sobre o motimo pelo qual os objetos trait
devem ser usados no CapÃ­tulo 19, na seÃ§Ã£o &quot;Tipos e tamanhos dimensionados dinamicamente&quot;).
Podemos usar objetos trait no lugar de um tipo genÃ©rico ou concreto. Onde quer que usemos
um objeto trait, o sistema de tipos do Rust irÃ¡ garantir em tempo de compilaÃ§Ã£o que qualquer
valor usado nesse contexto implementarÃ¡ o trait de um objeto trait.
Consequentemente, nÃ£o precisamos saber todos os possÃ­veis tipos em tempo de compilaÃ§Ã£o.</p>
<p>Mencionamos que em Rust evitamos de chamar estruturas e enums de
&quot;objetos&quot; para distingui-los dos objetos de outras linguagens. Em uma estrutura ou
enum, o dado nos campos e o comportamento no bloco <code>impl</code> sÃ£o
separados, enquanto em outras linguagens o dado e o comportamento sÃ£o combinados em um
conceito muitas vezes chamado de objeto. No entanto, objetos trait <em>sÃ£o</em> mais como
objetos em outras linguagens no sentido de combinar dados e comportamento.
Mas objetos trait diferem de objetos tradicionais, pois nÃ£o podemos adicionar dados
a um objeto trait. Objetos trait geralmente nÃ£o sÃ£o proveitosas como um objeto de outras
linguagens: sua finalidade Ã© simplemente possibilitar a abstraÃ§Ã£o entre
comportamento comum.</p>
<p>Listagem 17-3 mostra como definir um trait chamado <code>Draw</code> com um mÃ©todo chamado
<code>desenhar</code>:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Draw {
    fn desenhar(&amp;self);
}
#}</code></pre></pre>
<p><span class="caption">Listagem 17-3: DefiniÃ§Ã£o do trait <code>Draw</code></span></p>
<p>Essa sintaxe deve parecer familiar de outras discussÃµes de como definir traits
do CapÃ­tulo 10. Em seguida, vem uma nova sintaxe: A Listagem 17-4 define uma estrutuca chamada
<code>Janela</code> que contÃ©m um vetor chamado <code>componentes</code>. Esse vetor Ã© do tipo
<code>Box&lt;Draw&gt;</code>, que Ã© um objeto trait: Ã© um substituto para qualquer tipo dentro de um
<code>Box</code> que implementa o trait <code>Draw</code>.</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub trait Draw {
#     fn desenhar(&amp;self);
# }
#
pub struct Janela {
    pub componentes: Vec&lt;Box&lt;Draw&gt;&gt;,
}
#}</code></pre></pre>
<p><span class="caption">Listagem 17-4: DefiniÃ§Ã£o da estrutura <code>Janela</code> com um
campo <code>componentes</code> que contÃ©m um vetor de objetos trait que implementam o
trait <code>Draw</code></span></p>
<p>Na estrutura <code>Janela</code>, definiremos um mÃ©todo chamado <code>executar</code> que irÃ¡ chamar o
mÃ©todo <code>desenhar</code> em cada item do <code>componentes</code>, como mostrado na Listagem 17-5:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub trait Draw {
#     fn desenhar(&amp;self);
# }
#
# pub struct Janela {
#     pub componentes: Vec&lt;Box&lt;Draw&gt;&gt;,
# }
#
impl Janela {
    pub fn executar(&amp;self) {
        for component in self.componentes.iter() {
            component.desenhar();
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 17-5: Implementando um mÃ©todo<code>executar</code> na <code>Janela</code>
que chama o mÃ©todo <code>desenhar</code> para cada componente</span></p>
<p>Isso funciona de forma diferente do que definir uma estrutura que usa um parÃ¢metro de tipo
genÃ©rico com trait bounds. Um parÃ¢metro de tipo genÃ©rico pode
apenas ser substituido por um tipo concreto de cada vez, enquanto objetos trait permitem vÃ¡rios tipos
concretos para preencher o objeto trait em tempo de execuÃ§Ã£o. Por exemplo, poderÃ­amos
ter definido a estrutura <code>Janela</code> usando um tipo genÃ©rico e um trait bounds
como na Listagem 17-6:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub trait Draw {
#     fn desenhar(&amp;self);
# }
#
pub struct Janela&lt;T: Draw&gt; {
    pub componentes: Vec&lt;T&gt;,
}

impl&lt;T&gt; Janela&lt;T&gt;
    where T: Draw {
    pub fn executar(&amp;self) {
        for component in self.componentes.iter() {
            component.desenhar();
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 17-6: Uma implementaÃ§Ã£o alternativa da estrutura <code>Janela</code>
e seu mÃ©todo <code>executar</code> usando genÃ©ricos e trait bounds</span></p>
<p>Isso nos restringe a uma instÃ¢ncia de <code>Janela</code> que tem uma lista de componentes, todos
do tipo <code>Button</code> ou do tipo <code>TextField</code>. Se vocÃª tiver somente coleÃ§Ãµes do mesmo tipo,
usar genÃ©ricos e  trait bounds Ã© preferÃ­vel, porque as
definiÃ§Ãµes serÃ£o monomorfizadas em tempo de compilaÃ§Ã£o para os tipos concretos.</p>
<p>Por outro lado, com o mÃ©todo usando objetos trait, uma instÃ¢ncia de <code>Janela</code>
pode conter um <code>Vec</code> que contÃ©m um <code>Box&lt;Button&gt;</code> assim como um <code>Box&lt;TextField&gt;</code>.
Vamos ver como isso funciona e falaremos sobre as impliciaÃ§Ãµes do desempenho
em tempo de compilaÃ§Ã£o.</p>
<a class="header" href="print.html#implementando-o-trait" id="implementando-o-trait"><h3>Implementando o Trait</h3></a>
<p>Agora, adicionaremos alguns tipos que implementam o trait <code>Draw</code>. Forneceremos o
tipo <code>Button</code>. Novamente, a implementaÃ§Ã£o de uma biblioteca grÃ¡fica estÃ¡ alÃ©m do escopo
deste livro, entÃ£o o mÃ©todo <code>desenhar</code> nÃ£o terÃ¡ nenhum implementaÃ§Ã£o Ãºtil.
Para imaginar como a implementaÃ§Ã£o pode parecerm uma estrutura <code>Button</code>
pode ter os campos <code>largura</code>, <code>altura</code> e <code>label</code>, como mostra  a Listagem 17-7:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub trait Draw {
#     fn desenhar(&amp;self);
# }
#
pub struct Button {
    pub largura: u32,
    pub altura: u32,
    pub label: String,
}

impl Draw for Button {
    fn desenhar(&amp;self) {
        // CÃ³digo para realmente desenhar um botÃ£o
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 17-7: Uma estrutura <code>Button</code> que implementa o
trait <code>Draw</code></span></p>
<p>Os campos <code>largura</code>, <code>altura</code> e <code>label</code> do <code>Button</code> serÃ£o diferentes
de campos de outros componentes, como o tipo <code>TextField</code>, que pode ter esses campos,
mais um campo <code>placeholder</code>. Para cada um dos tipo, queremos que desenhar na
tela o que implementamos no trait <code>Draw</code>, mas usarÃ¡ cÃ³digos diferentes no
mÃ©todo <code>desenhar</code> para definir como desenhar aquele tipo em especÃ­fico, como o <code>Button</code> tem
aqui (sem o atual cÃ³digo da interface grÃ¡fica que estÃ¡ alÃ©m do escopo desse capÃ­tulo).
<code>Button</code>, por exemplo, pode ter um bloco <code>impl</code> adicional,
contÃªndo mÃ©todos reladionados com o que acontece quando um usuÃ¡rio clica no botÃ£o. Esses tipos de
mÃ©todos nÃ£o se aplicam a tipos como <code>TextField</code>.</p>
<p>Se alguÃ©m estiver usando nossa biblioteca para implementar a estrutura <code>SelectBox</code> que tem
os campos <code>largura</code>, <code>altura</code> e <code>opcoes</code>, eles implementam o
trait <code>Draw</code> no tipo <code>SelectBox</code>, como mostra a Listagem 17-8:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate gui;
use gui::Draw;

struct SelectBox {
    largura: u32,
    altura: u32,
    opcoes: Vec&lt;String&gt;,
}

impl Draw for SelectBox {
    fn desenhar(&amp;self) {
        // CÃ³digo para realmente desenhar um select box
    }
}
</code></pre>
<p><span class="caption">Listagem 17-8: Outro crate usando <code>gui</code> e implementando
o trait <code>Draw</code> na estrutura <code>SelectBox</code></span></p>
<p>Os usuÃ¡rios da nosso biblioteca agoora podem escrever suas funÃ§Ãµes <code>main</code> para criar uma
instÃ¢ncia de <code>Janela</code>. Para a instÃ¢ncia de <code>Janela</code>, eles podem adicionar um <code>SelectBox</code> e um <code>Button</code>
colocando cada um em um <code>Box&lt;T&gt;</code> para se tornar um objeto trait. Eles podem chamar o
mÃ©todo <code>executar</code> na instÃ¢ncia de <code>Janela</code>, que irÃ¡ chamar o <code>desenhar</code> para cada um dos
componentes. A Listagem 17-9 mostra essa implementaÃ§Ã£o:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">use gui::{Janela, Button};

fn main() {
    let screen = Janela {
        componentes: vec![
            Box::new(SelectBox {
                largura: 75,
                altura: 10,
                opcoes: vec![
                    String::from(&quot;Yes&quot;),
                    String::from(&quot;Maybe&quot;),
                    String::from(&quot;No&quot;)
                ],
            }),
            Box::new(Button {
                largura: 50,
                altura: 10,
                label: String::from(&quot;OK&quot;),
            }),
        ],
    };

    screen.executar();
}
</code></pre>
<p><span class="caption">Listagem 17-9: Usando objetos trait para armazenar valores
de tipos diferentes que implmentam trait semelhantes.</span></p>
<p>Quando escrevemos uma biblioteca, nÃ£o sabemos o que alguÃ©m pode adicionar ao
tipo <code>SelectBox</code>, mas nossa implementaÃ§Ã£o de <code>Janela</code> foi capaz de operar no
novo tipo e desenhÃ¡-lo, porque <code>SelectBox</code> implementa o tipo <code>Draw</code>, o que
significa que ele implementa o mÃ©todo <code>desenhar</code>.</p>
<p>Esse conceito - de se preocupar apenas com as mensagem que um valor responde
em vez do tipo concreto de valores - Ã© similar ao conceito <em>duck typing</em>
em linguagens dinÃ¢micamente tipadas: se anda como um pato e Ã© como um pato,
entÃ£o deve ser um pato! Na implementaÃ§Ã£o do <code>executar</code> na <code>Janela</code> na Listagem
17-5, <code>executar</code> nÃ£o precisa saber qual Ã© o tipo concreto que cada componente Ã©.
Ele nÃ£o verifica se um componente Ã© uma instÃ¢ncia de <code>Button</code> ou
um <code>SelectBox</code>, apenas chama o mÃ©todo <code>desenhar</code> do componente. Especificando
<code>Box&lt;Draw&gt;</code> como o tipo dos valores do vetor <code>componentes</code>, definimos
<code>Janela</code> por precisarmos de valores nos quais podemos chamar o mÃ©todo <code>desenhar</code>.</p>
<p>A vantagem de usar objetos trait e o sistema de tipos do Rust para escrever cÃ³digos
semelhante ao cÃ³digo usando duck typing Ã© que nunca precisamos verificar se um valor
implementa umm mÃ©todo em particular no tempo de execuÃ§Ã£o ou se preocupar com erros se
um valor nÃ£o implementa um mÃ©todo, mas nÃ³s o chamamos mesmo assim. Rust nÃ£o irÃ¡ compilar nosso
cÃ³digo se os valores nÃ£o implementarem os traits que o objeto trait precisa.</p>
<p>Por exemplo, a Listagem 17-10 mostra o que acontece se tentarmos criar uma <code>Janela</code>
com uma <code>String</code> como um componente:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate gui;
use gui::Janela;

fn main() {
    let screen = Janela {
        componentes: vec![
            Box::new(String::from(&quot;Hi&quot;)),
        ],
    };

    screen.executar();
}
</code></pre>
<p><span class="caption">Listagem 17-10: Tentativa de usar um tipo que nÃ£o
implementa o trait do objeto trait.</span></p>
<p>Obteremos esse erro, porque <code>String</code> nÃ£o implementa o trait <code>Draw</code>:</p>
<pre><code class="language-text">error[E0277]: the trait bound `std::string::String: gui::Draw` is not satisfied
  --&gt; src/main.rs:7:13
   |
 7 |             Box::new(String::from(&quot;Hi&quot;)),
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait gui::Draw is not
   implemented for `std::string::String`
   |
   = note: required for the cast to the object type `gui::Draw`
</code></pre>
<p>Esse erro nos permite saber se estamos passando algo para <code>Janela</code> que nÃ£o
pretenderÃ­amos passar e que deverÃ­amos passar um tipo diferente ou devemos implementar
<code>Draw</code> na <code>String</code>, para que <code>Janela</code> possa chamar <code>desenhar</code> nela.</p>
<a class="header" href="print.html#objetos-trait-executam-despacho-dinÃ¢mico" id="objetos-trait-executam-despacho-dinÃ¢mico"><h3>Objetos trait executam despacho dinÃ¢mico</h3></a>
<p>Lembre-se da seÃ§Ã£o &quot;Desempenho de cÃ³digo usando genÃ©ricos&quot; no CapÃ­tulo 10, nossa
discussÃ£o sobre o processo de monomorfizaÃ§Ã£o realizado pelo compilador quando
usamos trait bounds em genÃ©ricos: o compilador gera implementaÃ§Ãµes nÃ£o genÃ©ricas
de funÃ§Ãµes e mÃ©todos para cada tipo concreto que usamos no lugar
de um parÃ¢metro de tipo genÃ©rico. O cÃ³digo que resulta da monomorfizaÃ§Ã£o
estÃ¡ fazendo <em>despacho estÃ¡tico</em>, que Ã© quando o compilador sabe qual mÃ©todo vocÃª estÃ¡
chamando em tempo de compilaÃ§Ã£o. Isso Ã© oposto ao <em>despacho dinÃ¢mico</em>, que Ã© quando
o compilador nÃ£o sabe dizer que mÃ©todo vocÃª estÃ¡ chamando em tempo de compilaÃ§Ã£o. Nos casos
de despacho dinÃ¢mico, o compilador emite cÃ³digos que, em tempo de execuÃ§Ã£o, descobrirÃ¡ qual mÃ©todo
chamar.</p>
<p>Quando usamos objetos trait, o Rust deve usar despacho dinÃ¢mico. O compilador nÃ£o
sabe todos os tipos que podem ser usados com cÃ³digo que estÃ¡ usando os objetos trait,
por isso nÃ£o sabe qual mÃ©todo implementado em que tipo chamar.
Em vez disso, em tempo de execuÃ§Ã£o, Rust usa os ponteiros dentro de objeto trait para saber
que mÃ©todo, especÃ­fico, deve chamar. HÃ¡ um custo de tempo de execuÃ§Ã£o quando essa pesquisa ocorre,
que nÃ£o ocorre com despacho estÃ¡tico. Dispacho dinÃ¢mico tambÃ©m impede que o
compilador escolha inline o cÃ³digo de um mÃ©todo, o que, por vezes, impede
algumas otimizaÃ§Ãµes. No entanto, conseguimos uma maior flexibilidade no cÃ³digo que escrevemos
na Listagem 17-5 e foram capazes de suportar na Listagem 17-9, Ã© uma desvantagem
a se considerar.</p>
<a class="header" href="print.html#a-seguranÃ§a-do-objeto-Ã©-necessÃ¡rio-para-objetos-trait" id="a-seguranÃ§a-do-objeto-Ã©-necessÃ¡rio-para-objetos-trait"><h3>A seguranÃ§a do objeto Ã© necessÃ¡rio para objetos trait</h3></a>
<p>VocÃª apenas pode fazer <em>objetos traits seguros</em> em objetos traits. Algumas regras complexas
determinam todas as propriedades que fazem um objeto trait seguro, mas em prÃ¡tica, apenas
duas regras sÃ£o relevantes. Um trait Ã© um objeto seguro se todos os mÃ©todos definidos no
trait tem as seguintes propriedades:</p>
<ul>
<li>O retorno nÃ£o Ã© do tipo <code>Self</code>.</li>
<li>NÃ£o hÃ¡ parÃ¢metros de tipo genÃ©rico.</li>
</ul>
<p>A palavra-chave <code>Self</code> Ã© um pseudÃ´nimo para o tipo que estamos implementando o trait ou
mÃ©todo. Os objetos trait devem ser seguros, porque depois de usar um objeto trait,
o Rust nÃ£o conhece mais o tipo concreto que estÃ¡ implementando aquele trait.
Se um mÃ©todo trait renorna o tipo concreto <code>Self</code>, mas um objeto trait esquece
o tipo exato que `Self Ã©, nÃ£o hÃ¡ como o mÃ©todo usar o tipo concreto
original. O mesmo Ã© verdade para parÃ¢metros de tipo genÃ©rico que  sÃ£o preenchidos com
um parÃ¢metro de tipo concreto, quando o trait Ã© usado: os tipos concretos fazem
parte do tipo que implementa o trait. Quando o tipo Ã© esquecido atravÃ©s
do uso de um objeto trait, nÃ£o hÃ¡ como saber  que tipo preenchem os parÃ¢metros de
tipo genÃ©rico.</p>
<p>Um exemplo de trait cujos mÃ©todos nÃ£o sÃ£o seguros para objetos
Ã© o trait <code>Clone</code> da biblioteca padrÃ£o. A assinatura do mÃ©todo <code>clone</code> Ã© o trait <code>Clone</code>
se parece com isso:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Clone {
    fn clone(&amp;self) -&gt; Self;
}
#}</code></pre></pre>
<p>O tipo <code>String</code> implemento o trait <code>Clone</code> e quando chamamos o mÃ©todo <code>clone</code>
numa instÃ¢ncia de <code>String</code>, obtemos de retorno uma instÃ¢ncia de <code>String</code>.
Da mesma forma, se chamarmos <code>clone</code> numa instÃ¢ncia de <code>Vec</code>, retornamos uma instÃ¢ncia
de <code>Vec</code>. A assinatura de do <code>clone</code> precisa saber que tipo terÃ¡ o
<code>Self</code>, porque esse Ã© o tipo de retorno.</p>
<p>O compilador indicarÃ¡ quando vocÃª estiver tentando fazer algo que viole as
regras de seguranÃ§a de objetos em relaÃ§Ã£o a objetos trait. Por exemplo, digamos
que tentamos implementar a estrutuda da Listagem 17-4 para manter os tipos que
implementam o trait <code>Clone</code> em vez do trait <code>Draw</code>, desta forma:</p>
<pre><code class="language-rust ignore">pub struct Janela {
    pub componentes: Vec&lt;Box&lt;Clone&gt;&gt;,
}
</code></pre>
<p>Teremos o seguinte erro:</p>
<pre><code class="language-text">error[E0038]: the trait `std::clone::Clone` cannot be made into an object
 --&gt; src/lib.rs:2:5
  |
2 |     pub componentes: Vec&lt;Box&lt;Clone&gt;&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::clone::Clone` cannot be
made into an object
  |
  = note: the trait cannot require that `Self : Sized`
</code></pre>
<p>Esse erro significa que vocÃª nÃ£o pode usar esse trait como um objeto trait dessa maneira. Se
estiver interessado em mais detalhes sobre seguranÃ§a de objetos, veja <a href="https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md">Rust RFC 255</a>.</p>
<a class="header" href="print.html#implementando-um-padrÃ£o-de-projeto-orientado-a-objetos" id="implementando-um-padrÃ£o-de-projeto-orientado-a-objetos"><h2>Implementando um padrÃ£o de projeto orientado a objetos</h2></a>
<p>O <em>padrÃ£o de estado</em> Ã© um padrÃ£o de projeto orientado a objetos. O ponto crucial do padrÃ£o
Ã© que um valor tem algun estado interno, que Ã© representado por um conjunto
de <em>objetos de estado</em> e o comportamento do valor Ã© alterado com base no estado
interno. Os objetos de estado compartilham funcionalidade: em Rust, Ã© claro, usamos
estruturas e traits em vez de de objetos e heranÃ§a. Cada objeto de estado Ã©
responsÃ¡vel por seu prÃ³prio comportamento e por administrar quando dev mudar para outro
estado. O valor que contÃ©m um objeto de estado nÃ£o sabe nada sobre o
comportamento diferente dos estados ou quando fazer transiÃ§Ã£o entre os estados.</p>
<p>Usando o padrÃ£o de estados significa que quando os requisitos do negÃ³cio do programa
mudam, nÃ£o precisamos mudar o cÃ³digo do valor que detÃ©m o estado ou o
cÃ³digo que usa o valor. Precisamos apenas atualizar o cÃ³digo dentro de um dos
objetos de estados para mudar suas regras ou talvez adicionar mais objetos de estados. Vamos ver
um exemplo de padrÃ£o de projeto de estados e como usÃ¡-lo no Rust.</p>
<p>Implementaremos um fluxo de trabalho de postagens de maneira incremental. A funcionalidade
final do blog serÃ¡ assim:</p>
<ol>
<li>Uma postagem no blog comeÃ§a como um rascunho vazio.</li>
<li>Quando o rascunho Ã© concluÃ­do, Ã© necessÃ¡ria uma revisÃ£o da postagem.</li>
<li>Quando a postagem Ã© aprovada, ela Ã© aprovada.</li>
<li>Apenas postagens de blog publicadas retornam conteÃºdo para impressÃ£o, portanto, postagens nÃ£o aprovadas nÃ£o podem ser
publicadas por acidente.</li>
</ol>
<p>Quaisquer outras tentativas de mudanÃ§a em uma postagem nÃ£o deve ter efeito. Por exemplo, se
tentarmos aprovar um rascunho de postagem no blog antes de solicitarmos uma revisÃ£o, a postagem
a postagem deve permanecer em rascunho nÃ£o publicado.</p>
<p>Listagem 17-11 mostra esse fluxo de trabalho em forma de cÃ³digo: este Ã© um exemplo de uso de
API que implementaremos em um biblioteca crate chamada <code>blog</code>. Isso ainda nÃ£o foi compilado,
porque nÃ£o tempos implementado o crate <code>blog</code>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate blog;
use blog::Postagem;

fn main() {
    let mut post = Postagem::new();

    post.add_texto(&quot;Eu comi uma salada no almoÃ§o de hoje&quot;);
    assert_eq!(&quot;&quot;, post.conteudo());

    post.solicitar_revisao();
    assert_eq!(&quot;&quot;, post.conteudo());

    post.aprovar();
    assert_eq!(&quot;Eu comi uma salada no almoÃ§o de hoje&quot;, post.conteudo());
}
</code></pre>
<p><span class="caption">Listagem 17-11: CÃ³digo que demonstra o desejado
comportamento que queremos que o nosso crate<code>blog</code> tenha</span></p>
<p>Queremos permitir que o usuÃ¡rio crie uma nova postagem de blog com <code>Postagem :: new</code>.
EntÃ£o, queremos permitir que o texto seja adicionado Ã  postagem do blog enquanto ela estiver no estado de
rascunho. Se tentarmos obter o conteÃºdo da postagem imediatamente, antes da aprovaÃ§Ã£o,
nada deve acontecer porque a postagem ainda Ã© um rascunho. Adicionamos
<code>assert_eq!</code> no cÃ³digo para fins de demonstraÃ§Ã£o. Um excelente teste unitÃ¡rio para
isso seria afirmar que uma postagem do blog em rascunho retorna uma string vazia do mÃ©todo
<code>conteudo</code>, mas nÃ£o vamos escrever testes para este exemplo.</p>
<p>Em seguida, queremos possibilitar uma solicitaÃ§Ã£o de revisÃ£o para a postagem e queremos que o
<code>conteudo</code> retorne uma string vazia enquanto aguarda a revisÃ£o. Quand a postagem
for aprovada, deve ser publicada, significa que o texto da postagem
serÃ¡ retornada quando o <code>conteudo</code> for chamado.</p>
<p>Observe que o Ãºnico tipo com o qual estamos interagindo, do crate, Ã© o
tipo <code>Postagem</code>. Esse tipo usarÃ¡ padrÃ£o de estados e terÃ¡ um valor que serÃ¡
um dos trÃªs estados de objeto, representam os vÃ¡rios estados em que uma postagem pode estar
em - rascunho, esperando por revisÃ£o ou publicada. Mudar de um estado para outro serÃ¡
gerenciado internamente com o tipo <code>Postagem</code>. Os estados mudam em
resposta aos mÃ©todos chamados pelos usuÃ¡rios da bibliotÃ©ca sobre a instÃ¢ncia <code>Postagem</code>,
mas eles nÃ£o precisam gerenciar as alteraÃ§Ãµes de estados diretamente. AlÃ©m disso, usuÃ¡rios nÃ£o podem
cometer erros nos estados, como publicar uma postagem antes de revisÃ¡-la.</p>
<a class="header" href="print.html#definindo-postagem-e-criando-uma-nova-instÃ¢ncia-no-estado-de-rascunho" id="definindo-postagem-e-criando-uma-nova-instÃ¢ncia-no-estado-de-rascunho"><h3>Definindo <code>Postagem</code> e criando uma nova instÃ¢ncia no estado de rascunho</h3></a>
<p>Vamos comeÃ§ar a implementaÃ§Ã£o da biblioteca! Sabemos que precisamos da
estrutura pÃºblica <code>Postagem</code> que contenha algum conteÃºdo, por isso comeÃ§aremos com a
definiÃ§Ã£o da estrutura e a funÃ§Ã£o pÃºblica <code>new</code> associada para criar uma
instÃ¢ncia de <code>Postagem</code>, como mostra a Listageá¸¿ 17-12. TambÃ©m faremos um trait privado
<code>Estado</code>. EntÃ£o o <code>Postagem</code> conterÃ¡ um objeto trait <code>Box&lt;Estado&gt;</code> dentro de um
<code>Opcao</code> em um campo privado, chamado <code>estado</code>. VocÃª verÃ¡ porquÃª o <code>Opcao</code>
Ã© necessÃ¡rio.</p>
<p>O trait <code>Estado</code> define o comportamento compartilhado por diferentes estados de postagem e os
estados <code>Rascunho</code>, <code>RevisaoPendente</code> e <code>Publicado</code> implementarÃ£o todos os
trait <code>Estado</code>. Por equanto, o trait nÃ£o tem nenhum mÃ©todo; e comeÃ§aremos definindo
apenas o estado <code>Rascunho</code>, porque esse Ã© o estado em que queremos uma postagem inicialmente:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Postagem {
    estado: Opcao&lt;Box&lt;Estado&gt;&gt;,
    conteudo: String,
}

impl Postagem {
    pub fn new() -&gt; Postagem {
        Postagem {
            estado: Some(Box::new(Rascunho {})),
            conteudo: String::new(),
        }
    }
}

trait Estado {}

struct Rascunho {}

impl Estado for Rascunho {}
#}</code></pre></pre>
<p><span class="caption">Listagem 17-12: DefiniÃ§Ã£o da estrutura <code>Postagem</code> e a funÃ§Ã£o <code>new</code>,
que cria uma nova instÃ¢ncia de <code>Postagem</code>, um trait <code>Estado</code> e uma
estrutura <code>Rascunho</code></span></p>
<p>Quando criamos um novo <code>Postagem</code>, definimos seu campo <code>estado</code> como um valor <code>Some</code>, que
conterÃ¡ um <code>Box</code>. Este <code>Box</code> aponta para uma nova instÃ¢ncia da estrutura <code>Rascunho</code>. Isso
garante que sempre criamos uma nova instÃ¢ncia de <code>Postagem</code>, ela comeÃ§arÃ¡ como um
rascunho. Como o campo <code>estado</code> do <code>Postagem</code> Ã© privado, nÃ£o hÃ¡ como
criar um <code>Postagem</code> em qualquer outro estado!</p>
<a class="header" href="print.html#armazenando-o-texto-do-conteÃºdo-do-post" id="armazenando-o-texto-do-conteÃºdo-do-post"><h3>Armazenando o texto do conteÃºdo do post</h3></a>
<p>Na funÃ§Ã£o <code>Postagem::new</code>, definimos o campo <code>conteudo</code> como uma novo
<code>String</code> vazia. Listagem 17-11 mostrou que queremos poder chamar o mÃ©todo chamado
<code>add_texto</code> e passar um <code>&amp;str</code> que Ã© entÃ£o adicionado ao conteÃºdo do texto da
postagem do blog. Implementamos isso como uma mÃ©todo, em vez de expor o campo <code>conteudo</code>
como <code>pub</code>. Isso significa que podemos implementar um mÃ©todo posteriormente que controlarÃ¡
como os dados do campo <code>conteudo</code> sÃ£o lidos. O mÃ©todo <code>add_texto</code> Ã© bastante direto,
entÃ£o vamos adicionar a implementaÃ§Ã£o na Listagem 17-13 ao bloco
<code>impl Postagem</code>:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Postagem {
#     conteudo: String,
# }
#
impl Postagem {
    // --recorte--
    pub fn add_texto(&amp;mut self, text: &amp;str) {
        self.conteudo.push_str(text);
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 17-13: Implementando o mÃ©todo <code>add_texto</code> para adicionar o
texto ao <code>conteudo</code> da postagem</span></p>
<p>O mÃ©todo <code>add_texto</code> usa uma referÃªncia mutÃ¡vel ao <code>self</code>, porque estamos
mudando a instÃ¢ncia <code>Postagem</code> que estamos chamando a partir de<code>add_texto</code>. EntÃ£o chamamos
<code>push_str</code> na <code>String</code> em <code>conteudo</code> e passamos o argumento <code>text</code> para adicionar ao <code>conteudo</code>
salvo. Esse comportamento nÃ£o depende do estado em que a postagem estÃ¡,
portanto, nÃ£o faz parte do padrÃ£o de estados. O mÃ©todo <code>add_texto</code> nÃ£o interage
com o campo <code>estado</code>, mas faz parte do comportamento que queremos
suportar.</p>
<a class="header" href="print.html#garantindo-que-o-conteÃºdo-de-um-rascunho-de-postagem-esteja-vazio" id="garantindo-que-o-conteÃºdo-de-um-rascunho-de-postagem-esteja-vazio"><h3>Garantindo que o conteÃºdo de um rascunho de postagem esteja vazio</h3></a>
<p>Mesmo depois que chamamos <code>add_texto</code> e adicionamos algum conteÃºdo para nossa postagem, ainda
queremos que o mÃ©todo <code>conteudo</code> retorne um pedaÃ§o de string vazia, porque a postagem ainda
estÃ¡ no estÃ¡ de rascunho, como mostrado na linha 8 da Listagem 17-11. Por hora, vamos
implementar o mÃ©todo <code>conteudo</code> com a coisa mais simples que atenderÃ¡ a esse
requisito: sempre retornando um pedaÃ§o de string vazia. Mudaremos isso mais tarde,
quando implementaremos a possibilidade de mudar o estado de uma postagem para que ela possa ser publicada.
AtÃ© agora, postagens apenas podem estar no estado de rascunho, portanto, o conteÃºdo da publicaÃ§Ã£o deve estar
vazio. Listagem 17-14 mostra essa implementaÃ§Ã£o substituta:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Postagem {
#     conteudo: String,
# }
#
impl Postagem {
    // --recorte--
    pub fn conteudo(&amp;self) -&gt; &amp;str {
        &quot;&quot;
    }
}
#}</code></pre></pre>
<p><span class="caption">LIstagem 17-14: Adicionando temporÃ¡ria para
o mÃ©todo <code>conteudo</code> do <code>Postagem</code> que sempre retorna uma string vazia</span></p>
<p>Como o mÃ©todo <code>conteudo</code> adicionado, tudo na Listagem 17-11 atÃ© a linha 8
funciona como prentendido.</p>
<a class="header" href="print.html#solicitando-uma-revisÃ£o-da-postagem-que-altera-seu-estado" id="solicitando-uma-revisÃ£o-da-postagem-que-altera-seu-estado"><h3>Solicitando uma revisÃ£o da postagem que altera seu estado</h3></a>
<p>Em seguida, nÃ³s precisamos adicionar funcionalidade para solicitar uma revisÃ£o da postagem, que deve
mudar seu estado de <code>Rascunho</code> para <code>RevisaoPendente</code>. Listagem 17-15 mostra este cÃ³digo:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Postagem {
#     estado: Opcao&lt;Box&lt;Estado&gt;&gt;,
#     conteudo: String,
# }
#
impl Postagem {
    // --recorte--
    pub fn solicitar_revisao(&amp;mut self) {
        if let Some(s) = self.estado.take() {
            self.estado = Some(s.solicitar_revisao())
        }
    }
}

trait Estado {
    fn solicitar_revisao(self: Box&lt;Self&gt;) -&gt; Box&lt;Estado&gt;;
}

struct Rascunho {}

impl Estado for Rascunho {
    fn solicitar_revisao(self: Box&lt;Self&gt;) -&gt; Box&lt;Estado&gt; {
        Box::new(RevisaoPendente {})
    }
}

struct RevisaoPendente {}

impl Estado for RevisaoPendente {
    fn solicitar_revisao(self: Box&lt;Self&gt;) -&gt; Box&lt;Estado&gt; {
        self
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 17-15: Implementando mÃ©todo <code>solicitar_revisao</code> no
<code>Postagem</code> e no trait <code>Estado</code></span></p>
<p>NÃ³s fornecemos ao <code>Postagem</code> um mÃ©todo pÃºblico chamado <code>solicitar_revisao</code> que irÃ¡ tormar uma referÃªncia
mutÃ¡vel para <code>self</code>. Em seguida, chamamos internamente o mÃ©todo <code>solicitar_revisao</code>
do estado atual do <code>Postagem</code> e esse segundo mÃ©todo <code>solicitar_revisao</code> consome o
estado atual e retorna um novo estado.</p>
<p>Adicionamos o mÃ©todo <code>solicitar_revisao</code> para o trait <code>Estado</code>; todos os tipos
que implementam o trait, agora precisarÃ£o implementar o mÃ©todo <code>solicitar_revisao</code>.
Note que em vez de ter <code>self</code>, <code>&amp;self</code> ou <code>&amp;mut self</code> como
primeiro parÃ¢metro do mÃ©todo, temos <code>self: Box&lt;Self&gt;</code>. Essa sintaxe significa que
o mÃ©todo Ã© apenas vÃ¡lido quando chamado em um <code>Box</code> contendo o tipo. Essa sintaxe apropria-se
do <code>Box&lt;Self&gt;</code>, invalidando o antigo estado para que o valor de estado do
<code>Postagem</code> possa se transfor em um novo estado.</p>
<p>Para consumir o antigo estado, o mÃ©todo <code>solicitar_revisao</code> precisa apropriar-se
do valor do estado. Este Ã© o lugar onde o <code>Opcao</code> no campo <code>estado</code> do <code>Postagem</code>:
chamamos o mÃ©todo <code>take</code> para tirar o valor de <code>Some</code> do campo <code>estado</code>
e deixar um <code>None</code> no lugar, porque Rust nÃ£o nos permite ter
campos nÃ£o preenchidos nas estruturas. Isso nos permite mover o valor do <code>estado</code> para fora
do <code>Postagem</code> em vez de pedir emprestado. Em seguida, definiremos o valor do <code>estado</code> da postagem como
resultado da operaÃ§Ã£o.</p>
<p>Precisamos definir o <code>estado</code> como <code>None</code> temporariamente em vez de configurÃ¡-la diretamente
com o cÃ³digo <code>self.estado = self.estado.solicitar_revisao();</code> para obter a posse do
valor de <code>estado</code>. Isso garante que o <code>Postagem</code> nÃ£o pode usar o antigo valor do <code>estado</code> depois
de transformÃ¡-lo em um novo estado.</p>
<p>O mÃ©todo <code>solicitar_revisao</code> no <code>Rascunho</code> precisa retornar uma nova instÃ¢ncia em caixa de
uma nova estrutura <code>RevisaoPendente</code>, que representa o estado quando uma postagem estÃ¡ aguardando
uma revisÃ£o. A estrutura <code>RevisaoPendente</code> tambÃ©m implementa o mÃ©todo <code>solicitar_revisao</code>,
mas nÃ£o faz nenhuma transformaÃ§Ã£o. Em vez disso, ele retorna a si mesmo, porque
quando solicitamos uma revisÃ£o em uma publicaÃ§Ã£o jÃ¡ no estado <code>RevisaoPendente</code>, ele deve
permanecer no estado <code>RevisaoPendente</code>.</p>
<p>Agora podemos comeÃ§ar a ver as vantagens do padrÃ§ao de estados: o mÃ©todo
<code>solicitar_revisao</code> no <code>Postagem</code> Ã© o mesmo, nÃ£o importa seu valor <code>estado</code>. Cada
estado Ã© responsÃ¡vel por suas prÃ³prias regras.</p>
<p>Deixaremos o mÃ©todo <code>conteudo</code> do <code>Postagem</code> como estÃ¡, retornando uma string
vazia. Agora podemos ter um <code>Postagem</code> no estado <code>RevisaoPendente</code>, bem como no estado
<code>Rascunho</code>, mas queremos o mesmo comportamento no estado <code>RevisaoPendente</code>.
Listagem 17-11 agora funciona atÃ© a linha 11!</p>
<a class="header" href="print.html#adicionando-o-mÃ©todo-aprovar-que-muda-o-coportamento-do-conteudo" id="adicionando-o-mÃ©todo-aprovar-que-muda-o-coportamento-do-conteudo"><h3>Adicionando o mÃ©todo <code>aprovar</code> que muda o coportamento do <code>conteudo</code></h3></a>
<p>O mÃ©todo <code>aprovar</code> serÃ¡ semelhante ao mÃ©todo <code>solicitar_revisao</code>: ele
definirÃ¡ <code>estado</code> com um valor que o estado atual diz que deve ter quando esse
estado Ã© aprovado, como mostra a Listagem 17-16:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Postagem {
#     estado: Opcao&lt;Box&lt;Estado&gt;&gt;,
#     conteudo: String,
# }
#
impl Postagem {
    // --recorte--
    pub fn aprovar(&amp;mut self) {
        if let Some(s) = self.estado.take() {
            self.estado = Some(s.aprovar())
        }
    }
}

trait Estado {
    fn solicitar_revisao(self: Box&lt;Self&gt;) -&gt; Box&lt;Estado&gt;;
    fn aprovar(self: Box&lt;Self&gt;) -&gt; Box&lt;Estado&gt;;
}

struct Rascunho {}

impl Estado for Rascunho {
#     fn solicitar_revisao(self: Box&lt;Self&gt;) -&gt; Box&lt;Estado&gt; {
#         Box::new(RevisaoPendente {})
#     }
#
    // --recorte--
    fn aprovar(self: Box&lt;Self&gt;) -&gt; Box&lt;Estado&gt; {
        self
    }
}

struct RevisaoPendente {}

impl Estado for RevisaoPendente {
#     fn solicitar_revisao(self: Box&lt;Self&gt;) -&gt; Box&lt;Estado&gt; {
#         self
#     }
#
    // --recorte--
    fn aprovar(self: Box&lt;Self&gt;) -&gt; Box&lt;Estado&gt; {
        Box::new(Publicado {})
    }
}

struct Publicado {}

impl Estado for Publicado {
    fn solicitar_revisao(self: Box&lt;Self&gt;) -&gt; Box&lt;Estado&gt; {
        self
    }

    fn aprovar(self: Box&lt;Self&gt;) -&gt; Box&lt;Estado&gt; {
        self
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 17-16: Implementando o mÃ©todo <code>aprovar</code> no
<code>Postagem</code> e o trait <code>Estado</code></span></p>
<p>Adicionamos o mÃ©todo <code>aprovar</code> para o trait <code>Estado</code> e adicionamos uma nova estrutura que
implementa <code>Estado</code>, o estado <code>Publicado</code>.</p>
<p>Semelhante ao <code>solicitar_revisao</code>, se chamarmos o mÃ©todo <code>aprovar</code> no <code>Rascunho</code>, ele
nÃ£o terÃ¡ efeito, porque ele retornarÃ¡ <code>self</code>. Quando chamamos <code>aprovar</code> do
<code>RevisaoPendente</code>, ele retorna uma nova instÃ¢ncia em caixa da estrutura <code>Publicado</code>.
A estrutura <code>Publicado</code> implementa o trait <code>Estado</code> e, tanto para
o mÃ©todo <code>solicitar_revisao</code> quanto para o <code>aprovar</code>, ele retorna si prÃ³prio., porque
a postagem deve permanecer no estado <code>Publicado</code> nesses casos.</p>
<p>Agora, precisamos atualizar o mÃ©todo <code>conteudo</code> do <code>Postagem</code>: se o estado for
<code>Publicado</code>, queremos que retorne o valor do campo <code>conteudo</code> da publicaÃ§Ã£o;
caso contrÃ¡rio, queremos que retorne uma string vazia, como mostra a Listagem 17-17:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# trait Estado {
#     fn conteudo&lt;'a&gt;(&amp;self, post: &amp;'a Postagem) -&gt; &amp;'a str;
# }
# pub struct Postagem {
#     estado: Opcao&lt;Box&lt;Estado&gt;&gt;,
#     conteudo: String,
# }
#
impl Postagem {
    // --recorte--
    pub fn conteudo(&amp;self) -&gt; &amp;str {
        self.estado.as_ref().unwrap().conteudo(&amp;self)
    }
    // --recorte--
}
#}</code></pre></pre>
<p><span class="caption">Listagem 17-17: Atualizando o mÃ©todo <code>conteudo</code> do <code>Postagem</code> para
encarregar o mÃ©todo <code>conteudo</code> em <code>Estado</code></span></p>
<p>Porque o objetivo Ã© manter todos essas regras dentro das estruturas que implementam
<code>Estado</code>, chamamos o mÃ©todo <code>conteudo</code>no valor em <code>estado</code> e passamos a instÃ¢ncia
da postagem (que Ã©, <code>self</code>) como um argumento. EntÃ£o retornamos o valor que Ã©
retornado usando o mÃ©todo <code>conteudo</code> do valor do <code>estado</code>.</p>
<p>NÃ³s chamamos o mÃ©todo <code>as__ref</code> do <code>Opcao</code> porque queremos uma referÃªncia ao valor
do <code>Opcao</code> em vez da propriedade do valor. Como <code>estado</code>
Ã© um <code>Opcao&lt;Box&lt;Estado&gt;&gt;</code>, quando chamamos <code>as_ref</code>, um <code>Opcao&lt;Box&lt;Estado&gt;&gt;</code> Ã©
retornado. Se nÃ£o chamarmos <code>as__ref</code>, receberÃ­amos um erro,
porque nÃ£o podemos obter <code>estado</code> emprestado do <code>&amp;self</code> do parÃ¢metro da funÃ§Ã£o.</p>
<p>EntÃ£o chamamos o mÃ©todo <code>unwrap</code>, que sabemos que nunca vai entrar em pÃ¢nico, porque sabemos
que os mÃ©todos em <code>Postagem</code>garantem que o <code>estado</code> sempre conterÃ¡ um valor <code>Some</code>
quando esses mÃ©todos forem realizados. Esse Ã© um dos casos sobre os quais falamos na
seÃ§Ã£o &quot;Casos em que VocÃª Tem Mais InformaÃ§Ã£o Que o Compilador&quot; do CapÃ­tulo
9, quando sabemos que um valor <code>None</code> nunca Ã© possÃ­vel, mesmo que o compilador nÃ£o
consiga ententer isso.</p>
<p>Nesse momento, quando chamamos <code>conteudo</code> no <code>&amp;Box&lt;Estado&gt;</code>, a coerÃ§Ã£o deref terÃ¡
efeito no <code>&amp;</code> e no <code>Nox</code>, entÃ£o finalmente o mÃ©todo
<code>conteudo</code> Ã© chamado no tipo que implementa o trait <code>Estado</code>. Isso significa que precisamos adicionar
<code>conteudo</code> Ã  definiÃ§Ã£o do trait <code>Estado</code> e que Ã© onde colocaremos
a lÃ³gica de qual conteÃºdo retornar, dependendo do estado que temos, como mostra
a Listagem 17-18:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Postagem {
#     conteudo: String
# }
trait Estado {
    // --recorte--
    fn conteudo&lt;'a&gt;(&amp;self, post: &amp;'a Postagem) -&gt; &amp;'a str {
        &quot;&quot;
    }
}

// --recorte--
struct Publicado {}

impl Estado for Publicado {
    // --recorte--
    fn conteudo&lt;'a&gt;(&amp;self, post: &amp;'a Postagem) -&gt; &amp;'a str {
        &amp;post.conteudo
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 17-18: Adicionando o mÃ©todo <code>conteudo</code> ao trait
<code>Estado</code></span></p>
<p>Adicionamos uma implementaÃ§Ã£o padrÃ£o para o mÃ©todo <code>conteudo</code>, que retorna uma
string vazia. Isso significa que nÃ£o preciamos implementar <code>conteudo</code> nas estruturas <code>Rascunho</code> e
<code>RevisaoPendente</code>. A estrutura <code>Publicado</code> irÃ¡ sobrepor o mÃ©todo <code>conteudo</code>
e retornar o valor do <code>post.conteudo</code>.</p>
<p>Observe que precisamos anotaÃ§Ãµes de vida Ãºtil nesse mÃ©todo, como discutimos no
CapÃ­tulo 10. Estamos fazendo uma referÃªncia a um <code>post</code> como argumento e retornando uma
referÃªncia a parte desse <code>post</code>, entÃ£o o tempo de vida Ãºtil da referÃªncia retornada Ã©
relacionada ao tempo de vida Ãºtil do argumento <code>post</code>.</p>
<p>E estamos prontos - tudo da Listagem 17-11 agora funcionam! NÃ³s implementamos o padrÃ£o de estados
com as regras do fluxo de trabalho da postagem no blog. A lÃ³gica relacionada
Ã s regras vive nos objetos de estados, em vez de estar espalhada por todo o <code>Postagem</code>.</p>
<a class="header" href="print.html#vantagens-e-desvantagens-do-padrÃ£o-de-estados" id="vantagens-e-desvantagens-do-padrÃ£o-de-estados"><h3>Vantagens e desvantagens do padrÃ£o de estados</h3></a>
<p>Mostramos que o Rust Ã© capaz de implementar o padrÃ£o de estado orientaÃ§Ã£o a objetos
para encapsular os diferentes tipos de comportamentos que um post deve ter em
cada estado. Os mÃ©todos do <code>Postagem</code> nÃ£o sabem nada sobre os vÃ¡rios comportamentos. A
maneira como organizamos o cÃ³digo, nÃ³s sÃ³ temos de procurar num sÃ³ lugar pra conhecer as
diferentes formas como uma postagem pode comportar-se: a implementaÃ§Ã£o do trait <code>Estado</code>
na estrutura <code>Publicado</code>.</p>
<p>Se fÃ´ssemos criar uma implementaÃ§Ã£o alternativa que nÃ£o usasse o padrÃ£o
de estados, poderÃ­amos usar instruÃ§Ãµes <code>match</code> nos mÃ©todos do <code>Postagem</code> ou
mesmo no cÃ³digo <code>main</code>, que verifica o estado da postagem e muda o comportamento
nesses locais. Isso significaria que terÃ­amos que procurar em vÃ¡rios lugares para
entender todas as implicaÃ§Ãµes de uma postagem estar no estado publicado! Isso sÃ³
aumentaria o nÃºmero de estados que adicionamos: cada uma dessas instruÃ§Ãµes <code>match</code>
precisaria de outra ramificaÃ§Ã£o.</p>
<p>Com o padrÃ£o de de estados, os mÃ©todos de <code>Postagem</code> e os locais que usam <code>Postagem</code> nÃ£o
precisam da instruÃ§Ã£o <code>match</code> e para adicionar um novo estado, apenas precisamos adicionar uma nova estrutura e
implementar os mÃ©todos trait nessa estrutura.</p>
<p>A implementaÃ§Ã£o usando o padrÃ£o de estados Ã© fÃ¡cil de estender para adicionar mais
funcionalidades. Para ver a simplicidade de manter o cÃ³digo que usa padrÃ£o de
estados, tente usar essas sugestÃµes:</p>
<ul>
<li>Adicionar um mÃ©todo <code>reject</code> que altere o estado de postagem de <code>RevisaoPendente</code> de volta
para <code>Rascunho</code>.</li>
<li>Requer duas chamadas para <code>aprovar</code> antes que o estado possa ser alterado para <code>Publicado</code>.</li>
<li>Permitir que os usuÃ¡rios adicinem conteÃºdo de texto somente quando uma postagem estiver no estado <code>Rascunho</code>.
Dica: Ter o objeto de estado responsÃ¡vel pelo que pode mudar sobre o
conteÃºdo, mas nÃ£o responsÃ¡vel por modificar o <code>Postagem</code>.</li>
</ul>
<p>Uma desvantagem do padrÃ£o de estados Ã© que como os estados implementam as
transiÃ§Ãµes entre estados, alguns dos estados estÃ£o acoplados uns aos outros. Se adicionarmos
outros estados entre <code>RevisaoPendente</code> e <code>Publicado</code>, como um <code>Scheduled</code>,
terÃ­amos que mudar o cÃ³digo de <code>RevisaoPendente</code> para fazer a transiÃ§Ã£o para
<code>Scheduled</code>. Seria menos trabalhoso se <code>RevisaoPendente</code> nÃ£o precisasse de
mudanÃ§as com a adiÃ§Ã£o de um novo estado, mas isso significaria mudar para
outro padrÃ£o de projetos.</p>
<p>Outra desvantagem Ã© que nÃ³s duplicamos algumas lÃ³gicas. Para eleminar parte da
duplicaÃ§Ã£o, podemos tentar fazer a implementaÃ§Ã£o padrÃ£o dos mÃ©todos
<code>solicitar_revisao</code> e <code>aprovar</code> no trait <code>Estado</code>, que retorna <code>self</code>;
no entanto, isso violaria a seguranÃ§a dos objetos, porque o trait nÃ£o sabe
exatamente o que Ã© o <code>self</code> concreto. Queremos que seja possÃ­vel usar <code>Estado</code> como um
objeto trait, entao precisamos que seus mÃ©todos sejam objetos seguros.</p>
<p>Outra duplicaÃ§Ã£o inclui a implementaÃ§Ã£o semelhante dos mÃ©todos <code>solicitar_revisao</code>
e <code>aprovar</code> do <code>Postagem</code>. Ambos os mÃ©todos delegam a implementaÃ§Ã£o do
mesmo mÃ©todo sobre o valor do campo <code>estado</code> do <code>Opcao</code> e definem  o novo
valor do campo <code>estado</code> para o resultado. Se tivÃ©ssemos muitos mÃ©todos no <code>Postagem</code>
que seguissem  esse padrÃ£o, poderÃ­amos considerar a definiÃ§Ã£o de uma macro para eliminar
a repetiÃ§Ã£o (veja o ApÃªndice D, Macros).</p>
<p>Ao implementar o padrÃ£o de estados exatamente como ele Ã© definido para linguagens orientada a objetos,
nÃ£o estamos aproveitando ao mÃ¡ximo os pontos fortes do Rust como
poderÃ­amos. Vamos ver algumas mudanÃ§as que podemos fazer no o crate <code>blog</code>, que pode tornar
estados e transiÃ§Ãµes invÃ¡lidas em erros em tempo de compilaÃ§Ã£o.</p>
<a class="header" href="print.html#codificando-estados-e-comportamento-como-tipo" id="codificando-estados-e-comportamento-como-tipo"><h3>Codificando estados e comportamento como tipo</h3></a>
<p>Mostraremos como repensar o padrÃ£o de estados para obter um conjunto diferente de
compensaÃ§Ãµes. Em vez de encapsular completamente os estados e transiÃ§Ãµes para que o
cÃ³digo externo nÃ£o tenha conhecimento dele, codificaremos os estados em diferentes
tipos. Consequentemente, o sistema de verificaÃ§Ã£o de tipo do Rust impedirÃ¡ que as tentativas de usar
mensagens de rascunho, em que apenas as postagens publicadas sejam permitidas, emitem um erro do compilador.</p>
<p>Vamos considerar a primeira parte do <code>main</code> na Listagem 17-11:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let mut post = Postagem::new();

    post.add_texto(&quot;Eu comi uma salada no almoÃ§o de hoje&quot;);
    assert_eq!(&quot;&quot;, post.conteudo());
}
</code></pre>
<p>Ainda permitimos a criaÃ§Ã£o de novas postagens no estado de rascunho, usando <code>Postagem::new</code>
e a capacidade de adicionar texto ao conteÃºdo da postagem. Mas em vez de ter um
mÃ©todo <code>conteudo</code> em um rascunho, que retorna uma string vazia, vamos fazer com que as
mensagens de rascunho nÃ£o tenham o mÃ©todo <code>conteudo</code>. Dessa forma, se tentarmos pegar o
conteÃºdo de uma postagem de rascunho, receberemos um erro do compilador informando que o mÃ©todo
nÃ£o existe. Como resultado, serÃ¡ possÃ­vel exibir , acidentalmente,
o conteÃºdo do rascunho em produÃ§Ã£o, porque esse cÃ³digo nem serÃ¡ compilado.
Listagem 17-19 mostra a definiÃ§Ã£o de uma estrutura <code>Postagem</code>, uma estrutura <code>RascunhoPostagem</code> e
mÃ©todos em cada um deles:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Postagem {
    conteudo: String,
}

pub struct RascunhoPostagem {
    conteudo: String,
}

impl Postagem {
    pub fn new() -&gt; RascunhoPostagem {
        RascunhoPostagem {
            conteudo: String::new(),
        }
    }

    pub fn conteudo(&amp;self) -&gt; &amp;str {
        &amp;self.conteudo
    }
}

impl RascunhoPostagem {
    pub fn add_texto(&amp;mut self, text: &amp;str) {
        self.conteudo.push_str(text);
    }
}
#}</code></pre></pre>
<p><span class="caption">Arquivo 17-19: Uma <code>Postagem</code> com um mÃ©todo <code>conteudo</code>e um
<code>RascunhoPostagem</code> sem um mÃ©todo <code>conteudo</code></span></p>
<p>Ambas as estruturas <code>Postagem</code> e <code>RascunhoPostagem</code> tÃªm um campo <code>conteudo</code> privado, que
armazena o texto da postagem do blog. As estruturas nÃ£o tÃªm mais o campo <code>estado</code> porque
estamos movendo a codificaÃ§Ã£o do estado para os tipos de cada estrutura. A estrutura <code>Postagem</code>
representarÃ¡ uma postagem publicada e tem um mÃ©todo <code>conteudo</code> que
retorna o <code>conteudo</code>.</p>
<p>NÃ³s ainta temos uma funÃ§Ã£o <code>Postagem::new</code>, mas ao invÃ©s de retornar uma instÃ¢ncia de
<code>Postagem</code>, ela retorna uma instÃ¢ncia de <code>RascunhoPostagem</code>. Como <code>conteudo</code> Ã© privado
e nÃ£o hÃ¡ nenhuma funÃ§Ã£o que retorne <code>Postagem</code>, nÃ£o Ã© possÃ­vel criar uma
instÃ¢ncia de <code>Postagem</code> agora.</p>
<p>A estrutura <code>RascunhoPostagem</code> tem um mÃ©todo <code>add_texto</code> para que possamos adicionar texto ao <code>conteudo</code>
como antes, mas note que <code>RascunhoPostagem</code> nÃ£o possui um mÃ©todo <code>conteudo</code> definido!
EntÃ£o, agora, o programa garante que todas as postagens iniciem como rascunhos e, rascunho
nÃ£o tÃªm seu conteÃºdo disponÃ­vel para exibiÃ§Ã£o. Qualquer tentativa de contornar essas
restriÃ§Ãµes resultarÃ¡ em um erro de compilador.</p>
<a class="header" href="print.html#implementando-transaÃ§Ãµes-como-transformaÃ§Ãµes-em-diferentes-tipos" id="implementando-transaÃ§Ãµes-como-transformaÃ§Ãµes-em-diferentes-tipos"><h4>Implementando transaÃ§Ãµes como transformaÃ§Ãµes em diferentes tipos</h4></a>
<p>EntÃ£o, como conseguimos uma publicar uma postagem? Queremos impor a regra de que um
rascunho tenha de ser revisada e aprovada antes dela poder ser publicada. Uma postagem no estado de
revisÃ£o pendente ainda nÃ£o deve exibir nenhum conteÃºdo. Vamos implementar essas restriÃ§Ãµes
adicionando outra estrutura, <code>RevisaoPendentePostagem</code>, definindo o mÃ©todo
<code>solicitar_revisao</code> no <code>RascunhoPostagem</code> para retornar um <code>RevisaoPendentePostagem</code> e
definindo um mÃ©todo <code>aprovar</code> no <code>RevisaoPendentePostagem</code> para retornar um <code>Postagem</code>, como
mostra a Listagem 17-20:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Postagem {
#     conteudo: String,
# }
#
# pub struct RascunhoPostagem {
#     conteudo: String,
# }
#
impl RascunhoPostagem {
    // --recorte--

    pub fn solicitar_revisao(self) -&gt; RevisaoPendentePostagem {
        RevisaoPendentePostagem {
            conteudo: self.conteudo,
        }
    }
}

pub struct RevisaoPendentePostagem {
    conteudo: String,
}

impl RevisaoPendentePostagem {
    pub fn aprovar(self) -&gt; Postagem {
        Postagem {
            conteudo: self.conteudo,
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 17-20: Uma <code>RevisaoPendentePostagem</code> que Ã© criado
chamando <code>solicitar_revisao</code> no <code>RascunhoPostagem</code> e um mÃ©todo <code>aprovar</code> que transforma um
<code>RevisaoPendentePostagem</code> em um <code>Postagem</code> publicado</span></p>
<p>Os mÃ©todos <code>solicitar_revisao</code> e <code>aprovar</code> tomam posso do <code>self</code>, consumindo
as instÃ¢ncias <code>RascunhoPostagem</code> e <code>RevisaoPendentePostagem</code> e transformando-os
em <code>RevisaoPendentePostagem</code> e <code>Postagem</code> publicado respectivamente. Dessa forma,
nÃ£o teremos instÃ¢ncias <code>RascunhoPostagem</code> remanecentes apÃ³s chamarmos
<code>solicitar_revisao</code> e, assim por diante. A estrutura <code>RevisaoPendentePostagem</code> nÃ£o tem um mÃ©todo
<code>conteudo</code> definido dele, portanto, tentar ler seu conteÃºdo
resulta em um erro do compilador. como em <code>RascunhoPostagem</code>. Porque o Ãºnico modo de ter uma
instÃ¢ncia pÃºblica de <code>Postagem</code> que tenha um mÃ©todo <code>conteudo</code> definico Ã© chamar o
mÃ©todo <code>aprovar</code> em <code>RevisaoPendentePostagem</code> e a Ãºnica maneura de obter
<code>RevisaoPendentePostagem</code> Ã© chamar o mÃ©todo <code>solicitar_revisao</code> em <code>RascunhoPostagem</code>,
agora codificamos o fluxo de trabalho da postagem do blog em um sistema de tipos.</p>
<p>Mas tambÃ©m temos que fazer algumas pequenas mudanÃ§as no<code>main</code>. Os mÃ©todos <code>solicitar_revisao</code> e
<code>aprovar</code> retornam novas instÃ¢ncias em vez de modificar a estrutura para qual sÃ£o chamadas,
entÃ£o precisamos adicionar mais <code>let post</code> shadowing para salvar
as instÃ¢ncias retornadas. TambÃ©m nÃ£o temos certeza se o conteÃºdo do rascunho e da
postagem em revisÃ£o Ã© uma string vazia, nem precisamos delas: nÃ£o podemos
compilar cÃ³digo que tente usar o conteÃºdo da postagem nesses estados.
O cÃ³digo atualizado na <code>main</code> Ã© mostradp na Listagem 17-21:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate blog;
use blog::Postagem;

fn main() {
    let mut post = Postagem::new();

    post.add_texto(&quot;Eu comi uma salada no almoÃ§o de hoje&quot;);

    let post = post.solicitar_revisao();

    let post = post.aprovar();

    assert_eq!(&quot;Eu comi uma salada no almoÃ§o de hoje&quot;, post.conteudo());
}
</code></pre>
<p><span class="caption">Listagem 17-21: ModificaÃ§Ãµes na <code>main</code> para usar a nova
implementaÃ§Ã£o do fluxo de trabalho da psotagem no blog</span></p>
<p>As mudanÃ§as que precisamos fazer na <code>main</code>reatribuir <code>post</code>, o que significa que essa
implementaÃ§Ã£o nÃ£o segue mais o padrÃ£o de estados orientado a objetos:
as transformaÃ§Ãµes entre os estados nÃ£o sÃ£o mais encapsuladas inteiramente
dentro da implementaÃ§Ã£o do <code>Postagem</code>. No entanto, nosso ganho Ã© que estados invÃ¡lidos agora
sÃ£o impossÃ­veis por causa do sistema de tipos e a verificaÃ§Ã£o de tipos que acontecem em
tempo de compilaÃ§Ã£o! Isso garante que certos bugs, como o conteÃºdo de uma postagem
nÃ£o publicada sendo exibida, serÃ¡ descoberta antes de chegar em
produÃ§Ã£o.</p>
<p>Experimente as tarefas sugeridas como requisitos adicionais que mencionamos no
inÃ­cion dessa seÃ§Ã£o sobre o crate <code>blog</code> como estÃ¡ apÃ³s a Listagem 17-20 para ver
o que vocÃª acha sobre o design desta versÃ£o do cÃ³digo. Observe que algumas tarefas
podem ser concluÃ­das jÃ¡ neste design!</p>
<p>Vimos que, embora o Rust seja capas de implementar o padrÃ£o de projetos orientado a objetos,
outros padrÃµes, como codificar estados em sistema de tipos,
tambÃ©m estÃ£o disponÃ­veis. Esses padrÃµes tÃªm diferentes vantagens e desvantagens. Apesar
de vocÃª poder estar bastante familiarizado com o padrÃ£o orientado a objetos, repensar
o problema para aproveitar os recursos do Rust pode fornecer benefÃ­cios, como evitar
alguns bugs em tempo de compilaÃ§Ã£o. PadrÃµes orientados a objetos nem sempre serÃ£o a
melhor soluÃ§Ã£o em Rust devido certos recursos, como propriedade, que
as linguagens orientadas a objetos nÃ£o tÃªm.</p>
<a class="header" href="print.html#resumo-8" id="resumo-8"><h2>Resumo</h2></a>
<p>NÃ£o importa se vocÃª acha que Rust Ã© uma linguagem orientada a objetos depois
de ler este capÃ­tulo, vocÃª agora sabe que pode usar objetos trait para obter alguns
recursos orientado a objetos em Rust. O despacho dinÃ¢mico pode dar ao seu cÃ³digo alguma
flexibilidade em troca de um pouco de desempenho em tempo de execuÃ§Ã£o. VocÃª pode usar essa
flexibilidade para implementar padrÃ£o orientado a objetos que podem ajudar na manutenÃ§Ã£o
de seu cÃ³digo. Rust tambÃ©m tem outros recursos, como propriedade, que
linguagens orientadas aobjetos nÃ£o tÃªm. Um padrÃ£o orientado a objetos nem sempre
Ã© a melhor maneira de aproveitar os pontos fortes do Rust, mas Ã© uma opÃ§Ã£o disponÃ­vel.</p>
<p>Em seguida, veremos os padrÃµes, que sÃ£o outros dos recursos que permitem
muita flexibilidade. Veremos brevemente eles ao longo do livro, mas ainda nÃ£o vimos a capacidade total deles. Vamos lÃ¡!</p>
<a class="header" href="print.html#patterns" id="patterns"><h1>Patterns</h1></a>
<a class="header" href="print.html#more-lifetimes" id="more-lifetimes"><h1>More Lifetimes</h1></a>
<a class="header" href="print.html#advanced-type-system-features" id="advanced-type-system-features"><h1>Advanced Type System Features</h1></a>
<a class="header" href="print.html#appendix" id="appendix"><h1>Appendix</h1></a>
<a class="header" href="print.html#keywords" id="keywords"><h1>Keywords</h1></a>
<a class="header" href="print.html#operators" id="operators"><h1>Operators</h1></a>
<a class="header" href="print.html#derivable-traits" id="derivable-traits"><h1>Derivable Traits</h1></a>
<a class="header" href="print.html#nightly-rust" id="nightly-rust"><h1>Nightly Rust</h1></a>
<a class="header" href="print.html#macros" id="macros"><h1>Macros</h1></a>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if (getComputedStyle(document.querySelector(".fa")).fontFamily !== "FontAwesome") {
                var link = document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = '_FontAwesome/css/font-awesome.css';
                document.head.insertBefore(link, document.head.firstChild)
            }
        </script>

        

        

        

        
        <script>
            document.addEventListener('DOMContentLoaded', function() {
                window.print();
            })
        </script>
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
