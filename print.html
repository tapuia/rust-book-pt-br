<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title></title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme;
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            document.querySelector('html').classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="ch01-00-introduction.html"><strong aria-hidden="true">1.</strong> 🇧🇷 Introdução</a></li><li><ol class="section"><li><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> 🇧🇷 Instalação</a></li><li><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> 🇧🇷 Olá, Mundo!</a></li></ol></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> 🇧🇷 Jogo de Adivinhação</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> 🇧🇷 Conceitos Comuns de Programação</a></li><li><ol class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> 🇧🇷 Variáveis e Mutabilidade</a></li><li><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> 🇧🇷 Tipos de dados</a></li><li><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> 🇧🇷 Funções</a></li><li><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> 🇧🇷 Comentários</a></li><li><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> 🇧🇷 Controle de fluxo</a></li></ol></li><li><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> 🇧🇷 Entendendo Ownership</a></li><li><ol class="section"><li><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> 🇧🇷 O Que É Ownership?</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> 🇧🇷 Referências e Borrowing</a></li><li><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> 🇧🇷 Slices</a></li></ol></li><li><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> 🇧🇷 Structs</a></li><li><ol class="section"><li><a href="ch05-01-method-syntax.html"><strong aria-hidden="true">5.1.</strong> Method Syntax</a></li></ol></li><li><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> 🇧🇷 Enums e Casamento de Padrões</a></li><li><ol class="section"><li><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> 🇧🇷 Definindo uma Enum</a></li><li><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> 🇧🇷 Operador match</a></li><li><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> 🇧🇷 Controle de Fluxo Conciso com if let</a></li></ol></li><li><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> 🇧🇷 Módulos</a></li><li><ol class="section"><li><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> 🇧🇷 mod e o Sistema de Arquivos</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> 🇧🇷 Controlando a Visibilidade com pub</a></li><li><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> 🇧🇷 Importando nomes com use</a></li></ol></li><li><a href="ch08-00-fundamental-collections.html"><strong aria-hidden="true">8.</strong> Fundamental Collections</a></li><li><ol class="section"><li><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> 🇧🇷 Vetores</a></li><li><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> 🇧🇷 Strings</a></li><li><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> 🇧🇷 Hash Maps</a></li></ol></li><li><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> 🇧🇷 Tratamento de Erros</a></li><li><ol class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> 🇧🇷 Erros Irrecuperáveis com panic!</a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> 🇧🇷 Erros recuperáveis com Result</a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> 🇧🇷 Entrar em panic! ou Não Entrar em panic!</a></li></ol></li><li><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> 🇧🇷 Tipos Genéricos, Traits, e Tempos de vida (Lifetimes)</a></li><li><ol class="section"><li><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> 🇧🇷 Tipos Genéricos de Dados</a></li><li><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> 🇧🇷 Traits: Definindo Comportamento Compartilhado</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> 🇧🇷 Validating References with Lifetimes</a></li></ol></li><li><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Writing tests</a></li><li><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Running tests</a></li><li><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project</a></li><li><ol class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Improving Error Handling and Modularity</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Testing the Library's Functionality</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing to stderr instead of stdout</a></li></ol></li><li><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features in Rust</a></li><li><ol class="section"><li><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures</a></li><li><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Iterators</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving our I/O Project</a></li><li><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performance</a></li></ol></li><li><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Release Profiles</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> 🇧🇷 Ponteiros Inteligentes (Smart Pointers)</a></li><li><ol class="section"><li><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> 🇧🇷 Box<T> Aponta para Dados no Heap e Tem Tamanho Conhecido</a></li><li><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> 🇧🇷 Tratando Ponteiros Inteligentes como Referências Normais com a Trait Deref</a></li><li><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> 🇧🇷 A Trait Drop Roda Código durante a Limpeza</a></li><li><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> 🇧🇷 Rc<T>, o Ponteiro Inteligente com Contagem de Referências</a></li><li><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> 🇧🇷 RefCell<T> e a Pattern de Mutabilidade Interior</a></li><li><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> 🇧🇷 Ciclos de Referências Podem Vazar Memória</a></li></ol></li><li><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrency</a></li><li><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> 🇧🇷 Rust é uma linguagem orientada a objetos?</a></li><li><ol class="section"><li><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> 🇧🇷 O que significa orientado a objetos?</a></li><li><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> 🇧🇷 Usando objetos trait que permitem valores de tipos diferentes</a></li><li><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> 🇧🇷 Implementando um padrão de projeto orientado a objetos</a></li></ol></li><li><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns</a></li><li><a href="ch19-00-more-lifetimes.html"><strong aria-hidden="true">19.</strong> More Lifetimes</a></li><li><a href="ch20-00-advanced-types.html"><strong aria-hidden="true">20.</strong> Advanced Type System Features</a></li><li><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> Keywords</a></li><li><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> Operators</a></li><li><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> Derivable Traits</a></li><li><a href="appendix-04-nightly-rust.html"><strong aria-hidden="true">21.4.</strong> Nightly Rust</a></li><li><a href="appendix-05-macros.html"><strong aria-hidden="true">21.5.</strong> Macros</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="submenu">
                                <li><button class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li><button class="theme" id="rust">Rust</button></li>
                                <li><button class="theme" id="coal">Coal</button></li>
                                <li><button class="theme" id="navy">Navy</button></li>
                                <li><button class="theme" id="ayu">Ayu</button></li>
                            </ul>
                        </div>

                        <h1 class="menu-title"></h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="print.html#começando" id="começando"><h1>Começando</h1></a>
<p>Vamos começar a sua jornada Rust! Neste capítulo, nós iremos discutir:</p>
<ul>
<li>A instalação de Rust no Linux, Mac ou Windows</li>
<li>A escrita de um programa que imprime &quot;Hello, world!&quot; na tela</li>
<li>O uso do <code>cargo</code>, o gerenciador de pacote e sistema de compilação</li>
</ul>
<a class="header" href="print.html#instalação" id="instalação"><h2>Instalação</h2></a>
<p>O primeiro passo é instalar Rust. Nós vamos baixar Rust através do <code>rustup</code>,
uma ferramenta de linha de comando para gerenciar versões de Rust e ferramentas
associadas. Você vai precisar de uma conexão com a internet para executar o
download.</p>
<blockquote>
<p>Nota: se você prefere não usar o <code>rustup</code> por algum motivo, por favor veja o
<a href="https://www.rust-lang.org/tools/install">a página de instalação de Rust</a>
para outras opções.</p>
</blockquote>
<p>Os próximos passos irão instalar a última versão estável do compilador de Rust.
A garantias de estabilidade de Rust certificam-se de que todos os exemplos
neste livro que compilam vao continuar a compilar com novas versões de Rust.
As saídas podem variar um pouco de versão a versão, porque Rust frequentemente
melhora mensagens de erro e alertas. Em outras palavras, qualquer versão nova,
estável, de Rust qu você instalar usando esses passos devem funcionar como o
esperado com o conteúdo deste livro.</p>
<blockquote>
<a class="header" href="print.html#notação-de-linha-de-comando" id="notação-de-linha-de-comando"><h3>Notação de Linha de Comando</h3></a>
<p>Neste capítulo e ao longo do livro, nós iremos mostrar alguns comandos usados
no terminal. Linhas que você deve digitar num terminal todas começam com <code>$</code>.
Você não precisa digitar o caráctere <code>$</code>. Ele indica o início de cada comando.
Linhas que não comecem com <code>$</code> tipicamente mostram a saída do comando anterior.
Adicionalmente, exemplos específicos de PowerShell irão utilizar <code>&gt;</code> ao invés
de <code>$</code>.</p>
</blockquote>
<a class="header" href="print.html#instalando-rustup-em-linux-ou-mac" id="instalando-rustup-em-linux-ou-mac"><h3>Instalando <code>rustup</code> em Linux ou Mac</h3></a>
<p>Se você utiliza Linux ou Mac, abra um terminal e digite o seguinte comando:</p>
<pre><code class="language-text">$ curl https://sh.rustup.rs -sSf | sh
</code></pre>
<p>Este comando baixa um script e inicia a instalação da ferramenta <code>rustup</code>, a
qual instala a última versão estável de Rust. Talvez seja solicitado que você
digite sua senha. Se a instalação for bem-sucedida, a seguinte linha irá
aparecer:</p>
<pre><code class="language-text">Rust is installed now. Great!
</code></pre>
<p>Se preferir, sinta-se livre para baixar o script e inspecioná-lo antes de
executar.</p>
<p>O script de instalação adiciona automaticamente Rust à variável PATH do
seu ambiente após o seu próximo login. Se você quiser usar Rust imediatamente
ao invés de reiniciar o seu terminal, execute o seguinte comando no seu shell
para adicionar Rust à PATH do seu sistema manualmente:</p>
<pre><code class="language-text">$ source $HOME/.cargo/env
</code></pre>
<p>Outra opção é adicionar a linha abaixo ao seu <code>~/.bash_profile</code>:</p>
<pre><code class="language-text">$ export PATH=&quot;$HOME/.cargo/bin:$PATH&quot;
</code></pre>
<a class="header" href="print.html#instalando-no-windows" id="instalando-no-windows"><h3>Instalando no Windows</h3></a>
<p>No Windows, vá até <a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a> e siga
as instruções para instalar Rust. Em algum ponto da instalação, você receberá
uma mensagem explicando que você também irá precisar de ferramentas de
compilação de C++ para o Visual Studio 2013 ou superior. A forma mais fácil de
adquiri-las é instalando as <a href="https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2019">Ferramentas de Compilação para o Visual
Studio 2019</a>. As ferramentas estão na seção Other Tools and
Frameworks.</p>
<p>O restante deste livro utiliza comandos que funcionam tanto no <em>cmd.exe</em> quanto
no PowerShell. Se existirem diferenças específicas, nós iremos apontar qual
utilizar.</p>
<a class="header" href="print.html#atualizando-e-desinstalando" id="atualizando-e-desinstalando"><h3>Atualizando e desinstalando</h3></a>
<p>Após instalar Rust pelo <code>rustup</code>, atualizar para a última versão é fácil.
Do seu seu shell, rode o seguinte script de atualização:</p>
<pre><code class="language-text">$ rustup update
</code></pre>
<p>Para desinstalar Rust e o <code>rustup</code>, rode o seguinte script de desinstalação do
seu shell:</p>
<pre><code class="language-text">$ rustup self uninstall
</code></pre>
<a class="header" href="print.html#solução-de-problemas" id="solução-de-problemas"><h3>Solução de Problemas</h3></a>
<p>Para checar se você tem Rust instalado corretamente, abra um terminal e digite
esta linha:</p>
<pre><code class="language-text">$ rustc --version
</code></pre>
<p>Você deverá ver o número, o hash e a data do commit da última versão estável
lançada no seguinte formato:</p>
<pre><code class="language-text">rustc x.y.z (abcabcabc yyyy-mm-dd)
</code></pre>
<p>Se aparecer a mensagem acima, você instalou Rust com sucesso! Se você não ver
esta informação e você estiver no Windows, cheque que Rust está na sua variável
de ambiente <code>%PATH%</code>. Se tudo isso estiver correto e Rust ainda não funcionar,
existem vários locais em que você pode pedir ajuda. O mais fácil é o canal
#beginners no <a href="https://discord.gg/rust-lang">Discord oficial de Rust</a>. Lá, você pode falar com
outros Rustáceos (um apelido bobo que damos a nós mesmos) que podem te ajudar.
Outros ótimos recursos incluem <a href="https://users.rust-lang.org/">o fórum de usários</a> e o <a href="http://stackoverflow.com/questions/tagged/rust">Stack
Overflow</a>.</p>
<a class="header" href="print.html#documentação-local" id="documentação-local"><h3>Documentação local</h3></a>
<p>O instalador também inclui uma cópia local da documentação para que você possa
acessá-la offline. Execute o comando <code>rustup doc</code> para abrir a documentação no
seu navegador.</p>
<p>Sempre que um tipo ou for fornecido pela biblioteca padrão e você não tiver
certeza do que ele faz ou de como usá-lo, use a documentação da API para
descobrir!</p>
<!-- ## Hello, World!
<p>Now that you’ve installed Rust, let’s write your first Rust program. It’s
traditional when learning a new language to write a little program that prints
the text <code>Hello, world!</code> to the screen, so we’ll do the same here!</p>
<blockquote>
<p>Note: This book assumes basic familiarity with the command line. Rust makes
no specific demands about your editing or tooling or where your code lives, so
if you prefer to use an integrated development environment (IDE) instead of
the command line, feel free to use your favorite IDE. Many IDEs now have some
degree of Rust support; check the IDE’s documentation for details. Recently,
the Rust team has been focusing on enabling great IDE support, and progress
has been made rapidly on that front! --&gt;</p>
</blockquote>
<a class="header" href="print.html#olá-mundo" id="olá-mundo"><h2>Olá, Mundo!</h2></a>
<p>Agora que Rust já está instalado, vamos escrever seu primeiro programa Rust.
Quando aprendemos uma nova linguagem de programação, é tradicional escrever um
pequeno programa que imprime &quot;Olá, mundo!&quot; (<em>“Hello, world!”</em>) na tela, e vamos
fazer o mesmo aqui.</p>
<blockquote>
<p>Nota: Este livro assume que o leitor tem um pouco de familiaridade com a
linha de comando. Rust não faz nenhuma demanda a respeito do seu editor ou
ferramentas ou sobre onde seu código mora, então se você preferir usar uma
IDE ao invés da linha de comando, sinta-se livre para usar sua IDE favorita.
Muitas IDEs têm agora algum nível de suporte a Rust. Cheque  a documentação
da IDE para detalhes. Recentemente o time Rust tem focado em habilitar um
ótimo suporte a IDEs, e progresso tem sido rapidamente feito nesse front!</p>
</blockquote>
<!-- ### Creating a Project Directory
<p>You’ll start by making a directory to store your Rust code. It doesn’t matter
to Rust where your code lives, but for the exercises and projects in this book,
we suggest making a <em>projects</em> directory in your home directory and keeping all
your projects there.</p>
<p>Open a terminal and enter the following commands to make a <em>projects</em> directory
and a directory for the Hello, world! project within the <em>projects</em> directory.</p>
<p>For Linux, macOS, and PowerShell on Windows, enter this:</p>
<pre><code class="language-text">$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
</code></pre>
<p>For Windows CMD, enter this:</p>
<pre><code class="language-cmd">&gt; mkdir &quot;%USERPROFILE%\projects&quot;
&gt; cd /d &quot;%USERPROFILE%\projects&quot;
&gt; mkdir hello_world
&gt; cd hello_world
</code></pre>
<p>--&gt;</p>
<a class="header" href="print.html#criando-um-diretório-de-projeto" id="criando-um-diretório-de-projeto"><h3>Criando um Diretório de Projeto</h3></a>
<p>Você irá começar criando um diretório para guardar seu código Rust. Não importa
para Rust onde seu código vive, mas para os exercícios e projetos neste livro,
nós sugerimos criar um diretório <em>projects</em> no seu diretório principal e manter
todo o seus projetos lá.</p>
<p>Abra um terminal e digite os seguintes comandos para criar um diretório
<em>projects</em> e um diretório para o projeto &quot;Hello, world!&quot; dentro do diretório
<em>projects</em>.</p>
<p>Para Linux, macOS, e PowerShell no Windows, digite o seguinte:</p>
<pre><code class="language-text">$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
</code></pre>
<p>No CMD do Windows, digite o seguinte:</p>
<pre><code class="language-cmd">&gt; mkdir &quot;%USERPROFILE%\projects&quot;
&gt; cd /d &quot;%USERPROFILE%\projects&quot;
&gt; mkdir hello_world
&gt; cd hello_world
</code></pre>
<!-- ### Writing and Running a Rust Program
<p>Next, make a new source file and call it <em>main.rs</em>. Rust files always end with
the <em>.rs</em> extension. If you’re using more than one word in your filename, use
an underscore to separate them. For example, use <em>hello_world.rs</em> rather than
<em>helloworld.rs</em>.</p>
<p>Now open the <em>main.rs</em> file you just created and enter the code in Listing 1-1.</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p><span class="caption">Listing 1-1: A program that prints <code>Hello, world!</code></span></p>
<p>Save the file and go back to your terminal window. On Linux or macOS, enter
the following commands to compile and run the file:</p>
<pre><code class="language-text">$ rustc main.rs
$ ./main
Hello, world!
</code></pre>
<p>On Windows, enter the command <code>.\main.exe</code> instead of <code>./main</code>:</p>
<pre><code class="language-powershell">&gt; rustc main.rs
&gt; .\main.exe
Hello, world!
</code></pre>
<p>Regardless of your operating system, the string <code>Hello, world!</code> should print to
the terminal. If you don’t see this output, refer back to the
<a href="ch01-01-installation.html#troubleshooting">“Troubleshooting”</a> part of the Installation
section for ways to get help.</p>
<p>If <code>Hello, world!</code> did print, congratulations! You’ve officially written a Rust
program. That makes you a Rust programmer—welcome! --&gt;</p>
<a class="header" href="print.html#escrevendo-e-executando-um-programa-rust" id="escrevendo-e-executando-um-programa-rust"><h3>Escrevendo e Executando um Programa Rust</h3></a>
<p>Crie um novo arquivo <em>main.rs</em>. Arquivos Rust sempre terminam com a extensão
<em>.rs</em>. Se o nome do seu arquivo tem mais de uma palavra, use um <em>underscore</em>
para separá-los. Por exemplo, você deve nomear o seu arquivo <em>hello_world.rs</em>
em vez de <em>helloworld.rs</em>.</p>
<p>Agora abra o arquivo <em>main.rs</em> que você acabou de criar e digite o código na
Listagem 1-1:</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p><span class="caption">Listagem 1-1: Um programa que imprime <code>Hello, world!</code></span></p>
<p>Salve o arquivo e volte ao seu terminal. No Linux ou macOS, digite os seguintes
comandos para compilar e rodar o arquivo:</p>
<pre><code class="language-text">$ rustc main.rs
$ ./main
Hello, world!
</code></pre>
<p>No Windows, digite o comando <code>.\main.exe</code> ao invés de <code>./main</code>:</p>
<pre><code class="language-powershell">&gt; rustc main.rs
&gt; .\main.exe
Hello, world!
</code></pre>
<p>Independente do seu sistema operacional, você deverá ver a mensagem
<code>Hello, world!</code> no seu terminal. Se você não ver essa mensagem, volte à parte
<a href="ch01-01-installation.html#troubleshooting">“Troubleshooting”</a> da seção &quot;Instalação&quot; sobre formas de
obter ajuda.</p>
<p>Se <code>Hello, world!</code> apareceu, parabéns! Você oficialmente escreveu um programa
Rust. Isso faz de você um programador Rust! Seja bem-vindo!</p>
<!-- ### Anatomy of a Rust Program
<p>Let’s review in detail what just happened in your Hello, world! program.
Here’s the first piece of the puzzle:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {

}
</code></pre></pre>
<p>These lines define a function in Rust. The <code>main</code> function is special: it is
always the first code that runs in every executable Rust program. The first
line declares a function named <code>main</code> that has no parameters and returns
nothing. If there were parameters, they would go inside the parentheses, <code>()</code>. --&gt;</p>
<a class="header" href="print.html#anatomia-de-um-programa-em-rust" id="anatomia-de-um-programa-em-rust"><h3>Anatomia de um Programa em Rust</h3></a>
<p>Agora vamos ver o que aconteceu com o seu programa &quot;Hello, world!&quot; em detalhes.
Aqui está a primeira peça do quebra-cabeça:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {

}
</code></pre></pre>
<p>Estas linhas definem uma função em Rust. A função <code>main</code> é especial: ela é
sempre o primeiro código a ser executado em todo programa executável Rust.
A primeira linha declara uma função chamada <code>main</code> que não tem nenhum parâmetro
e não retorna nada. Se houvessem parâmetros, eles seriam inseridos dentro dos
parênteses, <code>()</code>.</p>
<!-- 
Also, note that the function body is wrapped in curly brackets, `{}`. Rust
requires these around all function bodies. It’s good style to place the opening
curly bracket on the same line as the function declaration, adding one space in
between.
<p>At the time of this writing, an automatic formatter tool called <code>rustfmt</code> is
under development. If you want to stick to a standard style across Rust
projects, <code>rustfmt</code> will format your code in a particular style. The Rust team
plans to eventually include this tool with the standard Rust distribution, like
<code>rustc</code>. So depending on when you read this book, it might already be installed
on your computer! Check the online documentation for more details.</p>
<p>Inside the <code>main</code> function is the following code:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    println!(&quot;Hello, world!&quot;);
``` --&gt;

Também, note que o corpo da função é envolvido em chaves, `{}`. Rust as requer
ao redor de todos os corpos de função. É boa prática colocar a chave de
abertura na mesma linha que a declaração da função, adicionando um espaço entre
elas.

No momento desta escrita, uma ferramenta de formatação automática chamada
`rustfmt` está sendo desenvolvida. Se você quiser se ater a um estilo padrão
através de projetos Rust, `rustfmt` irá formatar seu código num estilo
particular. O time Rust planeja eventualmente incluir esta ferramenta com a
distribuição padrão de Rust, assim como o `rustc`. Então dependendo de quando
você ler este livro, ela pode já estar instalada no seu computador! Cheque a
documentação online para mais detalhes.

Dentro da função `main` está o seguinte código:

```rust
    println!(&quot;Hello, world!&quot;);
#}</code></pre></pre>
<!-- This line does all the work in this little program: it prints text to the
screen. There are four important details to notice here. First, Rust style is
to indent with four spaces, not a tab.
<p>Second, <code>println!</code> calls a Rust macro. If it called a function instead, it
would be entered as <code>println</code> (without the <code>!</code>). We’ll discuss Rust macros in
more detail in Chapter 19. For now, you just need to know that using a <code>!</code>
means that you’re calling a macro instead of a normal function.</p>
<p>Third, you see the <code>&quot;Hello, world!&quot;</code> string. We pass this string as an argument
to <code>println!</code>, and the string is printed to the screen.</p>
<p>Fourth, we end the line with a semicolon (<code>;</code>), which indicates that this
expression is over and the next one is ready to begin. Most lines of Rust code
end with a semicolon. --&gt;</p>
<p>Esta linha faz todo o trabalho neste pequeno programa: ela imprime texto na
tela. Há quatro detalhes importantes a se notar aqui. Primeiro, o estilo Rust
é indentar com quatro espaços, não com uma tabulação (tab).</p>
<p>Em segundo, <code>println!</code> chama uma macro Rust. Se ele chamasse uma função ao
invés disso, ele seria escrito como <code>println</code> (sem a <code>!</code>). Nós iremos discutir
macros Rust em mais detalhes no capítulo 19. Por agora, você só precisa saber
que usar uma <code>!</code> significa que você está chamando uma macro ao invés de uma
função normal.</p>
<p>Em terceiro, você vê a string <code>&quot;Hello, world!&quot;</code>. Nós passamos essa string como
um argumento para o <code>println!</code>, e a string é impressa na tela.</p>
<p>Em quarto, nós terminamos a linha com um ponto e vírgula (<code>;</code>), que indica que
essa expressão terminou e a próxima está pronta para começar. A maioria das
linhas de Rust terminam com um ponto e vírgula.</p>
<!-- ### Compiling and Running Are Separate Steps
<p>You’ve just run a newly created program, so let’s examine each step in the
process.</p>
<p>Before running a Rust program, you must compile it using the Rust compiler by
entering the <code>rustc</code> command and passing it the name of your source file, like
this:</p>
<pre><code class="language-text">$ rustc main.rs
</code></pre>
<p>If you have a C or C++ background, you’ll notice that this is similar to <code>gcc</code>
or <code>clang</code>. After compiling successfully, Rust outputs a binary executable.</p>
<p>On Linux, macOS, and PowerShell on Windows, you can see the executable by
entering the <code>ls</code> command in your shell. On Linux and macOS, you’ll see two
files. With PowerShell on Windows, you’ll see the same three files that you
would see using CMD.</p>
<pre><code class="language-text">$ ls
main  main.rs
``` --&gt;

### Compilação e Execução São Etapas Diferentes

Você acabou de rodar um programa récem-criado, então vamos analisar cada etapa
no processo.

Antes de rodar um programa Rust, você deve compilá-lo usando o compilador Rust
ao digitar o comando `rustc` e passar a ele o nome do arquivo fonte, desta
forma:

```text
$ rustc main.rs
</code></pre>
<p>Se você tem experiência em C ou C++, vocẽ irá notar que isso é similar ao <code>gcc</code>
ou ao <code>clang</code>. Depois de compilar com sucesso, Rust produz um executável
binário.</p>
<p>Em Linux, macOS, e PowerShell no Windows, você pode ver o executável ao entrar
o comando <code>ls</code> no seu shell. Em Linux e macOS, você irá ver dois arquivos. No
PowerShell no Windows, você irá ver os mesmos três arquivos que você veria
usando CMD.</p>
<pre><code class="language-text">$ ls
main  main.rs
</code></pre>
<p>No CMD no Windows, você digitaria o seguinte:</p>
<pre><code class="language-cmd">&gt; dir /B %= the /B option says to only show the file names =%
main.exe
main.pdb
main.rs
</code></pre>
<p>Isto mostra o código fonte com a extensão <em>.rs</em>, o arquivo executável (
<em>main.exe</em> no Windows, mas <em>main</em> em todas as outras plataformas), e, usando
Windows, um arquivo contendo informação de debugging com a extensão <em>.pdb</em>.
Daqui, você roda os arquivos <em>main</em> ou <em>main.exe</em>, da seguinte forma:</p>
<pre><code class="language-text">$ ./main # or .\main.exe on Windows
</code></pre>
<p>Se <em>main.rs</em> era o seu programa &quot;Hello, world!&quot;, esta linha irá imprimir
<code>Hello, world!</code> no seu terminal.</p>
<!-- 
If you’re more familiar with a dynamic language, such as Ruby, Python, or
JavaScript, you might not be used to compiling and running a program as
separate steps. Rust is an *ahead-of-time compiled* language, meaning you can
compile a program and give the executable to someone else, and they can run it
even without having Rust installed. If you give someone a *.rb*, *.py*, or
*.js* file, they need to have a Ruby, Python, or JavaScript implementation
installed (respectively). But in those languages, you only need one command to
compile and run your program. Everything is a trade-off in language design.
<p>Just compiling with <code>rustc</code> is fine for simple programs, but as your project
grows, you’ll want to manage all the options and make it easy to share your
code. Next, we’ll introduce you to the Cargo tool, which will help you write
real-world Rust programs.</p>
<p><a href="ch01-01-installation.html#troubleshooting">troubleshooting</a>: ch01-01-installation.html#troubleshooting --&gt;</p>
<p>Se você é mais familiar com uma linguagem dinâmica, como Ruby, Python, ou
Javascript, você pode não estar acostumado a compilar e rodar um programa como
etapas separadas. Rust é uma linguagem compilada <em>ahead of time</em>
(antecipadamente), o que significa que você pode compilar um programa e dar o
executável para outra pessoa, e ela pode rodar o programa mesmos sem ter Rust
instalada. Se você der a alguém um arquivo <em>.rb</em>, <em>.py</em>, ou <em>.js</em>, ela irá
precisar ter uma implementação de Ruvy, Python, ou Javascript instaladas
respectivamente. Mas nessas linguagens, você apenas precisa de um comando
para compilar e rodar seu programa. Tudo é um trade-off no projeto de
linguagens.</p>
<p>Apenas compilando com <code>rustc</code> é ok para programas simples, mas quando seu
projeto crescer, você pode querer gerenciar todas as opções e tornar fácil
compartilhar seu código. Em seguida, nós iremos introduzir à ferramenta Cargo,
que irá ajudá-lo a escrever programas Rust reais.</p>
<a class="header" href="print.html#jogo-de-adivinhação" id="jogo-de-adivinhação"><h1>Jogo de Adivinhação</h1></a>
<p>Vamos entrar de cabeça no Rust e colocar a mão na massa! Este capítulo vai lhe
apresentar alguns conceitos bem comuns no Rust, mostrando como usá-los em um
programa de verdade. Você vai aprender sobre <code>let</code>, <code>match</code>, métodos, funções
associadas, crates externos, e mais! Os capítulos seguintes vão explorar essas
ideias em mais detalhes. Neste capítulo, você vai praticar o básico.</p>
<p>Vamos implementar um clássico problema de programação para iniciantes: um jogo
de adivinhação. Eis como ele funciona: o programa vai gerar um número inteiro
aleatório entre 1 e 100. Então, ele vai pedir ao jogador que digite um palpite.
Após darmos nosso palpite, ele vai nos indicar se o palpite é muito baixo ou
muito alto. Uma vez que o palpite estiver correto, ele vai nos dar os parabéns e
sair.</p>
<a class="header" href="print.html#preparando-um-novo-projeto" id="preparando-um-novo-projeto"><h2>Preparando um Novo Projeto</h2></a>
<p>Para iniciar um novo projeto, vá ao seu diretório de projetos que você criou no
Capítulo 1, e execute os comandos do Cargo a seguir:</p>
<pre><code class="language-text">$ cargo new jogo_de_advinhacao --bin
$ cd jogo_de_advinhacao
</code></pre>
<p>O primeiro comando, <code>cargo new</code>, recebe o nome do projeto (<code>jogo_de_advinhacao</code>)
como primeiro argumento. A flag <code>--bin</code> diz ao Cargo que faça um projeto
binário, similar ao do Capítulo 1. O segundo comando muda a pasta atual para o
diretório do projeto.</p>
<p>Confira o arquivo <em>Cargo.toml</em> gerado:</p>
<p><span class="filename">Arquivo: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;jogo_de_advinhacao&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Seu Nome &lt;voce@exemplo.com&gt;&quot;]

[dependencies]
</code></pre>
<p>Se as informações sobre o autor, que o Cargo obtém do seu ambiente, não
estiverem corretas, faça os reparos necessários e salve o arquivo.</p>
<p>Assim como no Capítulo 1, <code>cargo new</code> gera um programa &quot;Hello, world!&quot; para nós.
Confira em <em>src/main.rs</em>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Agora vamos compilar esse programa &quot;Hello, world!&quot; e executá-lo de uma vez só
usando o comando <code>cargo run</code>:</p>
<pre><code class="language-text">$ cargo run
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50 secs
     Running `target/debug/jogo_de_advinhacao`
Hello, world!
</code></pre>
<p>O comando <code>run</code> é uma boa opção quando precisamos iterar rapidamente em um
projeto, que é o caso neste jogo: nós queremos testar rapidamente cada iteração
antes de movermos para a próxima.</p>
<p>Abra novamente o arquivo <em>src/main.rs</em>. Escreveremos todo nosso código nele.</p>
<a class="header" href="print.html#processando-um-palpite" id="processando-um-palpite"><h2>Processando um Palpite</h2></a>
<p>A primeira parte do programa vai pedir uma entrada ao usuário, processar essa
entrada, e conferir se ela está no formato esperado. Pra começar, vamos permitir
que o jogador entre com um palpite. Coloque este código no arquivo
<em>src/main.rs</em>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;

fn main() {
    println!(&quot;Advinhe o número!&quot;);

    println!(&quot;Digite o seu palpite.&quot;);

    let mut palpite = String::new();

    io::stdin().read_line(&amp;mut palpite)
        .expect(&quot;Falha ao ler entrada&quot;);

    println!(&quot;Você disse: {}&quot;, palpite);
}
</code></pre>
<p><span class="caption">Listagem 2-1: Código para ler um palpite do usuário e
imprimí-lo na tela.</span></p>
<p>Esse código tem muita informação, vamos ver uma parte de cada vez. Para obter a
entrada do usuário, e então imprimir o resultado como saída, precisaremos trazer
ao escopo a biblioteca <code>io</code> (de entrada/saída). A biblioteca <code>io</code> provém da
biblioteca padrão (chamada de <code>std</code>):</p>
<pre><code class="language-rust ignore">use std::io;
</code></pre>
<p>Por padrão, o Rust traz apenas alguns tipos para o escopo de todos os programas
no <a href="../../std/prelude/index.html"><em>prelúdio</em></a><!-- ignore -->. Se um tipo que você quiser usar não
estiver no prelúdio, você terá que importá-lo explicitamente através do <code>use</code>.
A biblioteca <code>std::io</code> oferece várias ferramentas de entrada/saída, incluindo a
funcionalidade de ler dados de entrada do usuário.</p>
<p>Como visto no Capítulo 1, a função <code>main</code> é o ponto de entrada do programa:</p>
<pre><code class="language-rust ignore">fn main() {
</code></pre>
<p>A sintaxe <code>fn</code> declara uma nova função, o <code>()</code> indica que não há parâmetros, e
o <code>{</code> inicia o corpo da função.</p>
<p>Como você também já aprendeu no Capítulo 1, <code>println!</code> é uma macro que imprime
uma string na tela:</p>
<pre><code class="language-rust ignore">println!(&quot;Advinhe o número!&quot;);

println!(&quot;Digite o seu palpite.&quot;);
</code></pre>
<p>Este código está exibindo uma mensagem que diz de que se trata o jogo e solicita
uma entrada do usuário.</p>
<a class="header" href="print.html#armazenando-valores-em-variáveis" id="armazenando-valores-em-variáveis"><h3>Armazenando Valores em Variáveis</h3></a>
<p>Próximo passo, vamos criar um local para armazenar a entrada do usuário:</p>
<pre><code class="language-rust ignore">let mut palpite = String::new();
</code></pre>
<p>Agora o programa está ficando interessante! Tem muita coisa acontecendo nesta
pequena linha. Repare que esta é uma declaração <code>let</code>, que é usada para criar
<em>variáveis</em>. Segue outro exemplo:</p>
<pre><code class="language-rust ignore">let foo = bar;
</code></pre>
<p>Essa linha cria uma nova variável chamada <code>foo</code>, e a vincula ao valor <code>bar</code>. Em
Rust, variáveis são imutáveis por padrão. O exemplo a seguir mostra como usar
<code>mut</code> antes do nome da variável para torná-la mutável:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let foo = 5; // imutável
let mut bar = 5; // mutável
#}</code></pre></pre>
<blockquote>
<p>Nota: A sintaxe <code>//</code> inicia um comentário, que continua até o fim da linha.
Rust ignora tudo o que estiver nos comentários.</p>
</blockquote>
<p>Agora você sabe que <code>let mut palpite</code> vai introduzir uma variável mutável de
nome <code>palpite</code>. No outro lado do símbolo <code>=</code> está o valor ao qual <code>palpite</code> está
vinculado, que é o resultado da chamada <code>String::new</code>, uma função que retorna
uma nova instância de <code>String</code>. <a href="../../std/string/struct.String.html"><code>String</code></a><!-- ignore --> é um tipo
fornecido pela biblioteca padrão que representa uma cadeia expansível de
caracteres codificados em UTF-8.</p>
<p>A sintaxe <code>::</code> na linha <code>::new</code> indica que <code>new</code> é uma <em>função associada</em> do
tipo <code>String</code>. Uma função associada é implementada sobre um tipo, neste caso
<code>String</code>, em vez de uma instância particular de <code>String</code>. Algumas linguagens
dão a isso o nome <em>método estático</em>.</p>
<p>Esta função <code>new()</code> cria uma nova <code>String</code> vazia. Você encontrará uma função
<code>new()</code> em muitos tipos, já que é um nome comum para uma função que produz um
novo valor de algum tipo.</p>
<p>Para resumir, a linha <code>let mut palpite = String::new();</code> criou uma variável
mutável que está atualmente vinculada a uma nova instância vazia de uma
<code>String</code>. Ufa!</p>
<p>Lembre-se de que incluímos a funcionalidade de entrada/saída da biblioteca
padrão por meio do <code>use std::io;</code> na primeira linha do programa. Agora vamos
chamar uma função associada, <code>stdin</code>, em <code>io</code>:</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut palpite)
    .expect(&quot;Falha ao ler entrada&quot;);
</code></pre>
<p>Se não tivéssemos a linha <code>use std::io</code> no início do programa, poderíamos ter
escrito esta chamada como <code>std::io::stdin</code>. A função <code>stdin</code> retorna uma
instância de <a href="../../std/io/struct.Stdin.html"><code>std::io::Stdin</code></a><!-- ignore -->, um tipo que representa
um manipulador (<em>handle</em>) da entrada padrão do seu terminal.</p>
<p>A próxima parte do código, <code>.read_line(&amp;mut palpite)</code>, chama o método
<a href="../../std/io/struct.Stdin.html#method.read_line"><code>read_line</code></a><!-- ignore --> do <em>handle</em> da entrada padrão para obter
entrada do usuário. Também estamos passando um argumento para <code>read_line</code>:
<code>&amp;mut palpite</code>.</p>
<p>O trabalho da função <code>read_line</code> é receber o que o usuário digita na entrada
padrão e colocar isso numa string, por isso ela recebe essa string como
argumento. A string do argumento deve ser mutável para que o método consiga
alterar o seu conteúdo, adicionando a entrada do usuário.</p>
<p>O símbolo <code>&amp;</code> indica que o argumento é uma <em>referência</em>, o que permite múltiplas
partes do seu código acessar um certo dado sem precisar criar várias cópias dele
na memória. Referências são uma característica complexa, e uma das maiores
vantagens do Rust é o quão fácil e seguro é usar referências. Você não precisa
conhecer muitos desses detalhes para finalizar esse programa. O Capítulo 4 vai
explicar sobre referências de forma mais aprofundada. Por enquanto, tudo que
você precisa saber é que, assim como as variáveis, referências são imutáveis por
padrão. Por isso, precisamos escrever <code>&amp;mut palpite</code>, em vez de apenas
<code>&amp;palpite</code>, para fazer com que o palpite seja mutável.</p>
<p>Ainda não finalizamos completamente esta linha de código. Embora esta seja uma
única linha de texto, é apenas a primeira parte de uma linha lógica de código. A
segunda parte é a chamada para este método:</p>
<pre><code class="language-rust ignore">.expect(&quot;Falha ao ler entrada&quot;);
</code></pre>
<p>Quando você chama um método com a sintaxe <code>.foo()</code>, geralmente é bom introduzir
uma nova linha e outro espaço para ajudar a dividir linhas muito compridas.
Poderíamos ter feito assim:</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut palpite).expect(&quot;Falha ao ler entrada&quot;);
</code></pre>
<p>Porém, uma linha muito comprida fica difícil de ler. Então é melhor dividirmos a
linha em duas, uma para cada método chamado. Agora vamos falar sobre o que essa
linha faz.</p>
<a class="header" href="print.html#tratando-potenciais-falhas-com-o-tipo-result" id="tratando-potenciais-falhas-com-o-tipo-result"><h3>Tratando Potenciais Falhas com o Tipo <code>Result</code></h3></a>
<p>Como mencionado anteriormente, <code>read_line</code> coloca o que o usuário escreve dentro
da string que passamos como argumento, mas também retorna um valor - neste
caso, um <a href="../../std/io/type.Result.html"><code>io::Result</code></a><!-- ignore -->. Rust tem uma variedade de
tipos com o nome <code>Result</code> em sua biblioteca padrão: um <a href="../../std/result/enum.Result.html"><code>Result</code></a>
genérico e as versões específicas dos submódulos, como <code>io::Result</code>.</p>
<p>Os tipos <code>Result</code> são <a href="ch06-00-enums.html"><em>enumerações</em></a><!-- ignore -->, comumente chamadas
de <em>enums</em>. Uma enumeração é um tipo que pode ter um conjunto fixo de valores,
os quais são chamados de <em>variantes</em> da enum. O Capítulo 6 vai abordar enums em
mais detalhes.</p>
<p>Para <code>Result</code>, as variantes são <code>Ok</code> ou <code>Err</code>. <code>Ok</code> indica que a operação teve
sucesso, e dentro da variante <code>Ok</code> está o valor resultante. <code>Err</code> significa que
a operação falhou, e contém informações sobre como ou por que isso ocorreu.</p>
<p>O propósito destes tipos <code>Result</code> é codificar informações de manipulação de
erros. Valores do tipo <code>Result</code>, assim como qualquer tipo, possuem métodos
definidos. Uma instância de <code>io::Result</code> tem um <a href="../../std/result/enum.Result.html#method.expect">método <code>expect</code></a><!-- ignore -->
que você pode chamar. Se esta instância de <code>io::Result</code> é um <code>Err</code>, <code>expect</code> vai
terminar o programa com erro e mostrar a mensagem que você passou como argumento
ao <code>expect</code>. Se o método <code>read_line</code> retornar um <code>Err</code>, provavelmente seria o
resultado de um erro vindo do sistema operacional que está por trás. Se esta
instância de <code>io::Result</code> é um <code>Ok</code>, <code>expect</code> vai obter o valor contido no <code>Ok</code>
e retorná-lo para que você possa usá-lo. Neste caso, o valor é o número de bytes
dos dados que o usuário inseriu através da entrada padrão.</p>
<p>Se não chamarmos <code>expect</code>, nosso programa vai compilar, mas vamos ter um aviso:</p>
<pre><code class="language-text">$ cargo build
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
warning: unused `std::result::Result` which must be used
  --&gt; src/main.rs:10:5
   |
10 |     io::stdin().read_line(&amp;mut palpite);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: #[warn(unused_must_use)] on by default
</code></pre>
<p>Rust avisa que não usamos o valor <code>Result</code>, retornado por <code>read_line</code>, indicando
que o programa deixou de tratar um possível erro. A maneira correta de suprimir
o aviso é realmente escrevendo um tratador de erro, mas como queremos que o
programa seja encerrado caso ocorra um problema, podemos usar <code>expect</code>. Você
aprenderá sobre recuperação de erros no Capítulo 9.</p>
<a class="header" href="print.html#exibindo-valores-com-curingas-do-println" id="exibindo-valores-com-curingas-do-println"><h3>Exibindo Valores com Curingas do <code>println!</code></h3></a>
<p>Tirando a chave que delimita a função <code>main</code>, há apenas uma linha mais a ser
discutida no código que fizemos até agora, que é a seguinte:</p>
<pre><code class="language-rust ignore">println!(&quot;Você disse: {}&quot;, guess);
</code></pre>
<p>Esta linha imprime a string na qual salvamos os dados inseridos pelo usuário. O
<code>{}</code> é um curinga que reserva o lugar de um valor. Você pode imprimir mais de um
valor usando <code>{}</code>: o primeiro conjunto de <code>{}</code> guarda o primeiro valor listado
após a string de formatação, o segundo conjunto guarda o segundo valor, e
assim por diante. Imprimir múltiplos valores em uma só chamada a <code>println!</code>
seria assim:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
let y = 10;

println!(&quot;x = {} e y = {}&quot;, x, y);
#}</code></pre></pre>
<p>Esse código imprime <code>x = 5 e y = 10</code>.</p>
<a class="header" href="print.html#testando-a-primeira-parte" id="testando-a-primeira-parte"><h3>Testando a Primeira Parte</h3></a>
<p>Vamos testar a primeira parte do jogo de advinhação. Você pode executá-lo usando
<code>cargo run</code>:</p>
<pre><code class="language-text">$ cargo run
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
     Running `target/debug/jogo_de_advinhacao`
Advinhe o número!
Digite o seu palpite.
6
Você disse: 6
</code></pre>
<p>Nesse ponto, a primeira parte do jogo está feita: podemos coletar entrada do
teclado e mostrá-la na tela.</p>
<a class="header" href="print.html#gerando-um-número-secreto" id="gerando-um-número-secreto"><h2>Gerando um Número Secreto</h2></a>
<p>A seguir, precisamos gerar um número secreto que o usuário vai tentar advinhar.
O número secreto deve ser diferente a cada execução, para que o jogo tenha graça
em ser jogado mais de uma vez. Vamos usar um número aleatório entre 1 e 100,
para que o jogo não seja tão difícil. Rust ainda não inclui uma funcionalidade
de geração de números aleatórios em sua biblioteca padrão. Porém, a equipe Rust
fornece um <a href="https://crates.io/crates/rand">crate <code>rand</code></a>.</p>
<a class="header" href="print.html#usando-um-crate-para-ter-mais-funcionalidades" id="usando-um-crate-para-ter-mais-funcionalidades"><h3>Usando um Crate para Ter Mais Funcionalidades</h3></a>
<p>Lembre-se que um <em>crate</em> é um pacote de código Rust. O projeto que estamos
construindo é um <em>crate binário</em>, que é um executável. Já o <code>rand</code> é um
<em>crate de biblioteca</em>, que contém código cujo objetivo é ser usado por outros
programas.</p>
<p>É no uso de crates externos que Cargo realmente brilha. Antes que possamos
escrever o código usando <code>rand</code>, precisamos modificar o arquivo <em>Cargo.toml</em>
para incluir o crate <code>rand</code> como uma dependência. Abra o arquivo e adicione
esta linha no final, abaixo do cabeçalho da seção <code>[dependencies]</code> que o Cargo
criou para você:</p>
<p><span class="filename">Arquivo: Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]

rand = &quot;0.3.14&quot;
</code></pre>
<p>No arquivo <em>Cargo.toml</em>, tudo que vem depois de um cabeçalho é parte de uma
seção que segue até o início de outra. A seção <code>[dependencies]</code> é onde você diz
ao Cargo de quais crates externos o seu projeto depende, e quais versões desses
crates você exige. Neste caso, especificamos o crate <code>rand</code> com a versão
semântica <code>0.3.14</code>. Cargo compreende <a href="https://semver.org/lang/pt-BR/">Versionamento Semântico</a><!-- ignore -->
(às vezes chamado <em>SemVer</em>), um padrão para escrever números de versões. O
número <code>0.3.14</code> é, na verdade, uma forma curta de escrever <code>^0.3.14</code>, que
significa &quot;qualquer versão que tenha uma API pública compatível com a versão
0.3.14&quot;.</p>
<p>Agora, sem mudar código algum, vamos compilar nosso projeto, conforme mostrado
na Listagem 2-2:</p>
<pre><code class="language-text">$ cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading rand v0.3.14
 Downloading libc v0.2.14
   Compiling libc v0.2.14
   Compiling rand v0.3.14
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
</code></pre>
<p><span class="caption">Listagem 2-2: Resultado da execução de <code>cargo build</code>
depois de adicionar o crate <code>rand</code> como dependência.</span></p>
<p>Talvez pra você apareçam versões diferentes (mas elas são todas compatíveis com
o código, graças ao Versionamento Semântico!), e as linhas talvez apareçam em
ordem diferente.</p>
<p>Agora que temos uma dependência externa, Cargo busca as versões mais recentes de
tudo no <em>registro</em>, que é uma cópia dos dados do <a href="https://crates.io">Crates.io</a>.
Crates.io é onde as pessoas do ecossistema Rust postam seus projetos
<em>open source</em> para que os outros possam usar.</p>
<p>Após atualizar o registro, Cargo verifica a seção <code>[dependencies]</code> e baixa todas
as que você não tem ainda. Neste caso, embora tenhamos listado apenas <code>rand</code>
como dependência, o Cargo também puxou uma cópia da <code>libc</code>, porque <code>rand</code>
depende da <code>libc</code> para funcionar. Depois de baixá-las, o Cargo as compila e
então compila nosso projeto.</p>
<p>Se, logo em seguida, você executar <code>cargo build</code> novamente sem fazer mudanças,
não vai aparecer nenhuma mensagem de saída. O Cargo sabe que já baixou e
compilou as dependências, e você não alterou mais nada sobre elas no seu arquivo
<em>Cargo.toml</em>. Cargo também sabe que você não mudou mais nada no seu código, e
por isso não o recompila. Sem nada a fazer, ele simplesmente sai. Se você abrir
<em>src/main.rs</em>, fizer uma modificação trivial, salvar e compilar de novo, vai
aparecer uma mensagem de apenas duas linhas:</p>
<pre><code class="language-text">$ cargo build
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
</code></pre>
<p>Essas linhas mostram que o Cargo só atualiza o <em>build</em> com a sua pequena mudança
no arquivo <em>src/main.rs</em>. Suas dependências não mudaram, então o Cargo sabe que
pode reutilizar o que já tiver sido baixado e compilado para elas. Ele apenas
recompila a sua parte do código.</p>
<a class="header" href="print.html#o-arquivo-cargolock-garante-builds-reproduzíveis" id="o-arquivo-cargolock-garante-builds-reproduzíveis"><h4>O Arquivo <em>Cargo.lock</em> Garante <em>Builds</em> Reproduzíveis</h4></a>
<p>O Cargo tem um mecanismo que assegura que você pode reconstruir o mesmo artefato
toda vez que você ou outra pessoa compilar o seu código. O Cargo vai usar apenas
as versões das dependências que você especificou, até que você indique o
contrário. Por exemplo, o que acontece se, na semana que vem, sair a versão
<code>v0.3.15</code> contendo uma correção de bug, mas também uma regressão que não
funciona com o seu código?</p>
<p>A resposta para isso está no arquivo <em>Cargo.lock</em>, que foi criado na primeira
vez que você executou <code>cargo build</code>, e agora está no seu diretório
<em>jogo_de_advinhacao</em>. Quando você compila o seu projeto pela primeira vez, o
Cargo descobre as versões de todas as dependências que preenchem os critérios
e então as escreve no arquivo <em>Cargo.lock</em>. Quando você compilar o seu projeto
futuramente, o Cargo verá que o arquivo <em>Cargo.lock</em> existe e usará as versões
especificadas lá, em vez de refazer todo o trabalho descobrir as versões
novamente. Isto lhe permite ter um <em>build</em> reproduzível automaticamente. Em
outras palavras, seu projeto vai continuar com a versão <code>0.3.14</code> até que você
faça uma atualização explícita, graças ao arquivo <em>Cargo.lock</em>.</p>
<a class="header" href="print.html#atualizando-um-crate-para-obter-uma-nova-versão" id="atualizando-um-crate-para-obter-uma-nova-versão"><h4>Atualizando um Crate para Obter uma Nova Versão</h4></a>
<p>Quando você <em>quiser</em> atualizar um crate, o Cargo tem outro comando, <code>update</code>,
que faz o seguinte:</p>
<ol>
<li>Ignora o arquivo <em>Cargo.lock</em> e descobre todas as versões mais recentes que
atendem as suas especificações no <em>Cargo.toml</em>.</li>
<li>Se funcionar, o Cargo escreve essas versões no arquivo <em>Cargo.lock</em>.</li>
</ol>
<p>Mas, por padrão, o Cargo vai procurar as versões maiores que <code>0.3.0</code> e menores
que <code>0.4.0</code>. Se o crate <code>rand</code> já tiver lançado duas novas versões, <code>0.3.15</code> e
<code>0.4.0</code>, você verá a seguinte mensagem ao executar <code>cargo update</code>:</p>
<pre><code class="language-text">$ cargo update
    Updating registry `https://github.com/rust-lang/crates.io-index`
    Updating rand v0.3.14 -&gt; v0.3.15
</code></pre>
<p>Nesse ponto, você vai notar também uma mudança no seu arquivo <em>Cargo.lock</em>
dizendo que a versão do crate <code>rand</code> que você está usando agora é a <code>0.3.15</code>.</p>
<p>Se você quisesse usar a versão <code>0.4.0</code>, ou qualquer versão da série <code>0.4.x</code> do
<code>rand</code>, você teria que atualizar o seu <em>Cargo.toml</em> dessa forma:</p>
<pre><code class="language-toml">[dependencies]

rand = &quot;0.4.0&quot;
</code></pre>
<p>Na próxima vez que você executar <code>cargo build</code>, o Cargo vai atualizar o registro
de crates disponíveis e reavaliar os seus requisitos sobre o <code>rand</code> de acordo
com a nova versão que você especificou.</p>
<p>Há muito mais a ser dito sobre <a href="http://doc.crates.io">Cargo</a><!-- ignore --> e o <a href="http://doc.crates.io/crates-io.html">seu
ecossistema</a><!-- ignore --> que vai ser discutido no Capítulo 14,
mas por ora isto é tudo que você precisa saber. Cargo facilita muito reutilizar
bibliotecas, de forma que os <em>rustáceos</em> consigam escrever projetos menores que
são montados a partir de diversos pacotes.</p>
<a class="header" href="print.html#gerando-um-número-aleatório" id="gerando-um-número-aleatório"><h3>Gerando um Número Aleatório</h3></a>
<p>Agora vamos <em>usar</em>, de fato, o <code>rand</code>. O próximo passo é atualizar o
<em>src/main.rs</em> conforme mostrado na Listagem 2-3:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use rand::Rng;

fn main() {
    println!(&quot;Advinhe o número!&quot;);

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    println!(&quot;O número secreto é: {}&quot;, numero_secreto);

    println!(&quot;Digite o seu palpite.&quot;);

    let mut palpite = String::new();

    io::stdin().read_line(&amp;mut palpite)
        .expect(&quot;Falha ao ler entrada&quot;);

    println!(&quot;Você disse: {}&quot;, palpite);
}
</code></pre>
<p><span class="caption">Listagem 2-3: Mudanças necessárias do código para gerar um
número aleatório.</span></p>
<p>Estamos adicionando a linha <code>extern crate rand</code> ao topo do arquivo para indicar
ao Rust que estamos usando uma dependência externa. Isto também é equivalente a
um <code>use rand;</code>, assim podemos chamar qualquer coisa que esteja no crate <code>rand</code>
prefixando-a com <code>rand::</code>.</p>
<p>Em seguida, adicionamos outra linha <code>use</code>: <code>use rand::Rng</code>. <code>Rng</code> é um trait
que define métodos a serem implementados pelos geradores de números aleatórios,
e esse trait deve estar dentro do escopo para que possamos usar esses métodos. O
Capítulo 10 vai abordar traits em mais detalhes.</p>
<p>Tem outras duas linhas que adicionamos no meio. A função <code>rand::thread_rng</code> nos
dá o gerador de números aleatórios que vamos usar, um que é local à <em>thread</em>
corrente e que é inicializado pelo sistema operacional. Depois, vamos chamar o
método <code>gen_range</code> no gerador de números aleatórios. Esse método está definido
pelo trait <code>Rng</code> que trouxemos ao escopo por meio do <code>use rand::Rng</code>. Este
método recebe dois argumentos e gera um número aleatório entre eles. Ele inclui
o limite inferior mas exclui o superior, então precisamos passar <code>1</code> e <code>101</code>
para obter um número de 1 a 100.</p>
<p>Saber quais traits devem ser usadas e quais funções e métodos de um crate
devem ser chamados não é nada trivial. As instruções de como usar um crate
estão na documentação de cada um. Outra coisa boa do Cargo é que você pode rodar
o comando <code>cargo doc --open</code> que vai construir localmente a documentação
fornecida por todas as suas dependências e abrí-las no seu navegador. Se você
estiver interessado em outras funcionalidades do crate <code>rand</code>, por exemplo,
execute <code>cargo doc --open</code> e clique em <code>rand</code>, no menu ao lado esquerdo.</p>
<p>A segunda linha que adicionamos imprime o número secreto. Isto é útil enquanto
estamos desenvolvendo o programa para podermos testá-lo, mas vamos retirá-la da
versão final. Um jogo não é muito interessante se ele mostra a resposta logo no
início!</p>
<p>Tente rodar o programa algumas vezes:</p>
<pre><code class="language-text">$ cargo run
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
     Running `target/debug/jogo_de_advinhacao`
Advinhe o número!
O número secreto é: 7
Digite o seu palpite.
4
Você disse: 4
$ cargo run
     Running `target/debug/jogo_de_advinhacao`
Advinhe o número!
O número secreto é: 83
Digite o seu palpite.
5
Você disse: 5
</code></pre>
<p>Você já deve obter números aleatórios diferentes, e eles devem ser todos entre 1
e 100. Bom trabalho!</p>
<a class="header" href="print.html#comparando-o-palpite-com-o-número-secreto" id="comparando-o-palpite-com-o-número-secreto"><h2>Comparando o Palpite com o Número Secreto</h2></a>
<p>Agora que nós temos a entrada do usuário e o número secreto, vamos compará-los.
Esta estapa é mostrada na Listagem 2-4:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Advinhe o número!&quot;);

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    println!(&quot;O número secreto é: {}&quot;, numero_secreto);

    println!(&quot;Digite o seu palpite.&quot;);

    let mut palpite = String::new();

    io::stdin().read_line(&amp;mut palpite)
        .expect(&quot;Falha ao ler entrada&quot;);

    println!(&quot;Você disse: {}&quot;, palpite);

    match palpite.cmp(&amp;numero_secreto) {
        Ordering::Less =&gt; println!(&quot;Muito baixo!&quot;),
        Ordering::Greater =&gt; println!(&quot;Muito alto!&quot;),
        Ordering::Equal =&gt; println!(&quot;Você acertou!&quot;),
    }
}
</code></pre>
<p><span class="caption">Listagem 2-4: Tratando os possíveis resultados da
comparação de dois números.</span></p>
<p>A primeira novidade aqui é outro <code>use</code>, que traz ao escopo um tipo da biblioteca
padrão chamado <code>std::cmp::Ordering</code>. <code>Ordering</code> é outra enum, igual a <code>Result</code>,
mas as suas variantes são <code>Less</code>, <code>Greater</code> e <code>Equal</code> (elas significam menor,
maior e igual, respectivamente). Estes são os três possíveis resultados quando
você compara dois valores.</p>
<p>Depois, adicionamos cinco novas linhas no final que usam o tipo <code>Ordering</code>:</p>
<pre><code class="language-rust ignore">match palpite.cmp(&amp;numero_secreto) {
    Ordering::Less =&gt; println!(&quot;Muito baixo!&quot;),
    Ordering::Greater =&gt; println!(&quot;Muito alto!&quot;),
    Ordering::Equal =&gt; println!(&quot;Você acertou!&quot;),
}
</code></pre>
<p>O método <code>cmp</code> compara dois valores, e pode ser chamado a partir de qualquer
coisa que possa ser comparada. Ele recebe uma referência de qualquer coisa que
você queira comparar. Neste caso, está comparando o <code>palpite</code> com o
<code>numero_secreto</code>. <code>cmp</code> retorna uma variante do tipo <code>Ordering</code>, que trouxemos
ao escopo com <code>use</code>. Nós usamos uma expressão <a href="ch06-02-match.html"><code>match</code></a><!-- ignore -->
para decidir o que fazer em seguida, com base em qual variante de <code>Ordering</code> foi
retornada pelo método <code>cmp</code>, que foi chamado com os valores <code>palpite</code> e
<code>numero_secreto</code>.</p>
<p>Uma expressão <code>match</code> é composta de <em>braços</em>. Um braço consiste em um <em>padrão</em>
mais o código que deve ser executado se o valor colocado no início do <code>match</code> se
encaixar no padrão deste braço. O Rust pega o valor passado ao <code>match</code> e o
compara com o padrão de cada braço na sequência. A expressão <code>match</code> e os
padrões são ferramentas poderosas do Rust que lhe permitem expressar uma
variedade de situações que seu código pode encontrar, e ajuda a assegurar que
você tenha tratado todas elas. Essas ferramentas serão abordadas em detalhes nos
capítulos 6 e 18, respectivamente.</p>
<p>Vamos acompanhar um exemplo do que aconteceria na expressão <code>match</code> usada aqui.
Digamos que o usuário tenha colocado 50 como palpite, e o número secreto
aleatório desta vez é 38. Quando o código compara 50 com 38, o método <code>cmp</code> vai
retornar <code>Ordering::Greater</code>, porque 50 é maior que 38. <code>Ordering::Greater</code> é o
valor passado ao <code>match</code>. Ele olha para o padrão <code>Ordering::Less</code> do primeiro
braço, mas o valor <code>Ordering::Greater</code> não casa com <code>Ordering::Less</code>, então ele
ignora o código desse braço e avança para o próximo. Já o padrão do próximo
braço, <code>Ordering::Greater</code>, <em>casa</em> com <code>Ordering::Greater</code>! O código associado a
este braço vai ser executado e mostrar <code>Muito alto!</code> na tela. A expressão
<code>match</code> termina porque já não tem mais necessidade de verificar o último braço
nesse caso particular.</p>
<p>Porém, o código da Listagem 2-4 ainda não vai compilar. Vamos tentar:</p>
<pre><code class="language-text">$ cargo build
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
error[E0308]: mismatched types
  --&gt; src/main.rs:23:21
   |
23 |     match palpite.cmp(&amp;numero_secreto) {
   |                       ^^^^^^^^^^^^^^^ expected struct `std::string::String`, found integral variable
   |
   = note: expected type `&amp;std::string::String`
   = note:    found type `&amp;{integer}`

error: aborting due to previous error
Could not compile `jogo_de_advinhacao`.
</code></pre>
<p>O que este erro está dizendo é que temos <em>tipos incompatíveis</em>. Rust tem um
sistema de tipos forte e estático. Porém, Rust também tem inferência de tipos.
Quando escrevemos <code>let palpite = String::new()</code>, Rust foi capaz de inferir que
<code>palpite</code> deveria ser uma <code>String</code>, então ele não nos faz escrever o tipo. O
<code>numero_secreto</code>, por outro lado, é de um tipo numérico. Existem alguns tipos
numéricos capazes de guardar um valor entre 1 e 100: <code>i32</code>, que é um número de
32 bits; <code>u32</code>, um número de 32 bits sem sinal; <code>i64</code>, um número de 64 bits; e
mais alguns outros. O tipo numérico padrão do Rust é <code>i32</code>, que é o tipo do
<code>numero_secreto</code>, a não ser que adicionemos, em algum lugar, uma informação de
tipo que faça o Rust inferir outro tipo numérico. A razão do erro é que o Rust
não pode comparar uma string e um tipo numérico.</p>
<p>Em última análise, queremos converter a <code>String</code> que lemos como entrada em um
tipo numérico de verdade, de forma que possamos compará-lo numericamente com o
palpite. Podemos fazer isso com mais duas linhas no corpo da função <code>main</code>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Advinhe o número!&quot;);

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    println!(&quot;O número secreto é: {}&quot;, numero_secreto);

    println!(&quot;Digite o seu palpite.&quot;);

    let mut palpite = String::new();

    io::stdin().read_line(&amp;mut palpite)
        .expect(&quot;Falha ao ler entrada&quot;);

    let palpite: u32 = palpite.trim().parse()
        .expect(&quot;Por favor, digite um número!&quot;);

    println!(&quot;Você disse: {}&quot;, palpite);

    match palpite.cmp(&amp;numero_secreto) {
        Ordering::Less =&gt; println!(&quot;Muito baixo!&quot;),
        Ordering::Greater =&gt; println!(&quot;Muito alto!&quot;),
        Ordering::Equal =&gt; println!(&quot;Você acertou!&quot;),
    }
}
</code></pre>
<p>As duas linhas novas são:</p>
<pre><code class="language-rust ignore">let palpite: u32 = palpite.trim().parse()
    .expect(&quot;Por favor, digite um número!&quot;);
</code></pre>
<p>Nós criamos uma variável chamada <code>palpite</code>. Mas espera, o programa já não tinha
uma variável chamada <code>palpite</code>? Sim, mas o Rust nos permite <em>sombrear</em> o
<code>palpite</code> anterior com um novo. Isto é geralmente usado em situações em que você
quer converter um valor de um tipo em outro. O sombreamento nos permite
reutilizar o nome <code>palpite</code>, em vez de nos forçar a criar dois nomes únicos como
<code>palpite_str</code> e <code>palpite</code>, por exemplo. (O Capítulo 3 vai cobrir sombreamento em
mais detalhes).</p>
<p>Nós vinculamos <code>palpite</code> à expressão <code>palpite.trim().parse()</code>. O <code>palpite</code>, na
expressão, refere-se ao <code>palpite</code> original contendo a <code>String</code> de entrada do
usuário. O método <code>trim</code>, em uma instância de <code>String</code>, vai eliminar quaisquer
espaços em branco no início e no fim. <code>u32</code> pode conter apenas caracteres
numéricos, mas o usuário precisa pressionar <span class="keystroke">Enter</span>
para satisfazer o <code>read_line</code>. Quando o usuário pressiona
<span class="keystroke">Enter</span>, um caractere de nova linha é inserido na
string. Por exemplo, se o usuário digitar <span class="keystroke">5</span> e
depois <span class="keystroke">Enter</span>, <code>palpite</code> ficaria assim: <code>5\n</code>. O
<code>\n</code> representa uma linha nova, a tecla <span class="keystroke">Enter</span>.
O método <code>trim</code> elimina o <code>\n</code>, deixando apenas <code>5</code>.</p>
<p>O <a href="../../std/primitive.str.html#method.parse">método <code>parse</code> em strings</a><!-- ignore --> converte uma string para
algum tipo de número. Dado que ele pode interpretar uma variedade de tipos
numéricos, precisamos dizer ao Rust qual o tipo exato de número nós queremos, e
para isso usamos <code>let palpite: u32</code>. Os dois pontos (<code>:</code>) depois de <code>palpite</code>
informam ao Rust que estamos anotando seu tipo. O Rust tem alguns tipos
numéricos embutidos, o <code>u32</code> visto aqui é um inteiro de 32 bits sem sinal. É uma
boa escolha padrão para um número positivo pequeno. Você vai aprender sobre
outros tipos numéricos no Capítulo 3. Além disso, a anotação <code>u32</code> neste
programa de exemplo e a comparação com <code>numero_secreto</code> significam que o Rust
vai inferir que <code>numero_secreto</code> também deve ser um <code>u32</code>. Então agora a
comparação vai ser feita entre valores do mesmo tipo!</p>
<p>A chamada para <code>parse</code> poderia facilmente causar um erro. Por exemplo, se a
string contiver <code>A👍%</code>, não haveria como converter isto em um número. Como ele
pode falhar, o método <code>parse</code> retorna um <code>Result</code>, assim como o método
<code>read_line</code>, conforme discutido anteriormente na seção &quot;Tratando Potenciais
Falhas com o Tipo <code>Result</code>. Vamos tratar este <code>Result</code> da mesma forma usando o
método <code>expect</code> de novo. Se o <code>parse</code> retornar uma variante <code>Err</code> da enum
<code>Result</code>, por não conseguir criar um número a partir da string, a chamada ao
<code>expect</code> vai causar um <em>crash</em> no jogo e exibir a mensagem que passamos a ele.
Se o <code>parse</code> conseguir converter uma string em um número, ele vai retornar a
variante <code>Ok</code> da enum <code>Result</code> e <code>expect</code> vai retornar o número que queremos
extrair do valor <code>Ok</code>.</p>
<p>Agora vamos executar o programa!</p>
<pre><code class="language-text">$ cargo run
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43 secs
     Running `target/jogo_de_advinhacao`
Advinhe o número!
O número secreto é: 58
Digite o seu palpite.
  76
Você disse: 76
Muito alto!
</code></pre>
<p>Boa! Até mesmo colocando alguns espaços antes de digitar o palpite, o programa
ainda descobriu que o palpite do usuário é 76. Execute o programa mais algumas
vezes para verificar os diferentes comportamentos com diferentes tipos de
entrada: advinhe o número corretamente, digite um número muito alto, e digite um
número muito baixo.</p>
<p>Agora já temos a maior parte do jogo funcionando, mas o usuário só consegue dar
um palpite uma vez. Vamos mudar isso adicionando laços!</p>
<a class="header" href="print.html#permitindo-múltiplos-palpites-usando-looping" id="permitindo-múltiplos-palpites-usando-looping"><h2>Permitindo Múltiplos Palpites Usando <em>Looping</em></h2></a>
<p>A palavra-chave <code>loop</code> nos dá um laço (<em>loop</em>) infinito. Use-a para dar aos
usuários mais chances de advinhar o número:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Advinhe o número!&quot;);

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    println!(&quot;O número secreto é: {}&quot;, numero_secreto);

    loop {
        println!(&quot;Digite o seu palpite.&quot;);

        let mut palpite = String::new();

        io::stdin().read_line(&amp;mut palpite)
            .expect(&quot;Falha ao ler entrada&quot;);

        let palpite: u32 = palpite.trim().parse()
            .expect(&quot;Por favor, digite um número!&quot;);

        println!(&quot;Você disse: {}&quot;, palpite);

        match palpite.cmp(&amp;numero_secreto) {
            Ordering::Less =&gt; println!(&quot;Muito baixo!&quot;),
            Ordering::Greater =&gt; println!(&quot;Muito alto!&quot;),
            Ordering::Equal =&gt; println!(&quot;Você acertou!&quot;),
        }
    }
}
</code></pre>
<p>Como você pode ver, movemos tudo para dentro do laço a partir da mensagem
pedindo o palpite do usuário. Certifique-se de indentar essas linhas mais quatro
espaços cada uma, e execute o programa novamente. Repare que há um novo
problema, porque o programa está fazendo exatamente o que dissemos para ele
fazer: pedir sempre outro palpite! Parece que o usuário não consegue sair!</p>
<p>O usuário pode sempre interromper o programa usando as teclas
<span class="keystroke">ctrl-c</span>. Mas há uma outra forma de escapar deste
monstro insaciável que mencionamos na discussão do método <code>parse</code>, na seção
&quot;Comparando o Palpite com o Número Secreto&quot;: se o usuário fornece uma resposta
não-numérica, o programa vai sofrer um <em>crash</em>. O usuário pode levar vantagem
disso para conseguir sair, como mostrado abaixo:</p>
<pre><code class="language-text">$ cargo run
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
     Running `target/jogo_de_advinhacao`
Advinhe o número!
O número secreto é: 59
Digite o seu palpite.
45
Você disse: 45
Muito baixo!
Digite o seu palpite.
60
Você disse: 60
Muito alto!
Digite o seu palpite.
59
Você disse: 59
Você acertou!
Digite o seu palpite.
sair
thread 'main' panicked at 'Por favor, digite um número!: ParseIntError { kind: InvalidDigit }', src/libcore/result.rs:785
note: Run with `RUST_BACKTRACE=1` for a backtrace.
error: Process didn't exit successfully: `target/debug/jogo_de_advinhacao` (exit code: 101)
</code></pre>
<p>Digitar <code>sair</code>, na verdade, sai do jogo, mas isso também acontece com qualquer
outra entrada não numérica. Porém, isto não é o ideal. Queremos que o jogo
termine automaticamente quando o número é advinhado corretamente.</p>
<a class="header" href="print.html#saindo-após-um-palpite-correto" id="saindo-após-um-palpite-correto"><h3>Saindo Após um Palpite Correto</h3></a>
<p>Vamos programar o jogo para sair quando o usuário vencer, colocando um <code>break</code>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Advinhe o número!&quot;);

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    println!(&quot;O número secreto é: {}&quot;, numero_secreto);

    loop {
        println!(&quot;Digite o seu palpite.&quot;);

        let mut palpite = String::new();

        io::stdin().read_line(&amp;mut palpite)
            .expect(&quot;Falha ao ler entrada&quot;);

        let palpite: u32 = palpite.trim().parse()
            .expect(&quot;Por favor, digite um número!&quot;);

        println!(&quot;Você disse: {}&quot;, palpite);

        match palpite.cmp(&amp;numero_secreto) {
            Ordering::Less =&gt; println!(&quot;Muito baixo&quot;),
            Ordering::Greater =&gt; println!(&quot;Muito alto!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;Você acertou!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p>Adicionando a linha <code>break</code> após o <code>Você acertou!</code>, o programa vai sair do laço
quando o usuário advinhar corretamente o número secreto. Sair do laço também
significa sair do programa, pois o laço é a última parte da <code>main</code>.</p>
<a class="header" href="print.html#tratando-entradas-inválidas" id="tratando-entradas-inválidas"><h3>Tratando Entradas Inválidas</h3></a>
<p>Para refinar ainda mais o comportamento do jogo, em vez de causar um <em>crash</em> no
programa quando o usuário insere uma entrada não numérica, vamos fazer o jogo
ignorá-la para que o usuário possa continuar tentando. Podemos fazer isso
alterando a linha em que o <code>palpite</code> é convertido de <code>String</code> para <code>u32</code>:</p>
<pre><code class="language-rust ignore">let palpite: u32 = match palpite.trim().parse() {
    Ok(num) =&gt; num,
    Err(_) =&gt; continue,
};
</code></pre>
<p>Trocando uma chamada a <code>expect</code> por uma expressão <code>match</code> é a forma como você
geralmente deixa de causar um <em>crash</em> em um erro e passa a tratá-lo, de fato.
Lembre-se que o método <code>parse</code> retorna um valor do tipo <code>Result</code>, uma enum que
contém a variante <code>Ok</code> ou <code>Err</code>. Estamos usando um <code>match</code> aqui, assim como
fizemos com o <code>Ordering</code> resultante do método <code>cmp</code>.</p>
<p>Se o <code>parse</code> consegue converter a string em um número, ele vai retornar um <code>Ok</code>
contendo o número resultante. Esse valor <code>Ok</code> vai casar com o padrão do primeiro
braço, e o <code>match</code> vai apenas retornar o valor <code>num</code> produzido pelo <code>parse</code> e
colocado dentro do <code>Ok</code>. Esse número vai acabar ficando exatamente onde
queremos, na variável <code>palpite</code> que estamos criando.</p>
<p>Se o <code>parse</code> <em>não</em> conseguir converter a string em um número, ele vai retornar
um <code>Err</code> que contém mais informações sobre o erro. O valor <code>Err</code> não casa com o
padrão <code>Ok(num)</code> do primeiro braço do <code>match</code>, mas casa com o padrão <code>Err(_)</code> do
segundo braço. O <code>_</code> é um valor &quot;pega tudo&quot;. Neste exemplo, estamos dizendo que
queremos casar todos os valores <code>Err</code>, não importa qual informação há dentro
deles. Então o programa vai executar o código do segundo braço, <code>continue</code>, que
significa ir para a próxima iteração do <code>loop</code> e pedir outro palpite.
Efetivamente, o programa ignora todos os erros que o <code>parse</code> vier a encontrar!</p>
<p>Agora, tudo no programa deve funcionar como esperado. Vamos tentar executá-lo
usando o comando <code>cargo run</code>:</p>
<pre><code class="language-text">$ cargo run
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
     Running `target/jogo_de_advinhacao`
Advinhe o número!
O número secreto é: 61
Digite o seu palpite.
10
Você disse: 10
Muito baixo!
Digite o seu palpite.
99
Você disse: 99
Muito alto!
Digite o seu palpite.
foo
Digite o seu palpite.
61
Você disse: 61
Você acertou!
</code></pre>
<p>Demais! Com apenas um último ajuste, vamos finalizar o jogo de adivinhação:
lembre-se que o programa ainda está mostrando o número secreto. Isto foi bom
para testar, mas estraga o jogo. Vamos apagar o <code>println!</code> que revela o número
secreto. A Listagem 2-5 mostra o código final:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Advinhe o número!&quot;);

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    loop {
        println!(&quot;Digite o seu palpite.&quot;);

        let mut palpite = String::new();

        io::stdin().read_line(&amp;mut palpite)
            .expect(&quot;Falha ao ler entrada&quot;);

        let palpite: u32 = match palpite.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;Você disse: {}&quot;, palpite);

        match palpite.cmp(&amp;numero_secreto) {
            Ordering::Less =&gt; println!(&quot;Muito baixo!&quot;),
            Ordering::Greater =&gt; println!(&quot;Muito alto!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;Você acertou!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p><span class="caption">Listagem 2-5: Código completo do jogo de advinhação.
</span></p>
<a class="header" href="print.html#resumo" id="resumo"><h2>Resumo</h2></a>
<p>Neste ponto, você construiu com sucesso o jogo de adivinhação! Parabéns!</p>
<p>Este projeto foi uma forma prática de apresentar vários conceitos novos de Rust:
<code>let</code>, <code>match</code>, métodos, funções associadas, uso de crates externos, e outros.
Nos próximos capítulos, você vai aprender sobre esses conceitos em mais
detalhes. O Capítulo 3 aborda conceitos que a maioria das linguagens de
programação tem, como variáveis, tipos de dados e funções, e mostra como usá-los
em Rust. O Capítulo 4 explora posse (<em>ownership</em>), que é a característica do
Rust mais diferente das outras linguagens. O Capítulo 5 discute structs e a
sintaxe de métodos, e o Capítulo 6 se dedica a explicar enums.</p>
<a class="header" href="print.html#conceitos-comuns-de-programação" id="conceitos-comuns-de-programação"><h1>Conceitos Comuns de Programação</h1></a>
<p>Este capítulo aborda conceitos que aparecem em quase todas as linguagens de programação e como eles funcionam no Rust. Muitas linguagens de programação têm muito em comum em seu cerne. Nenhum dos conceitos apresentados neste capítulo é exclusivo de Rust, mas vamos discuti-los no contexto do Rust e explicar as convenções em torno do uso desses conceitos.</p>
<p>Especificamente, você aprenderá sobre variáveis, tipos básicos, funções, comentários e fluxo de controle. Esses princípios estarão em todos os programas em Rust, e aprendê-los cedo lhe dará uma boa base para começar.</p>
<blockquote>
<a class="header" href="print.html#palavras-chaves" id="palavras-chaves"><h3>Palavras chaves</h3></a>
<p>A linguagem Rust tem uma série de <em>palavras-chaves</em> que são reservadas para uso exclusivo
da linguagem, como ocorre em outras linguagens. Tenha em mente que você não
pode usar essas palavras como nome de variáveis ou funções. A maioria das palavras-chaves tem
um significado específico, e você estará usando-as para várias tarefas em programas em Rust;
algumas ainda não possuem funcionalidades associadas a elas, mas
foram reservadas para funcionalidades que podem ser adicionadas ao Rust futuramente. Você
encontrará uma lista de palavras-chaves no Apêndice A.</p>
</blockquote>
<a class="header" href="print.html#variáveis-e-mutabilidade" id="variáveis-e-mutabilidade"><h1>Variáveis e Mutabilidade</h1></a>
<p>Como mencionado no Capítulo 2, por padrão, as variáveis são imutáveis. Essa é uma das
maneiras que o Rust lhe dá para escrever o seu código de
modo seguro e a fácil concorrência que Rust oferece. No entanto, você ainda tem
a opção de tornar a sua variável mutável. Vamos explorar como e por que Rust
incentiva você a usar variáveis imutáveis e por que às vezes pode
não optar por utilizá-las.</p>
<p>Quando uma variável é imutável, logo que um valor é associado a uma variável, você não pode mudar este valor.
Para ilustrar isso, vamos criar um projeto chamado <em>variaveis</em>
no seu diretório <em>projetos</em> usando <code>cargo new --bin variables</code>.</p>
<p>Então dentro do novo diretório chamado <em>variaveis</em>, abra <em>src/main.rs</em> e substitua o
código com o código abaixo, que não irá compilar:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let x = 5;
    println!(&quot;O valor de x é: {}&quot;, x);
    x = 6;
    println!(&quot;O valor de x é: {}&quot;, x);
}
</code></pre>
<p>Salve e execute o programa usando <code>cargo run</code>. Você deve receber uma mensagem de erro,
conforme mostrado nesta saída:</p>
<pre><code class="language-text">error[E0384]: cannot assign twice to immutable variable `x`
 --&gt; src/main.rs:4:5
  |
2 |     let x = 5;
  |         - first assignment to `x`
3 |     println!(&quot;O valor de x é: {}&quot;, x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable
</code></pre>
<p>Esse exemplo mostra como o compilador ajuda você a encontrar erros no seus programas.
Mesmo que erros de compilação sejam frustrantes, eles apenas significam que seu programa
não está fazendo de modo seguro o que você espera fazer; eles <em>não</em> siginificam que você
não é um bom programador! Programadores experientes também recebem erros de compilação.</p>
<p>A mensagem indica que a causa do erro é que você
<code>não pode atribuir mais de uma vez à variável imutável x</code>, porque você tentou atribuir um segundo valor à variável <code>x</code>.</p>
<p>É importante que nos recebamos erros em tempo de compilação quando tentamos
alterar um valor que anteriormente foi indicado como imutável, porque
esta situação pode ocasionar erros. Se uma parte do seu código funciona assumindo
que o valor nunca será alterado e outra parte do seu código muda este valor, é
possível que a primeira parte do código não faça o que foi projetada para fazer.
A causa desse tipo de falha pode ser difícil de rastrear,
especialmente quando o segundo trecho de código muda o valor apenas <em>algumas vezes</em>.</p>
<p>Em Rust, o compilador garante que quando você afirma que um valor não pode mudar,
ele não mude. Isso significa que quando você está lendo e ecrevendo código,
você não tenha de acompanhar como e onde um valor pode mudar. E assim seu código
fica mais fácil de entender.</p>
<p>Mas mutabilidade pode ser muito útil. Variáveis são imutáveis por padrão; como
você fez no Capítulo 2, você pode torná-las mutáveis adicionando <code>mut</code> na frente do
nome da variável. Além de permitir que este valor mude, <code>mut</code> transmite
a intenção aos futuros leitores do código, indicando que naquela
parte do código estarão mudando o valor da variável.</p>
<p>Por exemplo, vamos mudar <em>src/main.rs</em> para o seguinte:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut x = 5;
    println!(&quot;O valor de x é: {}&quot;, x);
    x = 6;
    println!(&quot;O valor de x é: {}&quot;, x);
}
</code></pre></pre>
<p>Quando executamos o programa, recebemos isso:</p>
<pre><code class="language-text">$ cargo run
   Compiling variaveis v0.1.0 (file:///projects/variaveis)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30 secs
     Running `target/debug/variaveis`
O valor de x é: 5
O valor de x é: 6
</code></pre>
<p>Estamos autorizados a mudar o valor <code>5</code> contido  em <code>x</code> para <code>6</code>
quando <code>mut</code> é usado. Em alguns casos, você precisará criar uma variável mutável porque ela
será mais conveniente para escrever do que se fosse imutável.</p>
<p>Tem vários compromissos a serem considerados além de prevenção de
falhas. Por exemplo, nos casos em que você usa estruturas de dados grandes,
a alteração em uma instância pode ser mais rápida do que copiar e retornar a nova instância
alocada. Com estruturas de dados menores, criar novas instâncias e escrever
em um estilo de programação funcional pode ser mais fácil de entender, portanto,
um desempenho menor pode ser uma penalidade que vale a pena para obter mais clareza.</p>
<a class="header" href="print.html#diferenças-entre-variáveis-e-constantes" id="diferenças-entre-variáveis-e-constantes"><h3>Diferenças entre variáveis e constantes</h3></a>
<p>Ser incapaz de mudar o valor de uma variável, pode ter feito você lembrar de
outro conceito de programação, que a maioria das outras linguagens possui, chamado: <em>constantes</em>. Como
variáveis imutáveis, constantes são valores que estão vinculados ao nome e não
podem serem alterados, mas há algumas diferenças entre constantes e
variáveis.</p>
<p>Primeiro, você não pode usar <code>mut</code> com constantes. Constante não são apenas
imutáveis por padrão, constante são sempre imutáveis.</p>
<p>Você declara constante usando a palavra-chave <code>const</code> em vez de <code>let</code>,
e o tipo do valor <em>necessita</em> ser específicado. Falaremos sobre tipos de dados
na próxima seção, &quot;Data Type&quot;, então
não se preocupe com os detalhes por agora. Apenas saiba que você precisa especificar o tipo.</p>
<p>Constantes podem ser declaradas em qualquer escopo, incluindo o escopo global, o que os tornam
úteis para valores que várias partes do código precisa conhecer.</p>
<p>A última diferença é que as constantes podem ser definidas apenas para uma expressão constante,
ou seja, não pode ser o resultado de uma chamada de função ou qualquer outro valor que só poderia ser
calculado em tempo de execução.</p>
<p>Aqui está um exemplo de uma declaração constante, em que o nome da constante é
<code>PONTOS_MAXIMOS</code> e o valor definido é 100,000 (por
convenção, contantes em Rust são nomeadas usando maiúsculas e sublinhado entre as palavras):</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
const PONTOS_MAXIMOS: u32 = 100_000;
#}</code></pre></pre>
<p>Constante são válidas durante todo o tempo de execução de um programa, dentro do escopo em que
foram declaradas, tornando-as uma ótima escolha para valores no domínio da aplicação,
que várias partes do programa necessitam conhecer, como por exemplo,
o número máximo de pontos um jogador pode ter ou a
velocidade da luz.</p>
<p>A nomeação de valores codificados permanentemente usados em todo o programa como constantes é útil
para transmitir o significado desse valor para futuros mantenedores do código. Também
ajuda ter apenas um lugar em seu código que você precisaria mudar se o
valor codificado precisasse ser atualizado no futuro.</p>
<a class="header" href="print.html#shadowing" id="shadowing"><h3>Shadowing</h3></a>
<p>Como você viu na seção “Comparando o Adivinha ao Número Secreto” no Capítulo
2, você pode declarar uma nova variável com o mesmo nome de uma variável anterior,
e a nova variável sombreia a variável anterior. Rustaceans dizem que a
primeira variável é <em>sombreada</em> pela segunda, o que significa que o segundo
valor da variável é o que aparece quando a variável é usada. Podemos sombrear uma
variável usando o mesmo nome da variável e repetindo o uso da palavra-chave <code>let</code>
da seguinte forma:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 5;

    let x = x + 1;

    let x = x * 2;

    println!(&quot;O valor de x é: {}&quot;, x);
}
</code></pre></pre>
<p>Esse programa primeiro vincula <code>x</code> ao valor <code>5</code>. Em seguida <code>x</code> é sombreado por
<code>let x =</code>, pegando o valor original e adicionando <code>1</code>, então o valor de
<code>x</code> é <code>6</code>. O terceiro <code>let</code> também sombrea <code>x</code>, multiplicando o
valor anterior por <code>2</code> para então <code>x</code> ficar com o valor final de <code>12</code>. Quando nós executamos esse programa, é
produzida a seguinte saída:</p>
<pre><code class="language-text">$ cargo run
   Compiling variaveis v0.1.0 (file:///projects/variaveis)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/variaveis`
O valor de x é: 12
</code></pre>
<p>Shadowing é diferente do que dizer que uma variável é <code>mut</code>, porque teremos um
erro em tempo de compilação se, acidentalmente, tentarmos reatribuir essa variável sem
utilizar <code>let</code>. Usando <code>let</code>, nós podemos realizar algumas transformações,
mas sem ter uma variável imutável após estas transformações terem
sido concluídas.</p>
<p>Uma outra diferença entre <code>mut</code> e shadowing é que,
como estamos efetivamente criando uma nova várivel, quando usamos novamente a palavra-chave <code>let</code>, nós
podemos mudar o tipo do valor, mas reutilizando o mesmo nome. Por exemplo, digamos que nosso programa
solicite ao usuário que mostre quantos espaços deseja entre um texto, inserindo
caracteres de espaço, mas queremos armazenar essa entrada como um número:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let espacos = &quot;   &quot;;
let espacos = espacos.len();
#}</code></pre></pre>
<p>Essa construção é permitida, porque a primeira variável <code>espacos</code> é do tipo string
e a segunda variável, que é uma nova variável que tem o
mesmo nome que a primeira, é do tipo numérico. Shadowing nos poupa de
ter de criar nomes diferentes, como <code>str_espacos</code> e
<code>num_espacos</code>; em vez disso, podemos simplesmente reutilizar o nome <code>espacos</code>. No entanto, se
tentassemos usar <code>mut</code> para isso, como mostramos aqui, teremos um erro em tempo de compilação:</p>
<pre><code class="language-rust ignore">let mut espacos = &quot;   &quot;;
espacos = espacos.len();
</code></pre>
<p>O erro diz que não podemos alterar o tipo de variável:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:3:14
  |
3 |     espacos = espacos.len();
  |              ^^^^^^^^^^^^ expected &amp;str, found usize
  |
  = note: expected type `&amp;str`
             found type `usize`
</code></pre>
<p>Agora que exploramos como as variáveis funcionam, vamos ver mais tipos de dados.</p>
<a class="header" href="print.html#tipos-de-dados" id="tipos-de-dados"><h1>Tipos de dados</h1></a>
<p>Todo valor em Rust é um <em>tipo de dado</em>, que informa ao Rust que tipos de
dados estão sendo especificados para que saiba como trabalhar com esses dados. Vamos olhar para
dois subconjuntos de tipos de dados: escalar e composto.</p>
<p>Tenha em mente que Rust é uma linguagem de <em>tipagem estática</em>, o que significa
que deve conhecer os tipos de todas as variáveis em tempo de compilação. O compilador
geralmente pode inferir que tipo queremos com base no valor e como o usamos. Nos casos
em que são é possível vários tipos de dados, como quando convertemos uma <code>String</code> em um tipo numérico
usando <code>parse</code> na seção &quot;Comparando o Adivinha ao Número Secreto&quot; no
Capítulo 2, devemos adicionar uma anotação de tipo, como a seguinte:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let guess: u32 = &quot;42&quot;.parse().expect(&quot;Não é um número!&quot;);
#}</code></pre></pre>
<p>Se não adicionarmos uma anotação de tipo, Rust irá mostrar o seguinte erro,
que significa que o compilador precisa de mais informaçoes para saber qual tipo de dados
queremos usar:</p>
<pre><code class="language-text">error[E0282]: type annotations needed
 --&gt; src/main.rs:2:9
  |
2 |     let guess = &quot;42&quot;.parse().expect(&quot;Não é um número!&quot;);
  |         ^^^^^
  |         |
  |         cannot infer type for `_`
  |         consider giving `guess` a type
</code></pre>
<p>Você verá anotações de tipos diferentes para outros tipos de dados.</p>
<a class="header" href="print.html#tipos-escalares" id="tipos-escalares"><h3>Tipos escalares</h3></a>
<p>Um tipo <em>escalar</em> representa um valor único. Rust tem quatro tipos escalares primários:
inteiros, números de ponto flutuante, booleanos e caracteres. Você pode reconhecer
esses tipos de outras linguagens de programação. Vamos pular para como eles funcionam no Rust.</p>
<a class="header" href="print.html#tipos-inteiros" id="tipos-inteiros"><h3>Tipos inteiros</h3></a>
<p>Um <em>inteiro</em> é um número sem a parte fracionária. Usamos
um tipo inteiro no Capítulo 2, o tipo <code>u32</code>. Esse tipo de
declaração indica que
o valor associado deve ser um inteiro sem sinal (tipos inteiros com sinal começam com <code>i</code>, em vez de <code>u</code>) que ocupa 32 bits de espaço. Tabela 3-1 mostra
os tipos inteiros internos ao Rust. Cada variante está na
coluna com sinal e sem sinal (por exemplo, <code>i16</code>) pode ser usada para declarar um valor do tipo
inteiro.</p>
<p><span class="caption">Tabela 3-1: Tipos inteiros no Rust</span></p>
<table><thead><tr><th> Tamanho </th><th> Signed  </th><th> Unsigned </th></tr></thead><tbody>
<tr><td> 8-bit   </td><td> <code>i8</code>    </td><td> <code>u8</code>     </td></tr>
<tr><td> 16-bit  </td><td> <code>i16</code>   </td><td> <code>u16</code>    </td></tr>
<tr><td> 32-bit  </td><td> <code>i32</code>   </td><td> <code>u32</code>    </td></tr>
<tr><td> 64-bit  </td><td> <code>i64</code>   </td><td> <code>u64</code>    </td></tr>
<tr><td> arch    </td><td> <code>isize</code> </td><td> <code>usize</code>  </td></tr>
</tbody></table>
<p>Cada variante pode ser com ou sem sinal e ter tamanho explícito.
<em>Signed</em> e <em>unsigned</em> refere-se à possibilidade do número ser
negativo ou positivo - em outras palavras, se o número precisa de um sinal
com ele (signed) ou se sempre for
positivo pode ser representado sem um sinal (unsigned). É como escrevemos números no papel: Quando
o sinal importa, o número é mostrado com um sinal de mais ou menos; contudo,
quando é seguro assumir que o número é positivo, é mostrado sem sinal.
Números com sinais são armazenados usando a representação complemento de dois (se você não tiver
certeza do que é isso, você pode procurar sobre isso na internet; uma explicação está fora do escopo
deste livro).</p>
<p>Cada variante com sinal pode armazenar números de -(2<sup>n - 1</sup>) até 2<sup>n -
1</sup> - 1 incluso, sendo <em>n</em> o número de bits que varia de acordo com o uso. Então, um
<code>i8</code> pode armazenar números de -(2<sup>7</sup>) até 2<sup>7</sup> - 1, que é  igual
a -128 até 127. Variantes sem sinal pode armazenar números de 0 até 2<sup>n</sup> - 1,
entao um <code>u8</code> pode armazenar números de 0 até 2<sup>8</sup> - 1, que é de 0 até 255.</p>
<p>Além disso, os tipos <code>isize</code> e <code>usize</code> dependem do computador em que seu programa
está rodando: 64 bits se estiver em uma arquitetura de 64-bit e 32 bits
se sua arquitetura for 32-bit.</p>
<p>Você pode criar inteiros literais em qualquer uma das formas mostrada na Tabela 3-2. Observe
que todos os literais de números, exceto o byte literal, permitem um sufixo de tipo,
como por exemplo, <code>57u8</code> e <code>_</code> são separadores visuais, tal como <code>1_000</code>.</p>
<p><span class="caption">Tabela 3-2: Inteiros Literais no Rust</span></p>
<table><thead><tr><th> Números literais    </th><th> Exemplo       </th></tr></thead><tbody>
<tr><td> Decimal             </td><td> <code>98_222</code>      </td></tr>
<tr><td> Hexadecimal         </td><td> <code>0xff</code>        </td></tr>
<tr><td> Octal               </td><td> <code>0o77</code>        </td></tr>
<tr><td> Binário             </td><td> <code>0b1111_0000</code> </td></tr>
<tr><td> Byte (<code>u8</code> apenas)  </td><td> <code>b'A'</code>        </td></tr>
</tbody></table>
<p>Então como você pode saber qual tipo de inteiro usar? Se sentir-se inseguro, as
escolhas padrões do Rust geralmente são boas, e por padrão os inteiros são do tipo <code>i32</code>: Esse
tipo geralmente é o mais rápido, até em sistemas de 64-bit. A
principal situação em que você usuaria <code>isize</code> ou <code>usize</code> é indexar algum tipo de coleção.</p>
<a class="header" href="print.html#tipos-de-ponto-flutuante" id="tipos-de-ponto-flutuante"><h4>Tipos de ponto flutuante</h4></a>
<p>Rust também tem dois tipos primitivos para <em>números de ponto flutuante</em>, que são
números com casas decimais. Os pontos flutuantes do Rust são
<code>f32</code> e <code>f64</code>, que têm respectivamente os tamanhos de 32 e 64 bits. O tipo padrão é <code>f64</code>
porque nos processadores modernos, a velocidade é quase a mesma que em um <code>f32</code>, mas possui
maior precisão.</p>
<p>Esse exemplo mostra números de ponto flutuante em ação:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
</code></pre></pre>
<p>Números em ponto flutuante são representados de acordo com o padrão IEEE-754. O tipo
<code>f32</code> é de precisão simples e <code>f64</code> tem precisão dupla.</p>
<a class="header" href="print.html#operações-numéricas" id="operações-numéricas"><h4>Operações numéricas</h4></a>
<p>Rust suporta operações matemáticas básicas, você pode esperar
todas as seguintes operações para todos os tipos numéricos: adição, subtração, multiplicação, divisão e resto.
O código a seguir mostra como usar cada declaração <code>let</code>:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // adição
    let soma = 5 + 10;

    // subtração
    let diferenca = 95.5 - 4.3;

    // multiplicação
    let produto = 4 * 30;

    // divisão
    let quociente = 56.7 / 32.2;

    // resto
    let resto = 43 % 5;
}
</code></pre></pre>
<p>Cada expressão nessas declarações, usa um operador matemático e computa um único valor,
que então é atribuído à uma variável.
Apêndice B contém uma lista de todos os operadores que o Rust suporta.</p>
<a class="header" href="print.html#o-tipo-booleano" id="o-tipo-booleano"><h4>O tipo booleano</h4></a>
<p>Como em diversas linguagens de programação, o tipo Booleano em Rust possue dois valores
possíveis: <code>true</code> e <code>false</code>. O tipo Booleano no Rust é especificado usando <code>bool</code>.
Por exemplo:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let t = true;

    let f: bool = false; // com tipo explícito
}
</code></pre></pre>
<p>A principal utilização de valores Booleanos é através dos condicionais, como um <code>if</code>.
Veremos como a expressão <code>if</code> funciona em Rust na seção
&quot;Controle de fluxo&quot;.</p>
<a class="header" href="print.html#o-tipo-de-caractere" id="o-tipo-de-caractere"><h4>O tipo de caractere</h4></a>
<p>Até agora trabalhamos apenas com números, mas Rust também suporta letras. O <code>char</code>
é o tipo mais primitivo da linguaguem e o seguinte código
mostra uma forma de utilizá-lo. (Observe que o <code>char</code> é
específicado com aspas simples, é o oposto de strings, que usa aspas duplas.)</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let c = 'z';
    let z = 'ℤ';
    let heart_eyed_cat = '😻';
}
</code></pre></pre>
<p>O tipo <code>char</code> representa um valor unicode, o que quer dizer que você pode
armazenar muito mais que apenas ASCII. Letras com acentuação; ideogramas chinês, japonês e
coreano; emoji; e caracteres não visíveis são válidos.
Valores Unicode vão de <code>U+0000</code> até <code>U+D7FF</code> e <code>U+E000</code> até
<code>U+10FFFF</code> incluso. Contudo, um &quot;caractere&quot; não é realmente um conceito em Unicode,
então a sua intuição de o que é um &quot;caractere&quot; pode não combinar com o que é um
<code>char</code> em Rust. Discutiremos esse tópico em detalhes em &quot;Strings&quot; no Capítulo 8.</p>
<a class="header" href="print.html#tipos-compostos" id="tipos-compostos"><h3>Tipos compostos</h3></a>
<p><em>Tipos compostos</em> podem agrupar vários valores em um único tipo. Rust tem dois
tipos primitivos compostos: tuplas e vetores.</p>
<a class="header" href="print.html#o-tipo-tuplaero-de-valores" id="o-tipo-tuplaero-de-valores"><h4>O tipo tuplaero de valores</h4></a>
<p>Uma tupla é de modo geral uma forma de agrupar um certo número de valores
com uma variável do tipo composto.</p>
<p>Criamos uma tupla escrevendo uma lista de valores separados por vírgula
dentro de parênteses. Cada posição da tupla tem um tipo e os tipos dos elementos
da tupla não necessitam serem iguais.
Adicionamos anotações de tipo neste exemplo:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
</code></pre></pre>
<p>A variável <code>tup</code> liga-se a tupla, porque uma tupla é considerada
um único elemento composto. Para pegar os valores da tupla individualmente, podemos usar
a correspondência de padrões para desestruturar o valor de uma tupla, como este:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!(&quot;O valor do y é: {}&quot;, y);
}
</code></pre></pre>
<p>Esse primeito programa cria uma tupla e vincula ela à variável <code>tup</code>. Em seguida,
ele usa um padrão com <code>let</code> para tirar <code>tup</code> e tranformá-lo em três variáveis
separadas, <code>x</code>, <code>y</code> e <code>z</code>. Isso é chamado de <em>desestruturação</em>, porque quebra uma única tupla
em três partes. Finalmente, o programa exibe o valor de <code>y</code>,
que é <code>6.4</code>.</p>
<p>Além de desestruturar através da correspondência de padrões, podemos
acessar diretamente um elemento da tupla usando um ponto (<code>.</code>) como índice
do valor que queremos acessar. Por exemplo:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let quinhentos = x.0;

    let seis_ponto_quatro = x.1;

    let um = x.2;
}
</code></pre></pre>
<p>Esse programa cria uma tupla, <code>x</code>, e então cria uma variável para cada
elemento usando seus índices. Como ocorre nas maiorias das linguagens, o primeiro
índice em uma tupla é o 0.</p>
<a class="header" href="print.html#o-tipo-matriz" id="o-tipo-matriz"><h4>O tipo matriz</h4></a>
<p>Uma outra maneira de ter uma coleção de vários valores é uma <em>matriz</em>. Diferentemente
de uma tupla, todos os elementos de uma matriz devem ser do mesmo tipo.
Matrizes em Rust são diferentes de matrizes de outras linguagens, porque matrizes em Rust são de
tamanhos fixos: uma vez declarado, eles não podem aumentar ou diminuir de tamanho.</p>
<p>Em Rust, os valores que entram numa matriz são escritos em uma lista separados
por vírgulas dentro de colchetes:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];
}
</code></pre></pre>
<p>Matrizes são úteis quando você deseja que seus dados sejam alocados em pilha do que
no heap (discutiremos mais sobre pilha e heap no Capítulo 4), ou quando
você quer garantir que sempre terá um número fixo de elementos. Uma matriz não
é tão flexível como um vetor. Um vetor é de tipo semelhante,
fornecido pela biblioteca padrão que <em>é</em> permitido diminuir ou aumentar o tamanho.
Se você não tem certeza se deve usar uma matriz ou vetor, você provavlemente usará um
vetor. O Capítulo 8 discute sobre vetores com mais detalhes.</p>
<p>Um exemplo de quando você poderia necessitar usar uma matriz no lugar de um vetor é
um programa em que você precisa saber o nome dos meses do ano. É improvável
que tal programa deseje adicionar ou remover meses, então você pode usar uma matriz
porque você sabe que sempre conterá 12 itens:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let meses = [&quot;Janeiro&quot;, &quot;Fevereiro&quot;, &quot;Março&quot;, &quot;Abril&quot;, &quot;Maio&quot;, &quot;Junho&quot;, &quot;Julho&quot;,
              &quot;Agosto&quot;, &quot;Setembro&quot;, &quot;Outubro&quot;, &quot;Novembro&quot;, &quot;Dezembro&quot;];
#}</code></pre></pre>
<a class="header" href="print.html#acessando-um-elemento-da-matriz" id="acessando-um-elemento-da-matriz"><h5>Acessando um elemento da matriz</h5></a>
<p>Uma matriz é um pedaço da memória alocada na pilha. Você pode acessar
os elementos da matriz usando indices, como a seguir:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];

    let primeiro = a[0];
    let segundo = a[1];
}
</code></pre></pre>
<p>Neste exemplo, a variável chamada <code>primeiro</code> irá pegar o valor <code>1</code>, porque
é o valor indexado por <code>[0]</code> na matriz. A variável chamada <code>segundo</code> irá
pegar o valor <code>2</code>, do indice <code>[1]</code> da matriz.</p>
<a class="header" href="print.html#acesso-inválido-a-elemento-da-matriz" id="acesso-inválido-a-elemento-da-matriz"><h5>Acesso inválido a elemento da matriz</h5></a>
<p>O que acontece se você tentar acessar um elemento da matriz que está além do fim
da matriz? Digamos que você mude o exemplo para o código a seguir, que será compilado,
mas existe um erro quando for executar:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let a = [1, 2, 3, 4, 5];
    let indice = 10;

    let elemento = a[indice];

    println!(&quot;O valor do elemento é: {}&quot;, elemento);
}
</code></pre>
<p>Executando esse código usando <code>cargo run</code>, é produzido o seguinte resultado:</p>
<pre><code class="language-text">$ cargo run
   Compiling arrays v0.1.0 (file:///projects/arrays)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/arrays`
thread '&lt;main&gt;' panicked at 'index out of bounds: the len is 5 but the index is
 10', src/main.rs:6
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>A compilação não produz nenhum erro, mas o programa resulta um
erro <em>em tempo de execução</em> e não uma saída com sucesso. Quando você
tenta acessar um elemento usando indexação, o Rust verifica se o índice especificado é menor que o tamaho
da matriz. Se o índice é maior que o tamanho, o Rust vai entrar
em <em>pânico</em>, que é o termo usado pelo Rust quando um programa resulta em erro.</p>
<p>Esse é o primeiro exemplo dos pricípios de segurança do Rust em ação. Em várias
linguagens de baixo nível, esse tipo de verificação não é feita e quando você fornece um
índice incorreto, memória inválida pode ser acessada. Rust protege você deste tipo
de erro ao sair imediatamente, em vez de permitir o acesso à memória e
continuando. O Capítulo 9 discute mais sobre o tratamento de erros do Rust.</p>
<a class="header" href="print.html#funções" id="funções"><h1>Funções</h1></a>
<p>Funções são difundidas em códigos em Rust. Você já viu uma das mais
importantes funções da linguagem: a função <code>main</code>, que é o
ponto de entrada de diversos programas. Você também já viu a notação <code>fn</code>, que permite você
declarar uma nova função.</p>
<p>Códigos em Rust usam, por convenção, o estilo <em>snake case</em> para nomes de função e
variável. No snake case, todas as letras são minúsculas e sublinhado (underline) separa as palavras.
Aqui está um programa que contém uma definição de função de exemplo:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Olá, mundo!&quot;);

    outra_funcao();
}

fn outra_funcao() {
    println!(&quot;Outra função.&quot;);
}
</code></pre></pre>
<p>As definições de funções em Rust iniciam com <code>fn</code> e tem um par de parênteses
depois do nome da função. As chaves dizem ao compilador onde o
corpo da função começa e termina.</p>
<p>Podemos chamar qualqer função que tenhamos definido, inserindo seu nome, seguido de um
conjunto de parenteses. Pelo fato da <code>outra_funcao</code> ter sido definida no programa, ela pode
ser chamada dentro da função <code>main</code>. Note que definimos <code>outra_funcao</code>
<em>depois</em> da função <code>main</code>; poderíamos ter definido antes
também. Rust não se importa onde você definiu suas funções, apenas que elas foram
definidas em algum lugar.</p>
<p>Vamos começar um novo projeto binário, chamado <em>funcoes</em> para explorar mais
funções. Coloque o exemplo <code>outra_funcao</code> em <em>src/main.rs</em> e execute-o. Você
verá a seguinte saída:</p>
<pre><code class="language-text">$ cargo run
   Compiling funcoes v0.1.0 (file:///projects/funcoes)
    Finished dev [unoptimized + debuginfo] target(s) in 0.28 secs
     Running `target/debug/funcoes`
Olá, mundo!
Outra função.
</code></pre>
<p>As linhas são executadas na ordem em que aparecem na função <code>main</code>.
Primeiro, a mensagem &quot;Olá, mundo!&quot; é exibida, e então
<code>outra_funcao</code> é chamada e exibida a mensagem.</p>
<a class="header" href="print.html#parâmetros-de-função" id="parâmetros-de-função"><h3>Parâmetros de função</h3></a>
<p>Funções também podem ser definidas tendo <em>parâmetros</em>, que são variáveis especiais
que fazem parte da assinatura da função. Quando uma função tem parâmetros, você
pode fornecer tipos específicos para esses parâmetros. Tecnicamente, os
valores definidos são chamados de <em>argumentos</em>, mas informalmente, as pessoas tendem
a usar as palavras <em>parâmetro</em> e <em>argumento</em> para falar tanto de
variáveis da definição da função como os valores passados quando você
chama uma função.</p>
<p>A seguinte versão (reescrita) da <code>outra_funcao</code> mostra como os parâmetros
aparecem no Rust:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    outra_funcao(5);
}

fn outra_funcao(x: i32) {
    println!(&quot;O valor de x é: {}&quot;, x);
}
</code></pre></pre>
<p>Tente executar este programa; você verá a seguinte saída:</p>
<pre><code class="language-text">$ cargo run
   Compiling funcoes v0.1.0 (file:///projects/funcoes)
    Finished dev [unoptimized + debuginfo] target(s) in 1.21 secs
     Running `target/debug/funcoes`
O valor de x é: 5
</code></pre>
<p>A declaração de <code>outra_funcao</code> tem um parâmetro chamado <code>x</code>. O tipo do
<code>x</code> é especificado como <code>i32</code>. Quando <code>5</code> é passado para a <code>outra_funcao</code>, a macro
<code>println!</code> coloca <code>5</code> onde o par de chaves estava na string
de formato.</p>
<p>Nas assinaturas de função, você <em>deve</em> declarar o tipo de cada parâmetro. Essa é
decisão deliberada no design do Rust: exigir anotações de tipo na definição da função,
significa que o compilador quase nunca precisará que as use em outro lugar do código
para especificar o que você quer.</p>
<p>Quando você precisa que uma função tenha vários parâmetros, separe as declarações de parâmetros
com vírgula, como a seguir:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    outra_funcao(5, 6);
}

fn outra_funcao(x: i32, y: i32) {
    println!(&quot;O valor de x é: {}&quot;, x);
    println!(&quot;O valor de y é: {}&quot;, y);
}
</code></pre></pre>
<p>Este exemplo cria uma função com dois parâmetros, ambos com o
tipo <code>i32</code>. Então a função exibe os valores de ambos os parâmetros. Note que os
parâmetros de função não precisam ser do mesmo tipo, isto apenas
aconteceu neste exemplo.</p>
<p>Vamos tentar executar este código. Substitua o programa <em>src/main.rs</em>, atualmente em seu projeto <em>funcoes</em>
com o exemplo anterior e execute-o usando <code>cargo run</code>:</p>
<pre><code class="language-text">$ cargo run
   Compiling funcoes v0.1.0 (file:///projects/funcoes)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/funcoes`
O valor de x é: 5
O valor de y é: 6
</code></pre>
<p>Porque nós chamamos a função com <code>5</code> sendo o valor de<code>x</code> e <code>6</code> é passado
como o valor de <code>y</code>, as duas cadeias são impressas com esses valores.</p>
<a class="header" href="print.html#corpos-de-função" id="corpos-de-função"><h3>Corpos de função</h3></a>
<p>Corpos de função são constituídos por uma série de declarações que terminam,
opcionalmente, em uma expressão. Até agora, foram apresentadas apenas funções sem uma expressão final,
mas você viu uma expressão como parte de instruções. Porque Rust é uma
linguagem baseada em expressão, essa é uma importante distinção a ser entendida.
Outras linguagens não têm as mesmas distinções, então, vamos ver o que são
declarações e expressões e como elas afetam o corpo
das funções.</p>
<a class="header" href="print.html#declarações-e-expressões" id="declarações-e-expressões"><h3>Declarações e Expressões</h3></a>
<p>Na verdade, já usamos declarações e expressões. <em>Declarações</em> são
instruções que executam alguma ação e não retornam um resultado. E <em>expressões</em>
retornam um resultado. Vamos ver alguns exemplos.</p>
<p>Criar uma variável e atribuir um valor a ela com a palavra-chave <code>let</code> é uma declaração.
Na Listagem 3-1, <code>let y = 6;</code> é uma declaração:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let y = 6;
}
</code></pre></pre>
<p><span class="caption">Listagem 3-1: A declaração da função <code>main</code> contendo uma declaração.</span></p>
<p>Definições de função também são definições; todo o exemplo
é uma declaração em si.</p>
<p>Definições não retornam valores. Assim sendo, você não pode atribuir uma declaração <code>let</code> para
outra variável, como o código a seguir tenta fazer; você receberá um erro:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let x = (let y = 6);
}
</code></pre>
<p>Quando você rodar esse programa, o erro será o seguinte:</p>
<pre><code class="language-text">$ cargo run
   Compiling funcoes v0.1.0 (file:///projects/funcoes)
error: expected expression, found statement (`let`)
 --&gt; src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^
  |
  = note: variable declaration using `let` is a statement
</code></pre>
<p>A declaração <code>let y = 6</code> não retorna um valor, então não existe nada para o
<code>x</code> se ligar. Isso é diferente do que acontece em
outras linguagens, como
C e Ruby, onde a atribuição retorna o valor atribuído. Nestas linguagens, você pode escrever <code>x = y = 6</code> e ter ambos, <code>x</code> e <code>y</code> contendo o valor
<code>6</code>; esse não é o caso em Rust.</p>
<p>Expressões avaliam algo e compõem a maior parte do código que
você escreverá em Rust. Considere uma simples operação matemática, como um <code>5 + 6</code>, que
é uma expressão que avalia o valor <code>11</code>. Expressões podem fazer parte de
declarações: na Listagem 3-1, o <code>6</code> na declaração <code>let y = 6;</code> é uma
expressão que avalia o valor <code>6</code>. A chamada de função é uma
expressão. Chamar uma macro é uma expressão. O bloco que vamos usar para criar
um novo escopo, <code>{}</code>, é uma expressão, por exemplo:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 5;

    let y = {
        let x = 3;
        x + 1
    };

    println!(&quot;O valor de y é: {}&quot;, y);
}
</code></pre></pre>
<p>A expressão:</p>
<pre><code class="language-rust ignore">{
    let x = 3;
    x + 1
}
</code></pre>
<p>é um bloco que, nesse exemplo, avalia <code>4</code>. Esse valor fica vinculado ao <code>y</code>
como parte da declaração <code>let</code>. Note o  <code>x + 1</code> sem um ponto e vírgula no final, que é diferente da maioria das linhas vistas até agora.
Expressões não terminam com ponto e vírgula.
Se você adicionar um ponto e vírgula ao fim de uma expressão,
você a transforma em uma declaração, que então não retornará um valor.
Tenha isso em mente, enquanto explora os valores e expressões de retorno da função a seguir.</p>
<a class="header" href="print.html#funções-com-valor-de-retorno" id="funções-com-valor-de-retorno"><h3>Funções com valor de retorno</h3></a>
<p>Funções podem retornar valores para o código que os chama. Não nomeamos valores de
retorno, mas declaramos o tipo deles depois de uma seta (<code>-&gt;</code>). Em Rust, o valor de retorno
da função é sinônimo do valor da expressão
final no bloco do corpo de uma função. Você pode retornar cedo de uma função usando
a palavra-chave <code>return</code> e especificando um valor, mas a maioria das funções retorna
a última expressão implicitamente. Veja um exemplo de uma função que retorna um
valor:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn cinco() -&gt; i32 {
    5
}

fn main() {
    let x = cinco();

    println!(&quot;O valor de x é: {}&quot;, x);
}
</code></pre></pre>
<p>Não há chamadas de função, macros ou até mesmo declarações <code>let</code> na função<code>cinco</code></p>
<ul>
<li>apenas o número <code>5</code> por si só. Essa é uma função perfeitamente válida em
Rust. Observe que o tipo de retorno da função também é especificado como <code>-&gt; i32</code>. Tente
executar este código; a saída deve ficar assim:</li>
</ul>
<pre><code class="language-text">$ cargo run
   Compiling funcoes v0.1.0 (file:///projects/funcoes)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30 secs
     Running `target/debug/funcoes`
O valor de x é: 5
</code></pre>
<p>O <code>5</code> em<code>cinco</code> é o valor de retorno da função, e é por isso que o tipo de retorno
é <code>i32</code>. Vamos verificar isso com mais detalhes. Existem dois bits importantes:
primeiro, a linha <code>let x = cinco ();</code> mostra que estamos usando o valor de retorno de uma
função para inicializar uma variável. Porque a função <code>cinco</code> retorna um<code>5</code>,
essa linha é a mesma que a seguinte:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
#}</code></pre></pre>
<p>Em segundo lugar, a função <code>cinco</code> não tem parâmetros e define o tipo de
valor de retorno, mas o corpo da função é um <code>5</code> solitário sem ponto e vírgula
porque é uma expressão cujo valor queremos retornar.</p>
<p>Vamos ver outro exemplo:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = soma_um(5);

    println!(&quot;O valor de x é: {}&quot;, x);
}

fn soma_um(x: i32) -&gt; i32 {
    x + 1
}
</code></pre></pre>
<p>A execução deste código irá imprimir <code>O valor de x é: 6</code>. Mas se colocarmos um
ponto e vírgula no final da linha que contém <code>x + 1</code>, alterando-o de
expressão para uma declaração, receberemos um erro.</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let x = soma_um(5);

    println!(&quot;O valor de x é: {}&quot;, x);
}

fn soma_um(x: i32) -&gt; i32 {
    x + 1;
}
</code></pre>
<p>Executar este código produz um erro, da seguinte maneira:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:7:28
  |
7 |   fn soma_um(x: i32) -&gt; i32 {
  |  ____________________________^
8 | |     x + 1;
  | |          - help: consider removing this semicolon
9 | | }
  | |_^ expected i32, found ()
  |
  = note: expected type `i32`
             found type `()`
</code></pre>
<p>A principal mensagem de erro, &quot;tipos incompatíveis&quot;, revela o problema central com este
código. A definição da função <code>soma_um</code> diz que retornará uma
<code>i32</code>, mas as declarações não avaliam um valor expresso por<code>()</code>,
a tupla vazia. Portanto, nada é retornado, o que contradiz a função
definição e resulta em erro. Nesta saída, Rust fornece uma mensagem para
possivelmente ajudar a corrigir este problema: sugere a remoção do ponto e vírgula, que
iria corrigir o erro.</p>
<a class="header" href="print.html#comentários" id="comentários"><h2>Comentários</h2></a>
<p>Todos os programadores se esforçam para tornar seu código fácil de entender, mas às vezes
explicação extra é garantida. Nestes casos, os programadores deixam notas ou
<em>comentários</em>, em seus códigos fonte que o compilador irá ignorar, mas as pessoas que
lerem o código-fonte podem achar útil.</p>
<p>Aqui está um comentário simples:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Olá, mundo.
#}</code></pre></pre>
<p>Em Rust, os comentários devem começar com duas barras e continuar até o final da
linha. Para comentários que se estendem além de uma única linha, você precisará incluir
<code>//</code> em cada linha, assim:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Então, estamos fazendo algo complicado aqui, tempo suficiente para que precisemos
// várias linhas de comentários para fazer isso! Ufa! Espero que este comentário
// explique o que está acontecendo.
#}</code></pre></pre>
<p>Comentários também podem ser colocados no final das linhas contendo código:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let numero_da_sorte = 7; // Estou com sorte hoje.
}
</code></pre></pre>
<p>Mas você verá com mais frequência essas palavras nesse formato, com o comentário em uma
linha separada acima do código que está anotando:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // Estou com sorte hoje.
    let numero_da_sorte = 7;
}
</code></pre></pre>
<p>O Rust também tem outro tipo de comentário, comentários de documentação, que discutiremos
no Capítulo 14.</p>
<a class="header" href="print.html#controle-de-fluxo" id="controle-de-fluxo"><h2>Controle de fluxo</h2></a>
<p>Decidir se deve ou não executar algum código, dependendo se uma condição é verdadeira
e decidir executar algum código repetidamente enquanto uma condição é verdadeira,
são blocos de construção básicos na maioria das linguagens de programação. As construções
mais comuns que permitem controlar o fluxo de execução do código Rust são as expressões <code>if</code> e
laços de repetição.</p>
<a class="header" href="print.html#expressão-if" id="expressão-if"><h3>Expressão <code>if</code></h3></a>
<p>Uma expressão <code>if</code> permite ramificar seu código dependendo das condições. Você
fornecer uma condição e, em seguida, estado, &quot;Se esta condição for cumprida, execute este bloco
de código. Se a condição não for atendida, não execute este bloco de código. ”</p>
<p>Crie um novo projeto chamado <em>branches</em> no seu diretório <em>projects</em> para explorar
a expressão <code>if</code>. No arquivo * src / main.rs *, digite o seguinte:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let numero = 3;

    if numero &lt; 5 {
        println!(&quot;condição era verdadeira&quot;);
    } else {
        println!(&quot;condição era falsa&quot;);
    }
}
</code></pre></pre>
<!-- NEXT PARAGRAPH WRAPPED WEIRD INTENTIONALLY SEE #199 -->
<p>Todas as expressões <code>if</code> começam com a palavra-chave <code>if</code>, que é seguida por uma
condição. Neste caso, a condição verifica se a variável
<code>number</code> tem um valor menor que 5. O bloco de código que queremos executar se o
condição é verdadeira é colocada imediatamente após a condição dentro de chaves.
Blocos de código associados às condições em expressões <code>if</code> são
às vezes chamado de <em>divisões</em>, assim como as expressões <code>de combinação</code> que nós
discutimos na seção “Comparando o Palpite ao Número Secreto” de
Capítulo 2.</p>
<p>Opcionalmente, também podemos incluir uma expressão <code>else</code>, que escolhemos
fazer aqui, para dar ao programa um bloco de código alternativo a ser executado, caso a
condição seja avaliada como falsa. Se você não fornecer uma expressão <code>else</code> e a
condição for falsa, o programa simplesmente ignorará o bloco <code>if</code> e passará para o
próximo bit de código.</p>
<p>Tente executar este código; você deve ver a seguinte saída:</p>
<pre><code class="language-text">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/branches`
condição era verdadeira
</code></pre>
<p>Vamos tentar alterar o valor de <code>numero</code> para um valor que torne a condição
<code>false</code> para ver o que acontece:</p>
<pre><code class="language-rust ignore">let numero = 7;
</code></pre>
<p>Execute o programa novamente e observe a saída:</p>
<pre><code class="language-text">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/branches`
condição era falsa
</code></pre>
<p>Também é importante notar que a condição neste código <em>deve</em> ser um <code>bool</code>. E se
a condição não é um <code>bool</code>, nós vamos receber um erro. Por exemplo:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let numero = 3;

    if numero {
        println!(&quot;número era 3&quot;);
    }
}
</code></pre>
<p>A condição <code>if</code> é avaliada para um valor de <code>3</code> desta vez, e Rust lança um
erro:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:4:8
  |
4 |     if numero {
  |        ^^^^^^ expected bool, found integral variable
  |
  = note: expected type `bool`
             found type `{integer}`
</code></pre>
<p>O erro indica que Rust esperava um <code>bool</code>, mas obteve um inteiro. Ao contrário de
linguagens como Ruby e JavaScript, o Rust não tentará automaticamente
converter tipos não-booleanos em um booleano. Você deve explicitar e sempre fornecer
<code>if</code> com um booleano como sua condição. Se quisermos que o bloco de código <code>if</code> seja executado
somente quando um número não é igual a <code>0</code>, por exemplo, podemos mudar o <code>if</code>
para o seguinte:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let numero = 3;

    if numero != 0 {
        println!(&quot;número era algo diferente de zero&quot;);
    }
}
</code></pre></pre>
<p>A execução deste código irá imprimir <code>número era algo diferente de zero</code>.</p>
<a class="header" href="print.html#gerenciando-múltiplas-condições-com-else-if" id="gerenciando-múltiplas-condições-com-else-if"><h4>Gerenciando Múltiplas Condições com <code>else if</code></h4></a>
<p>Você pode ter várias condições combinando <code>if</code> e<code>else</code> em um <code>else if</code>.
Por exemplo:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let numero = 6;

    if numero % 4 == 0 {
        println!(&quot;número é divisível por 4&quot;);
    } else if numero % 3 == 0 {
        println!(&quot;número é divisível por 3&quot;);
    } else if numero % 2 == 0 {
        println!(&quot;número é divisível por 2&quot;);
    } else {
        println!(&quot;número não é divisível por 4, 3 ou 2&quot;);
    }
}
</code></pre></pre>
<p>Este programa tem quatro caminhos possíveis. Depois de executá-lo, você deve
ver a seguinte saída:</p>
<pre><code class="language-text">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/branches`
número é divisível por 3
</code></pre>
<p>Quando este programa é executado, ele verifica cada expressão <code>if</code> por sua vez e executa
o primeiro corpo para o qual a condição é verdadeira. Note que mesmo que 6 seja
divisível por 2, nós não vemos a saída <code>o número é divisível por 2</code>, nem vemos o
texto <code>número não é divisível por 4, 3 ou 2</code> do bloco <code>else</code>.
Isso ocorre porque o Rust só executa o bloco para a primeira condição verdadeira e,
depois de encontrar um, não verifica o restante.</p>
<p>Usar muitas expressões <code>else if</code> pode confundir seu código, portanto, se você tiver
mais de uma, convém refatorar seu código. O Capítulo 6 descreve uma poderosa
construção de ramificação em Rust chamada <code>match</code> para esses casos.</p>
<a class="header" href="print.html#usando-if-em-uma-declaração-let" id="usando-if-em-uma-declaração-let"><h4>Usando <code>if</code> em uma declaração <code>let</code></h4></a>
<p>Pelo fato de <code>if</code> ser uma expressão, podemos usá-la do lado direito de uma declaração <code>let</code>,
como na Listagem 3-2:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let condicao = true;
    let numero = if condicao {
        5
    } else {
        6
    };

    println!(&quot;O valor do número é: {}&quot;, numero);
}
</code></pre></pre>
<p><span class = "caption"> Listagem 3-2: Atribuindo o resultado de uma expressão <code>if</code>
para uma variável </span></p>
<p>A variável <code>numero</code> será ligada a um valor baseado no resultado da expressão <code>if</code>.
Execute este código para ver o que acontece:</p>
<pre><code class="language-text">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30 secs
     Running `target/debug/branches`
O valor do número é: 5
</code></pre>
<p>Lembre-se de que os blocos de código são avaliados até a última expressão, e os
números por si mesmos também são expressões. Neste caso, o valor de
toda a expressão <code>if</code> depende de qual bloco de código é executado. Isso significa que
os valores que têm o potencial de serem resultados de cada braço do <code>if</code> e que devem ser
do mesmo tipo; na Listagem 3-2, os resultados do braço <code>if</code> e do <code>else</code>
eram inteiros <code>i32</code>. Se os tipos forem incompatíveis, como no exemplo a
seguir, receberemos um erro:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let condicao = true;

    let numero = if condicao {
        5
    } else {
        &quot;seis&quot;
    };

    println!(&quot;O valor do número é: {}&quot;, numero);
}
</code></pre>
<p>Quando tentamos executar esse código, recebemos um erro. Os braços <code>if</code> e<code>else</code> possuem
valores de tipos que são incompatíveis, e Rust indica exatamente onde encontrar o
problema no programa:</p>
<pre><code class="language-text">error[E0308]: if and else have incompatible types
 --&gt; src/main.rs:4:18
  |
4 |       let numero = if condicao {
  |  __________________^
5 | |         5
6 | |     } else {
7 | |         &quot;seis&quot;
8 | |     };
  | |_____^ expected integral variable, found &amp;str
  |
  = note: expected type `{integer}`
             found type `&amp;str`
</code></pre>
<p>A expressão no bloco <code>if</code> é avaliada como um inteiro, e a expressão no bloco<code>else</code> é
avaliada como uma string. Isso não funcionará porque as variáveis precisam ter
um único tipo. Rust precisa saber em tempo de compilação qual é o tipo da variável <code>numero</code>,
definitivamente, para que possa verificar em tempo de compilação que seu tipo é
válido em todos os lugares em que usamos <code>numero</code>. Rust não seria capaz de fazer isso se o tipo
de <code>numero</code> fosse determinado apenas em tempo de execução; o compilador seria mais complexo e
faria menos garantias sobre o código se tivesse que manter o controle de
vários tipos hipotéticos para qualquer variável.</p>
<a class="header" href="print.html#repetição-com-laços-de-repetição" id="repetição-com-laços-de-repetição"><h3>Repetição com laços de repetição</h3></a>
<p>Geralmente, é útil executar um bloco de código mais de uma vez. Para essa tarefa,
o Rust fornece vários <em>loops</em>. Um loop percorre o código dentro do corpo do loop
até o final e, em seguida, inicia imediatamente no início. Para
experimentar loops, vamos criar um novo projeto chamado <em>loops</em>.</p>
<p>O Rust possui três tipos de loops: <code>loop</code>,<code>while</code> e <code>for</code>. Vamos tentar cada um.</p>
<a class="header" href="print.html#código-de-repetição-com-loop" id="código-de-repetição-com-loop"><h4>Código de Repetição com <code>loop</code></h4></a>
<p>A palavra-chave <code>loop</code> diz ao Rust para executar um bloco de código várias vezes
para sempre ou até que você diga explicitamente para parar.</p>
<p>Como exemplo, altere o arquivo <em>src/main.rs</em> do diretório <em>loops</em> para algo
como isso:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    loop {
        println!(&quot;novamente!&quot;);
    }
}
</code></pre>
<p>Quando executamos este programa, veremos ``novamente!` impresso repetidamente
até que paremos o programa manualmente. A maioria dos terminais suporta um atalho de teclado,
<span class = "keystroke"> ctrl-c </span>, para parar um programa que está preso em um
loop contínuo. De uma chance:</p>
<pre><code class="language-text">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.29 secs
     Running `target/debug/loops`
novamente!
novamente!
novamente!
novamente!
^Cnovamente!
</code></pre>
<p>O símbolo <code>^C</code> representa onde você pressionou <span class ="keystroke"> ctrl-c
</span>. Você pode ou não ver a palavra <code>novamente!</code> Impressa depois do <code>^C</code>,
dependendo de onde o código estava no loop quando recebeu o sinal de parada.</p>
<p>Felizmente, o Rust oferece outra maneira mais confiável de sair de um loop.
Você pode colocar a palavra-chave <code>break</code> dentro do loop para dizer ao programa quando
parar de executar o loop. Lembre-se que fizemos isso no jogo de adivinhação no
“Quitting After a Guess Correct” do Capítulo 2 para sair do
programa quando o usuário ganhou o jogo, adivinhando o número correto.</p>
<a class="header" href="print.html#loops-condicionais-com-while" id="loops-condicionais-com-while"><h4>Loops condicionais com <code>while</code></h4></a>
<p>Geralmente, é útil para um programa avaliar uma condição dentro de um loop. Enquanto
a condição é verdadeira, o loop é executado. Quando a condição deixa de ser verdadeira,
o programa chama o <code>break</code>, parando o loop. Esse tipo de loop pode ser implementado
usando uma combinação de <code>loop</code>,<code>if</code>, <code>else</code> e<code>break</code>; você poderia tentar isso
agora em um programa, se você quiser.</p>
<p>No entanto, esse padrão é tão comum que o Rust possui uma construção de linguagem integrada
para isso, chamado de loop <code>while</code>. A Listagem 3-3 usa <code>while</code>: o programa faz o loop
três vezes, a contagem decrescente de cada vez e, depois do ciclo, imprime
outra mensagem e sai.</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut numero = 3;

    while numero != 0 {
        println!(&quot;{}!&quot;, numero);

        numero = numero - 1;
    }

    println!(&quot;LIFTOFF!!!&quot;);
}
</code></pre></pre>
<p><span class = "caption"> Listagem 3-3: Usando um loop <code>while</code> para executar o código enquanto
condição for verdadeira </span></p>
<p>Essa construção elimina muito o aninhamento que seria necessário se você usasse
<code>loop</code>,<code>if</code>, <code>else</code> e<code>break</code>, e é mais claro. Enquanto a condição for
verdadeira, o código é executado; caso contrário, sai do loop.</p>
<a class="header" href="print.html#looping-através-de-uma-coleção-com-for" id="looping-através-de-uma-coleção-com-for"><h4>Looping através de uma coleção com <code>for</code></h4></a>
<p>Você poderia usar a construção <code>while</code> para fazer um loop sobre os elementos de uma coleção,
como uma matriz. Por exemplo, vamos ver a Listagem 3-4:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut indice = 0;

    while indice &lt; 5 {
        println!(&quot;O valor é: {}&quot;, a[indice]);

        indice = indice + 1;
    }
}
</code></pre></pre>
<p><span class = "caption"> Listagem 3-4: percorrendo cada elemento de uma coleção
usando um loop <code>while</code> </span></p>
<p>Aqui, o código conta através dos elementos na matriz. Começa no índice
<code>0</code> e, em seguida, faz um loop até atingir o índice final na matriz (isto é,
quando <code>indice &lt;5</code> não é mais verdadeiro). Executando este código irá imprimir todos os elementos
na matriz:</p>
<pre><code class="language-text">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
     Running `target/debug/loops`
O valor é: 10
O valor é: 20
O valor é: 30
O valor é: 40
O valor é: 50
</code></pre>
<p>Todos os cinco valores de matriz aparecem no terminal, conforme esperado. Embora <code>indice</code>
vai chegar a um valor de <code>5</code> em algum momento, o loop para de executar antes de tentar
para buscar um sexto valor da matriz.</p>
<p>Mas essa abordagem é propensa a erros; poderíamos fazer o programa entrar em pânico se o
o comprimento do índice estivesse incorreto. Também é lento, porque o compilador adiciona código de tempo de execução
para executar a verificação condicional em cada elemento em cada iteração
através do loop.</p>
<p>Como uma alternativa mais concisa, você pode usar um laço <code>for</code> e executar algum código
para cada item de uma coleção. Um laço <code>for</code> parece com este código na Listagem 3-5:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];

    for elemento in a.iter() {
        println!(&quot;O valor é: {}&quot;, elemento);
    }
}
</code></pre></pre>
<p><span class = "caption"> Listagem 3-5: percorrendo cada elemento de uma coleção
usando um laço <code>for</code> </span></p>
<p>Quando executamos esse código, veremos a mesma saída da listagem 3-4. Mais
importante, agora aumentamos a segurança do código e eliminamos a
chance de erros que podem resultar de ir além do final da matriz ou não
indo longe o suficiente e faltando alguns itens.</p>
<p>Por exemplo, no código da Listagem 3-4, se você removeu um item do array <code>a</code>,
mas esqueceu de atualizar a condição para <code>while indice &lt;4</code>, o código causaria um
pânico. Usando o loop <code>for</code>, você não precisa se lembrar de alterar qualquer outro
código se você alterou o número de valores na matriz.</p>
<p>A segurança e a concisão dos loops <code>for</code> fazem deles o loop mais comumente usado
em Rust. Mesmo em situações em que você deseja executar algum código
certo número de vezes, como no exemplo da contagem regressiva que usou um loop <code>while</code>
da Listagem 3-3, a maioria dos Rustaceans usaria um loop <code>for</code>. A maneira de fazer isso
seria usar um <code>Range</code>, que é um tipo fornecido pela biblioteca padrão
que gera todos os números em sequência a partir de um número e terminando
antes de outro número.</p>
<p>Veja como seria a contagem regressiva usando um loop <code>for</code> e outro método,
que nós ainda não falamos, <code>rev</code>, para reverter o intervalo:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    for numero in (1..4).rev() {
        println!(&quot;{}!&quot;, numero);
    }
    println!(&quot;LIFTOFF!!!&quot;);
}
</code></pre></pre>
<p>Este código é um pouco melhor, não é?</p>
<a class="header" href="print.html#resumo-1" id="resumo-1"><h2>Resumo</h2></a>
<p>Você conseguiu! Esse foi um capítulo considerável: você aprendeu sobre variáveis, tipos
de dados escalares e compostos, funções, comentários, expressões <code>if</code> e loops! E se
você quer praticar com os conceitos discutidos neste capítulo, tente construir
programas para fazer o seguinte:</p>
<ul>
<li>Converta temperaturas entre Fahrenheit e Celsius.</li>
<li>Gerar o n-ésimo número de Fibonacci.</li>
<li>Imprima a letra da canção de natal &quot;Os Doze Dias de Natal&quot;
aproveitando a repetição na música.</li>
</ul>
<p>Quando você estiver pronto para seguir em frente, falaremos sobre um conceito em Rust que <em>não</em>
comumente existente em outras linguagens de programação: propriedade.</p>
<a class="header" href="print.html#entendendo-ownership" id="entendendo-ownership"><h1>Entendendo <em>Ownership</em></h1></a>
<p><em>Ownership</em> (posse) é a característica mais única do Rust, que o permite ter
garantias de segurança de memória sem precisar de um <em>garbage collector</em>. Logo,
é importante entender como funciona ownership no Rust. Neste capítulo, falaremos
sobre ownership e também sobre várias características relacionadas: <em>borrowing</em>,
<em>slices</em> e como o Rust dispõe seus dados na memória.</p>
<a class="header" href="print.html#o-que-É-ownership" id="o-que-É-ownership"><h2>O Que É Ownership?</h2></a>
<p>A característica central do Rust é <em>ownership</em>. Embora seja bem direta de
explicar, ela tem implicações profundas em todo o resto da linguagem.</p>
<p>Todos os programas têm que decidir de que forma vão usar a memória do computador
durante a execução. Algumas linguagens possuem <em>garbage collection</em> (coleta de
lixo), que constantemente busca segmentos de memória que já não são mais
utilizados enquanto o programa executa; em outras linguagens, o programador deve
alocar e liberar memória de forma explícita. Rust usa uma terceira abordagem: a
memória é gerenciada através de um sistema de posse, que tem um conjunto de
regras verificadas em tempo de compilação. Nenhuma característica relacionada ao
ownership implica qulaquer custo em tempo de execução.</p>
<p>Como ownership é um conceito novo para muitos programadores, leva um pouco de
tempo para se acostumar. A boa notícia é que quanto mais experiente você se
torna em Rust e nas regras do sistema de posse, mais você será capaz de
escrever, naturalmente, código seguro e eficiente. Fique aí!</p>
<p>Quando você entender ownership, você terá uma fundação sólida para entender as
características que fazem o Rust ser único. Neste capítulo, você vai aprender
ownership trabalhando em alguns exemplos com foco em uma estrutura de dados
muito comum: <em>strings</em>.</p>
<!-- PROD: START BOX -->
<blockquote>
<a class="header" href="print.html#a-pilha-e-a-heap" id="a-pilha-e-a-heap"><h3>A Pilha e a <em>Heap</em></h3></a>
<p>Em muitas linguagens de programação, não temos que pensar muito sobre a pilha
e sobre a <em>heap</em>. Mas em uma linguagem de programação de sistemas, como Rust,
o fato de um valor estar na pilha ou na heap tem impacto na forma como a
linguagem se comporta e no porquê de termos que tomar certas decisões. Vamos
descrever partes do ownership em relação à pilha e à heap mais para a frente
neste capítulo, então aqui vai uma explicação preparatória.</p>
<p>Tanto a pilha como a heap são partes da memória que estão disponíveis ao seu
código para uso em tempo de execução, mas elas são estruturadas de formas
diferentes. A pilha armazena valores na ordem em que eles chegam, e os remove
na ordem inversa. Isto é chamado de <em>last in, first out</em> (último a chegar,
primeiro a sair). Imagine uma pilha de pratos: quando você coloca mais pratos,
você os põe em cima da pilha, e quando você precisa de um prato, você pega o
que está no topo. Adicionar ou remover pratos do meio ou do fundo não funciona
tão bem! Dizemos fazer um <em>push</em> na pilha quando nos refererimos a inserir
dados, e fazer um <em>pop</em> da pilha quando nos referimos a remover dados.</p>
<p>A pilha é rápida por conta da forma como ela acessa os dados: ela nunca tem
que procurar um lugar para colocar novos dados, ou um lugar de onde obter
dados, este lugar é sempre o topo da pilha. Outra propriedade que faz a pilha
ser rápida é que todos os dados contidos nela devem ocupar um tamanho fixo e
conhecido.</p>
<p>Para dados com um tamanho desconhecido em tempo de compilação, ou com um
tamanho que pode mudar, podemos usar a heap em vez da pilha. A heap é menos
organizada: quando colocamos dados na heap, nós pedimos um certo espaço de
memória. O sistema operacional encontra um espaço vazio em algum lugar na heap
que seja grande o suficiente, marca este espaço como em uso, e nos retorna um
<em>ponteiro</em>, que é o endereço deste local. Este processo é chamado de
<em>alocar na heap</em>, e às vezes se abrevia esta frase como apenas &quot;alocação&quot;.
Colocar valores na pilha não é considerado uma alocação. Como o ponteiro tem
um tamanho fixo e conhecido, podemos armazená-lo na pilha, mas quando queremos
os dados, de fato, temos que seguir o ponteiro.</p>
<p>Imagine que você está sentado em um restaurante. Quando você entra, você diz
o número de pessoas que estão com você, o atendente encontra uma mesa vazia
que acomode todos e os leva para lá. Se alguém do seu grupo chegar mais tarde,
poderá perguntar onde vocês estão para encontrá-los.</p>
<p>Acessar dados na heap é mais lento do que acessar dados na pilha, porque você
precisa seguir um ponteiro para chegar lá. Processadores de hoje em dia são
mais rápidos se não precisarem pular tanto de um lugar para outro na memória.
Continuando com a analogia, considere um garçom no restaurante anotando os
pedidos de várias mesas. É mais eficiente anotar todos os pedidos de uma única
mesa antes de passar para a mesa seguinte. Anotar um pedido da mesa A, depois
um da mesa B, depois outro da mesa A, e outro da mesa B novamente seria um
processo bem mais lento. Da mesma forma, um processador pode cumprir melhor
sua tarefa se trabalhar em dados que estão próximos uns dos outros (assim como
estão na pilha) em vez de dados afastados entre si (como podem estar na heap).
Alocar um espaço grande na heap também pode levar tempo.</p>
<p>Quando nosso código chama uma função, os valores passados para ela (incluindo
possíveis ponteiros para dados na heap) e as variáveis locais da função são
colocados na pilha. Quando a função termina, esses valores são removidos dela.</p>
<p>Rastrear quais partes do código estão usando quais dados na heap, minimizar a
quantidade de dados duplicados na heap e limpar segmentos inutilizados da heap
para que não fiquemos sem espaço são todos problemas tratados pelo ownership.
Uma vez que você entende ownership, você não vai mais precisar pensar tanto
sobre a pilha e a heap, mas saber que ownership existe para gerenciar os dados
na heap pode ajudar a explicar como e por que ele funciona.</p>
</blockquote>
<!-- PROD: END BOX -->
<a class="header" href="print.html#regras-de-ownership" id="regras-de-ownership"><h3>Regras de Ownership</h3></a>
<p>Primeiro, vamos dar uma olhada nas regras de ownership. Mantenha em mente essas
regras quando trabalharmos com os exemplos em seguida:</p>
<blockquote>
<ol>
<li>Cada valor em Rust possui uma variável que é dita seu <em>owner</em> (sua dona).</li>
<li>Pode apenas haver um owner por vez.</li>
<li>Quando o owner sai fora de escopo, o valor será destruído.</li>
</ol>
</blockquote>
<a class="header" href="print.html#escopo-de-variáveis" id="escopo-de-variáveis"><h3>Escopo de Variáveis</h3></a>
<p>Já analisamos um exemplo de programa em Rust no Capítulo 2. Agora que já
passamos da sintaxe básica, não vamos incluir o código <code>fn main() {</code> nos
próximos exemplos, então se você estiver acompanhando, terá que colocá-los
manualmente dentro de uma função <code>main</code>. Como resultado, nossos exemplos serão
um pouco mais concisos, mantendo o foco nos detalhes que realmente interessam.</p>
<p>Como um primeiro exemplo de ownership, vamos olhar para o <em>escopo</em> de algumas
variáveis. Um escopo é a área dentro de um programa para a qual um item é
válido. Digamos que nós temos uma variável como esta:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = &quot;olá&quot;;
#}</code></pre></pre>
<p>A variável <code>s</code> se refere a uma string literal cujo valor é fixo no código. A
variável é válida do ponto em que é declarada até o fim do atual <em>escopo</em>. A
Listagem 4-1 tem comentários indicando onde a variável <code>s</code> é válida:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{                      // s não é válida aqui, ainda não está declarada
    let s = &quot;texto&quot;;   // s é válida deste ponto em diante

    // faz alguma coisa com s
}                      // agora este escopo terminou, e s não é mais válida
#}</code></pre></pre>
<p><span class="caption">Listagem 4-1: Uma variável e o escopo em que ela é
válida.</span></p>
<p>Em outras palavras, existem dois pontos no tempo que são importantes aqui:</p>
<ol>
<li>Quando <code>s</code> <em>entra no escopo</em>, ela é válida.</li>
<li>Permanece dessa maneira até que ela <em>saia de escopo</em>.</li>
</ol>
<p>Neste ponto, a relação entre escopos e quando variáveis são válidas é similar a
outras linguagens de programação. Agora vamos construir sobre este entendimento,
apresentando o tipo <code>String</code>.</p>
<a class="header" href="print.html#o-tipo-string" id="o-tipo-string"><h3>O Tipo <code>String</code></h3></a>
<p>Para ilustrar as regras de ownership, precisamos de um tipo de dados que seja
mais complexo do que aqueles abordados no Capítulo 3. Os tipos abordados na
seção &quot;Tipos de Dados&quot; são todos armazenados na pilha, e retirados dela quando
seu escopo termina, mas queremos ver dados que são armazenados na heap e
explorar como o Rust faz para saber quando limpar esses dados.</p>
<p>Vamos usar <code>String</code> como exemplo aqui, e concentrar nas partes de <code>String</code> que
estão relacionadas ao ownership. Esses aspectos também se aplicam aos outros
tipos complexos de dados fornecidos pela biblioteca padrão e os que você mesmo
cria. Vamos discutir <code>String</code> mais a fundo no Capítulo 8.</p>
<p>Já vimos strings literais, em que um valor de string é fixado pelo código do
nosso programa. Strings literais são convenientes, mas nem sempre são adequadas
para situações em que queremos usar texto. Um motivo é que elas são imutáveis.
Outro é que nem todos os valores de string são conhecidos enquanto escrevemos
nosso código: por exemplo, o que fazer se queremos obter uma entrada do usuário
e armazená-la? Para essas situações, Rust tem um segundo tipo de strings,
<code>String</code>. Este tipo é alocado na heap, e como tal, é capaz de armazenar uma
quantidade de texto que é desconhecida em tempo de compilação. Você pode criar
uma <code>String</code> de uma string literal usando a função <code>from</code>, da seguinte forma:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;texto&quot;);
#}</code></pre></pre>
<p>O <code>::</code> é um operador que nos permite indicar que o <em>namespace</em> desta função
<code>from</code>, em particular, é o tipo <code>String</code>, de forma que não precisamos usar um
nome específico como <code>string_from</code>. Vamos discutir esta sintaxe na seção
&quot;Sintaxe do Método&quot; do Capítulo 5, e quando falarmos sobre <em>namespaces</em> com
módulos no Capítulo 7.</p>
<p>Este tipo de string <em>pode</em> ser alterada:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::from(&quot;olá&quot;);

s.push_str(&quot;, mundo!&quot;); // push_str() adiciona um literal à String

println!(&quot;{}&quot;, s); // Isso vai exibir `olá, mundo!`
#}</code></pre></pre>
<p>Mas então, qual é a diferença aqui? Por que <code>String</code> pode ser alterada enquanto
literais não podem? A diferença está em como esses dois tipos lidam com memória.</p>
<a class="header" href="print.html#memória-e-alocação" id="memória-e-alocação"><h3>Memória e Alocação</h3></a>
<p>No caso de uma string literal, sabemos o seu conteúdo em tempo de compilação,
então o texto é injetado diretamente para dentro do executável final, o que
faz strings literais serem rápidas e eficientes. Mas essas propriedades provêm
apenas da sua imutabilidade. Infelizmente, não podemos colocar um segmento de
memória dentro do binário para cada texto cujo tamanho é desconhecido em tempo
de compilação, e cujo tamanho pode mudar ao longo da execução do programa.</p>
<p>Com o tipo <code>String</code>, para poder acomodar um trecho mutável e expansível de
texto, precisamos alocar uma quantidade de memória na heap, que é desconhecida
em tempo de compilação, para manter o seu conteúdo. Isto significa que:</p>
<ol>
<li>A memória deve ser solicitada ao sistema operacional em tempo de execução.</li>
<li>Precisamos de uma forma de retornar esta memória ao sistema operacional
quando tivermos finalizado nossa <code>String</code>.</li>
</ol>
<p>A primeira parte é feita por nós: quando chamamos <code>String::from</code>, sua
implementação solicita a memória de que precisa. Isso é meio que universal em
linguagens de programação.</p>
<p>No entanto, a segunda parte é diferente. Em linguagnes com um <em>garbage collector
(GC)</em>, o GC rastreia e limpa a memória que não está mais sendo usada, e nós,
como programadores, não precisamos pensar sobre isso. Sem um GC, é
resposabilidade do programador identificar quando a memória não está mais sendo
usada e chamar, explicitamente, um código que a retorne, assim como fizemos para
solicitá-la. Fazer isso corretamente tem sido, historicamente, um problema
difícil de programação. Se esquecermos, vamos desperdiçar memória. Se fizermos
cedo demais, teremos uma variável inválida. Se fizermos duas vezes, também será
um bug. Precisamos casar exatamente um <code>allocate</code> (alocar) com exatamente um
<code>free</code> (liberar).</p>
<p>Rust segue um caminho diferente: a memória é automaticamente retornada assim que
a variável que a possui sai de escopo. Aqui está uma versão do nosso exemplo de
escopo da Listagem 4-1 usando uma <code>String</code> em vez de uma string literal:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    let s = String::from(&quot;texto&quot;); // s é válida deste ponto em diante

    // faz alguma coisa com s
}                                  // agora este escopo terminou, e s não é
                                   // mais válida
#}</code></pre></pre>
<p>Existe um ponto natural em que podemos retornar ao sistema operacional a memória
da qual precisa nossa <code>String</code>: quando <code>s</code> sai de escopo. Quando uma variável
sai de escopo, o Rust chama para nós uma função especial. Essa função é chamada
<code>drop</code>, e é aí que o autor de <code>String</code> pode colocar o código que retorna
a memória. Rust chama <code>drop</code> automaticamente ao fechar chaves (<code>}</code>).</p>
<blockquote>
<p>Nota: Em C++, esta forma de desalocar recursos no fim do tempo de vida útil de
um item às vezes é chamado de <em>Resource Acquisition Is Initialization</em> (RAII,
do inglês, Aquisição de Recurso É Inicialização). A função <code>drop</code> em Rust vai
lhe ser bastante familar se você já tiver usado padrões RAII.</p>
</blockquote>
<p>Este padrão tem um profundo impacto na forma de escrever código em Rust. Pode
parecer simples agora, mas o comportamento do código pode ser inesperado em
situações mais complicadas, quando queremos que múltiplas variáveis usem os
dados que alocamos na heap. Vamos explorar algumas dessas situações agora.</p>
<a class="header" href="print.html#formas-de-interação-entre-variáveis-e-dados-move" id="formas-de-interação-entre-variáveis-e-dados-move"><h4>Formas de Interação Entre Variáveis e Dados: <em>Move</em></h4></a>
<p>Múltiplas variáveis podem interagir com os mesmos dados de diferentes formas em
Rust. Vamos ver um exemplo usando um número inteiro na Listagem 4-2:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
let y = x;
#}</code></pre></pre>
<p><span class="caption">Listagem 4-2: Atribuindo o valor inteiro da variável <code>x</code>
para <code>y</code>.</span></p>
<p>Provavelmente podemos advinhar o que isto faz com base nas nossas experiências
com outras linguagens: &quot;Associe o valor <code>5</code> a <code>x</code>; depois faça uma cópia do
valor em <code>x</code> e a associe a <code>y</code>.&quot; Agora temos duas variáveis, <code>x</code> e <code>y</code>, e ambas
são iguais a <code>5</code>. É isto mesmo que acontece, porque números inteiros são valores
simples que possuem um tamanho fixo e conhecido, e esses dois valores <code>5</code> são
colocados na pilha.</p>
<p>Agora vamos ver a versão usando <code>String</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;texto&quot;);
let s2 = s1;
#}</code></pre></pre>
<p>Isso parece bem similar ao código anterior, então poderíamos assumir que
funcionaria da mesma forma, isto é, a segunda linha faria uma cópia do valor em
<code>s1</code> e a associaria a <code>s2</code>. Mas não é exatamente isso que acontece.</p>
<p>Para explicar isso mais detalhadamente, vamos ver como a <code>String</code> funciona por
baixo dos panos na Figura 4-1. Uma <code>String</code> é feita de três partes, mostradas
à esquerda: um ponteiro para a memória que guarda o conteúdo da string, um
tamanho, e uma capacidade. Este grupo de dados é armazenado na pilha. No lado
direito está a memória na heap que guarda o conteúdo.</p>
<p><img alt="String na memória" src="img/trpl04-01.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Figura 4-1: Representação na memória de uma <code>String</code>
contendo o valor <code>&quot;texto&quot;</code> associado a <code>s1</code>.</span></p>
<p>O tamanho representa quanta memória, em bytes, o conteúdo da <code>String</code> está
usando atualmente. A capacidade é a quantidade total de memória, em bytes, que
a <code>String</code> recebeu do sistema operacional. A diferença entre tamanho e
capacidade é importante, mas não neste contexto, então não há problema em
ignorar a capacidade por enquanto.</p>
<p>Quando atribuímos <code>s1</code> a <code>s2</code>, os dados da <code>String</code> são copiados, o que
significa que estamos copiando o ponteiro, o tamanho e a capacidade que estão na
pilha. Não estamos copiando os dados que estão na heap, aos quais o ponteiro se
refere. Em outras palavras, a representação dos dados na memória ocorre como
na Figura 4-2.</p>
<p><img alt="s1 e s2 apontando para o mesmo valor" src="img/trpl04-02.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Figura 4-2: Representação na memória da variável <code>s2</code>, que
tem uma cópia do ponteiro, tamanho e capacidade de <code>s1</code>.</span></p>
<p>A representação <em>não</em> ocorre como na Figura 4-3, que é como ficaria a memória se
o Rust também copiasse os dados da heap. Se o Rust fizesse isso, a operação
<code>s2 = s1</code> seria potencialmente bastante custosa em termos de desempenho em tempo
de execução caso os dados na heap fossem grandes.</p>
<p><img alt="s1 e s2 em dois lugares" src="img/trpl04-03.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Figura 4-3: Outra possibilidade do que <code>s2 = s1</code> poderia
fazer se o Rust também copiasse os dados da heap.</span></p>
<p>Anteriormente, dissemos que, quando uma variável sai de escopo, o Rust
automaticamente chama a função <code>drop</code> e limpa a memória da heap para esta
variável. Mas a Figura 4-2 mostra que os dois ponteiros estão apontando para o
mesmo lugar. Isso é um problema: quando <code>s2</code> e <code>s1</code> saem de escopo, os dois vão
tentar liberar a mesma memória. Isso é conhecido como erro de <em>double free</em>
(liberação dupla), e é um dos bugs de segurança de memória que mencionamos
anteriormente. Liberar memória duas vezes pode levar à corrupção da memória,
o que pode, por sua vez, trazer potenciais vulnerabilidades de segurança.</p>
<p>Para garantir a segurança de memória, há um outro detalhe sobre o que acontece
nesta situação em Rust. Em vez de tentar copiar a memória alocada, o Rust
considera que <code>s1</code> deixa de ser válida, e portanto, o Rust não precisa liberar
nenhuma memória quando <code>s1</code> sai de escopo. Veja só o que acontece quando você
tenta usar <code>s1</code> depois que <code>s2</code> é criada, não vai funcionar:</p>
<pre><code class="language-rust ignore">let s1 = String::from(&quot;texto&quot;);
let s2 = s1;

println!(&quot;{}&quot;, s1);
</code></pre>
<p>Você vai ter um erro como este, porque o Rust lhe impede de usar a referência
que foi invalidada:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `s1`
 --&gt; src/main.rs:5:20
  |
3 |     let s2 = s1;
  |         -- value moved here
4 |
5 |     println!(&quot;{}&quot;, s1);
  |                    ^^ value used here after move
  |
  = note: move occurs because `s1` has type `std::string::String`, which does
  not implement the `Copy` trait
</code></pre>
<p>Se você já ouviu os termos &quot;cópia rasa&quot; e &quot;cópia profunda&quot; (<em>shallow copy</em> e
<em>deep copy</em>) enquanto trabalhava com outras linguagens, o conceito de copiar o
ponteiro, tamanho e capacidade sem copiar os dados provavelmente parece uma
cópia rasa. Mas como o Rust também invalida a primeira variável, em vez de
chamar isto de cópia rasa, isto é conhecido como um <em>move</em>. Aqui poderíamos
dizer que <code>s1</code> foi <em>movida</em> para <code>s2</code>. Então, o que realmente acontece é
mostrado na Figura 4-4.</p>
<p><img alt="s1 movida para s2" src="img/trpl04-04.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Figura 4-4: Representação na memória depois de <code>s1</code> ter
sido invalidada.</span></p>
<p>Isso resolve o nosso problema! Tendo apenas <code>s2</code> válida, quando ela sair de
escopo, somente ela vai liberar a memória, e pronto.</p>
<p>Ademais, isto implica uma decisão de projeto: Rust nunca vai criar <em>deep copies</em>
dos seus dados. Logo, para qualquer cópia <em>automática</em> que aconteça, pode-se
assumir que ela não será custosa em termos de desempenho em tempo de execução.</p>
<a class="header" href="print.html#formas-de-interação-entre-variáveis-e-dados-clone" id="formas-de-interação-entre-variáveis-e-dados-clone"><h4>Formas de Interação Entre Variáveis e Dados: Clone</h4></a>
<p>Se nós <em>queremos</em> fazer uma cópia profunda dos dados da <code>String</code> que estão na
heap, e não apenas os dados que estão na pilha, podemos usar um método comum
chamado <code>clone</code>. Vamos discutir sintaxe de métodos no Capítulo 5, mas como os
métodos constituem uma característica comum em várias linguagens de programação,
você provavelmente já os viu antes.</p>
<p>Aqui está um exemplo de uso do método <code>clone</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;texto&quot;);
let s2 = s1.clone();

println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);
#}</code></pre></pre>
<p>Isto funciona bem, e é assim que você pode, explicitamente, produzir o
comportamento mostrado na Figura 4-3, onde os dados da heap <em>são</em> copiados.</p>
<p>Quando você ver uma chamada para <code>clone</code>, você sabe que algum código arbitrário
está sendo executado, e que este código talvez seja custoso. É um indicador
visual de que algo diferente está acontecendo.</p>
<a class="header" href="print.html#dados-somente-da-pilha-copy" id="dados-somente-da-pilha-copy"><h4>Dados Somente da Pilha: Copy</h4></a>
<p>Há um outro detalhezinho de que ainda não falamos. Este código usando números
inteiros, parte do qual foi mostrado anteriormente na Listagem 4-2, funciona e é
válido:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
let y = x;

println!(&quot;x = {}, y = {}&quot;, x, y);
#}</code></pre></pre>
<p>Mas este código parece contradizer o que acabamos de aprender: não temos uma
chamada ao método <code>clone</code>, mas <code>x</code> ainda é válido e não foi movido para <code>y</code>.</p>
<p>O motivo é que tipos como números inteiros têm um tamanho conhecido em tempo de
compilação e são armazenados inteiramente na pilha, e por isso, cópias desses
valores são rápidas de se fazer. Isso significa que não há razão para impedir
<code>x</code> de ser válido após criarmos a variável <code>y</code>. Em outras palavras, não há
diferença entre cópia rasa e profunda aqui, então chamar o método <code>clone</code> não
faria nada diferente de uma cópia rasa, por isso podemos deixá-lo de lado.</p>
<p>O Rust tem uma anotação especial chamada de <em>trait</em> <code>Copy</code>, que podemos colocar
em tipos como números inteiros, que são armazenados na pilha (falaremos mais
sobre traits no Capítulo 10). Se um tipo possui o trait <code>Copy</code>, uma variável
anterior vai continuar sendo utilizável depois de uma atribuição. O Rust não vai
nos deixar anotar um tipo com o trait <code>Copy</code> se este tipo, ou qualquer uma de
suas partes, tiver implementado o trait <code>Drop</code>. Se o tipo precisa que algo
especial aconteça quando o valor sair de escopo e há uma anotação <code>Copy</code> neste
tipo, vamos ter um erro de compilação. Para aprender sobre como inserir a
anotação <code>Copy</code> ao seu tipo, veja o Apêndice C em Traits Deriváveis.</p>
<p>Então quais tipos são <code>Copy</code>? Você pode verificar a documentação de um
determinado tipo para se certificar, mas como regra geral, qualquer grupo de
valores simples escalares podem ser <code>Copy</code>, e nada que precise de alocação ou
que seja uma forma de recurso é <code>Copy</code>. Aqui estão alguns tipos que são <code>Copy</code>:</p>
<ul>
<li>Todos os tipos inteiros, como <code>u32</code>.</li>
<li>O tipo booleano, <code>bool</code>, com valores <code>true</code> e <code>false</code>.</li>
<li>O tipo caractere, <code>char</code>.</li>
<li>Todos os tipos de ponto flutuante, como <code>f64</code>.</li>
<li>Tuplas, mas apenas aquelas que contém tipos que também são <code>Copy</code>.
<code>(i32, i32)</code> é <code>Copy</code>, mas <code>(i32, String)</code> não.</li>
</ul>
<a class="header" href="print.html#ownership-e-funções" id="ownership-e-funções"><h3>Ownership e Funções</h3></a>
<p>A semântica para passar um valor a uma função é similar à de atribuir um valor
a uma variável. Passar uma variável a uma função irá mover ou copiar, assim como
acontece em uma atribuição. A Listagem 4-3 tem um exemplo com algumas anotações
mostrando onde as variáveis entram e saem de escopo:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s = String::from(&quot;texto&quot;);  // s entra em escopo.

    toma_posse(s);                  // move o valor de s para dentro da função...
                                    // ... e ele não é mais válido aqui.

    let x = 5;                      // x entra em escopo.

    faz_uma_copia(x);               // x seria movido para dentro da função,
                                    // mas i32 é Copy, então está tudo bem em
                                    // usar x daqui para a frente.

} // Aqui, x sai de escopo, e depois s. Mas como o valor de s foi movido, nada
  // de especial acontece.

fn toma_posse(uma_string: String) { // uma_string entra em escopo.
    println!(&quot;{}&quot;, uma_string);
} // Aqui, uma_string sai de escopo, e o método `drop` é chamado. A memória que
  // guarda seus dados é liberada.

fn faz_uma_copia(um_inteiro: i32) { // um_inteiro entra em escopo.
    println!(&quot;{}&quot;, um_inteiro);
} // Aqui, um_inteiro sai de escopo. Nada de especial acontece.
</code></pre></pre>
<p><span class="caption">Listagem 4-3: Funções com anotações de ownership e
escopo</span></p>
<p>Se tentássemos usar <code>s</code> após a chamada para <code>toma_posse</code>, o Rust iria lançar um
erro de compilação. Essas verificações estáticas nos protegem de certo enganos.
Tente adicionar um código à função <code>main</code> que usa <code>s</code> e <code>x</code> para ver onde você
pode usá-los e onde as regras de ownership lhe impedem de fazê-lo.</p>
<a class="header" href="print.html#retorno-de-valores-e-escopo" id="retorno-de-valores-e-escopo"><h3>Retorno de Valores e Escopo</h3></a>
<p>Retornar valores também pode transferir a posse de um valor. Aqui está um
exemplo com anotações similares àquelas da Listagem 4-3:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = entrega_valor();           // entrega_valor move o valor retornado
                                        // para s1.

    let s2 = String::from(&quot;texto&quot;);     // s2 entra em escopo.

    let s3 = pega_e_entrega_valor(s2);  // s2 é movido para dentro da função
                                        // pega_e_entrega_valor, que também
                                        // move o valor retornado para s3.
} // Aqui, s3 sai de escopo e é destruída. s2 sai de escopo, mas já foi movida,
  // então nada demais acontece. s1 sai de escopo e é destruída.

fn entrega_valor() -&gt; String {               // entrega_valor move o valor
                                             // retornado para dentro da função
                                             // que a chamou.

    let uma_string = String::from(&quot;olá&quot;);    // uma_string entra em escopo.

    uma_string                               // uma_string é retornada e movida
                                             // para a função que chamou
                                             // entrega_valor.
}

// pega_e_entrega_valor vai pegar uma String e retorná-la.
fn pega_e_entrega_valor(uma_string: String) -&gt; String { // uma_string entra em
                                                        // escopo.

    uma_string  // uma_string é retornada e movida para a função que chamou
                // pega_e_entrega_valor.
}
</code></pre></pre>
<p>A posse de uma variável segue o mesmo padrão toda vez: atribuir um valor a outra
variável irá movê-lo. Quando uma variável que inclui dados na heap sai de
escopo, o valor será destruído pelo método <code>drop</code>, a não ser que os dados tenham
sido movidos para outra variável.</p>
<p>Obter e retornar a posse de um valor em cada função é um pouco tedioso. O que
fazer se queremos deixar uma função usar um valor sem tomar posse dele? É meio
irritante saber que qualquer coisa que passemos a uma função também precisa ser
passado de volta se quisermos usá-lo novamente, além de algum possível resultado
proveniente do corpo da função que também queremos retornar.</p>
<p>É possível retornar múltiplos valores usando uma tupla, da seguinte forma:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;texto&quot;);

    let (s2, tamanho) = calcula_tamanho(s1);

    println!(&quot;O tamanho de '{}' é {}.&quot;, s2, tamanho);
}

fn calcula_tamanho(s: String) -&gt; (String, usize) {
    let tamanho = s.len(); // len() retorna o tamanho de uma String.

    (s, tamanho)
}
</code></pre></pre>
<p>Mas isto é muita cerimônia e trabalho para um conceito que deveria ser comum.
Para nossa sorte, Rust tem uma ferramenta para este conceito, e ela é chamada de
<em>referências</em>.</p>
<a class="header" href="print.html#referências-e-borrowing" id="referências-e-borrowing"><h2>Referências e <em>Borrowing</em></h2></a>
<p>O problema de usar tuplas, que vimos no fim da seção anterior, é que precisamos
retornar a <code>String</code>, de forma que ainda possamos usá-la após a chamada à função
<code>calcula_tamanho</code>, para dentro da qual a <code>String</code> foi movida.</p>
<p>Aqui está uma forma de como você poderia definir e usar uma função
<code>calcula_tamanho</code> que recebe uma <em>referência</em> para um objeto como parâmetro, em
vez de pegar este valor para si:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;texto&quot;);

    let tamanho = calcula_tamanho(&amp;s1);

    println!(&quot;O tamanho de '{}' é {}.&quot;, s1, tamanho);
}

fn calcula_tamanho(s: &amp;String) -&gt; usize {
    s.len()
}
</code></pre></pre>
<p>Primeiro, repare que todo aquele código usando uma tupla na declaração da
variável e no retorno da função já se foi. Segundo, note que passamos <code>&amp;s1</code> para
<code>calcula_tamanho</code>, e na sua definição, temos <code>&amp;String</code> em vez de apenas
<code>String</code>.</p>
<p>Esses <code>&amp;</code> são <em>referências</em>, e eles permitem que você se refira a algum valor
sem tomar posse dele. A Figura 4-5 mostra um diagrama.</p>
<p><img alt="&String s apontando para String s1" src="img/trpl04-05.svg" class="center" /></p>
<p><span class="caption">Figura 4-5: <code>&amp;String s</code> apontando para <code>String s1</code></span></p>
<blockquote>
<p>Nota: O oposto de referenciar usando <code>&amp;</code> é <em>derreferenciar</em>, feito por meio do
operador derreferenciador, <code>*</code>. Veremos alguns usos do operador
derreferenciador no Capítulo 8 e vamos discutir detalhes da derreferenciação
no Capítulo 15.</p>
</blockquote>
<p>Vamos olhar mais de perto esta chamada de função:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# fn calcula_tamanho(s: &amp;String) -&gt; usize {
#     s.len()
# }
let s1 = String::from(&quot;texto&quot;);

let tamanho = calcula_tamanho(&amp;s1);
#}</code></pre></pre>
<p>A sintaxe <code>&amp;s1</code> nos permite criar uma referência que <em>se refere</em> ao valor <code>s1</code>,
mas não o possui. Como ela não o possui, o valor a que ela aponta não será
destruído quando a referência sair de escopo.</p>
<p>Da mesma forma, a assinatura da função usa <code>&amp;</code> para indicar que o tipo do
parâmetro <code>s</code> é uma referência. Vamos adicionar algumas anotações para explicar:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn calcula_tamanho(s: &amp;String) -&gt; usize { // s é uma referência para uma String
    s.len()
} // Aqui, s sai de escopo. Mas como ela não possui o valor a que se refere,
  // nada acontece.
#}</code></pre></pre>
<p>O escopo no qual a variável <code>s</code> é válida é o mesmo escopo de qualquer parâmetro
de função, mas não destruímos o valor apontado pela referência quando ela sai de
escopo, pois ela não tem posse dele. Funções que têm referências como
parâmetros, em vez dos próprios valores, não precisam retornar os valores para
devolver a posse deles, já que nunca tiveram esta posse.</p>
<p>Colocar referências como parâmetros de funções é chamado de <em>borrowing</em> (do
inglês, empréstimo). Assim como na vida real, se uma pessoa possui alguma coisa,
você pode pegar emprestado dela. Quando você termina de usar, você deve
devolver.</p>
<p>E o que acontece se tentarmos modificar alguma coisa que pegamos emprestado?
Tente rodar o código da Listagem 4-4. Alerta de spoiler: não funciona!</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let s = String::from(&quot;texto&quot;);

    modifica(&amp;s);
}

fn modifica(uma_string: &amp;String) {
    uma_string.push_str(&quot; longo&quot;);
}
</code></pre>
<p><span class="caption">Listagem 4-4: Tentativa de modificar um valor emprestado</span></p>
<p>Aqui está o erro:</p>
<pre><code class="language-text">error[E0596]: cannot borrow immutable borrowed content `*uma_string` as mutable
 --&gt; main.rs:8:5
  |
7 | fn modifica(uma_string: &amp;String) {
  |                         ------- use `&amp;mut String` here to make mutable
8 |     uma_string.push_str(&quot; longo&quot;);
  |     ^^^^^^^^^^ cannot borrow as mutable
</code></pre>
<p>Assim como as variáveis são imutáveis por padrão, referências também são. Não
temos permissão para modificar algo para o qual temos uma referência.</p>
<a class="header" href="print.html#referências-mutáveis" id="referências-mutáveis"><h3>Referências Mutáveis</h3></a>
<p>Podemos corrigir o erro no código da Listagem 4-4 com um pequeno ajuste:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut s = String::from(&quot;texto&quot;);

    modifica(&amp;mut s);
}

fn modifica(uma_string: &amp;mut String) {
    uma_string.push_str(&quot; longo&quot;);
}
</code></pre></pre>
<p>Primeiro, temos que fazer com que <code>s</code> seja <code>mut</code>. Depois, temos que criar uma
referência mutável com <code>&amp;mut s</code> e aceitar uma referência mutável com
<code>uma_string: &amp;mut String</code>.</p>
<p>Mas referências mutáveis possuem uma grande restrição: você só pode ter uma
referência mutável para um determinado dado em um determinado escopo. Este
código vai falhar:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">let mut s = String::from(&quot;texto&quot;);

let r1 = &amp;mut s;
let r2 = &amp;mut s;
</code></pre>
<p>Aqui está o erro:</p>
<pre><code class="language-text">error[E0499]: cannot borrow `s` as mutable more than once at a time
 --&gt; main.rs:5:19
  |
4 |     let r1 = &amp;mut s;
  |                   - first mutable borrow occurs here
5 |     let r2 = &amp;mut s;
  |                   ^ second mutable borrow occurs here
6 | }
  | - first borrow ends here
</code></pre>
<p>Esta restrição permite a mutação, mas de uma forma bem controlada. Isto é algo
com que novos Rustáceos passam trabalho, porque a maioria das linguagens de
programação permitem modificar um valor quando você quiser. O benefício de ter
esta restrição é que o Rust previne <em>data races</em> em tempo de compilação.</p>
<p>Um <em>data race</em> é parecido com uma condição de corrida, e acontece quando esses
três fatores ocorrem:</p>
<ol>
<li>Dois ou mais ponteiros acessam o mesmo dado ao mesmo tempo.</li>
<li>Ao menos um dos ponteiros é usado para escrever sobre o dado.</li>
<li>Não há nenhum mecanismo sendo usado para sincronizar o acesso ao dado.</li>
</ol>
<p>Data races causam comportamento indefinido e pode ser difíceis de diagnosticar
e corrigir quando você está tentando rastreá-los em tempo de execução. Rust
previne este problema de acontecer porque não vai nem deixar compilar um código
com data races!</p>
<p>Como sempre, podemos usar chaves (<code>{}</code>) para criar um novo escopo, permitindo
múltiplas referências mutáveis, mas não <em>simultâneas</em>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::from(&quot;texto&quot;);

{
    let r1 = &amp;mut s;

} // aqui r1 sai de escopo, então já podemos criar uma nova referência sem
  // problema nenhum.

let r2 = &amp;mut s;
#}</code></pre></pre>
<p>Existe uma regra parecida para combinar referências mutáveis e imutáveis. Este
código resulta em erro:</p>
<pre><code class="language-rust ignore">let mut s = String::from(&quot;texto&quot;);

let r1 = &amp;s; // sem problema
let r2 = &amp;s; // sem problema
let r3 = &amp;mut s; // PROBLEMA GRANDE
</code></pre>
<p>Aqui está o erro:</p>
<pre><code class="language-text">error[E0502]: cannot borrow `s` as mutable because it is also borrowed as
immutable
 --&gt; main.rs:6:19
  |
4 |     let r1 = &amp;s; // sem problema
  |               - immutable borrow occurs here
5 |     let r2 = &amp;s; // sem problema
6 |     let r3 = &amp;mut s; // PROBLEMA GRANDE
  |                   ^ mutable borrow occurs here
7 | }
  | - immutable borrow ends here
</code></pre>
<p>Eita! Nós <em>também</em> não podemos ter uma referência mutável enquanto temos uma
imutável. Usuários de uma referência imutável não esperam que os valores mudem
de repente! Porém, múltiplas referências imutáveis são permitidas, pois ninguém
que esteja apenas lendo os dados será capaz de afetar a leitura que está sendo
feita em outra parte do código.</p>
<p>Mesmo que esses erros sejam frustrantes às vezes, lembre-se que é o compilador
do Rust apontando um bug potencial antecipadamente (em tempo de compilação,
em vez de execuçao), e mostrando exatamente onde está o problema, em vez de você
ter que investigar por que algumas vezes os seus dados não são aquilo que você
esperava que fosse.</p>
<a class="header" href="print.html#referências-soltas" id="referências-soltas"><h3>Referências Soltas</h3></a>
<p>Em linguagens com ponteiros, é fácil criar erroneamente um <em>ponteiro solto</em>, um
ponteiro que referencia um local na memória que pode ter sido dado para outra
parte do programa, basta liberar alguma memória e preservar um ponteiro para
ela. Por outro lado, em Rust, o compilador garante que nenhuma referência será
uma referência solta: se temos uma referência para algum dado, o compilador vai
se certificar que esse dado não vai sair de escopo antes da referência.</p>
<p>Vamos tentar criar uma referência solta, que o Rust vai impedir com um erro em
tempo de compilação:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let referencia_para_o_nada = soltar();
}

fn soltar() -&gt; &amp;String {
    let s = String::from(&quot;texto&quot;);

    &amp;s
}
</code></pre>
<p>Aqui está o erro:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt; main.rs:5:16
  |
5 | fn soltar() -&gt; &amp;String {
  |                ^ expected lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is
  no value for it to be borrowed from
  = help: consider giving it a 'static lifetime
</code></pre>
<p>Esta mensagem de erro se refere a uma característica que não abordamos ainda:
<em>lifetimes</em>. Vamos discutir lifetimes em detalhe no Capítulo 10. Mas, se você
desconsiderar a parte sobre lifetimes, a mensagem mostra a razão deste código
ser um problema:</p>
<pre><code class="language-text">this function's return type contains a borrowed value, but there is no value
for it to be borrowed from.
</code></pre>
<blockquote>
<p>Tradução: o tipo de retorno desta função contém um valor emprestado, mas não
há nenhum valor que se possa pegar emprestado.</p>
</blockquote>
<p>Vamos dar uma olhada mais de perto no que está acontecendo, exatamente, em cada
estágio da nossa função <code>soltar</code>:</p>
<pre><code class="language-rust ignore">fn soltar() -&gt; &amp;String { // soltar retorna uma referência a uma String

    let s = String::from(&quot;texto&quot;); // s é uma nova String

    &amp;s // retornamos uma referência a uma String, s
} // Aqui, s sai de escopo e é destruída. Sua memória é devolvida.
  // Perigo!
</code></pre>
<p>Como <code>s</code> é criada dentro da função <code>soltar</code>, quando o código desta função
termina, <code>s</code> é desalocada. Mas nós tentamos retornar uma referência para ela.
Isto significa que esta referência apontaria para uma <code>String</code> inválida! Isso
não é bom. Rust não vai nos deixar fazer isso.</p>
<p>A solução aqui é retornar a <code>String</code> diretamente:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn não_soltar() -&gt; String {
    let s = String::from(&quot;texto&quot;);

    s
}
#}</code></pre></pre>
<p>Isto funciona sem nenhum problema. A <code>String</code> é movida para fora, e nada é
desalocado.</p>
<a class="header" href="print.html#as-regras-de-referências" id="as-regras-de-referências"><h3>As Regras de Referências</h3></a>
<p>Vamos recapitular o que discutimos sobre referências:</p>
<ol>
<li>Em um dado momento, você pode ter <em>um ou outro</em>, mas não os dois:</li>
</ol>
<ul>
<li>Uma referência mutável.</li>
<li>Qualquer número de referências imutáveis.</li>
</ul>
<ol start="2">
<li>Referências devem ser válidas sempre.</li>
</ol>
<p>Em seguida, vamos ver um tipo diferente de referências: <em>slices</em>.</p>
<a class="header" href="print.html#slices" id="slices"><h2><em>Slices</em></h2></a>
<p>Outro tipo de dados em que não há ownership é a <em>slice</em> (do inglês, fatia).
Slices lhe permitem referenciar uma sequência contígua de elementos em uma
coleção em vez de referenciar a coleção inteira.</p>
<p>Aqui está um pequeno problema de programação: escrever uma função que pega uma
string e retorna a primeira palavra que encontrar dentro dela. Se a função não
encontrar um espaço na string, significa que a string inteira é uma palavra só,
então a string toda deve ser retornada.</p>
<p>Vamos pensar sobre a assinatura desta função:</p>
<pre><code class="language-rust ignore">fn primeira_palavra(s: &amp;String) -&gt; ?
</code></pre>
<p>Esta função, <code>primeira_palavra</code>, tem uma <code>&amp;String</code> como parâmetro. Nós não
queremos tomar posse dela, então tudo bem. Mas o que nós deveríamos retornar?
Não temos uma forma de falar sobre <em>parte</em> de uma string. No entanto, poderíamos
retornar o índice do final de uma palavra. Vamos tentar fazer isso, conforme
mostrado na Listagem 4-5:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn primeira_palavra(s: &amp;String) -&gt; usize {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
#}</code></pre></pre>
<p><span class="caption">Listagem 4-5: A função <code>primeira_palavra</code>, que retorna um
índice para um byte da <code>String</code> passada como parâmetro.</span></p>
<p>Vamos dividir este código em algumas partes. Como precisamos varrer a <code>String</code>
elemento por elemento, e verificar se algum valor é um espaço, vamos converter
nossa <code>String</code> em um array de bytes usando o método <code>as_bytes</code>:</p>
<pre><code class="language-rust ignore">let bytes = s.as_bytes();
</code></pre>
<p>Depois, criamos um iterador sobre o array de bytes usando o método <code>iter</code>:</p>
<pre><code class="language-rust ignore">for (i, &amp;item) in bytes.iter().enumerate() {
</code></pre>
<p>Vamos discutir sobre iteradores em mais detalhes no Capítulo 13. Por enquanto,
saiba que <code>iter</code> é um método que retorna cada elemento em uma coleção, e
<code>enumerate</code> encapsula o resultado do <code>iter</code> e retorna cada elemento como parte
de uma tupla. O primeiro elemento da tupla é o índice, e o segundo elemento é
uma referência ao valor. Isto é um pouco mais conveniente do que calcular o
índice nós mesmos.</p>
<p>Como o método <code>enumerate</code> retorna uma tupla, podemos usar padrões para
desestruturar esta tupla, assim como qualquer outra coisa em Rust. Então, no
<code>for</code>, especificamos um padrão que tem <code>i</code> para o índice na tupla e <code>&amp;item</code> para
o byte. Como pegamos uma referência ao elemento através do
<code>.iter().enumerate()</code>, usamos um <code>&amp;</code> neste padrão.</p>
<p>Nós procuramos o byte que representa um espaço usando a sintaxe de byte literal.
Se encontrarmos um espaço, retornamos a posição dele. Caso contrário, retornamos
o tamanho da string usando <code>s.len()</code>:</p>
<pre><code class="language-rust ignore">    if item == b' ' {
        return i;
    }
}
s.len()
</code></pre>
<p>Agora temos uma forma de descobrir o índice do fim da primeira palavra na
string, mas tem um problema. Estamos retornando um <code>usize</code> por si só, mas ele só
possui um significado no contexto da <code>&amp;String</code>. Em outras palavras, como é um
valor separado da <code>String</code>, não há garantia de que ele ainda será válido no
futuro. Considere o programa na Listagem 4-6, que usa a função da Listagem 4-5:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn primeira_palavra(s: &amp;String) -&gt; usize {
#     let bytes = s.as_bytes();
#
#     for (i, &amp;item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return i;
#         }
#     }
#
#     s.len()
# }
#
fn main() {
    let mut s = String::from(&quot;texto longo&quot;);

    let palavra = primeira_palavra(&amp;s); // palavra vai ter o valor 5.

    s.clear(); // Isso esvazia a String, deixando ela igual a &quot;&quot;.

    // palavra ainda tem o valor 5 aqui, mas já não há mais uma string para a
    // qual o valor 5 faça algum sentido. palavra agora é totalmente inválida!
}
</code></pre></pre>
<p><span class="caption">Listagem 4-6: Armazenando o resultado de uma chamada à
função <code>primeira_palavra</code>, e depois, mudando o conteúdo da <code>String</code>.</span></p>
<p>Este programa compila sem erros, e também o faria se usássemos a variável
<code>palavra</code> depois de chamar <code>s.clear()</code>. <code>palavra</code> não está conectada ao estado
de <code>s</code> de nenhuma forma, então, <code>palavra</code> ainda contém o valor <code>5</code>. Poderíamos
usar esse valor <code>5</code> com a variável <code>s</code> para tentar extrair a primeira palavra da
string, mas isso seria um bug, pois o conteúdo de <code>s</code> já mudou após termos salvo
o valor <code>5</code> na variável <code>word</code>.</p>
<p>Ter que se preocupar sobre o índice da <code>palavra</code> ficar fora de sincronia com os
dados em <code>s</code> é tedioso e propenso a erros! Gerenciar esses índices é ainda mais
delicado se escrevermos uma função <code>segunda_palavra</code>. Sua assinatura teria que
ser algo do tipo:</p>
<pre><code class="language-rust ignore">fn segunda_palavra(s: &amp;String) -&gt; (usize, usize) {
</code></pre>
<p>Agora estamos rastreando os índices do início <em>e</em> do final, e temos ainda mais
valores que são calculados a partir dos dados em um estado particular, mas que
não estão vinculados a este estado de nenhuma forma. Agora temos três variáveis
não relacionadas flutuando que precisam ser mantidas em sincronia.</p>
<p>Felizmente, Rust possui uma solução para este problema: slices de string.</p>
<a class="header" href="print.html#slices-de-string" id="slices-de-string"><h3>Slices de String</h3></a>
<p>Uma <em>slice de string</em> é uma referência para uma parte de uma <code>String</code>, e tem a
seguinte forma:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;texto longo&quot;);

let texto = &amp;s[0..5];
let longo = &amp;s[6..11];
#}</code></pre></pre>
<p>Isto é similar a pegar uma referência à <code>String</code> inteira, mas com um <code>[0..5]</code> a
mais. Em vez de uma referência à <code>String</code> inteira, trata-se de uma referência a
uma porção da <code>String</code>. A sintaxe <code>início..fim</code> representa um <em>range</em>
(uma faixa) que começa em <code>início</code> e continua até, mas não incluindo, <code>fim</code>.</p>
<p>Podemos criar slices usando um range entre colchetes especificando
<code>[índice_inicial..índice_final]</code>, em que <code>índice_inicial</code> é a primeira posição
inclusa na slice, e <code>índice_final</code> é um a mais que a última posição inclusa na
slice. Internamente, a estrutura de dados de uma slice armazena a posição
inicial e o tamanho da slice, que corresponde a <code>índice_final</code> menos
<code>índice_inicial</code>. Então, no caso do <code>let longo = &amp;s[6..11];</code>, <code>longo</code> seria uma
slice que contém um ponteiro para o sétimo byte de <code>s</code> (índice 6) e um tamanho
igual a 5.</p>
<p>A Figura 4-6 mostra isto em um diagrama.</p>
<p><img alt="mundo contendo um ponteiro para o 7o byte da String s e um tamanho 5" src="img/trpl04-06.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Figura 4-6: Slice referente a uma parte de uma
<code>String</code></span></p>
<p>Com a sintaxe de range do Rust (<code>..</code>), se você quiser começar com o primeiro
elemento (índice zero), você pode omitir o valor antes dos dois pontos. Em
outras palavras, estas formas são equivalentes:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;texto&quot;);

let slice = &amp;s[0..2];
let slice = &amp;s[..2];
#}</code></pre></pre>
<p>Da mesma forma, se a sua slice inclui o último byte da <code>String</code>, você pode
omitir o último número. Isso significa que as seguintes formas são equivalentes:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;texto&quot;);

let tamanho = s.len();

let slice = &amp;s[3..tamanho];
let slice = &amp;s[3..];
#}</code></pre></pre>
<p>Você também pode omitir ambos os valores para pegar uma slice da string inteira.
Logo, essas duas formas são equivalentes:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;texto&quot;);

let tamanho = s.len();

let slice = &amp;s[0..tamanho];
let slice = &amp;s[..];
#}</code></pre></pre>
<blockquote>
<p>Nota: Os índices do range de uma slice de string devem coincidir com os
limites entre caracteres UTF-8 válidos. Se você tentar criar uma slice de
string no meio de um caractere que tenha mais de um byte, seu programa vai
terminar com erro. Para introduzir slices de string, estamos utilizando
apenas caracteres ASCII nesta seção; uma discussão mais detalhada sobre
manipulação de caracteres UTF-8 será feita na seção &quot;Strings&quot; do Capítulo 8.</p>
</blockquote>
<p>Com toda essa informação em mente, vamos reescrever a função <code>primeira_palavra</code>
para retornar uma slice. O tipo que representa &quot;slice de string&quot; é escrito como
<code>&amp;str</code>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn primeira_palavra(s: &amp;String) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
#}</code></pre></pre>
<p>Pegamos o índice para o fim da palavra da mesma forma como fizemos na Listagem
4-5, buscando a primeira ocorrência de um espaço. Quando o encontramos,
retornamos uma slice de string usando o início da string e o índice do espaço
como índices inicial e final, respectivamente.</p>
<p>Agora, quando chamamos <code>primeira_palavra</code>, pegamos de volta um único valor que
está vinculado à string. O valor é composto de uma referência para o ponto
inicial da slice e o número de elementos que ela contém.</p>
<p>Retornar uma slice também funcionaria para uma função <code>segunda_palavra</code>:</p>
<pre><code class="language-rust ignore">fn segunda_palavra(s: &amp;String) -&gt; &amp;str {
</code></pre>
<p>Agora, temos uma API bem direta que é bem mais difícil de bagunçar, uma vez que
o compilador vai se certificar que as referências dentro da <code>String</code>
permanecerão válidas. Lembra do bug do programa na Listagem 4-6, quando
obtivemos o índice para o fim da primeira palavra mas depois limpamos a string,
invalidando o índice obtido? Aquele código era logicamente incorreto, mas não
mostrava nenhum erro imediato. Os problemas apareceriam mais tarde quando
tentássemos usar o índice da primeira palavra com uma string que foi esvaziada.
Slices tornam esse bug impossível de acontecer e nos permitem saber que temos um
problema no código muito mais cedo. Na versão usando slice, a função
<code>primeira_palavra</code> vai lançar um erro em tempo de compilação:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let mut s = String::from(&quot;texto longo&quot;);

    let palavra = first_word(&amp;s);

    s.clear(); // Erro!
}
</code></pre>
<p>Aqui está o erro:</p>
<pre><code class="language-text">error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:5
  |
4 |     let word = primeira_palavra(&amp;s);
  |                                  - immutable borrow occurs here
5 |
6 |     s.clear(); // Erro!
  |     ^ mutable borrow occurs here
7 | }
  | - immutable borrow ends here
</code></pre>
<p>Voltando às regras de borrowing, lembre-se que, se temos uma referência imutável
para algum valor, não podemos também obter uma referência mutável do mesmo. Como
<code>clear</code> precisa truncar a <code>String</code>, esse método tenta obter uma referência
mutável, e acaba falhando. O Rust não só tornou nossa API mais fácil de usar,
como também eliminou uma classe inteira de erros em tempo de compilação!</p>
<a class="header" href="print.html#strings-literais-são-slices" id="strings-literais-são-slices"><h4>Strings Literais São Slices</h4></a>
<p>Lembre-se de que falamos sobre strings literais serem armazenadas dentro do
binário. Agora que conhecemos slices, podemos entender strings literais
adequadamente:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = &quot;Olá, mundo!&quot;;
#}</code></pre></pre>
<p>O tipo de <code>s</code> aqui é <code>&amp;str</code>: é uma slice apontando para aquele ponto específico
do binário. Também é por isso que strings literais são imutáveis; <code>&amp;str</code> é uma
referência imutável.</p>
<a class="header" href="print.html#slices-de-strings-como-parâmetros" id="slices-de-strings-como-parâmetros"><h4>Slices de Strings como Parâmetros</h4></a>
<p>Saber que você pode obter slices de literais e <code>String</code>s nos levam a mais um
aprimoramento da função <code>primeira_palavra</code>, e aqui está sua assinatura:</p>
<pre><code class="language-rust ignore">fn primeira_palavra(s: &amp;String) -&gt; &amp;str {
</code></pre>
<p>Um Rustáceo mais experiente escreveria esta função conforme a seguir, permitindo
utilizar a mesma função com <code>String</code>s e <code>&amp;str</code>s:</p>
<pre><code class="language-rust ignore">fn primeira_palavra(s: &amp;str) -&gt; &amp;str {
</code></pre>
<p>Se temos uma slice de string, podemos passá-la diretamente. Se temos uma
<code>String</code>, podemos passar uma slice da <code>String</code> inteira. Definir uma função que
recebe uma slice em vez de uma referência para uma String deixa nossa API mais
genérica e útil sem perder nenhuma funcionalidade:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn primeira_palavra(s: &amp;str) -&gt; &amp;str {
#     let bytes = s.as_bytes();
#
#     for (i, &amp;item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return &amp;s[0..i];
#         }
#     }
#
#     &amp;s[..]
# }
fn main() {
    let minha_string = String::from(&quot;texto longo&quot;);

    // primeira_palavra funciona com slices de `String`s
    let palavra = primeira_palavra(&amp;minha_string[..]);

    let minha_string_literal = &quot;texto longo&quot;;

    // primeira_palavra funciona com strings literais
    let palavra = primeira_palavra(&amp;minha_string_literal[..]);
    
    // uma vez que strings literais *são* slices de strings,
    // isso também funciona, sem nem usar sintaxe de slice!
    let palavra = primeira_palavra(minha_string_literal);
}
</code></pre></pre>
<a class="header" href="print.html#outras-slices" id="outras-slices"><h3>Outras Slices</h3></a>
<p>Slices de string, como você pode imaginar, são específicas de strings. Mas há
também um tipo de slice mais genérico. Considere esta array:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a = [1, 2, 3, 4, 5];
#}</code></pre></pre>
<p>Assim como às vezes queremos nos referir a uma parte de uma string, podemos
também querer nos referir a uma parte de uma array, e faríamos isso da seguinte
forma:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];
#}</code></pre></pre>
<p>Essa slice tem o tipo <code>&amp;[i32]</code>. Ela funciona da mesma forma que as slices de
string, armazenando uma referência para o primeiro elemento e um tamanho. Você
vai usar esse tipo de slice para todos os tipos de coleções. Vamos discutir
essas coleções em mais detalhe quando falarmos sobre vetores no Capítulo 8.</p>
<a class="header" href="print.html#resumo-2" id="resumo-2"><h2>Resumo</h2></a>
<p>Os conceitos de ownership, borrowing, e slices são o que garante a segurança de
memória dos programas em Rust em tempo de compilação. A linguagem Rust lhe dá
controle sobre o uso da memória, assim como outras linguagens de programação de
sistemas, mas como o dono dos dados limpa automaticamente a memória quando ele
sai de escopo, você não tem que escrever e debugar código extra para ter esse
controle.</p>
<p>O ownership afeta o funcionamento de várias outras partes do Rust, por isso
vamos falar um pouco mais sobre esses conceitos neste livro daqui para a frente.
Vamos seguir para o próximo capítulo e ver como agrupar dados em uma <code>struct</code>.</p>
<a class="header" href="print.html#usando-structs-para-estruturar-dados-relacionados" id="usando-structs-para-estruturar-dados-relacionados"><h1>Usando Structs para Estruturar Dados Relacionados</h1></a>
<p>Uma <em>struct</em>, ou <em>estrutura</em>, é um tipo de dados personalizado que nos permite
nomear e criar um conjunto de vários valores relacionados que compõem um grupo
de dados. Se você estiver familiarizado com uma linguagem orientada a objeto,
um <em>struct</em> é como os atributos de dados de um objeto. Neste capítulo, vamos
comparar e diferenciar tuplas com structs, demonstrar como usar structs e
discutir como definir os métodos e funções associadas às structs para
especificar o comportamento associado com os dados de uma struct. Os conceitos
de struct e <em>enum</em> (que será discutido no Capítulo 6) são os blocos necessários
para a criação de novos tipos para o seu programa, para tirar o máximo proveito
da verificação de tipo no tempo de compilação do Rust.</p>
<a class="header" href="print.html#method-syntax" id="method-syntax"><h1>Method Syntax</h1></a>
<a class="header" href="print.html#enums-e-casamento-de-padrões-pattern-matching" id="enums-e-casamento-de-padrões-pattern-matching"><h1>Enums e Casamento de Padrões (<em>Pattern Matching</em>)</h1></a>
<p>Neste capítulo vamos ver <em>enumerações</em>, também chamadas de <em>enums</em>. Enums
permitem definir um tipo por meio da enumeração de seus possíveis valores.
Primeiro, vamos definir e usar uma enum para mostrar como ela pode atrelar
significado aos nossos dados. Depois, vamos explorar uma enum particularmente
útil, chamada <code>Option</code>, que expressa um valor que tanto pode ser algo quanto
pode não ser nada. Em seguida, vamos ver como o casamento de padrões por meio
da expressão <code>match</code> facilita a execução de códigos diferentes para diferentes
valores de uma enum. Por fim, vamos abordar o <code>if let</code>, outra forma concisa e
conveniente que você pode usar para tratar enums no seu código.</p>
<p>Enums são ferramentas que aparecem em muitas linguagens, mas suas
características variam de uma para outra. Em Rust, enums são mais parecidas com
os <em>tipos de dados algébricos</em> das linguagens de programação funcional como F#,
OCaml e Haskell.</p>
<a class="header" href="print.html#definindo-uma-enum" id="definindo-uma-enum"><h2>Definindo uma Enum</h2></a>
<p>Vamos ver um caso em que enums podem ser mais apropriadas do que structs e
descobrir como elas podem ser úteis. Digamos que estamos trabalhando com
endereços IP. Atualmente, existem duas versões do protocolo IP que são mais
utilizadas: a quatro e a seis. Estas são as únicas possibilidades para um
endereço IP com que o nosso programa vai trabalhar: nós podemos <em>enumerar</em>
todos os possíveis valores, é daí que vem o nome enumeração.</p>
<p>Um endereço IP qualquer pode ser ou da versão quatro ou da versão seis, mas
nunca das duas ao mesmo tempo. Esta propriedade dos endereços IP faz com que a
enum seja bem apropriada para este caso, pois enums só podem assumir o valor de
uma de suas variantes. Os endereços de ambas as versões, seja quatro ou seis,
ainda são, fundamentalmente, endereços IP, e deveriam ser tratados pelo mesmo
tipo no código em situações que se aplicam a qualquer versão de endereço IP.</p>
<p>Podemos expressar esse conceito em código definindo uma enum <code>VersaoIp</code> e
listando os possíveis tipos de que um endereço IP pode ser: <code>V4</code> e <code>V6</code>. Estas
são as chamadas <em>variantes</em> da enum:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum VersaoIp {
    V4,
    V6,
}
#}</code></pre></pre>
<p><code>VersaoIp</code> é um tipo de dados que agora nós podemos usar em qualquer lugar no
nosso código.</p>
<a class="header" href="print.html#valores-de-uma-enum" id="valores-de-uma-enum"><h3>Valores de uma Enum</h3></a>
<p>Podemos criar instâncias de cada uma das duas variantes de <code>VersaoIp</code>, da
seguinte forma:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum VersaoIp {
#     V4,
#     V6,
# }
#
let quatro = VersaoIp::V4;
let seis = VersaoIp::V6;
#}</code></pre></pre>
<p>Repare que as variantes pertencem ao <em>namespace</em> da enum, e se usa <code>::</code> para
separar os dois. Isso é útil porque agora ambos os valores <code>VersaoIp::V4</code> e
<code>VersaoIp::V6</code> são do mesmo tipo: <code>VersaoIp</code>. Agora nós podemos, por exemplo,
definir uma função que usa qualquer <code>VersaoIp</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum VersaoIp {
#     V4,
#     V6,
# }
#
fn rotear(versao_ip: VersaoIp) { }
#}</code></pre></pre>
<p>E podemos ainda chamar esta função passando qualquer uma das variantes:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum VersaoIp {
#     V4,
#     V6,
# }
#
# fn rotear(versao_ip: VersaoIp) { }
#
rotear(VersaoIp::V4);
rotear(VersaoIp::V6);
#}</code></pre></pre>
<p>O uso de enums tem ainda mais vantagens. Pensando mais a fundo sobre o nosso
tipo de endereço IP, ainda não temos uma forma de representar o <em>endereço</em> em
si, apenas sabemos qual a <em>versão</em> dele. Tendo em vista o que você acabou de
aprender sobre structs no Capítulo 5, você poderia abordar esse problema assim
como visto na Listagem 6-1:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum VersaoIp {
    V4,
    V6,
}

struct EnderecoIp {
    versao: VersaoIp,
    endereco: String,
}

let local = EnderecoIp {
    versao: VersaoIp::V4,
    endereco: String::from(&quot;127.0.0.1&quot;),
};

let loopback = EnderecoIp {
    versao: VersaoIp::V6,
    endereco: String::from(&quot;::1&quot;),
};
#}</code></pre></pre>
<p><span class="caption">Listagem 6-1: Representação do endereço e da variante
<code>VersaoIp</code> de um endereço IP usando uma <code>struct</code></span></p>
<p>Aqui nós definimos uma struct <code>EnderecoIp</code> que tem dois membros: <code>versao</code>, do
tipo <code>VersaoIp</code> (que definimos anteriormente) e <code>endereco</code>, do tipo <code>String</code>.
Temos duas instâncias dessa struct. A primeira, <code>local</code>, tem o valor
<code>VersaoIp::V4</code> como sua <code>versao</code>, e um endereço associado igual a <code>127.0.0.1</code>.
A segunda instância, <code>loopback</code>, tem como sua <code>versao</code> a outra variante de
<code>VersaoIp</code>, <code>V6</code>, e o endereço <code>::1</code> associado a ela. Nós usamos uma struct
para encapsular os valores de <code>versao</code> e <code>endereco</code>, agora a variante está
associada ao valor.</p>
<p>Podemos representar o mesmo conceito de uma forma mais concisa usando apenas
uma enum, em vez de uma enum dentro de uma struct, colocando dados dentro de
cada variante da enum, diretamente. Esta nova definição da enum <code>EnderecoIp</code>
diz que ambas as variantes, <code>V4</code> e <code>V6</code>, terão uma <code>String</code> associada:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum EnderecoIp {
    V4(String),
    V6(String),
}

let local = EnderecoIp::V4(String::from(&quot;127.0.0.1&quot;));

let loopback = EnderecoIp::V6(String::from(&quot;::1&quot;));
#}</code></pre></pre>
<p>Podemos anexar dados a cada variante da enum diretamente, assim não existe mais
a necessidade de uma struct adicional.</p>
<p>Há uma outra vantagem de se usar uma enum em vez de uma struct: cada variante
pode conter dados de diferentes tipos e quantidades. Os endereços IP da versão
quatro têm sempre quatro componentes numéricas, cada uma com valor de 0 a 255.
Se quiséssemos representar endereços <code>V4</code> como quatro valores <code>u8</code>, e ao mesmo
tempo manter os endereços <code>V6</code> como uma <code>String</code>, não poderíamos usar uma
struct. Já as enums podem facilmente atender a este caso:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum EnderecoIp {
    V4(u8, u8, u8, u8),
    V6(String),
}

let local = EnderecoIp::V4(127, 0, 0, 1);

let loopback = EnderecoIp::V6(String::from(&quot;::1&quot;));
#}</code></pre></pre>
<p>Acabamos de ver algumas possibilidades que poderíamos usar para representar
endereços IP das duas versões por meio de uma enum. Acontece que essa
necessidade de representar endereços IP, incluindo sua versão, é tão comum que
a biblioteca padrão já possui uma definição que podemos usar! (<a href="https://doc.rust-lang.org/std/net/enum.IpAddr.html">Veja a
documentação em inglês</a><!-- ignore -->). Vamos ver como a biblioteca
padrão define <code>IpAddr</code>: ele tem basicamente a mesma enum e as mesmas variantes
que nós definimos e usamos anteriormente, mas os dados do endereço são
embutidos dentro das variantes na forma de duas structs separadas, que são
definidas de um jeito diferente pra cada variante.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Ipv4Addr {
    // detalhes omitidos
}

struct Ipv6Addr {
    // detalhes omitidos
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
#}</code></pre></pre>
<p>Esse código mostra que você pode colocar qualquer tipo de dados dentro de uma
variante de enum: strings, tipos numéricos ou structs, por exemplo. Você pode
até mesmo incluir outra enum! Além disso, os tipos definidos pela biblioteca
padrão não são tão mais complicados do que o que talvez você pensaria em fazer.</p>
<p>Repare que, mesmo havendo um <code>IpAddr</code>definido pela biblioteca padrão, nós ainda
podemos criar e utilizar nossa própria definição (com o mesmo nome, inclusive)
sem nenhum conflito, porque não trouxemos a definição da biblioteca padrão para
dentro do nosso escopo. Falaremos mais sobre a inclusão de tipos em um escopo
no Capítulo 7.</p>
<p>Vamos ver outro exemplo de uma enum na Listagem 6-2: esta tem uma grande
variedade de tipos embutidos nas suas variantes:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Mensagem {
    Sair,
    Mover { x: i32, y: i32 },
    Escrever(String),
    MudarCor(i32, i32, i32),
}
#}</code></pre></pre>
<p><span class="caption">Listagem 6-2: Enum <code>Mensagem</code>, cujas variantes contêm,
cada uma, diferentes tipos e quantidades de dados</span></p>
<p>Esta enum tem quatro variantes de diferentes tipos:</p>
<ul>
<li><code>Sair</code> não tem nenhum dado associado.</li>
<li><code>Mover</code> contém uma struct anônima.</li>
<li><code>Escrever</code> contém uma única <code>String</code>.</li>
<li><code>MudarCor</code> contém três valores do tipo <code>i32</code>.</li>
</ul>
<p>Definir uma enum com variantes iguais às da Listagem 6-2 é similar a definir
diferentes tipos de struct, exceto que a enum não usa a palavra-chave <code>struct</code>,
e todas as variantes são agrupadas dentro do tipo <code>Mensagem</code>. As structs
seguintes podem guardar os mesmos dados que as variantes da enum anterior:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct MensagemSair; // unit struct
struct MensagemMover {
    x: i32,
    y: i32,
}
struct MensagemEscrever(String); // tuple struct
struct MensagemMudarCor(i32, i32, i32); // tuple struct
#}</code></pre></pre>
<p>Mas se usarmos structs diferentes, cada uma tendo seu próprio tipo, não vamos
conseguir tão facilmente definir uma função que possa receber qualquer um
desses tipos de mensagens, assim como fizemos com a enum <code>Mensagem</code>, definida
na Listagem 6-2, que consiste em um tipo único.</p>
<p>Há mais uma similaridade entre enums e structs: da mesma forma como podemos
definir métodos em structs usando <code>impl</code>, também podemos definir métodos em
enums. Aqui está um método chamado <code>invocar</code>, que poderia ser definido na nossa
enum <code>Mensagem</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum Mensagem {
#     Sair,
#     Mover { x: i32, y: i32 },
#     Escrever(String),
#     MudarCor(i32, i32, i32),
# }
#
impl Mensagem {
    fn invocar(&amp;self) {
        // o corpo do método é definido aqui
    }
}

let m = Mensagem::Escrever(String::from(&quot;olá&quot;));
m.invocar();
#}</code></pre></pre>
<p>O corpo do método usaria o valor <code>self</code> para obter a mensagem sobre a qual o
método foi chamado. Neste exemplo, criamos a variável <code>m</code>, que contém o valor
<code>Mensagem::Escrever(String::from(&quot;olá&quot;))</code>, e é isso que <code>self</code> vai ser no corpo
do método <code>invocar</code> quando <code>m.invocar()</code> for executado.</p>
<p>Vamos ver agora outra enum da biblioteca padrão que também é muito útil e
comum: <code>Option</code>.</p>
<a class="header" href="print.html#a-enum-option-e-suas-vantagens-sobre-valores-nulos" id="a-enum-option-e-suas-vantagens-sobre-valores-nulos"><h3>A Enum <code>Option</code> e Suas Vantagens Sobre Valores Nulos</h3></a>
<p>Na seção anterior, vimos como a enum <code>EnderecoIp</code> nos permite usar o sistema de
tipos do Rust para codificar em nosso programa mais informação do que apenas os
dados que queremos representar. Essa seção explora um caso de estudo da
<code>Option</code>, que é outra enum definida pela biblioteca padrão. O tipo <code>Option</code> é
muito utilizado, pois engloba um cenário muito comum, em que um valor pode ser
algo ou pode não ser nada. Expressar esse conceito por meio do sistema de tipos
significa que o compilador pode verificar se você tratou, ou não, todos os
casos que deveriam ser tratados, podendo evitar <em>bugs</em> que são extremamente
comuns em outras linguagens de programação.</p>
<p>O <em>design</em> de uma linguagem de programação é geralmente tratado em termos de
quais características são incluídas, mas as que são excluídas também têm
importância. Rust não tem o valor nulo (<em>null</em>) que outras linguagens têm. O
valor nulo quer dizer que não há nenhum valor. Em linguagens que têm essa
característica, as variáveis sempre estão em um dos dois estados: nulo ou não
nulo.</p>
<p>Em uma conferência, Tony Hoare, inventor do valor nulo, disse o seguinte:</p>
<blockquote>
<p>Eu o chamo meu erro de um bilhão de dólares. Naquela época, eu estava
projetando o primeiro sistema abrangente de tipos para referências em uma
linguagem orientada a objetos. Meu objetivo era garantir que todo uso de
referências deveria ser absolutamente seguro, com verificação automática
feita pelo compilador. Mas não pude resistir à tentação de colocar uma
referência nula, simplesmente porque era tão fácil de implementar. Isso tem
provocado inúmeros erros, vulnerabilidades, e falhas de sistemas que
provavelmente causaram um bilhão de dólares de dor e danos nos últimos
quarenta anos.</p>
</blockquote>
<p>O problema com valores nulos é que, se você tentar usar um valor nulo como se
fosse não nulo, vai acontecer algum tipo de erro. Pelo fato dessa propriedade
de nulo e não nulo ser tão sutil, é extremamente fácil cometer esse tipo de
erro.</p>
<p>Porém, o conceito que o valor nulo tenta expressar ainda é útil: um valor nulo
representa algo que, por algum motivo, está inválido ou ausente no momento.</p>
<p>O problema, na verdade, não está no conceito, mas na implementação em
particular. Por isso, Rust não possui valores nulos, mas sim uma enum que
engloba o conceito de um valor estar presente ou ausente. Esta enum é a
<code>Option&lt;T&gt;</code>, que está definida na biblioteca padrão da seguinte forma:
(<a href="https://doc.rust-lang.org/std/option/enum.Option.html">Veja a documentação em inglês</a><!-- ignore -->).</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Option&lt;T&gt; {
    Some(T), // algum valor
    None, // nenhum valor
}
#}</code></pre></pre>
<p>A enum <code>Option&lt;T&gt;</code> é tão útil que ela já vem inclusa no prelúdio: você não
precisa trazê-la explicitamente para o seu escopo. Além disso, o mesmo ocorre
com suas variantes: você pode usar <code>Some</code> e <code>None</code> diretamente sem prefixá-las
com <code>Option::</code>. <code>Option&lt;T&gt;</code> continua sendo uma enum como qualquer outra, e
<code>Some(T)</code> e <code>None</code> ainda são variantes do tipo <code>Option&lt;T&gt;</code>.</p>
<p>A sintaxe do <code>&lt;T&gt;</code> é uma característica do Rust de que não falamos ainda.
Trata-se de um parâmetro de tipo genérico, vamos abordá-lo com mais detalhe no
Capítulo 10. Por ora, tudo que você precisa saber é que <code>&lt;T&gt;</code> significa que a
variante <code>Some</code> da enum <code>Option</code> pode conter um dado de qualquer tipo. Aqui vão
alguns exemplos de <code>Option</code> contendo tipos de número e texto:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let algum_numero = Some(5);
let algum_texto = Some(&quot;um texto&quot;);

let numero_ausente: Option&lt;i32&gt; = None;
#}</code></pre></pre>
<p>Se usamos <code>None</code> em vez de <code>Some</code>, precisamos dizer ao Rust qual é o tipo de
<code>Option&lt;T&gt;</code> que nós temos, porque o compilador não consegue inferir qual tipo
estará contido na variante <code>Some</code> apenas olhando para um valor <code>None</code>.</p>
<p>Quando temos um <code>Some</code>, sabemos que um valor está presente, contido dentro do
<code>Some</code>. Já quando temos um <code>None</code>, de certa forma, significa o mesmo que um
valor nulo: não temos um valor que seja válido. Então por que a <code>Option&lt;T&gt;</code> é
tão melhor que usar um valor nulo?</p>
<p>Em resumo, é porque <code>Option&lt;T&gt;</code> e <code>T</code> (podendo <code>T</code> ser de qualquer tipo) são
tipos diferentes, por isso, o compilador não vai permitir usar um valor do tipo
<code>Option&lt;T&gt;</code> como se ele definitivamente tivesse um valor válido. Por exemplo,
o código seguinte não vai compilar, porque ele está tentando somar um <code>i8</code> a um
<code>Option&lt;i8&gt;</code>:</p>
<pre><code class="language-rust ignore">let x: i8 = 5;
let y: Option&lt;i8&gt; = Some(5);

let soma = x + y;
</code></pre>
<p>Quando executamos esse código, temos uma mensagem de erro como essa:</p>
<pre><code class="language-text">error[E0277]: the trait bound `i8: std::ops::Add&lt;std::option::Option&lt;i8&gt;&gt;` is
not satisfied
 --&gt;
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + std::option::Option&lt;i8&gt;`
  |
</code></pre>
<p>Intenso! O que essa mensagem quer dizer é que o Rust não consegue entender como
somar um <code>i8</code> e um <code>Option&lt;i8&gt;</code>, porque eles são de tipos diferentes. Quando
temos um valor de um tipo como <code>i8</code> em Rust, o compilador tem certeza de que
temos sempre um valor válido. Podemos prosseguir com confiança, sem ter de
verificar se o valor é nulo antes de usá-lo. Somente quando temos um
<code>Option&lt;i8&gt;</code> (ou qualquer que seja o tipo com que estamos trabalhando), vamos
ter de nos preocupar com a possibilidade de não haver um valor, e o compilador
vai se certificar de que nós estamos tratando este caso antes de usar o valor.</p>
<p>Em outras palavras, você tem que converter um <code>Option&lt;T&gt;</code> em um <code>T</code> antes de
poder executar operações com ele. Geralmente, isso ajuda a detectar um dos
problemas mais comuns com valores nulos: assumir que algo não é nulo quando,
na verdade, ele é.</p>
<p>Só de não ter que se preocupar com a possibilidade de ter deixado um valor nulo
escapar já lhe dá mais confiança em seu código. Pra ter um valor que pode ser
nulo em algum momento, você precisa, explicitamente, marcá-lo como sendo do
tipo <code>Option&lt;T&gt;</code>. A partir daí, sempre que for usar o valor, você será obrigado
a tratar, de forma explícita, o caso do valor sendo nulo. Sempre que houver um
valor que não seja um <code>Option&lt;T&gt;</code>, você <em>pode</em> assumir, com segurança, que o
valor não é nulo. Esta foi uma decisão deliberada de projeto do Rust para
limitar as sutilezas dos valores nulos e aumentar a segurança do código.</p>
<p>Então, como obter o valor <code>T</code> da variante <code>Some</code> quando se tem um <code>Option&lt;T&gt;</code>,
para que se possa usar seu valor? A enum <code>Option&lt;T&gt;</code> possui diversos métodos
que são úteis em uma variedade de situações, você pode pesquisá-los na
<a href="https://doc.rust-lang.org/std/option/enum.Option.html">documentação</a><!-- ignore --> (em inglês). Será extremamente útil na sua
jornada com Rust se familizarizar com os métodos da enum <code>Option&lt;T&gt;</code>.</p>
<p>Em geral, pra usar um valor <code>Option&lt;T&gt;</code>, queremos ter um código que trate cada
uma das variantes. Queremos um código que só será executado quando tivermos um
valor <code>Some(T)</code>, e esse código terá permissão para usar o valor <code>T</code> que está
embutido. Queremos também um outro código que seja executado se tivermos um
valor <code>None</code>, e esse código não terá um valor <code>T</code> disponível. A expressão
<code>match</code> é uma instrução de controle de fluxo que faz exatamente isso quando
usada com enums: ela executa códigos diferentes dependendo de qual variante
tiver a enum, e esse código poderá usar os dados contidos na variante
encontrada.</p>
<a class="header" href="print.html#operador-match-de-controle-de-fluxo" id="operador-match-de-controle-de-fluxo"><h2>Operador <code>match</code> de Controle de Fluxo</h2></a>
<p>O Rust tem um excelente operador de controle de fluxo chamado <code>match</code>, que nos
permite comparar um valor com uma série de padrões e executar um código com
base no padrão que casar. Padrões podem ser compostos de valores literais,
variáveis, caracteres-curinga e várias outras coisas. O Capítulo 18 aborda
todos os tipos de padrões e o que eles fazem. A grande utilidade do <code>match</code> vem
da expressividade dos padrões e das análises feitas pelo compilador, tendo
certeza de que todos os casos possíveis estão sendo tratados.</p>
<p>Imagine que expressão <code>match</code> funciona como uma máquina de contar moedas: as
moedas passam por um canal que possui furos de vários tamanhos, e cada moeda
cai no primeiro furo em que ela couber. Da mesma forma, os valores passam por
cada padrão de um <code>match</code>, e logo no primeiro padrão que o valor &quot;se encaixar&quot;,
o bloco de código que estiver associado a ele será executado.</p>
<p>Aproveitando que acabamos de falar sobre moedas, vamos usá-las como exemplo de
utilização do <code>match</code>! Podemos escrever uma função que recebe uma moeda
qualquer dos Estados Unidos e, assim como uma máquina, determina qual moeda ela
é e retorna seu valor em <em>cents</em>, como mostra a Listagem 6-3:</p>
<blockquote>
<p><strong>Nota do tradutor:</strong> diferentemente do que acontece na maioria dos países,
as moedas dos Estados Unidos possuem nomes: as de 1 <em>cent</em> são chamadas de
<em>Penny</em>; as de 5 <em>cents</em>, de <em>Nickel</em>; as de 10 <em>cents</em>, de <em>Dime</em>; e as de 25
<em>cents</em>, de <em>Quarter</em>.</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Moeda {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn valor_em_cents(moeda: Moeda) -&gt; u32 {
    match moeda {
        Moeda::Penny =&gt; 1,
        Moeda::Nickel =&gt; 5,
        Moeda::Dime =&gt; 10,
        Moeda::Quarter =&gt; 25,
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 6-3: Uma enum e uma expressão <code>match</code> em que os
padrões comparados são as variantes da enum.</span></p>
<p>Vamos analisar o <code>match</code> da função <code>valor_em_cents</code>. Primeiro, usamos a
palavra-chave <code>match</code> seguida de uma expressão, que neste caso é o valor
<code>moeda</code>. É parecido a uma expressão utilizada com <code>if</code>, mas tem uma grande
diferença: com <code>if</code>, a expressão precisa retornar um valor <em>booleano</em>. Aqui,
pode ser de qualquer tipo. O tipo da variável <code>moeda</code>, neste exemplo, é a enum
<code>Moeda</code>, que definimos na Listagem 6-3.</p>
<p>Em seguida vêm os braços do <code>match</code>. Um braço é composto por duas partes: um
padrão e algum código. O primeiro braço deste exemplo tem um padrão, que é o
valor <code>Moeda::Penny</code>, e o operador <code>=&gt;</code> que separa o padrão do código associado
a ele. O código, nesse caso, é apenas o valor <code>1</code>. Os braços são separados uns
dos outros com uma vírgula.</p>
<p>Quando o <code>match</code> é executado, ele compara o valor resultante com o padrão de
cada braço, na ordem. Se o valor casar com um determinado padrão, o código
associado a esse padrão será executado. Se o valor não se encaixa nesse padrão,
a execução passa para o próximo braço, bem parecido com a máquina de contar
moedas. Podemos ter tantos braços quanto precisamos. No caso da Listagem 6-3,
nosso <code>match</code> tem quatro braços.</p>
<p>O código associado a cada braço é uma expressão, e o seu valor resultante, no
braço que combinar, é o que será retornado pela expressão <code>match</code>.</p>
<p>Tipicamente não se usa chaves se o braço do <code>match</code> for curto, como é o caso na
Listagem 6-3, em que cada braço retorna apenas um valor. Se você quiser
executar mais de uma linha de código em um braço, você pode usar chaves para
delimitá-las. Por exemplo, o código seguinte vai escrever na tela &quot;Moeda da
sorte!&quot; sempre que o método for chamado com uma <code>Moeda::Penny</code>, mas ainda vai
retornar o último valor do bloco, <code>1</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum Moeda {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter,
# }
#
fn valor_em_cents(moeda: Moeda) -&gt; u32 {
    match moeda {
        Moeda::Penny =&gt; {
            println!(&quot;Moeda da sorte!&quot;);
            1
        },
        Moeda::Nickel =&gt; 5,
        Moeda::Dime =&gt; 10,
        Moeda::Quarter =&gt; 25,
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#padrões-atrelados-a-valores" id="padrões-atrelados-a-valores"><h3>Padrões Atrelados a Valores</h3></a>
<p>Outra característica útil dos braços do <code>match</code> é que eles podem ser atrelados
a partes dos valores que se encaixam no padrão. É assim que podemos extrair
valores dentro de uma variante de uma enum.</p>
<p>Por exemplo, vamos alterar uma das nossas variantes, inserindo dados dentro
dela. De 1999 até 2008, os Estados Unidos cunhou <em>quarters</em> com um <em>design</em>
diferente para cada um dos 50 estados em um dos lados da moeda. Nenhuma outra
moeda tinha essa diferença no <em>design</em>, apenas os <em>quarters</em>. Podemos adicionar
essa informação à nossa <code>enum</code> alterando a variante <code>Quarter</code> para incluir o
valor <code>Estado</code>, como é feito na Listagem 6-4:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug)] // Para podermos ver qual é o estado com mais facilidade
enum Estado {
    Alabama,
    Alaska,
    // ... etc
}

enum Moeda {
    Penny,
    Nickel,
    Dime,
    Quarter(Estado),
}
#}</code></pre></pre>
<p><span class="caption">Listagem 6-4: Enum <code>Moeda</code>, cuja variante <code>Quarter</code>
também guarda o valor <code>Estado</code>.</span></p>
<p>Vamos imaginar que um amigo nosso está tentando colecionar todas os <em>quarters</em>
dos 50 estados. Enquanto separamos nosso troco por tipo de moeda, vamos também
dizer o nome do estado associado a cada <em>quarter</em>. Se for um dos que o nosso
amigo ainda não tem, ele pode colocá-lo na sua coleção.</p>
<p>Na expressão <code>match</code> desse código, vamos adicionar uma variável chamada
<code>estado</code> ao padrão que casa com os valores da variante <code>Moeda::Quarter</code>. Quando
uma <code>Moeda::Quarter</code> é testada, a variável <code>estado</code> vai ser atrelada ao valor
do estado daquele <em>quarter</em>. Assim vamos poder usar o <code>estado</code> no código do
braço, desse jeito:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug)]
# enum Estado {
#    Alabama,
#    Alaska,
# }
#
# enum Moeda {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter(Estado),
# }
#
fn valor_em_cents(moeda: Moeda) -&gt; u32 {
    match moeda {
        Moeda::Penny =&gt; 1,
        Moeda::Nickel =&gt; 5,
        Moeda::Dime =&gt; 10,
        Moeda::Quarter(estado) =&gt; {
            println!(&quot;Quarter do estado {:?}!&quot;, estado);
            25
        },
    }
}
#}</code></pre></pre>
<p>Se executarmos <code>valor_em_cents(Moeda::Quarter(Estado::Alaska))</code>, <code>moeda</code> seria
<code>Moeda::Quarter(Estado::Alaska)</code>. Quando comparamos esse valor em cada um dos
braços do <code>match</code>, nenhum deles vai casar enquanto não chegar em
<code>Moeda::Quarter(estado)</code>. Nesse ponto, <code>estado</code> vai estar atrelado ao valor
<code>Estado::Alaska</code>. Podemos, então, usar esse valor na expressão <code>println!</code>,
obtendo o estado contido na variante <code>Quarter</code> da enum <code>Moeda</code>.</p>
<a class="header" href="print.html#usando-match-com-optiont" id="usando-match-com-optiont"><h3>Usando <code>match</code> com <code>Option&lt;T&gt;</code></h3></a>
<p>Na seção anterior, queríamos obter o valor <code>T</code> contido em um <code>Some</code> quando era
o caso em uma <code>Option&lt;T&gt;</code>. Também podemos manipular uma <code>Option&lt;T&gt; usando</code>match<code>, assim como fizemos com a enum</code>Moeda<code>! Em vez de comparar moedas, vamos comparar as variantes de</code>Option<T><code>, mas a forma de trabalhar com a expressão</code>match` continua a mesma.</p>
<p>Digamos que queremos escrever uma função que recebe um <code>Option&lt;i32&gt;</code>, e se
houver um valor embutido nele, soma um a esse valor. Se não houver um valor,
a função deve retornar <code>None</code>, e nem tentar executar nenhuma operação.</p>
<p>Essa função é bem fácil de implementar, graças ao <code>match</code>, e vai ficar conforme
visto na Listagem 6-5:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn mais_um(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        None =&gt; None,
        Some(i) =&gt; Some(i + 1),
    }
}

let cinco = Some(5);
let seis = mais_um(cinco);
let nenhum = mais_um(None);
#}</code></pre></pre>
<p><span class="caption">Listagem 6-5: Uma função que usa um <code>match</code> para tratar
uma <code>Option&lt;i32&gt;</code>.</span></p>
<a class="header" href="print.html#casando-somet" id="casando-somet"><h4>Casando <code>Some(T)</code></h4></a>
<p>Vamos examinar a primeira execução de <code>mais_um</code> em mais detalhes. Quando
chamamos <code>mais_um(cinco)</code>, a variável <code>x</code> no corpo da função <code>mais_um</code> vai ter
o valor <code>Some(5)</code>. Então comparamos ele a cada braço do <code>match</code>.</p>
<pre><code class="language-rust ignore">None =&gt; None,
</code></pre>
<p>O valor <code>Some(5)</code> não casa com o padrão <code>None</code>, então seguimos para o
próximo braço.</p>
<pre><code class="language-rust ignore">Some(i) =&gt; Some(i + 1),
</code></pre>
<p><code>Some(5) casa com</code>Some(i)<code>? Sim, casa! Temos a mesma variante. O</code>i<code>está atrelado ao valor contido em</code>Some<code>, então</code>i<code>passa a ter o valor</code>5<code>. O código desse braço é executado, então somamos um ao valor de</code>i<code>e criamos um novo</code>Some<code>contendo nosso total de</code>6`.</p>
<a class="header" href="print.html#casando-none" id="casando-none"><h4>Casando <code>None</code></h4></a>
<p>Agora vamos considerar a segunda chamada da função <code>mais_um</code> na Listagem 6-5,
em que <code>x</code> é <code>None</code>. Nós entramos no <code>match</code> e comparamos com o primeiro braço.</p>
<pre><code class="language-rust ignore">None =&gt; None,
</code></pre>
<p>Confere! Não há nenhum valor para somar, então o programa pára e retorna o
valor <code>None</code> do lado direito do <code>=&gt;</code>. Como o primeiro braço já casou, nenhum
dos demais será testado.</p>
<p>A combinação de enums e a expressão <code>match</code> é útil em diversas situações. Você
verá muito esse padrão em Rust: fazer o <code>match</code> de uma enum, associar uma
variável ao valor embutido, e então executar um código baseado nele. Pode
parecer complicado no começo, mas uma vez que você se acostume, você vai querer
que tivesse isso em todas as linguagens. É, sistematicamente, um favorito dos
usuários.</p>
<a class="header" href="print.html#matches-são-exaustivos" id="matches-são-exaustivos"><h3><em>Matches</em> São Exaustivos</h3></a>
<p>Há outro aspecto do <code>match</code> que precisamos discutir. Considere essa versão da
nossa função <code>mais_um</code>:</p>
<pre><code class="language-rust ignore">fn mais_um(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        Some(i) =&gt; Some(i + 1),
    }
}
</code></pre>
<p>Nós não tratamos o caso <code>None</code>, logo vai ocorrer um <em>bug</em> no nosso código. Por
sorte, é um <em>bug</em> que o Rust sabe detectar. Se tentarmos compilar esse código,
vamos ter esse erro:</p>
<pre><code class="language-text">error[E0004]: non-exhaustive patterns: `None` not covered
 --&gt;
  |
6 |         match x {
  |               ^ pattern `None` not covered
</code></pre>
<p>O Rust sabe que nós não cobrimos todos os casos possíveis, e sabe até de qual
padrão nos esquecemos! <em>Matches</em> em Rust são <em>exaustivos</em>: precisamos extinguir
até a última possibilidade pra que o nosso código seja válido. Especialmente no
caso de uma <code>Option&lt;T&gt;</code>, em que o Rust não nos deixa esquecer de tratar
explicitamente o caso <code>None</code>. Ele nos impede de assumir que temos um valor
válido quando possivelmente temos um valor nulo, e portanto, cometer o erro de
um bilhão de dólares que vimos mais cedo.</p>
<a class="header" href="print.html#the-_-placeholder" id="the-_-placeholder"><h3>The <code>_</code> Placeholder</h3></a>
<a class="header" href="print.html#o-placeholder-_" id="o-placeholder-_"><h3>O <em>Placeholder</em> <code>_</code></h3></a>
<p>O Rust também tem um padrão que podemos usar em situações em que não queremos
listar todos os valores possíveis. Por exemplo, um <code>u8</code> pode ter valores
válidos de 0 a 255. Se nos importamos apenas com os valores 1, 3, 5 e 7, não
queremos ser obrigados a listar o 0, 2, 4, 6, 8, 9, e assim por diante até 255.
Felizmente, nem precisamos: em vez disso, podemos usar o padrão especial <code>_</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let algum_valor_u8 = 0u8;
match algum_valor_u8 {
    1 =&gt; println!(&quot;um&quot;),
    3 =&gt; println!(&quot;três&quot;),
    5 =&gt; println!(&quot;cinco&quot;),
    7 =&gt; println!(&quot;sete&quot;),
    _ =&gt; (),
}
#}</code></pre></pre>
<p>O padrão <code>_</code> casa com qualquer valor. Colocando ele depois dos demais
braços, o <code>_</code> vai casar com todos os casos possíveis que não foram
especificados antes dele. O <code>()</code> é só o valor-unidade, pra que nada aconteça no
caso <code>_</code>. Como resultado, podemos dizer que não queremos fazer nada com os
possíveis valores que não listamos antes do <em>placeholder</em> <code>_</code>.</p>
<p>Contudo, a expressão <code>match</code> pode ser um tanto verbosa em uma situação em que
queremos apenas lidar com <em>um</em> dos casos. Pra essa situação, o Rust oferece o
<code>if let</code>.</p>
<a class="header" href="print.html#controle-de-fluxo-conciso-com-if-let" id="controle-de-fluxo-conciso-com-if-let"><h2>Controle de Fluxo Conciso com <code>if let</code></h2></a>
<p>A sintaxe do <code>if let</code> permite combinar <code>if</code> e <code>let</code> em uma forma menos verbosa
de tratar apenas os valores que casam com um padrão e ignorar os demais.
Considere o programa da Listagem 6-6, que confere um valor do tipo
<code>Option&lt;u8&gt;</code>, mas só executa um código se houver um valor associado igual a
três:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let algum_valor_u8 = Some(0u8);
match algum_valor_u8 {
    Some(3) =&gt; println!(&quot;três&quot;),
    _ =&gt; (),
}
#}</code></pre></pre>
<p><span class="caption">Listagem 6-6: Um <code>match</code> que só executa um código quando
o valor é <code>Some(3)</code>.</span></p>
<p>Queremos fazer alguma coisa com o <code>Some(3)</code>, mas não queremos fazer nada com
nenhum outro valor, seja <code>Some&lt;u8&gt;</code> ou <code>None</code>. Pra satisfazer a expressão
<code>match</code>, temos que colocar <code>_ =&gt; ()</code> após processar apenas uma variante, ou
seja, é muito código para pouca coisa.</p>
<p>Em vez disso, poderíamos escrever o mesmo código de uma forma mais compacta,
usando <code>if let</code>. O código seguinte tem o mesmo comportamento do <code>match</code> na
Listagem 6-6:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# let algum_valor_u8 = Some(0u8);
if let Some(3) = algum_valor_u8 {
    println!(&quot;três&quot;);
}
#}</code></pre></pre>
<p><code>if let</code> recebe um padrão e uma expressão separados por um <code>=</code>. Isso funciona
da mesma forma que um <code>match</code>, em que a expressão seria passada para o <code>match</code>,
e o padrão apareceria no primeiro braço.</p>
<p>Usar o <code>if let</code> implica menos código pra digitar e menos indentação. Porém,
perdemos a verificação exaustiva que é garantida pelo <code>match</code>. A escolhe entre
<code>match</code> e <code>if let</code> depende do que você está fazendo em uma situação particular,
e se a redução no volume de código compensa a perda da verificação exaustiva.</p>
<p>Em outras palavras, você pode enxergar o <code>if let</code> como um <em>syntax sugar</em> (um
atalho) para um <code>match</code> que só executa um código quando o valor casa com um
único padrão, e ignora todos os outros valores.</p>
<p>Também podemos incluir um <code>else</code> em um <code>if let</code>. O bloco de código que vai no
<code>else</code> é o mesmo que iria no caso <code>_</code> da expressão <code>match</code> equivalente.
Lembre-se da enum <code>Moeda</code> que definimos na Listagem 6-4, cuja variante
<code>Quarter</code> guardava um valor do tipo <code>Estado</code>. Se queremos contar todas as
moedas que não forem <em>quarters</em>, enquanto também anunciamos o estado dos
<em>quarters</em>, poderíamos fazer isso com uma expressão <code>match</code> igual a esta:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug)]
# enum Estado {
#    Alabama,
#    Alaska,
# }
#
# enum Moeda {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter(Estado),
# }
# let moeda = Coin::Penny;
let mut contagem = 0;
match moeda {
    Moeda::Quarter(estado) =&gt; println!(&quot;Quarter do estado {:?}!&quot;, estado),
    _ =&gt; contagem += 1,
}
#}</code></pre></pre>
<p>Ou poderíamos usar um <code>if let</code> e um <code>else</code> desta forma:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug)]
# enum Estado {
#    Alabama,
#    Alaska,
# }
#
# enum Moeda {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter(Estado),
# }
# let moeda = Moeda::Penny;
let mut contagem = 0;
if let Moeda::Quarter(estado) = moeda {
    println!(&quot;Quarter do estado {:?}!&quot;, estado);
} else {
    contagem += 1;
}
#}</code></pre></pre>
<p>Se a lógica do seu programa fica muito verbosa quando é expressa por meio de um
<code>match</code>, lembre-se que você também dispõe do <code>if let</code>.</p>
<a class="header" href="print.html#resumo-3" id="resumo-3"><h2>Resumo</h2></a>
<p>Nós acabamos de ver como usar enums para criar tipos customizados a partir de
um conjunto de valores enumerados. Mostramos como o tipo <code>Option&lt;T&gt;</code>, da
biblioteca padrão, ajuda você a usar o sistema de tipos para evitar erros.
Quando as enums contêm dados, você pode usar <code>match</code> ou <code>if let</code> para extrair
e usar esses valores, dependendo de quantos casos você precisa tratar.</p>
<p>Agora, seus programas em Rust podem expressar conceitos em seu domínio usando
structs e enums. Criar tipos customizados para a sua <em>API</em> aumenta sua
segurança: o compilador vai se certificar de que suas funções recebem apenas
os valores que correspondem aos tipos esperados.</p>
<p>Para fornecer uma API bem organizada aos seus usuários, que seja simples de
usar, e que exponha apenas o que é necessário aos usuários, vamos agora passar
para os módulos em Rust.</p>
<a class="header" href="print.html#usando-módulos-para-reutilizar-e-organizar-código" id="usando-módulos-para-reutilizar-e-organizar-código"><h1>Usando Módulos para Reutilizar e Organizar Código</h1></a>
<p>Quando você começa a escrever programas em Rust, seu código pode se manter apenas na
função <code>main</code>. À medida que seu código cresce, você acabará por mover funcionalidades para
outras outras funções a fim de reutilizar código e melhorar a organização. Ao dividir seu código em
pequenos pedaços, cada pedaço é mais fácil de entender por si só. Mas o que acontece
se você tem muitas funções? Rust possui um sistema de módulos que permite a reutilização
de código de forma organizada.</p>
<p>Da mesma forma que você extrai linhas de código em uma função, você pode extrair
funções (e outros códigos, como structs e enums) em diferentes módulos. Um
<em>módulo</em> é um namespace que contém definições de funções ou tipos, e
você pode escolher se essas definições são visíveis fora de seu módulo
(público) ou não (privado). Aqui está uma visão geral de como os módulos funcionam:</p>
<ul>
<li>A palavra-chave <code>mod</code> declara um novo módulo. O código dentro do módulo aparece
   imediatamente após esta declaração dentro de chaves ou em
   outro arquivo.</li>
<li>Por padrão, as funções, tipos, constantes e módulos são privados. A palavra-chave <code>pub</code>
    torna um item público e, portanto, visível fora do seu namespace.</li>
<li>A palavra-chave <code>use</code> traz módulos, ou as definições dentro dos módulos, ao
   escopo, assim é mais fácil se referir a eles.</li>
</ul>
<p>Examinaremos cada uma dessas partes para ver como elas se encaixam no todo.</p>
<a class="header" href="print.html#mod-e-o-sistema-de-arquivos" id="mod-e-o-sistema-de-arquivos"><h2><code>mod</code> e o Sistema de Arquivos</h2></a>
<p>Vamos iniciar o nosso exemplo de módulo fazendo um novo projeto com o Cargo, mas em vez de
criar um crate binário, faremos um crate de biblioteca: um projeto que
as outras pessoas podem puxar para os seus projetos como uma dependência. Por exemplo, o crate <code>rand</code>
discutido no Capítulo 2, é um crate de biblioteca que usamos como uma dependência no
projeto do jogo de adivinhação.</p>
<p>Criaremos um esqueleto de uma biblioteca que fornece algumas funcionalidades gerais
de rede; nos concentraremos na organização dos módulos e funções,
mas não nos preocuparemos com o código que está dentro das funções. Chamaremos
nossa biblioteca de <code>communicator</code>. Por padrão, o Cargo criará uma biblioteca, a menos que
outro tipo de projeto seja especificado: se omitimos a opção <code>--bin</code>, que temos
usado em todos os capítulos anteriores a este, nosso projeto será um
biblioteca:</p>
<pre><code class="language-text">$ cargo new communicator
$ cd communicator
</code></pre>
<p>Observe que Cargo gerou <em>src/lib.rs</em> em vez de <em>src/main.rs</em>. Dentro de
<em>src/lib.rs</em> encontraremos o seguinte:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
#}</code></pre></pre>
<p>Cargo cria um teste de exemplo para nos ajudar a começar nossa biblioteca, em vez de
o binário “Hello, world!” que recebemos quando usamos a opção <code>--bin</code>. Olharemos
a sintaxe <code>#[]</code> e <code>mod tests</code> no “Usando <code>super</code> para Acessar um
Módulo Pai” mais adiante neste capítulo, mas por agora, deixe este código
na parte inferior de <em>src/lib.rs</em>.</p>
<p>Como não temos um arquivo <em>src/main.rs</em>, não há nada para ser executado pelo Cargo
com o comando <code>cargo run</code>. Portanto, usaremos o comando  <code>cargo build</code>
para compilar o código da nossa biblioteca.</p>
<p>Examinaremos diferentes opções para organizar o código da sua biblioteca que serão
adequados em uma variedade de situações, dependendo da intenção do código.</p>
<a class="header" href="print.html#definições-do-módulo" id="definições-do-módulo"><h3>Definições do Módulo</h3></a>
<p>Para a nossa biblioteca de rede <code>communicator</code>, primeiro definiremos um módulo chamado
<code>network</code> que contém a definição de uma função chamada<code>connect</code>. Cada
definição de módulo em Rust começa com a palavra-chave <code>mod</code>. Adicione este código ao
início do arquivo <em>src/lib.rs</em>, acima do código de teste:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod network {
    fn connect() {
    }
}
#}</code></pre></pre>
<p>Após a palavra-chave <code>mod</code>, colocamos o nome do módulo, <code>network</code> e, em seguida, um
bloco de código entre chaves. Tudo dentro deste bloco está dentro do
namespace <code>network</code>. Neste caso, temos uma única função, <code>connect</code>. Se nós
quisermos chamar essa função do código fora do módulo <code>network</code>, nós
precisaremos especificar o módulo e usar a sintaxe do namespace <code>::</code>, assim:
<code>network::connect()</code> em vez de apenas <code>connect()</code>.</p>
<p>Também podemos ter múltiplos módulos, lado a lado, no mesmo arquivo <em>src/lib.rs</em>.
Por exemplo, para ter mais um módulo <code>client</code> que possui uma função chamada <code>connect</code>
, podemos adicioná-lo como mostrado na Listagem 7-1:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod network {
    fn connect() {
    }
}

mod client {
    fn connect() {
    }
}
#}</code></pre></pre>
<p><span class = "caption"> Listagem 7-1: O módulo <code>network</code> e o módulo <code>client</code>
definidos lado a lado em <em>src/lib.rs</em> </span></p>
<p>Agora, temos uma função <code>network::connect</code> e uma função <code>client::connect</code>.
Estas podem ter funcionalidades completamente diferentes, e os nomes das funções
não estão em conflito entre si porque estão em módulos diferentes.</p>
<p>Nesse caso, como estamos construindo uma biblioteca, o arquivo que serve como
ponto de entrada para construir nossa biblioteca é <em>src/lib.rs</em>. No entanto, em relação a
criação de módulos, não há nada de especial sobre <em>src/lib.rs</em>. Poderíamos também
criar módulos em <em>src/main.rs</em> para um crate binário da mesma forma que nós
criamos módulos em <em>src/lib.rs</em> para o crate de biblioteca. Na verdade, podemos colocar módulos
dentro de módulos, o que pode ser útil à medida que seus módulos crescem para manter juntas
funcionalidades relacionadas e separar funcionalidades não relacionadas. A
escolha de como você organiza seu código depende do que você pensa sobre a
relação entre as partes do seu código. Por exemplo, o código <code>client</code>
e a função <code>connect</code> podem ter mais sentido para os usuários de nossa biblioteca se
eles estivessem dentro do namespace <code>network</code>, como na Listagem 7-2:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod network {
    fn connect() {
    }

    mod client {
        fn connect() {
        }
    }
}
#}</code></pre></pre>
<p><span class = "caption"> Listagem 7-2: Movendo o módulo <code>client</code> para dentro do
módulo <code>network</code></span></p>
<p>No seu arquivo <em>src/lib.rs</em>, substitua as definições <code>mod network</code> e <code>mod client</code>
pelas da Listagem 7-2, que possuem o módulo <code>client</code> como um
módulo interno da <code>network</code>. Agora temos as funções <code>network::connect</code> e
<code>network::client::connect</code>: novamente, as duas funções denominadas <code>connect</code> não conflitam
uma com a outra porque elas estão em diferentes namespaces.</p>
<p>Desta forma, os módulos formam uma hierarquia. O conteúdo de <em>src/lib.rs</em> está no
nível superior mais alto, e os submódulos estão em níveis mais baixos. Aqui está
a nossa organização quando pensada de forma hierárquica na Listagem 7-1:</p>
<pre><code class="language-text">communicator
 ├── network
 └── client
</code></pre>
<p>E aqui está a hierarquia correspondente ao exemplo na Listagem 7-2:</p>
<pre><code class="language-text">communicator
 └── network
     └── client
</code></pre>
<p>Conforme a hierarquia mostrada na Listagem 7-2, <code>client</code> é um filho do módulo <code>network</code>
em vez de um irmão. Projetos mais complicados podem ter muitos módulos, é necessário
organizá-los logicamente para mantê-los sob controle. O que &quot;logicamente&quot; significa em
seu projeto fica a seu critério, e depende do que você e os usuários da sua biblioteca
pensam sobre o domínio do seu projeto. Use as técnicas mostradas
aqui para criar módulos lado a lado e módulos aninhados em qualquer estrutura que
você queira.</p>
<a class="header" href="print.html#movendo-módulos-para-outros-arquivos" id="movendo-módulos-para-outros-arquivos"><h3>Movendo Módulos para Outros Arquivos</h3></a>
<p>Os módulos formam uma estrutura hierárquica, bem parecida com outra estrutura computacional
que você conhece: sistemas de arquivos! Podemos usar o sistema de módulos do Rust juntamente com
vários arquivos para dividir projetos Rust de forma que nem tudo resida em
<em>src/lib.rs</em> ou <em>src/main.rs</em>. Para este exemplo, vamos começar com o código em
Listagem 7-3:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod client {
    fn connect() {
    }
}

mod network {
    fn connect() {
    }

    mod server {
        fn connect() {
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 7-3: Três módulos, <code>client</code>, <code>network</code>, e
<code>network::server</code>, todos definidos em <em>src/lib.rs</em></span></p>
<p>O arquivo <em>src/lib.rs</em> possui esta hierarquia de módulos:</p>
<pre><code class="language-text">communicator
 ├── client
 └── network
     └── server
</code></pre>
<p>Se esses módulos tivessem muitas funções, e elas estivessem se alongando muito,
seria difícil percorrer esse arquivo para encontrar o código com que queremos
trabalhar. Como as funções estão aninhadas dentro de um ou mais blocos <code>mod</code>,
as linhas de código dentro das funções começarão a se alongar também.
Estes seriam bons motivos para separar os módulos <code>client</code>, <code>network</code>, e <code>server</code>
de <em>src/lib.rs</em> e colocá-los em seus próprios arquivos.</p>
<p>Primeiro, substitua o código do módulo <code>client</code> por apenas a declaração do
módulo <code>client</code>, para que seu <em>src/lib.rs</em> se pareça com o código mostrado na Listagem 7-4:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">mod client;

mod network {
    fn connect() {
    }

    mod server {
        fn connect() {
        }
    }
}
</code></pre>
<p><span class="caption"> Listagem 7-4: Extraindo o conteúdo do módulo <code>client</code>, mas deixando a declaração em <em>src/lib.rs</em> </span></p>
<p>Ainda estamos <em>declarando</em> o módulo <code>client</code> aqui, mas ao substituir o bloco
por um ponto e vírgula, estamos dizendo ao Rust para que procure, em outro local, o código
definido no escopo do módulo <code>client</code>. Em outras palavras, a linha <code>mod client;</code> significa:</p>
<pre><code class="language-rust ignore">mod client {
    // conteúdo de client.rs
}
</code></pre>
<p>Agora precisamos criar o arquivo externo com o nome do módulo. Crie um
arquivo <em>client.rs</em> em <em>src/</em> e abra-o. Em seguida digite o seguinte,
que é a função <code>connect</code> do módulo <code>client</code> que foi
removida na etapa anterior:</p>
<p><span class="filename">Arquivo: src/client.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn connect() {
}
#}</code></pre></pre>
<p>Observe que não precisamos de uma declaração <code>mod</code> neste arquivo porque já fizemos
a declaração do módulo <code>client</code> com <code>mod</code> em <em>src/lib.rs</em>. Este arquivo apenas
fornece o <em>conteúdo</em> do módulo <code>client</code>. Se colocarmos um <code>mod client</code> aqui,
nós estaríamos dando ao módulo <code>client</code> seu próprio submódulo chamado <code>client</code>!</p>
<p>Rust só sabe olhar em <em>src/lib.rs</em> por padrão. Se quisermos adicionar mais
arquivos para o nosso projeto, precisamos dizer ao Rust em <em>src/lib.rs</em> para procurar em outros
arquivos; é por isso que <code>mod client</code> precisa ser definido em <em>src/lib.rs</em> e não pode
ser definido em <em>src/client.rs</em>.</p>
<p>Agora, o projeto deve compilar com sucesso, embora você obtenha alguns
warnings (avisos). Lembre-se de usar <code>cargo build</code>, em vez de <code>cargo run</code>, porque temos
um crate de biblioteca em vez de um crate binário:</p>
<pre><code class="language-text">$ cargo build
   Compiling communicator v0.1.0 (file:///projects/communicator)
warning: function is never used: `connect`
 --&gt; src/client.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
  |
  = note: #[warn(dead_code)] on by default

warning: function is never used: `connect`
 --&gt; src/lib.rs:4:5
  |
4 | /     fn connect() {
5 | |     }
  | |_____^

warning: function is never used: `connect`
 --&gt; src/lib.rs:8:9
  |
8 | /         fn connect() {
9 | |         }
  | |_________^
</code></pre>
<p>Esses <em>warnings</em> nos dizem que temos funções que nunca são usadas. Não se preocupe
com esses <em>warnings</em> por enquanto; vamos abordá-los mais adiante neste capítulo, na
seção “Controlando a visibilidade com <code>pub</code>”. A boa notícia é que eles são apenas
<em>warnings</em>; nosso projeto foi construído com sucesso!</p>
<p>Em seguida, vamos extrair o módulo <code>network</code> em seu próprio arquivo usando o mesmo
procedimento. Em <em>src/lib.rs</em>, exclua o corpo do módulo <code>network</code> e adicione um
ponto e vírgula à declaração, assim:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">mod client;

mod network;
</code></pre>
<p>Em seguida, crie um novo arquivo <em>src/network.rs</em> e digite o seguinte:</p>
<p><span class="filename">Arquivo: src/network.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn connect() {
}

mod server {
    fn connect() {
    }
}
#}</code></pre></pre>
<p>Observe que ainda temos uma declaração <code>mod</code> dentro deste arquivo de módulo; isto é
porque ainda queremos que <code>server</code> seja um submódulo de <code>network</code>.</p>
<p>Execute <code>cargo build</code> novamente. Sucesso! Temos mais um módulo para extrair: <code>server</code>.
Como ele é um submódulo - ou seja, um módulo dentro de outro - nossa tática atual de
extrair um módulo para um arquivo com o nome do módulo não funcionará. Iremos
tentar, de qualquer maneira, para que você possa ver o erro. Primeiro, altere o arquivo <em>src/network.rs</em> colocando
<code>mod server;</code> no lugar do conteúdo do módulo <code>server</code>:</p>
<p><span class="filename">Arquivo: src/network.rs</span></p>
<pre><code class="language-rust ignore">fn connect() {
}

mod server;
</code></pre>
<p>Em seguida, crie um arquivo <em>src/server.rs</em> e insira o conteúdo do módulo <code>server</code>
que extraímos:</p>
<p><span class="filename">Arquivo: src/server.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn connect() {
}
#}</code></pre></pre>
<p>Quando tentamos <code>cargo build</code>, obteremos o erro mostrado na Listagem 7-5:</p>
<pre><code class="language-text">$ cargo build
   Compiling communicator v0.1.0 (file:///projects/communicator)
error: cannot declare a new module at this location
 --&gt; src/network.rs:4:5
  |
4 | mod server;
  |     ^^^^^^
  |
note: maybe move this module `src/network.rs` to its own directory via `src/network/mod.rs`
 --&gt; src/network.rs:4:5
  |
4 | mod server;
  |     ^^^^^^
note: ... or maybe `use` the module `server` instead of possibly redeclaring it
 --&gt; src/network.rs:4:5
  |
4 | mod server;
  |     ^^^^^^
</code></pre>
<p><span class="caption">Listagem 7-5: Erro ao tentar extrair o submódulo <code>server</code>
em <em>src/server.rs</em> </span></p>
<p>O erro diz que não podemos declarar um novo módulo neste local (<code>cannot declare a new module at this location</code>)
e está apontando para a linha <code>mod server</code>; em <em>src/network.rs</em>. Então <em>src/network.rs</em> é
diferente de <em>src/lib.rs</em> de alguma forma: continue lendo para entender o porquê.</p>
<p>A nota no meio da Listagem 7-5 é realmente muito útil,
porque ela aponta para algo de que não falamos ainda:</p>
<pre><code class="language-text">note: maybe move this module `network` to its own directory via
`network/mod.rs`
</code></pre>
<p>(<strong>Tradução:</strong> talvez mover este módulo network para o seu próprio diretório via <code>network/mod.rs</code>)</p>
<p>Em vez de continuar a seguir o mesmo padrão de nomeação de arquivo usado
anteriormente, podemos fazer o que a nota sugere:</p>
<ol>
<li>Crie um novo <em>diretório</em> chamado <em>network</em>, o nome do módulo pai.</li>
<li>Mova o arquivo <em>src/network.rs</em> para o novo diretório <em>network</em> e
    renomeie para <em>src/network/mod.rs</em>.</li>
<li>Mova o arquivo de submódulo <em>src/server.rs</em> para o diretório <em>network</em>.</li>
</ol>
<p>Aqui estão os comandos para executar estas etapas:</p>
<pre><code class="language-text">$ mkdir src/network
$ mv src/network.rs src/network/mod.rs
$ mv src/server.rs src/network
</code></pre>
<p>Agora, quando tentamos executar <code>cargo build</code>, a compilação funcionará (embora ainda teremos
avisos). O layout dos nossos módulos ainda é exatamente o
mesmo de quando tínhamos todo o código em <em>src/lib.rs</em> na Listagem 7-3:</p>
<pre><code class="language-text">communicator
 ├── client
 └── network
     └── server
</code></pre>
<p>O layout dos arquivos correspondentes agora ficou assim:</p>
<pre><code class="language-text">├── src
│   ├── client.rs
│   ├── lib.rs
│   └── network
│       ├── mod.rs
│       └── server.rs
</code></pre>
<p>Quando queríamos extrair o módulo <code>network::server</code>, por que precisávamos
também mudar o arquivo <em>src/network.rs</em> para o arquivo <em>src/network/mod.rs</em> e colocar
o código de <code>network::server</code> no diretório <em>network</em> em
<em>src/network/server.rs</em> em vez de apenas extrair o
módulo <code>network::server</code> em <em>src/server.rs</em>? O motivo é que Rust não
será capaz de reconhecer que <code>server</code> deveria ser um submódulo de <code>network</code>
se o arquivo <em>server.rs</em> estiver no diretório <em>src</em>. Para esclarecer o comportamento de Rust
aqui, consideremos um exemplo diferente com a seguinte hierarquia de módulos,
onde todas as definições estão em <em>src/lib.rs</em>:</p>
<pre><code class="language-text">communicator
 ├── client
 └── network
     └── client
</code></pre>
<p>Neste exemplo, temos novamente três módulos : <code>client</code>,<code>network</code>, e
<code>network::client</code>. Seguindo os mesmos passos anteriores para extrair
módulos em arquivos, poderíamos criar <em>src/client.rs</em> para o módulo <code>client</code>.
Para o módulo <code>network</code>, poderíamos criar <em>src/network.rs</em>. Mas não seríamos
capazes de extrair o módulo <code>network::client</code> para um arquivo <em>src/client.rs</em>
porque ele já existe para o módulo <code>client</code> de nível superior! Se pudéssemos colocar
o código para <em>ambos</em> os módulos <code>client</code> e<code>network::client</code> no arquivo
<em>src/client.rs</em>, Rust não teria nenhuma maneira de saber se o código era
para <code>client</code> ou para <code>network::client</code>.</p>
<p>Portanto, para extrair um arquivo para o submódulo <code>network::client</code> do
módulo <code>network</code>, precisamos criar um diretório para o módulo <code>network</code>
em vez de um arquivo <em>src/network.rs</em>. O código que está no módulo <code>network</code>
entra no arquivo <em>src/network/mod.rs</em>, e o submódulo
<code>network::client</code> pode ter seu próprio arquivo <em>src/network/client.rs</em>. Agora o
o nível superior <em>src/client.rs</em> é inequivocamente o código que pertence ao
módulo <code>client</code>.</p>
<a class="header" href="print.html#regras-dos-módulos-e-seus-arquivos" id="regras-dos-módulos-e-seus-arquivos"><h3>Regras dos Módulos e Seus Arquivos</h3></a>
<p>Vamos resumir as regras dos módulos em relação aos arquivos:</p>
<ul>
<li>Se um módulo chamado <code>foo</code> não possui submódulos, você deve colocar as declarações
   para <code>foo</code> em um arquivo chamado <em>foo.rs</em>.</li>
<li>Se um módulo chamado <code>foo</code> possui submódulos, você deve colocar as declarações
   para <code>foo</code> em um arquivo chamado <em>foo/mod.rs</em>.</li>
</ul>
<p>Essas regras se aplicam de forma recursiva, então, se um módulo chamado <code>foo</code> tiver um submódulo chamado
<code>bar</code> e<code>bar</code> não possui submódulos, você deve ter os seguintes arquivos
no seu diretório <em>src</em>:</p>
<pre><code class="language-text">├── foo
│   ├── bar.rs (contém as declarações em `foo::bar`)
│   └── mod.rs (contém as declarações em `foo`, incluindo `mod bar`)
</code></pre>
<p>Os módulos devem ser declarados no arquivo do módulo pai usando a palavra-chave <code>mod</code>.</p>
<p>Em seguida, vamos falar sobre a palavra-chave <code>pub</code> e nos livrar dessas warnings!</p>
<a class="header" href="print.html#controlando-a-visibilidade-com-pub" id="controlando-a-visibilidade-com-pub"><h2>Controlando a Visibilidade com <code>pub</code></h2></a>
<p>Resolvemos as mensagens de erro mostradas na Listagem 7-5 movendo o código de <code>network</code> e
<code>network::server</code> para  os arquivos <em>src/network/mod.rs</em> e
<em>src/network/server.rs</em>, respectivamente. Nesse ponto, <code>cargo build</code> era
capaz de construir nosso projeto, mas ainda recebemos mensagens de <em>warning</em> sobre as
funções <code>client::connect</code>, <code>network::connect</code>, e <code>network::server::connect</code>
não estarem em uso:</p>
<pre><code class="language-text">warning: function is never used: `connect`
 --&gt; src/client.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
  |
  = note: #[warn(dead_code)] on by default

warning: function is never used: `connect`
 --&gt; src/network/mod.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^

warning: function is never used: `connect`
 --&gt; src/network/server.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
</code></pre>
<p>Então, por que estamos recebendo esses warnings(avisos)? Afinal, estamos construindo uma biblioteca
com funções que se destinam a ser usadas pelos nossos <em>usuários</em>, não necessariamente por
nós dentro de nosso próprio projeto, por isso não deveria importar que essas funções <code>connect</code>
não sejam utilizadas. O ponto de criá-las é que elas serão usadas por
outro projeto, não o nosso.</p>
<p>Para entender por que esse programa invoca esses warnings(avisos), vamos tentar usar a
biblioteca <code>connect</code> de outro projeto, chamando-a externamente. Para fazer isso,
vamos criar um crate binário no mesmo diretório que o nosso crate de biblioteca
inserindo um arquivo <em>src/main.rs</em> que contém esse código:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate communicator;

fn main() {
    communicator::client::connect();
}
</code></pre>
<p>Usamos o comando <code>extern crate</code> para trazer o crate de biblioteca <code>communicator</code>
para o escopo. Nosso pacote agora contém <em>duas</em> crates. Cargo trata <em>src/main.rs</em>
como um arquivo raiz de um crate binário, que é separado do crate de biblioteca existente
cujo arquivo raiz é <em>src/lib.rs</em>. Esse padrão é bastante comum para
projetos executáveis: a maioria das funcionalidades está em um crate de biblioteca e o crate binário
usa esse crate de biblioteca. Como resultado, outros programas também podem usar o
crate de biblioteca, e é uma boa separação de responsabilidades.</p>
<p>Do ponto de vista de um crate fora da biblioteca <code>communicator</code>
todos os módulos que criamos estão dentro de um módulo que tem o mesmo
nome como do crate, <code>communicator</code>. Chamamos o módulo de nível superior de um
crate de <em>módulo raiz</em>.</p>
<p>Observe também que, mesmo que estejamos usando um crate externo dentro de um submódulo do nosso
projeto, o <code>extern crate</code> deve entrar em nosso módulo raiz (então em <em>src/main.rs</em>
ou <em>src/lib.rs</em>). Então, em nossos submódulos, podemos consultar itens de crates externos
como se os itens fossem módulos de nível superior.</p>
<p>Agora, nosso crate binário apenas chama a função <code>connect</code> da nossa biblioteca do
módulo <code>client</code>. No entanto, invocar agora <code>cargo build</code> nos dará um erro
após os <em>warnings</em>:</p>
<pre><code class="language-text">error[E0603]: module `client` is private
 --&gt; src/main.rs:4:5
  |
4 |     communicator::client::connect();
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</code></pre>
<p>Ah ha! Este erro nos diz que o módulo <code>client</code> é privado, que é o
cerne das advertências. É também a primeira vez em que nos encontramos com os conceitos de
<em>público</em> e <em>privado</em> no contexto do Rust. O estado padrão de todos os códigos em
Rust é privado: ninguém mais tem permissão para usar o código. Se você não usar uma
função privada dentro do seu programa, como ele é o único código
permitido a usar essa função, Rust irá avisá-lo de que a função
não foi utilizada.</p>
<p>Depois de especificar que uma função como <code>client::connect</code> é pública, não só
será permitida a nossa chamada para essa função a partir de nosso crate binário, mas o
warning(aviso) de que a função não é utilizada irá desaparecer. Marcar uma função como pública
permite ao Rust saber que a função será usada por código fora do nosso programa.
Rust considera que agora é possível que a
função esteja &quot;sendo usada&quot;. Assim, quando uma função é marcada como pública, Rust não
exige que seja usada em nosso programa e deixará de avisar que a função
não é utilizada.</p>
<a class="header" href="print.html#fazendo-uma-função-pública" id="fazendo-uma-função-pública"><h3>Fazendo uma Função Pública</h3></a>
<p>Para dizer ao Rust que torne pública uma função, adicionamos a palavra-chave <code>pub</code> ao início
da declaração. Nos focaremos em corrigir o <em>warning</em> que indica
<code>client::connect</code> não foi utilizado por enquanto, assim como o erro <code>module `client` is private</code> (<code>módulo `client` é privado</code>) do nosso crate binário. Modifique <em>src/lib.rs</em> para tornar
o módulo <code>client</code> público, assim:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub mod client;

mod network;
</code></pre>
<p>A palavra-chave <code>pub</code> é colocada logo antes do <code>mod</code>. Vamos tentar fazer o build novamente:</p>
<pre><code class="language-text">error[E0603]: function `connect` is private
 --&gt; src/main.rs:4:5
  |
4 |     communicator::client::connect();
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</code></pre>
<p>Opa! Temos um erro diferente! Sim, mensagens diferentes de erro
são motivo para comemorar. O novo erro mostra que que a função <code>connect</code> é privada
(function <code>connect</code> is private), então vamos editar <em>src/client.rs</em> para torná-la pública também:</p>
<p><span class="filename">Arquivo: src/client.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn connect() {
}
#}</code></pre></pre>
<p>Agora execute <code>cargo build</code> novamente:</p>
<pre><code class="language-text">warning: function is never used: `connect`
 --&gt; src/network/mod.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
  |
  = note: #[warn(dead_code)] on by default

warning: function is never used: `connect`
 --&gt; src/network/server.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
</code></pre>
<p>O código compila, e o warning(aviso) sobre <code>client::connect</code> não estar em uso
se foi!</p>
<p>Os avisos de código não utilizados nem sempre indicam que um item no seu código precisa
se tornar público: se você <em>não</em> quiser que essas funções façam parte de sua
API pública, <em>warnings</em> de código não utilizado podem alertá-lo de que esses códigos não são mais necessários,
e que podem ser excluídos com segurança. Eles também podem estar alertando você para um bug, caso você tivesse apenas
acidentalmente removido todos os lugares dentro da sua biblioteca onde esta função é
chamada.</p>
<p>Mas neste caso, nós <em>queremos</em> que as outras duas funções façam parte da nossa
API pública do crate, então vamos marcá-las como <code>pub</code> também para nos livrar dos
<em>warnings</em> remanescentes. Modifique <em>src/network/mod.rs</em> dessa forma:</p>
<p><span class="filename">Arquivo: src/network/mod.rs</span></p>
<pre><code class="language-rust ignore">pub fn connect() {
}

mod server;
</code></pre>
<p>Em seguida, compile o código:</p>
<pre><code class="language-text">warning: function is never used: `connect`
 --&gt; src/network/mod.rs:1:1
  |
1 | / pub fn connect() {
2 | | }
  | |_^
  |
  = note: #[warn(dead_code)] on by default

warning: function is never used: `connect`
 --&gt; src/network/server.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
</code></pre>
<p>Hmmm, ainda estamos recebendo um <em>warning</em> de função não utilizada, embora
<code>network::connect</code> esteja marcada como <code>pub</code>. A razão é que a função é pública
dentro do módulo, mas o módulo <code>network</code> na qual a função reside não é
público. Estamos trabalhando a partir do interior da biblioteca desta vez, enquanto que
com <code>client::connect</code> trabalhamos de fora. Precisamos mudar
<em>src/lib.rs</em> para tornar <code>network</code> pública também, assim:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub mod client;

pub mod network;
</code></pre>
<p>Agora, quando compilamos, esse aviso desapareceu:</p>
<pre><code class="language-text">warning: function is never used: `connect`
 --&gt; src/network/server.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
  |
  = note: #[warn(dead_code)] on by default
</code></pre>
<p>Apenas um warning(aviso) permanece. Tente consertar isso por conta própria!</p>
<a class="header" href="print.html#regras-de-privacidade" id="regras-de-privacidade"><h3>Regras de Privacidade</h3></a>
<p>No geral, estas são as regras para a visibilidade do item:</p>
<ol>
<li>Se um item for público, ele pode ser acessado através de qualquer um dos seus módulos pais.</li>
<li>Se um item é privado, ele só pode ser acessado por seu módulo pai imediato e
   qualquer um dos módulos filhos do pai.</li>
</ol>
<a class="header" href="print.html#exemplos-de-privacidade" id="exemplos-de-privacidade"><h3>Exemplos de Privacidade</h3></a>
<p>Vejamos mais alguns exemplos de privacidade para obter alguma prática. Crie um novo
projeto de biblioteca e digite o código da Listagem 7-6 no arquivo
<em>src/lib.rs</em> desse novo projeto:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">mod outermost {
    pub fn middle_function() {}

    fn middle_secret_function() {}

    mod inside {
        pub fn inner_function() {}

        fn secret_function() {}
    }
}

fn try_me() {
    outermost::middle_function();
    outermost::middle_secret_function();
    outermost::inside::inner_function();
    outermost::inside::secret_function();
}
</code></pre>
<p><span class="caption">Lista 7-6: Exemplos de funções públicas e privadas,
alguns dos quais estão incorretos</span></p>
<p>Antes de tentar compilar este código, tente um palpite sobre quais linhas na
função <code>try_me</code> terá erros. Em seguida, tente compilar o código para ver se
você estava certo e leia sobre a discussão dos erros!</p>
<a class="header" href="print.html#olhando-para-os-erros" id="olhando-para-os-erros"><h4>Olhando para os Erros</h4></a>
<p>A função <code>try_me</code> está no módulo raiz do nosso projeto. O módulo chamado
<code>outermost</code> é privado, mas a segunda regra de privacidade afirma que a função <code>try_me</code>
pode acessar o módulo <code>outermost</code> porque <code>outermost</code> está no
módulo atual (raiz), bem como <code>try_me</code>.</p>
<p>A chamada para <code>outermost::middle_function</code> funcionará porque <code>middle_function</code> é
pública e <code>try_me</code> está acessando <code>middle_function</code> através do seu módulo pai
<code>outermost</code>. Determinamos no parágrafo anterior que este módulo é
acessível.</p>
<p>A chamada para <code>outermost::middle_secret_function</code> causará um erro de compilação.
<code>middle_secret_function</code> é privado, então a segunda regra se aplica. O módulo raiz
não é nem o módulo atual de <code>middle_secret_function</code> (que seria o <code>outermost</code>),
nem um módulo filho do módulo atual de <code>middle_secret_function</code>.</p>
<p>O módulo denominado <code>inside</code> é privado e não tem módulos filhos, portanto, ele só pode
ser acessado pelo seu módulo atual <code>outermost</code>. Isso significa que a função <code>try_me</code>
não tem permissão de chamar <code>outermost::inside::inner_function</code> ou
<code>outermost::inside::secret_function</code>.</p>
<a class="header" href="print.html#reparando-os-erros" id="reparando-os-erros"><h4>Reparando os Erros</h4></a>
<p>Aqui estão algumas sugestões para alterar o código na tentativa de corrigir os
erros. Antes de tentar cada uma, tente adivinhar se ela irá consertar os
erros e, em seguida, compile o código para ver se você está certo ou não, usando as
regras de privacidade para entender o porquê.</p>
<ul>
<li>E se o módulo <code>inside</code> fosse público?</li>
<li>E se <code>outermost</code> fosse público e <code>inside</code> fosse privado?</li>
<li>E se, no corpo de <code>inner_function</code>, você chamasse o
  <code>::outermost::middle_secret_function()</code>? (Os dois dois pontos no início significam
   que queremos consultar os módulos a partir do módulo raiz.)</li>
</ul>
<p>Sinta-se livre para projetar mais experimentos que lhe vierem à mente!</p>
<p>Em seguida, vamos falar sobre trazer itens ao escopo com a palavra-chave <code>use</code>.</p>
<a class="header" href="print.html#referindo-se-a-nomes-em-módulos-diferentes" id="referindo-se-a-nomes-em-módulos-diferentes"><h2>Referindo-se a Nomes em Módulos Diferentes</h2></a>
<p>Vimos como chamar funções definidas dentro de um módulo usando o nome do módulo
como parte da chamada, como na chamada para a função <code>nested_modules</code> mostrada
aqui na Listagem 7-7:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">pub mod a {
    pub mod series {
        pub mod of {
            pub fn nested_modules() {}
        }
    }
}

fn main() {
    a::series::of::nested_modules();
}
</code></pre></pre>
<p><span class="caption">Listagem 7-7: Chamando uma função especificando completamente
o caminho do módulo que a cerca</span></p>
<p>Como você pode ver, referir-se ao nome totalmente qualificado pode ficar bastante longo.
Felizmente, Rust tem uma palavra-chave para tornar estas chamadas mais concisas.</p>
<a class="header" href="print.html#trazendo-nomes-no-escopo-com-a-palavra-chave-use" id="trazendo-nomes-no-escopo-com-a-palavra-chave-use"><h3>Trazendo Nomes no Escopo com a Palavra-Chave <code>use</code></h3></a>
<p>A palavra-chave <code>use</code> de Rust encurta as chamadas de função longas, trazendo os módulos e
a função que deseja chamar para o escopo. Aqui está um exemplo de como trazer o
módulo <code>a::series::of</code> para dentro do escopo raiz de um crate binário:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">pub mod a {
    pub mod series {
        pub mod of {
            pub fn nested_modules() {}
        }
    }
}

use a::series::of;

fn main() {
    of::nested_modules();
}
</code></pre></pre>
<p>A linha <code>use a::series::of;</code> significa que, em vez de usar todo o caminho
<code>a::series::of</code> sempre que quisermos nos referir ao módulo <code>of</code>, podemos usar
<code>of</code>.</p>
<p>A palavra-chave <code>use</code> traz apenas o que especificamos no escopo: ela não
leva os filhos dos módulos ao escopo. É por isso que ainda temos que usar
<code>of::nested_modules</code> quando queremos chamar a função <code>nested_modules</code>.</p>
<p>Poderíamos ter escolhido trazer a função para o escopo, em vez de especificar a função
no <code>use</code> da seguinte forma:</p>
<pre><pre class="playpen"><code class="language-rust">pub mod a {
    pub mod series {
        pub mod of {
            pub fn nested_modules() {}
        }
    }
}

use a::series::of::nested_modules;

fn main() {
    nested_modules();
}
</code></pre></pre>
<p>Isso nos permite excluir todos os módulos e fazer referência à função
diretamente.</p>
<p>Como as enums também formam uma espécie de <em>namespace</em>, assim como os módulos, podemos trazer
as variantes de uma enum para o escopo com <code>use</code> também. Para qualquer tipo de declaração de <code>use</code>
se você estiver trazendo vários itens de um <em>namespace</em> para o escopo, você pode listá-los
usando chaves e vírgulas na última posição, assim:</p>
<pre><pre class="playpen"><code class="language-rust">enum TrafficLight {
    Red,
    Yellow,
    Green,
}

use TrafficLight::{Red, Yellow};

fn main() {
    let red = Red;
    let yellow = Yellow;
    let green = TrafficLight::Green;
}
</code></pre></pre>
<p>Nós ainda estamos especificando o <em>namespace</em> <code>TrafficLight</code> para a variante <code>Green</code>
porque não incluímos <code>Green</code> na declaração <code>use</code>.</p>
<a class="header" href="print.html#trazendo-todos-os-nomes-para-o-escopo-com-um-glob" id="trazendo-todos-os-nomes-para-o-escopo-com-um-glob"><h3>Trazendo Todos os Nomes para o Escopo com um Glob</h3></a>
<p>Para trazer todos os itens de um <em>namespace</em> para o escopo ao mesmo tempo, podemos usar a sintaxe <code>*</code>, que é chamada de <em>operador glob</em>. Este exemplo traz todas as variantes de uma enum ao escopo sem ter que listar cada uma especificamente:</p>
<pre><pre class="playpen"><code class="language-rust">enum TrafficLight {
    Red,
    Yellow,
    Green,
}

use TrafficLight::*;

fn main() {
    let red = Red;
    let yellow = Yellow;
    let green = Green;
}
</code></pre></pre>
<p>O <code>*</code> trará para o escopo todos os itens visíveis no <em>namespace</em> <code>TrafficLight</code>.
Você deve usar globs com moderação: eles são convenientes, mas isso pode
também trazer mais itens do que se esperava e causar conflitos de nomeação.</p>
<a class="header" href="print.html#usando-super-para-acessar-um-módulo-pai" id="usando-super-para-acessar-um-módulo-pai"><h3>Usando <code>super</code> para Acessar um Módulo Pai</h3></a>
<p>Como vimos no início deste capítulo, quando você cria um crate de biblioteca,
o Cargo faz um módulo <code>tests</code> para você. Vamos ver isso em mais detalhes agora.
No seu projeto <code>communicator</code>, abra <em>src/lib.rs</em>:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub mod client;

pub mod network;

#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
</code></pre>
<p>O Capítulo 11 explica mais sobre testes, mas algumas partes deste exemplo devem fazer
sentido agora: temos um módulo chamado <code>tests</code> que se situa ao lado de nossos outros módulos
e contém uma função chamada <code>it_works</code>. Embora existam anotações especiais,
o módulo <code>tests</code> é apenas outro módulo! Então nossa hierarquia de módulos
se parece com isso:</p>
<pre><code class="language-text">communicator
 ├── client
 ├── network
 |   └── client
 └── tests
</code></pre>
<p>Os testes servem para exercitar o código dentro da nossa biblioteca, então vamos tentar chamar nossa
função <code>client :: connect</code> a partir da função<code>it_works</code>, mesmo que não verefiquemos nenhuma
funcionalidade agora. Isso ainda não funcionará:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        client::connect();
    }
}
#}</code></pre></pre>
<p>Execute os testes invocando o comando <code>cargo test</code>:</p>
<pre><code class="language-text">$ cargo test
   Compiling communicator v0.1.0 (file:///projects/communicator)
error[E0433]: failed to resolve. Use of undeclared type or module `client`
 --&gt; src/lib.rs:9:9
  |
9 |         client::connect();
  |         ^^^^^^ Use of undeclared type or module `client`
</code></pre>
<p>A compilação falhou, mas por quê? Não precisamos colocar <code>communicator ::</code> em
frente da função como fizemos em <em>src/main.rs</em> porque estamos definitivamente
dentro do crate da biblioteca <code>communicator</code> aqui. A razão é que os caminhos são
sempre relativos ao módulo atual, que aqui é <code>tests</code>. A única
exceção está em uma instrução <code>use</code>, onde os caminhos são relativos à crate raiz
por padrão. Nosso módulo <code>tests</code> precisa do módulo <code>client</code> no seu escopo!</p>
<p>Então, como podemos retroceder um módulo na hierarquia para chamar a
função <code>client::connect</code> no módulo <code>tests</code>? No módulo <code>tests</code>, temos a opção de
usar <code>::</code> na frente para indicar ao Rust que queremos começar a partir da raiz
e listar todo o caminho, assim:</p>
<pre><code class="language-rust ignore">::client::connect();
</code></pre>
<p>Ou, podemos usar <code>super</code> para voltar um módulo na hierarquia a partir de nosso
módulo atual, assim:</p>
<pre><code class="language-rust ignore">super::client::connect();
</code></pre>
<p>Essas duas opções não parecem tão diferentes neste exemplo, mas se você estiver
mais fundo em uma hierarquia de módulos, começar sempre a partir da raiz tornaria
seu código muito longo. Nesses casos, usar <code>super</code> para ir do módulo atual aos
módulos irmãos é um bom atalho. Além disso, se você especificou o caminho a partir da
raiz em muitos lugares do seu código e depois vai reorganizar seus módulos movendo
uma sub-árvore para outro lugar, você acabaria precisando atualizar o caminho em vários
lugares, o que seria tedioso.</p>
<p>Também seria chato ter que digitar <code>super ::</code> em cada teste, mas você
já viu a ferramenta para essa solução: <code>use</code>! A funcionalidade <code>super ::</code>
altera o caminho que você dá para <code>use</code>, tornando-o relativo ao módulo pai
em vez do módulo raiz.</p>
<p>Por estas razões, especialmente no módulo <code>tests</code>, <code>use super::alguma_coisa</code> é
geralmente a melhor solução. Então, agora nosso teste ficou assim:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    use super::client;

    #[test]
    fn it_works() {
        client::connect();
    }
}
#}</code></pre></pre>
<p>Quando executarmos novamente <code>cargo test</code>, o teste passará e a primeira parte do
resultado do teste será o seguinte:</p>
<pre><code class="language-text">$ cargo test
   Compiling communicator v0.1.0 (file:///projects/communicator)
     Running target/debug/communicator-92007ddb5330fa5a

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<a class="header" href="print.html#resumo-4" id="resumo-4"><h2>Resumo</h2></a>
<p>Agora você conhece algumas técnicas novas para organizar o seu código! Use estas técnicas
para agrupar as funcionalidades relacionadas, evitar que os arquivos tornem-se muito longos, e
apresentar uma API pública arrumada para os usuários da sua biblioteca.</p>
<p>Em seguida, analisaremos algumas estruturas de dados de coleções na biblioteca padrão
que você pode usar em seu código limpo e elegante!</p>
<a class="header" href="print.html#fundamental-collections" id="fundamental-collections"><h1>Fundamental Collections</h1></a>
<a class="header" href="print.html#vetores" id="vetores"><h2>Vetores</h2></a>
<p>O primeiro tipo que iremos ver é <code>Vec&lt;T&gt;</code>, também conhecido como <em>vetor</em>. Vetores
permitem guardar mais de um valor na mesma estrutura de dados que coloca todos
os valores um ao lado do outro na memória. Vetores só podem guardar valores do
mesmo tipo. Eles são úteis em situações onde há uma lista de itens, como
as linha de texto em um arquivo ou preços de itens em um carrinho de compras.</p>
<a class="header" href="print.html#criando-um-novo-vetor" id="criando-um-novo-vetor"><h3>Criando um Novo Vetor</h3></a>
<p>Para criar um novo vetor, vazio, chamamos a função <code>Vec::new</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v: Vec&lt;i32&gt; = Vec::new();
#}</code></pre></pre>
<p>Note que adicionamos uma anotação de tipo aqui. Como não estamos inserindo nenhum valor
no vetor, Rust não sabe o tipo de elementos que irá guardar.
Isto é um ponto importante. Vetores são homogêneos: eles podem guardar muitos
valores, mas todos esses valores devem ser do mesmo tipo. Vetores são implementados
usando genéricos, onde o capítulo 10 irá cobrir como usar em seus tipos. Por
agora, tudo o que precisa saber é que o tipo <code>Vec</code> fornecido pela biblioteca
padrão pode conter qualquer tipo, e quando um <code>Vec</code> específico possui um tipo específico, o
tipo vai dentro de <code>&lt; &gt;</code>. Falamos para Rust que <code>Vec</code> em <code>v</code> guardará
elementos do tipo <code>i32</code>.</p>
<p>No código real, a Rust pode inferir o tipo de valor que queremos armazenar uma vez que inserimos
valores, então você raramente precisa fazer essa anotação de tipo. É mais comum
criar um <code>Vec</code> que possui valores iniciais, e o Rust fornece a macro <code>vec!</code> por
conveniência. A macro criará um novo <code>Vec</code> que contém os valores que damos
. Isso criará um novo <code>Vec &lt;i32&gt;</code> que contém os valores <code>1</code>,<code>2</code> e <code>3</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3];
#}</code></pre></pre>
<p>Como nós damos valores iniciais  <code>i32</code>, Rust pode inferir que o tipo de <code>v</code>
é <code>Vec &lt;i32&gt;</code>, e a anotação de tipo não é necessária. Vejamos a seguir como
modificar um vetor.</p>
<a class="header" href="print.html#modificando-um-vetor" id="modificando-um-vetor"><h3>Modificando um Vetor</h3></a>
<p>Para criar um vetor e adicionar elementos a ele, podemos usar o método <code>push</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut v = Vec::new();

v.push(5);
v.push(6);
v.push(7);
v.push(8);
#}</code></pre></pre>
<p>Como qualquer variável que discutimos no Capítulo 3, se quisermos poder
alterar seu valor, precisamos fazê-lo mutável com a palavra-chave <code>mut</code>. Os
números que inserimos são todos do tipo <code>i32</code>, e Rust infere isso dos
dados, por isso não precisamos da anotação <code>Vec &lt;i32&gt;</code>.</p>
<a class="header" href="print.html#descartar-um-vetor-descarta-seus-elementos" id="descartar-um-vetor-descarta-seus-elementos"><h3>Descartar um Vetor Descarta seus Elementos</h3></a>
<p>Como qualquer outro <code>struct</code>, um vetor será liberado quando ele sair do escopo:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    let v = vec![1, 2, 3, 4];

    // use as informações em v

} // &lt;- v sai do escopo e é liberado aqui
#}</code></pre></pre>
<p>Quando o vetor é descartado, todos os seus conteúdos também será descartado, o que significa
esses inteiros que ele contém serão limpos. Isso pode parecer um
ponto direto, mas pode ficar um pouco mais complicado quando começamos a
introduzir referências aos elementos do vetor. Vamos abordar isso em seguida!</p>
<a class="header" href="print.html#lendo-elementos-do-vetor" id="lendo-elementos-do-vetor"><h3>Lendo Elementos do Vetor</h3></a>
<p>Agora que você sabe como criar, atualizar e destruir vetores,
saber ler o seu conteúdo é um bom passo seguinte. Existem duas maneiras de fazer referência a
valores armazenados em um vetor. Nos exemplos, anotamos os tipos de
valores que são retornados dessas funções para maior clareza.</p>
<p>Este exemplo mostra os dois métodos de acesso a um valor em um vetor com
sintaxe de indexação ou o método <code>get</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3, 4, 5];

let third: &amp;i32 = &amp;v[2];
let third: Option&lt;&amp;i32&gt; = v.get(2);
#}</code></pre></pre>
<p>Há algumas coisas a serem observadas aqui. Primeiro, que usamos o valor do índice de <code>2</code>
para obter o terceiro elemento: os vetores são indexados por número, começando em zero.
Em segundo lugar, as duas maneiras diferentes de obter o terceiro elemento são: usando <code>&amp;</code> e
<code>[]</code>, que nos dá uma referência, ou usando o método <code>get</code> com o índice
passado como um argumento, o que nos dá uma <code>Option&lt;&amp;T&gt;</code>.</p>
<p>A razão pela qual Rust tem duas maneiras de fazer referência a um elemento é para que você possa escolher
como o programa se comporta quando você tenta usar um valor de índice para o qual
o vetor não tem um elemento correspondente. Por exemplo, o que um programa deve fazer se tiver
um vetor que contém cinco elementos, então tenta acessar um elemento no índice 100
dessa maneira:</p>
<pre><pre class="playpen"><code class="language-rust should_panic">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &amp;v[100];
let does_not_exist = v.get(100);
#}</code></pre></pre>
<p>Quando você executar isso, você verá que com o primeiro método <code>[]</code>, Rust irá
causar um <code>panic!</code> quando um elemento inexistente é referenciado. Este método seria
preferível se você quiser que seu programa considere uma tentativa de acessar um
elemento, passado o fim do vetor, para ser um erro fatal que deve finalizar o
programa.</p>
<p>Quando é passado um índice que está fora da matriz para o método <code>get</code>, ele
retorna <code>None</code> sem entrar em pânico. Você usaria isso se acessar um elemento
além do alcance do vetor ocorrerá ocasionalmente sob
circunstâncias normais. Seu código pode então ter lógica para lidar tanto com
<code>Some(&amp;element)</code> ou <code>None</code>, como discutimos no Capítulo 6. Por exemplo, o
O índice pode ser proveniente de uma pessoa que digite um número. Se eles acidentalmente
insira um número que é muito grande e seu programa recebe um valor <code>None</code>, você poderia
dizer ao usuário quantos itens estão no atual <code>Vec</code> e dar uma nova
chance de inserir um valor válido. Isso seria mais amigável do que quebrar o
programa por um erro de digitação!</p>
<a class="header" href="print.html#referências-inválidas" id="referências-inválidas"><h4>Referências Inválidas</h4></a>
<p>Uma vez que o programa tenha uma referência válida, o verificador de empréstimo (borrow checker) faz valer
as regras de propriedade e empréstimo abrangidas no Capítulo 4 para garantir que essa referência e
quaisquer outras referências aos conteúdos do vetor permaneçam válidas. Lembre-se da regra
que diz que não podemos ter referências mutáveis e imutáveis no mesmo escopo.
Essa regra se aplica neste exemplo, onde mantemos uma referência imutável ao
primeiro elemento em um vetor e tentamos adicionar um elemento ao final:</p>
<pre><code class="language-rust ignore">let mut v = vec![1, 2, 3, 4, 5];

let first = &amp;v[0];

v.push(6);
</code></pre>
<p>Compilar isso nos dará esse erro:</p>
<pre><code class="language-text">error[E0502]: cannot borrow `v` as mutable because it is also borrowed as
immutable
  |
4 | let first = &amp;v[0];
  |              - immutable borrow occurs here
5 |
6 | v.push(6);
  | ^ mutable borrow occurs here
7 | }
  | - immutable borrow ends here
</code></pre>
<p>Este código pode parecer que deveria funcionar: por que uma referência ao primeiro
elemento deveria se preocupar com o que muda sobre o final do vetor? A razão porque
este código não é permitido é devido à forma como os vetores funcionam. Adicionando um novo elemento
no final do vetor pode exigir a atribuição de nova alocação de memória e copiar os
elementos antigos para o novo espaço, na circunstância de não haver espaço suficiente
para colocar todos os elementos próximos um do outro onde o vetor estava. Nesse
caso, a referência ao primeiro elemento apontaria para memória não alocada.
As regras de empréstimo impedem que os programas acabem nessa situação.</p>
<blockquote>
<p>Nota: para mais informações, veja o Rustonomicon em
<em>https://doc.rust-lang.org/stable/nomicon/vec.html</em>.</p>
</blockquote>
<a class="header" href="print.html#usando-um-enum-para-armazenar-vários-tipos" id="usando-um-enum-para-armazenar-vários-tipos"><h3>Usando um Enum para Armazenar Vários Tipos</h3></a>
<p>No início deste capítulo, dissemos que os vetores só podem armazenar valores
que são todos do mesmo tipo. Isso pode ser inconveniente; definitivamente há casos
de uso para a necessidade de armazenar uma lista de coisas de diferentes tipos. Felizmente,
as variantes de um enum são todas definidas sob o mesmo tipo de enum, então, quando precisamos
armazenar elementos de um tipo diferente em um vetor, podemos definir e usar um
enum!</p>
<p>Por exemplo, digamos que queremos obter valores de uma linha em uma planilha, onde
algumas das colunas da linha contêm números inteiros, alguns números de ponto flutuante,
e algumas strings. Podemos definir um enum cujas variantes guardarão os diferentes
tipos de valor, e então todas as variantes de enum serão consideradas do mesmos
tipo, o do enum. Então, podemos criar um vetor que contenha esse enum e
então, em última instância, possui diferentes tipos:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from(&quot;blue&quot;)),
    SpreadsheetCell::Float(10.12),
];
#}</code></pre></pre>
<p><span class="caption">Listagem 8-1: Definindo um enum para poder guardar
diferentes tipos de dados em um vetor</span></p>
<p>A razão pela qual Rust precisa saber exatamente quais tipos estarão no vetor em
tempo de compilação é para que ele saiba exatamente a quantidade de memória no heap que será
necessária para armazenar cada elemento. Uma vantagem secundária para isso é que podemos ser
explícitos sobre quais tipos são permitidos neste vetor. Se Rust permitisse um vetor
guardar qualquer tipo, haveria uma chance de que um ou mais dos tipos
causar erros com as operações realizadas nos elementos do vetor. Usando
um enum mais um <code>match</code> significa que a Rust garantirá no tempo de compilação que nós
sempre lidaremos com todos os casos possíveis, como discutimos no Capítulo 6.</p>
<p>Se você não sabe no momento em que você está escrevendo um programa, o conjunto exaustivo
dos tipos que o programa irá precisar no tempo de execução para armazenar em um vetor, a técnica de usar
o enum não funcionará. Em vez disso, você pode usar um objeto trait, que abordaremos no
Capítulo 17.</p>
<p>Agora que examinamos algumas das maneiras mais comuns de usar vetores, certifique-se
para dar uma olhada na documentação da API para todos os muitos métodos úteis
definidos no <code>Vec</code> pela biblioteca padrão. Por exemplo, além de <code>push</code>
existe um método <code>pop</code> que irá remover e retornar o último elemento. Vamos mover
para o próximo tipo de coleção: <code>String</code>!</p>
<a class="header" href="print.html#strings" id="strings"><h2>Strings</h2></a>
<p>Nós já conversamos sobre as strings no capítulo 4, mas vamos dar uma olhada mais
em profundidade agora. As strings são uma área que os novos Rustáceos geralmente tem maior
dificuldade. Isto é devido a uma combinação de três coisas: a propensão de Rust de
certificar-se de expor possíveis erros, as strings são estruturas de dados mais complicadas
que muitos programadores lhes dão crédito, e UTF-8. Essas coisas
combina de tal forma que parecem difícil quando se vem de outras linguagens.</p>
<p>A razão pela qual as strings estão no capítulo de coleções é que as strings são
implementadas como uma coleção de bytes mais alguns métodos para fornecer informações úteis e
funcionalidade quando esses bytes são interpretados como texto. Nesta seção, iremos
falar sobre as operações em <code>String</code> que todo tipo de coleção tem, como
criar, atualizar e ler. Também discutiremos as formas em que <code>String</code>
é diferente das outras coleções, a saber, como a indexação em um <code>String</code> é
complicada pelas diferenças entre como as pessoas e os computadores interpretam
dados <code>String</code>.</p>
<a class="header" href="print.html#o-que-é-string" id="o-que-é-string"><h3>O que é String?</h3></a>
<p>Antes de podermos explorar esses aspectos, precisamos falar sobre o que exatamente
significa o termo <em>string</em>. Rust realmente só tem um tipo de string no núcleo
da própria linguagem: <code>str</code>, a fatia de string, que geralmente é vista na forma emprestada
, <code>&amp;str</code>. Nós falamos sobre <em>fatias de strings</em> no Capítulo 4: estas são uma
referência a alguns dados de string codificados em UTF-8 armazenados em outro lugar. Literais de strings,
por exemplo, são armazenados na saída binária do programa e, portanto, são
fatias de string.</p>
<p>O tipo chamado <code>String</code> é fornecido na biblioteca padrão do Rust, em vez de
codificado no núleo da linguagem, e é um extensível, mutável, <code>owned</code>, tipo string
codificado UTF-8. Quando Rustáceos falam sobre “strings” em Rust, geralmente significa
tanto os tipos <code>String</code> quanto os tipos de string<code>&amp;str</code>, normalmente ambos.
Esta seção, é em grande parte sobre <code>String</code>, mas ambos esses tipos são usados em grande parte
na biblioteca padrão da Rust. Tanto o <code>String</code> como as fatias de string são codificadas em UTF-8.</p>
<p>A biblioteca padrão do Rust também inclui uma série de outros tipos de string, como
<code>OsString</code>,<code>OsStr</code>, <code>CString</code> e<code>CStr</code>. Bibliotecas crates podem fornecer
mais opções para armazenar dados de string. Semelhante ao nome <code>*String</code>/<code>*Str</code>,
elas geralmente fornecem uma variante owned e borrowed, assim como <code>String</code>/<code>&amp;str</code>.
Esses tipos de string podem armazenar diferentes codificações ou ser representados na memória de
maneira diferente, por exemplo. Nós não estaremos falando sobre esse outro tipo de string
neste capítulo; veja a documentação da API para obter mais informações sobre como usá-los
e quando cada um é apropriado.</p>
<a class="header" href="print.html#criando-uma-nova-string" id="criando-uma-nova-string"><h3>Criando uma Nova String</h3></a>
<p>Muitas das mesmas operações disponíveis com <code>Vec</code> também estão disponíveis em <code>String</code>,
começando com a função <code>new</code> para criar uma string, assim:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::new();
#}</code></pre></pre>
<p>Isso cria uma nova string vazia chamada <code>s</code> na qual podemos carregar dados.</p>
<p>Muitas vezes, teremos alguns dados iniciais que gostaríamos de já colocar na string.
Para isso, usamos o método <code>to_string</code>, que está disponível em qualquer tipo
que implementa a trait <code>Display</code>, como as strings literais:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let data = &quot;initial contents&quot;;

let s = data.to_string();

// o método também funciona em literais diretamente
let s = &quot;initial contents&quot;.to_string();
#}</code></pre></pre>
<p>Isso cria uma string contendo <code>initial contents</code>.</p>
<p>Também podemos usar a função <code>String :: from</code> para criar uma<code>String</code> de uma string
literal. Isso equivale a usar <code>to_string</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;initial contents&quot;);
#}</code></pre></pre>
<p>Como as strings são usadas para tantas coisas, existem várias APIs genéricas diferentes
que podem ser usadas para strings, então há muitas opções. Algumas delas
podem parecer redundantes, mas todas têm seu lugar! Nesse caso, <code>String :: from</code>
e <code>.to_string</code> acabam fazendo exatamente o mesmo, então a que você escolher é uma
questão de estilo.</p>
<p>Lembre-se de que as string são codificadas em UTF-8, para que possamos incluir qualquer dados apropriadamente codificados
neles:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let hello = &quot;السلام عليكم&quot;;
let hello = &quot;Dobrý den&quot;;
let hello = &quot;Hello&quot;;
let hello = &quot;שָׁלוֹם&quot;;
let hello = &quot;नमस्ते&quot;;
let hello = &quot;こんにちは&quot;;
let hello = &quot;안녕하세요&quot;;
let hello = &quot;你好&quot;;
let hello = &quot;Olá&quot;;
let hello = &quot;Здравствуйте&quot;;
let hello = &quot;Hola&quot;;
#}</code></pre></pre>
<a class="header" href="print.html#atualizando-uma-string" id="atualizando-uma-string"><h3>Atualizando uma String</h3></a>
<p>Uma <code>String</code> pode crescer em tamanho e seu conteúdo pode mudar assim como o conteúdo
de um <code>Vec</code>, empurrando mais dados para ela. Além disso, <code>String</code> tem
operações de concatenação implementadas com o operador <code>+</code> por conveniência.</p>
<a class="header" href="print.html#anexando-a-uma-string-com-push" id="anexando-a-uma-string-com-push"><h4>Anexando a uma String com Push</h4></a>
<p>Podemos criar uma <code>String</code> usando o método <code>push_str</code> para adicionar uma  seqüência de caracteres:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::from(&quot;foo&quot;);
s.push_str(&quot;bar&quot;);
#}</code></pre></pre>
<p><code>s</code> conterá “foobar“ após essas duas linhas. O método <code>push_str</code> leva um
fatia de string porque não necessariamente queremos ownership do
parâmetro. Por exemplo, seria lamentável se não pudéssemos usar <code>s2</code>
depois de atualizar o seu conteúdo a <code>s1</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s1 = String::from(&quot;foo&quot;);
let s2 = String::from(&quot;bar&quot;);
s1.push_str(&amp;s2);
#}</code></pre></pre>
<p>O método <code>push</code> é definido para ter um único caractere como parâmetro e adicionar
à <code>String</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::from(&quot;lo&quot;);
s.push('l');
#}</code></pre></pre>
<p>Após isso, <code>s</code> irá conter “lol”.</p>
<a class="header" href="print.html#concatenação-com-o-operador--ou-a-macro-format" id="concatenação-com-o-operador--ou-a-macro-format"><h4>Concatenação com o Operador + ou a macro <code>format!</code></h4></a>
<p>Muitas vezes, queremos combinar duas strings existentes. Uma maneira é usar
o operador <code>+</code> dessa forma:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;Hello, &quot;);
let s2 = String::from(&quot;world!&quot;);
let s3 = s1 + &amp;s2; // Note que s1 foi movido aqui e não pode ser mais usado
#}</code></pre></pre>
<p>Após este código, a String <code>s3</code> conterá <code>Hello, world!</code>. O motivo que
<code>s1</code> não é mais válido após a adição e o motivo que usamos uma
referência a <code>s2</code> tem a ver com a assinatura do método que é chamado
quando usamos o operador <code>+</code>. O operador <code>+</code> usa o método <code>add</code>, cuja
assinatura parece algo assim:</p>
<pre><code class="language-rust ignore">fn add(self, s: &amp;str) -&gt; String {
</code></pre>
<p>Esta não é a assinatura exata que está na biblioteca padrão; lá o <code>add</code> é
definido usando genéricos. Aqui, estamos olhando a assinatura do <code>add</code> com
tipos de concreto substituídos pelos genéricos, o que acontece quando nós
chamamos esse método com valores <code>String</code>. Vamos discutir genéricos no
Capítulo 10. Esta assinatura nos dá as pistas que precisamos para entender o complicado
operador <code>+</code>.</p>
<p>Antes de tudo, <code>s2</code> tem um <code>&amp;</code>, o que significa que estamos adicionando uma <em>referência</em> da
segunda string para a primeira string. Isso é devido ao parâmetro <code>s</code> na
função <code>add</code>: só podemos adicionar um <code>&amp;str</code> à <code>String</code>, não podemos adicionar dois
valores <code>String</code> juntos. Mas espere - o tipo de <code>&amp;s2</code> é <code>&amp;String</code>, não
<code>&amp;str</code>, conforme especificado no segundo parâmetro para<code>add</code>. Por que nosso exemplo
compila? Podemos usar <code>&amp;s2</code> na chamada para <code>add</code> porque um <code>&amp;String</code>
o argumento pode ser <em>coerced</em> em um <code>&amp;str</code> - quando a função<code>add</code> é chamada,
Rust usa algo chamado de <em>deref coercion</em>, o que você poderia pensar aqui como
virando <code>&amp;s2</code> para<code>&amp;s2[..]</code> para uso na função <code>add</code>. Vamos discutir deref
coercion  em maior profundidade no Capítulo 15. Como o <code>add</code> não se apropria
o parâmetro <code>s2</code> ainda será uma <code>String</code> válida após essa operação.</p>
<p>Em segundo lugar, podemos ver na assinatura que <code>add</code> toma posse de<code>self</code>,
porque <code>self</code> <em>não</em> tem <code>&amp;</code>. Isso significa <code>s1</code> no exemplo acima
será transferido para a chamada <code>add</code> e não será mais válido depois disso. Por enquanto
<code>let s3 = s1 + &amp;s2;</code> parece que irá copiar ambas as strings e criar uma nova,
esta declaração realmente adere a <code>s1</code>, acrescenta uma cópia do conteúdo
de <code>s2</code>, então retorna ownership do resultado. Em outras palavras, parece
estar fazendo muitas cópias, mas não é: a implementação é mais eficiente
do que copiar.</p>
<p>Se precisarmos concatenar várias strings, o comportamento de <code>+</code> fica complicado:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;tic&quot;);
let s2 = String::from(&quot;tac&quot;);
let s3 = String::from(&quot;toe&quot;);

let s = s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;s3;
#}</code></pre></pre>
<p><code>s</code> será “tic-tac-toe” neste momento. Com todos os <code>+</code> e <code>&quot;</code>,
fica difícil ver o que está acontecendo. Para strings mais complicadas
, podemos usar o macro <code>format!</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;tic&quot;);
let s2 = String::from(&quot;tac&quot;);
let s3 = String::from(&quot;toe&quot;);

let s = format!(&quot;{}-{}-{}&quot;, s1, s2, s3);
#}</code></pre></pre>
<p>Este código também definirá <code>s</code> para “tic-tac-toe”. A macro <code>format!</code> funciona
do mesmo modo que <code>println!</code>, mas em vez de imprimir a saída para a tela, ela
retorna uma <code>String</code> com o conteúdo. Esta versão é muito mais fácil de ler, e
também não incide ownership em nenhum dos seus parâmetros.</p>
<a class="header" href="print.html#indexação-em-strings" id="indexação-em-strings"><h3>Indexação em Strings</h3></a>
<p>Em muitas outras linguagens, acessar caracteres individuais em uma string por
referenciando por índice é uma operação válida e comum. Em Rust, no entanto, se
nós tentamos acessar partes de uma <code>String</code> usando sintaxe de indexação, vamos ter um erro.
Ou seja, este código:</p>
<pre><code class="language-rust ignore">let s1 = String::from(&quot;hello&quot;);
let h = s1[0];
</code></pre>
<p>resultará neste erro:</p>
<pre><code class="language-text">error: the trait bound `std::string::String: std::ops::Index&lt;_&gt;` is not
satisfied [--explain E0277]
  |&gt;
  |&gt;     let h = s1[0];
  |&gt;             ^^^^^
note: the type `std::string::String` cannot be indexed by `_`
</code></pre>
<p>O erro e a nota contam a história: as strings em Rust não suportam a indexação. Assim
a próxima pergunta é, por que não? Para responder a isso, temos que conversar um
pouco sobre como o Rust armazena strings na memória.</p>
<a class="header" href="print.html#representação-interna" id="representação-interna"><h4>Representação Interna</h4></a>
<p>Uma <code>String</code> é um invólucro sobre um <code>Vec &lt;u8&gt;</code>. Vejamos alguns dos nossos
exemplos UTF-8, codificadas corretamente, de strings vistas anteriormente. Primeiro, este:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let len = String::from(&quot;Hola&quot;).len();
#}</code></pre></pre>
<p>Neste caso, <code>len</code> terá valor de quatro, o que significa que o<code>Vec</code> armazena a string
”Hola” tem quatro bytes de comprimento: cada uma dessas letras leva um byte quando codificado em
UTF-8. E o que acontece para esse exemplo?</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let len = String::from(&quot;Здравствуйте&quot;).len();
#}</code></pre></pre>
<p>Uma pessoa que pergunte pelo comprimento da string pode dizer que ela deva ter 12.No entanto, a resposta de Rust
é 24. Este é o número de bytes que é necessário para codificar “Здравствуйте“ em
UTF-8, uma vez que cada valor escalar Unicode leva dois bytes de armazenamento. Assim sendo,
um índice nos bytes da string nem sempre se correlaciona com um  valor escalar Unicode válido.</p>
<p>Para demonstrar, considere este código inválido do Rust:</p>
<pre><code class="language-rust ignore">let hello = &quot;Здравствуйте&quot;;
let answer = &amp;hello[0];
</code></pre>
<p>Qual deve ser o valor da <code>answer</code>? Seria <code>З</code>, a primeira letra? Quando
codificado em UTF-8, o primeiro byte de <code>З</code> é <code>208</code>, e o segundo é <code>151</code>, então
a <code>answer</code> deve, na verdade, ser <code>208</code>, mas <code>208</code> não é um caractere válido em
si. Retornar <code>208</code> provavelmente não é o que uma pessoa gostaria se eles pedissem
a primeira letra desta string, mas esse é o único dado que Rust tem no byte
de índice 0. O retorno do valor do byte provavelmente não é o que as pessoas querem, mesmo com
caracteres contendo acentuação: <code>&amp;&quot;hello&quot;[0]</code> retornaria <code>104</code>, não<code>h</code>. Para evitar o
retornando um valor inesperado e causando erros que podem não ser descobertos
imediatamente, Rust escolhe não compilar este código e previne
mal-entendidos anteriormente.</p>
<a class="header" href="print.html#bytes-e-valores-escalares-e-clusters-de-grafemas-nossa" id="bytes-e-valores-escalares-e-clusters-de-grafemas-nossa"><h4>Bytes e Valores Escalares e Clusters de Grafemas! Nossa!</h4></a>
<p>Isso leva a outro ponto sobre UTF-8: existem realmente três maneiras relevantes
de olhar para as strings, da perspectiva do Rust: como bytes, valores escalares e
clusters de grafemas (a coisa mais próxima do que as pessoas chamariam <em>letras</em>).</p>
<p>Se olharmos para a palavra Hindi “नमस्ते” escrita na escrita Devanagari, é
em última instância, armazenada como um <code>Vec</code> de valores <code>u8</code> que se parece com isto:</p>
<pre><code class="language-text">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
</code></pre>
<p>Isso é 18 bytes, e é como os computadores de fato armazenam esses dados. Se olharmos para
eles como valores escalares Unicode, que são o tipo <code>char</code> de Rust, aqueles
bytes se parecem com isto:</p>
<pre><code class="language-text">['न', 'म', 'स', '्', 'त', 'े']
</code></pre>
<p>Existem seis valores <code>char</code> aqui, mas o quarto e o sexto não são letras,
Eles são diacríticos que não fazem sentido por conta própria. Finalmente, se olharmos para
eles como clusters de grafemas, teríamos o que uma pessoa chamaria as quatro letras
que compõem esta palavra:</p>
<pre><code class="language-text">[&quot;न&quot;, &quot;म&quot;, &quot;स्&quot;, &quot;ते&quot;]
</code></pre>
<p>Rust fornece diferentes maneiras de interpretar os dados de uma string bruta que os computadores
armazenem para que cada programa possa escolher a interpretação que necessite, não importa
em que idioma humano os dados estão.</p>
<p>Uma razão final do Rust não permitir que você indexe uma <code>String</code> para obter um
caracter é que as operações de indexação sempre esperam um tempo constante
(O(1)). Não é possível garantir que o desempenho com uma <code>String</code>,
entretanto, já que o Rust teria que percorrer todo o conteúdo desde o início
até o índice para determinar quantos caracteres válidos havia.</p>
<a class="header" href="print.html#fatiando-strings" id="fatiando-strings"><h3>Fatiando Strings</h3></a>
<p>Porque não está claro qual seria o tipo de retorno da indexação de string, e
muitas vezes é uma má idéia indexar uma string, Rust dissuade-o de fazê-lo
pedindo que você seja mais específico se você realmente precisar disso. Do jeito que você pode ser
mais específico que a indexação usando <code>[]</code> com um único número é usando <code>[]</code> com
um intervalo para criar uma fatia de string contendo bytes específicos:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let hello = &quot;Здравствуйте&quot;;

let s = &amp;hello[0..4];
#}</code></pre></pre>
<p>Aqui, <code>s</code> será um <code>&amp;str</code> que contém os primeiros quatro bytes da string.
Mais cedo, mencionamos que cada um desses personagens era de dois bytes, de modo que
significa que <code>s</code> será “Зд”.</p>
<p>O que aconteceria se fizéssemos <code>&amp;hello[0..1]</code>? A resposta: entrará em pânico
em tempo de execução, da mesma maneira que acessar um índice inválido em um vetor:</p>
<pre><code class="language-text">thread 'main' panicked at 'index 0 and/or 1 in `Здравствуйте` do not lie on
character boundary', ../src/libcore/str/mod.rs:1694
</code></pre>
<p>Você deve usar isso com cautela, pois isso pode fazer com que seu programa falhe.</p>
<a class="header" href="print.html#métodos-para-interagir-sobre-strings" id="métodos-para-interagir-sobre-strings"><h3>Métodos para Interagir Sobre Strings</h3></a>
<p>Felizmente, existem outras maneiras de acessar elementos em um String.</p>
<p>Se precisarmos realizar operações em valores escalares Unicode individuais, a melhor
maneira de fazer isso é usar o método <code>chars</code>. Chamando <code>chars</code> em “नमस्ते”
é separado e retorna seis valores do tipo <code>char</code>, e você pode interar
no resultado para acessar cada elemento:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
for c in &quot;नमस्ते&quot;.chars() {
    println!(&quot;{}&quot;, c);
}
#}</code></pre></pre>
<p>Este código irá imprimir:</p>
<pre><code class="language-text">न
म
स
्
त
े
</code></pre>
<p>O método <code>bytes</code> retorna cada byte bruto, que pode ser apropriado para o seu
domínio:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
for b in &quot;नमस्ते&quot;.bytes() {
    println!(&quot;{}&quot;, b);
}
#}</code></pre></pre>
<p>Este código imprimirá os 18 bytes que compõem esse <code>String</code>, começando por:</p>
<pre><code class="language-text">224
164
168
224
// ... etc
</code></pre>
<p>Mas lembre-se de que os valores escalares Unicode válidos podem ser constituídos por
mais de um byte.</p>
<p>Obter clusters de grafemas de strings é complexo, então esta funcionalidade não é
fornecida pela biblioteca padrão. Existem crates disponíveis em crates.io se
Esta é a funcionalidade que você precisa.</p>
<a class="header" href="print.html#as-strings-não-são-tão-simples" id="as-strings-não-são-tão-simples"><h3>As Strings Não são tão Simples</h3></a>
<p>Para resumir, as strings são complicadas. Diferentes linguagens de programação fazem
escolhas diferentes sobre como apresentar essa complexidade ao programador. Rust
optou por fazer o tratamento correto dos dados <code>String</code> o comportamento padrão
para todos os programas Rust, o que significa que os programadores devem pensar mais
no gerenciamento de dados UTF-8 antecipadamente. Este tradeoff expõe mais da complexidade
de strings do que outras linguagens de programação, mas isso irá impedi-lo de
ter que lidar com erros envolvendo caracteres não-ASCII mais tarde em seu
ciclo de desenvolvimento.</p>
<p>Vamos mudar para algo um pouco menos complexo: hash maps!</p>
<a class="header" href="print.html#hash-maps" id="hash-maps"><h2>Hash Maps</h2></a>
<p>A última das nossas coleções comuns é o <em>hash map</em>. O tipo <code>HashMap &lt;K, V&gt;</code>
armazena um mapeamento de chaves do tipo <code>K</code> para valores do tipo<code>V</code>. Ele faz isso através de um
<em>hashing function</em>, que determina como ele coloca essas chaves e valores em
memória. Muitas linguagens de programação diferentes suportam este tipo de
estrutura de dados, mas muitas vezes com um nome diferente: hash, map, object, hash table ou
associative array, apenas para citar alguns.</p>
<p>Os Hash maps são úteis para quando você deseja poder procurar dados sem uso de
índice, como você pode com vetores, mas usando uma chave que pode ser de qualquer tipo. Por
exemplo, em um jogo, você poderia acompanhar a pontuação de cada equipe em um hash map
onde cada chave é o nome de uma equipe e os valores são cada pontuação da equipe. Dado um
nome da equipe, você pode recuperar sua pontuação.</p>
<p>Examinaremos a API básica dos hash map neste capítulo, mas há muitos
mais coisas escondidas nas funções definidas no <code>HashMap</code> pela biblioteca
padrão. Como sempre, verifique a documentação da biblioteca padrão para mais
informação.</p>
<a class="header" href="print.html#criando-um-novo-hash-map" id="criando-um-novo-hash-map"><h3>Criando um novo Hash Map</h3></a>
<p>Podemos criar um <code>HashMap</code> vazio com <code>new</code>, e adicionar elementos com <code>insert</code>.
Aqui, estamos acompanhando as pontuações de duas equipes cujos nomes são Blue e
Yellow. A equipe blue começará com 10 pontos e a equipe yellow começa com
50:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);
#}</code></pre></pre>
<p>Observe que precisamos primeiro <code>use</code> o <code>HashMap</code> da parte de coleções da
biblioteca padrão. De nossas três coleções comuns, esta é a de menor
frequencia de uso, por isso não está inclusa nos recursos importados automaticamente no
prelúdio. Os Hash maps também têm menos suporte da biblioteca padrão; não há
macro embutida para construí-los, por exemplo.</p>
<p>Assim como os vetores, os mapas hash armazenam seus dados no heap. Este <code>HashMap</code> tem
chaves do tipo <code>String</code> e valores do tipo <code>i32</code>. Como vetores, os hash maps são
homogêneos: todas as chaves devem ter o mesmo tipo e todos os valores
devem ter o mesmo tipo.</p>
<p>Outra maneira de construir um hash map é usando o método <code>collect</code> em um
vetor de tuplas, onde cada tupla consiste de uma chave e seu valor. O
método <code>collect</code> reúne dados em vários tipos de coleção, incluindo
<code>HashMap</code>. Por exemplo, se tivéssemos os nomes das equipes e as pontuações iniciais em dois
vetores separados, podemos usar o método <code>zip</code> para criar um vetor de tuplas
onde “Blue” é emparelhado com 10, e assim por diante. Então podemos usar o método <code>collect</code>
para transformar esse vetor de tuplas em um <code>HashMap</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let teams  = vec![String::from(&quot;Blue&quot;), String::from(&quot;Yellow&quot;)];
let initial_scores = vec![10, 50];

let scores: HashMap&lt;_, _&gt; = teams.iter().zip(initial_scores.iter()).collect();
#}</code></pre></pre>
<p>A anotação de tipo <code>HashMap &lt;_, _&gt;</code> é necessária aqui porque é possível
<code>collect</code> em muitas estruturas de dados diferentes, e Rust não sabe qual você
deseja, a menos que você especifique. Para os parâmetros de tipo, para os tipos de chave e valor,
no entanto, usamos underscores e Rust pode inferir os tipos que o hash map
contém com base nos tipos de dados no vetor.</p>
<a class="header" href="print.html#hash-maps-e-ownership" id="hash-maps-e-ownership"><h3>Hash Maps e Ownership</h3></a>
<p>Para os tipos que implementam a <code>Copy</code> trait, como <code>i32</code>, os valores são copiados
no hash map. Para valores owned como <code>String</code>, os valores serão movidos e
o hash map será o owner desses valores:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let field_name = String::from(&quot;Favorite color&quot;);
let field_value = String::from(&quot;Blue&quot;);

let mut map = HashMap::new();
map.insert(field_name, field_value);
// field_name e field_value são inválidos neste ponto
#}</code></pre></pre>
<p>Não poderíamos usar as ligações <code>field_name</code> e<code>field_value</code> depois
que foram transferidos para o hash map com a chamada para <code>insert</code>.</p>
<p>Se inserimos referências a valores no hash map, os próprios valores
não serão movido para o hash map. Os valores que as referências apontam devem ser
válido pelo menos enquanto o hash map seja válido, no entanto. Falaremos mais
sobre esses problemas na seção Lifetimes do Capítulo 10.</p>
<a class="header" href="print.html#acessando-valores-em-um-hash-map" id="acessando-valores-em-um-hash-map"><h3>Acessando Valores em um Hash Map</h3></a>
<p>Podemos obter um valor do hash map fornecendo a chave para o método <code>get</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);

let team_name = String::from(&quot;Blue&quot;);
let score = scores.get(&amp;team_name);
#}</code></pre></pre>
<p>Aqui, <code>score</code> terá o valor que está associado à equipe Blue, e o
resultado será <code>Some(&amp;10)</code>. O resultado está envolvido em <code>Some</code> porque <code>get</code>
retorna <code>Option&lt;&amp;V&gt;</code>; se não houver valor para essa chave no hash map, <code>get</code>
retornará <code>None</code>. O programa precisará lidar com <code>Option</code> em uma das
formas que abordamos no Capítulo 6.</p>
<p>Podemos iterar sobre cada par chave/valor em um hash map de uma maneira similar à que
fazemos com vetores, usando um loop <code>for</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);

for (key, value) in &amp;scores {
    println!(&quot;{}: {}&quot;, key, value);
}
#}</code></pre></pre>
<p>Isso imprimirá cada par, em uma ordem arbitrária:</p>
<pre><code class="language-text">Yellow: 50
Blue: 10
</code></pre>
<a class="header" href="print.html#atualizando-um-hash-map" id="atualizando-um-hash-map"><h3>Atualizando um Hash Map</h3></a>
<p>Embora o número de chaves e valores sejam crescentes, cada chave individual pode apenas
tem um valor associado a ele por vez. Quando queremos mudar os dados em
um hash map, temos que decidir como lidar com o caso quando uma chave já possui uma
valor atribuído. Poderíamos optar por substituir o valor antigo pelo novo valor,
desconsiderando completamente o valor antigo. Poderíamos escolher manter o valor antigo
e ignorar o novo valor, e apenas adicione o novo valor se a chave ainda <em>não</em>
tem um valor. Ou podemos combinar o valor antigo ao valor novo.
Vejamos como fazer cada um desses!</p>
<a class="header" href="print.html#sobrescrevendo-um-valor" id="sobrescrevendo-um-valor"><h4>Sobrescrevendo um Valor</h4></a>
<p>Se inserimos uma chave e um valor em um hash map, então  se inserir essa mesma chave com
um valor diferente, o valor associado a essa chave será substituído. Eembora
o seguinte código chame <code>insert</code> duas vezes, o hash map só conterá
um par de chave/valor porque inserimos o valor da chave da equipe Blue
ambas as vezes:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Blue&quot;), 25);

println!(&quot;{:?}&quot;, scores);
#}</code></pre></pre>
<p>Isso imprimirá <code>{&quot;Blue&quot;: 25}</code>. O valor original de 10 foi substituído.</p>
<a class="header" href="print.html#insira-apenas-se-a-chave-não-possui-valor" id="insira-apenas-se-a-chave-não-possui-valor"><h4>Insira Apenas se a Chave Não Possui Valor</h4></a>
<p>É comum querer verificar se uma determinada chave tem um valor e, se
não tiver, inserir um valor para ela. Os Hash maps possuem uma API especial para isso, chamada
<code>entry</code>, que leva a chave que queremos verificar como um argumento. O valor de retorno
da função <code>entry</code> é um enum, <code>Entry</code>, que representa um valor que pode
ou não existir. Digamos que queremos verificar se a chave para o time Yellow
tem um valor associado a ela. Se não tiver, queremos inserir o valor
50, e o mesmo para a equipe Blue. Com a API de entrada, o código irá parecer
com:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from(&quot;Blue&quot;), 10);

scores.entry(String::from(&quot;Yellow&quot;)).or_insert(50);
scores.entry(String::from(&quot;Blue&quot;)).or_insert(50);

println!(&quot;{:?}&quot;, scores);
#}</code></pre></pre>
<p>O método <code>or_insert</code> em <code>Entry</code> retorna o valor para o <code>Entry</code> correspondente
se a chave existir, e se não, insere seu argumento como o novo valor para
esta chave e retorna a <code>Entry</code> modificada. Isso é muito mais limpo do que escrever
a lógica por nós mesmos e, além disso, trabalha-se de forma mais limpa com o borrow checker.</p>
<p>Este código imprimirá <code>{&quot;Yellow&quot;: 50, &quot;Blue&quot;: 10}</code>. A primeira chamada para <code>entry</code>
irá inserir a chave para a equipe Yellow com o valor 50, uma vez que o time Yellow
já não possua um valor. A segunda chamada para <code>entry</code> não vai mudar
o hash map pois o time Blue já possui o valor 10.</p>
<a class="header" href="print.html#atualize-um-valor-com-base-no-valor-antigo" id="atualize-um-valor-com-base-no-valor-antigo"><h4>Atualize um Valor com Base no Valor Antigo</h4></a>
<p>Outro caso de uso comum para hash maps é procurar o valor de uma chave e, em seguida, atualiza-la
, com base no valor antigo. Por exemplo, se quisermos contar quantas vezes
cada palavra apareceu em algum texto, podemos usar um hash map com as palavras como chaves
e incrementar o valor para acompanhar quantas vezes vimos essa palavra.
Se esta é a primeira vez que vimos uma palavra, primeiro inseriremos o valor <code>0</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let text = &quot;hello world wonderful world&quot;;

let mut map = HashMap::new();

for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    *count += 1;
}

println!(&quot;{:?}&quot;, map);
#}</code></pre></pre>
<p>Isso imprimirá <code>{&quot;world&quot;: 2, &quot;hello&quot;: 1, &quot;wonderful&quot;: 1}</code>. O método <code>or_insert</code>
na verdade retorna uma referência mutável (<code>&amp; mutV</code>) para o valor desta
chave. Aqui nós armazenamos essa referência mutável na variável <code>count</code>, então,
para poder atribuir esse valor, devemos primeiro desreferenciar <code>count</code> usando o asterisco
(<code>*</code>). A referência mutável fica fora do escopo no final do loop <code>for</code>, então
todas essas mudanças são seguras e permitidas pelas regras de borrow.</p>
<a class="header" href="print.html#funções-hashing" id="funções-hashing"><h3>Funções Hashing</h3></a>
<p>Por padrão, <code>HashMap</code> usa uma função de hashing criptográficamente segura que pode
fornecer resistência aos ataques de Negação de Serviço (DoS). Este não é o algoritmo
mais rápido de hashing por aí, mas a compensação por uma melhor segurança que vem
com a queda na performance vale a pena. Se você testar a velocidade do seu código e encontrar
que a função de hash padrão é muito lenta para seus propósitos, você pode mudar para
outra função especificando um <em>hasher</em> diferente. Um hasher é um tipo que
implementa a trait <code>BuildHasher</code>. Vamos falar sobre traits e como
implementá-los no Capítulo 10. Você não precisa necessariamente implementar o seu próprio
hasher do zero; crates.io tem bibliotecas de hashers de uso comum que
outras pessoas compartilharam lá.</p>
<a class="header" href="print.html#sumário" id="sumário"><h2>Sumário</h2></a>
<p>Vetores, strings e hash maps irão levá-lo longe em programas onde você precisa
armazenar, acessar e modificar dados. Aqui estão alguns exercícios que você deve estar
capacitado para resolver:</p>
<ul>
<li>Dada uma lista de inteiros, use um vetor e retorne a média, a mediana
   (quando classificado, o valor na posição do meio) e modo (o valor que
   ocorre com mais frequência; um hash map será útil aqui) da lista.</li>
<li>Converta strings para Pig Latin, onde a primeira consoante de cada palavra é movida
   para o final da palavra adicionado um &quot;ay&quot; , então “first” se torna “irst-fay”.
   Palavras que começam com uma vogal recebem “hay” adicionado ao final (“apple”
   torna-se “apple-hay”). Lembre-se sobre a codificação UTF-8!</li>
<li>Usando um hash map e vetores, crie uma interface de texto para permitir que um usuário adicione
   nomes de funcionários para um departamento da empresa. Por exemplo, “Add Sally to
Engineering” ou “Add Amir to Sales”. Em seguida, deixe o usuário recuperar uma lista de todas
   as pessoas de um departamento ou todas as pessoas na empresa por departamento, ordenadas
   alfabeticamente.</li>
</ul>
<p>A documentação da API da biblioteca padrão descreve métodos que esses tipos possuem
que será útil para esses exercícios!</p>
<p>Estamos entrando em programas mais complexos onde as operações podem falhar, o que significa
que é um momento perfeito para passar pelo tratamento de erros em seguida!</p>
<a class="header" href="print.html#tratamento-de-erros" id="tratamento-de-erros"><h1>Tratamento de Erros</h1></a>
<p>O comprometimento de Rust à segurança se extende ao tratamento de erros. Erros
são um fato da vida em software, portanto Rust possui um número de <em>features</em>
para lidar com situações em que algo dá errado. Em vários casos, Rust requer que
você reconheça a possibilidade de um erro acontecer e aja preventivamente antes
que seu código compile. Esse requisito torna seu programa mais robusto ao assegurar
que voce irá descobrir erros e lidar com eles apropriadamente antes de mandar seu
código para produção!</p>
<p>Rust agrupa erros em duas categorias principais: <em>recuperáveis</em> e <em>irrecuperáveis</em>.
Erros recuperáveis são situações em que é razoável reportar o problema ao usuário
e tentar a operação novamente, como um erro de arquivo não encontrado. Erros
irrecuperáveis são sempre sintomas de bugs, como tentar acessar uma localização
além do fim de um <em>array</em>.</p>
<p>A maioria das linguagens não distingue esses dois tipos de erros e lida
com ambos da mesma maneira usando mecanismos como exceções. Rust não tem
exceções. Em vez disso, ele tem o valor <code>Result&lt;T, E&gt;</code> para erros recuperáveis
e a macro <code>panic!</code> que para a execução ao encontrar um erro irrecuperável. Esse
capítulo cobre primeiro como chamar <code>panic!</code> e depois fala sobre retornar valores
<code>Result&lt;T, E&gt;</code>. Adicionalmente, vamos explorar o que se levar em consideração
para decidir entre tentar se recuperar de um erro ou parar execução.</p>
<a class="header" href="print.html#erros-irrecuperáveis-com-panic" id="erros-irrecuperáveis-com-panic"><h2>Erros Irrecuperáveis com <code>panic!</code></h2></a>
<p>Às vezes coisas ruins acontecem no seu código, e não há nada que você possa fazer
sobre isso. Nesses casos, Rust tem a macro <code>panic!</code>. Quando ela é executada, seu
programa vai imprimir uma mensagem de falha, resolver e limpar a pilha e então
terminar. A situação mais comum em que isso acontece é quando algum tipo de bug
foi detectado, e não é claro para o programador como tratar esse erro.</p>
<blockquote>
<a class="header" href="print.html#resolver-a-pilha-ou-abortar-em-resposta-a-panic" id="resolver-a-pilha-ou-abortar-em-resposta-a-panic"><h3>Resolver a Pilha ou Abortar em Resposta a <code>panic!</code></h3></a>
<p>Por padrão, quando acontece um <code>panic!</code>, o programa começa a <em>resolver</em> a pilha,
o que significa que Rust percorre a pilha e limpa os dados de cada função que encontra.
Mas essa limpeza dá bastante trabalho. A alternativa é imediatamente <em>abortar</em>,
que termina o programa sem fazer a limpeza. A memória que o programa estava usando vai então
precisar ser limpada pelo sistema operacional. Se no seu projeto você precisa tornar
o binário final o menor possível, você pode deixar de resolver e sim abortar no <em>panic</em>
adicionando <code>panic = 'abort'</code> à seção apropriadada de <code>[profile]</code> no seu arquivo
<em>Cargo.toml</em>. Por exemplo, se você quiser abortar no <em>panic</em> no modo de <em>release</em>, adicione
isso:</p>
<pre><code class="language-toml">[profile.release]
panic = 'abort'
</code></pre>
</blockquote>
<p>Vamos tentar chamar <code>panic!</code> em um programa simples:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">fn main() {
    panic!(&quot;Quebra tudo&quot;);
}
</code></pre></pre>
<p>Quando você roda o programa, verá algo como isso:</p>
<pre><code class="language-text">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.25 secs
     Running `target/debug/panic`
thread 'main' panicked at 'Quebra tudo', src/main.rs:2
note: Run with `RUST_BACKTRACE=1` for a backtrace.
error: Process didn't exit successfully: `target/debug/panic` (exit code: 101)
</code></pre>
<p>A chamada a <code>panic!</code> causa a mensagem de erro contida nas últimas três linhas.
A primeira linha mostra nossa mensagem de pânico e a posição no código fonte
em que ocorreu o pânico: <em>src/main.rs:2</em> indica que é a segunda linha do nosso
arquivo <em>src/main.rs</em>.</p>
<p>Nesse caso, a linha indicada é parte do nosso código, e se formos àquela linha
veremos a chamada à macro <code>panic!</code>. Em outros casos, a chamada a <code>panic!</code> pode
estar em código que nosso código chama. O nome do arquivo e número de linha
reportado pela mensagem de erro será no código de outra pessoa quando a macro
<code>panic!</code> for chamada, não a linha do nosso código que eventualmente levou a chamada
de <code>panic!</code>. Podemos usar o <em>backtrace</em> das funções de onde veio a chamada a <code>panic!</code>
para entender qual parte de nosso código está causando o problema. Vamos discutir
o que é um <em>backtrace</em> em seguida.</p>
<a class="header" href="print.html#usando-um-backtrace-de-panic" id="usando-um-backtrace-de-panic"><h3>Usando um Backtrace de <code>panic!</code></h3></a>
<p>Vamos ver outro exemplo para ver o que acontece quando uma chamada <code>panic!</code> vem de uma
biblioteca por causa de um bug no nosso código em vez de nosso código chamar
a macro diretamente. A Listagem 9-1 tem código que tenta acessar um elemento em
um vetor por meio de um índice:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">fn main() {
    let v = vec![1, 2, 3];

    v[99];
}
</code></pre></pre>
<p><span class="caption">Listagem 9-1: Tentativa de acessar um elemento além do fim
de um vetor, que causará um <code>panic!</code></span></p>
<p>Aqui, estamos tentando acessar o centésimo elemento (centésimo pois o índice
começa em zero) de nosso vetor, mas ele só tem três elementos. Nesse caso, Rust
entrará em pânico. Supostamente <code>[]</code> devolve um elemento, mas se você passa um
índice inválido, não há elemento que Rust possa retornar que fosse correto.</p>
<p>Outras linguagens, como C, vão tentar te dar exatamente o que você pediu nessa
situação, mesmo que não seja o que você quer: você vai receber o que quer que
esteja na localização na memória que corresponderia àquele elemento no vetor,
mesmo que a memória não pertença ao vetor. Isso se chama um <em>buffer overread</em> e
pode levar a vulnerabilidades de segurança se um agressor for capaz de manipular
o índice de forma a ler dados guardados depois do array aos quais ele não deveria
ter acesso.</p>
<p>Para proteger seu programa desse tipo de vulnerabilidade, se você tentar ler
um elemento em um índice que não exista, Rust vai parar a execução e se recusar
a continar. Vamos fazer isso e ver o que acontece:</p>
<pre><code class="language-text">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27 secs
     Running `target/debug/panic`
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is
100', /stable-dist-rustc/build/src/libcollections/vec.rs:1362
note: Run with `RUST_BACKTRACE=1` for a backtrace.
error: Process didn't exit successfully: `target/debug/panic` (exit code: 101)
</code></pre>
<p>Esse erro aponta para um arquivo que não escrevemos, <em>libcollections/vec.rs</em>.
Essa é a implementação de <code>Vec&lt;T&gt;</code> na biblioteca padrão. O código que roda
quando usamos <code>[]</code> em nosso vetor <code>v</code> está em <em>libcollections/vec.rs</em>, e é aí
que o <code>panic!</code> está de fato acontecendo.</p>
<p>A próxima linha nos diz que podemos definir a variável de ambiente <code>RUST_BACKTRACE</code>
para ter um <em>backtrace</em> (rastro) do que aconteceu, exatamente, para causar o erro. Um
<em>backtrace</em> é uma lista de todas as funções que foram chamadas para chegar a esse
ponto. <em>Backtraces</em> em Rust funcionam como em outras linguagens: a chave para ler
o <em>backtrace</em> é começar do topo e ler até você ver os arquivos que você escreveu.
Esse é o ponto em que o problema se originou. As linhas acima das que mencionam seu
código são funções que você chamou; as linhas abaixo são funções que chamaram seu
código. Essas linhas podem incluir código do núcleo do Rust, código das bibliotecas
padrão, ou <em>crates</em> que você está usando. Vamos tentar ver um backtrace: a Listagem 9-2
mostra uma saída semelhante a o que você verá:</p>
<pre><code class="language-text">$ RUST_BACKTRACE=1 cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/panic`
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 100', /stable-dist-rustc/build/src/libcollections/vec.rs:1392
stack backtrace:
   1:     0x560ed90ec04c - std::sys::imp::backtrace::tracing::imp::write::hf33ae72d0baa11ed
                        at /stable-dist-rustc/build/src/libstd/sys/unix/backtrace/tracing/gcc_s.rs:42
   2:     0x560ed90ee03e - std::panicking::default_hook::{{closure}}::h59672b733cc6a455
                        at /stable-dist-rustc/build/src/libstd/panicking.rs:351
   3:     0x560ed90edc44 - std::panicking::default_hook::h1670459d2f3f8843
                        at /stable-dist-rustc/build/src/libstd/panicking.rs:367
   4:     0x560ed90ee41b - std::panicking::rust_panic_with_hook::hcf0ddb069e7abcd7
                        at /stable-dist-rustc/build/src/libstd/panicking.rs:555
   5:     0x560ed90ee2b4 - std::panicking::begin_panic::hd6eb68e27bdf6140
                        at /stable-dist-rustc/build/src/libstd/panicking.rs:517
   6:     0x560ed90ee1d9 - std::panicking::begin_panic_fmt::abcd5965948b877f8
                        at /stable-dist-rustc/build/src/libstd/panicking.rs:501
   7:     0x560ed90ee167 - rust_begin_unwind
                        at /stable-dist-rustc/build/src/libstd/panicking.rs:477
   8:     0x560ed911401d - core::panicking::panic_fmt::hc0f6d7b2c300cdd9
                        at /stable-dist-rustc/build/src/libcore/panicking.rs:69
   9:     0x560ed9113fc8 - core::panicking::panic_bounds_check::h02a4af86d01b3e96
                        at /stable-dist-rustc/build/src/libcore/panicking.rs:56
  10:     0x560ed90e71c5 - &lt;collections::vec::Vec&lt;T&gt; as core::ops::Index&lt;usize&gt;&gt;::index::h98abcd4e2a74c41
                        at /stable-dist-rustc/build/src/libcollections/vec.rs:1392
  11:     0x560ed90e727a - panic::main::h5d6b77c20526bc35
                        at /home/you/projects/panic/src/main.rs:4
  12:     0x560ed90f5d6a - __rust_maybe_catch_panic
                        at /stable-dist-rustc/build/src/libpanic_unwind/lib.rs:98
  13:     0x560ed90ee926 - std::rt::lang_start::hd7c880a37a646e81
                        at /stable-dist-rustc/build/src/libstd/panicking.rs:436
                        at /stable-dist-rustc/build/src/libstd/panic.rs:361
                        at /stable-dist-rustc/build/src/libstd/rt.rs:57
  14:     0x560ed90e7302 - main
  15:     0x7f0d53f16400 - __libc_start_main
  16:     0x560ed90e6659 - _start
  17:                0x0 - &lt;unknown&gt;

</code></pre>
<p><span class="caption">Listagem 9-2: O <em>backtrace</em> gerado por uma chamada
a <code>panic!</code> mostrado quando a variável de ambiente <code>RUST_BACKTRACE</code> está definida.</span></p>
<p>Isso é bastante saída! A saída exata que você recebe pode ser diferente dependendo
do seu sistema operacional e versão de Rust. Para conseguir <em>backtraces</em> com essa
informação, símbolos de debug devem estar ativados. Símbolos de debug estão ativados
por padrão quando usamos cargo build ou cargo run sem a opção de --release,
como temos aqui.</p>
<p>Na saída da Listagem 9-2, a linha 11 do <em>backtrace</em> aponta para a linha no nosso
projeto que está causando o problema: <em>src/main.rs</em> na linha 4. Se não
queremos que nosso programa entre em pânico, a localização apontada pela primeira
linha mencionando um arquivo que escrevemos é onde deveríamos começar a investigar
para entender como chegamos nesse ponto com valores que causaram o pânico. Na lista
9-1 onde nós deliberadamente escrevemos código que causaria pânico para demonstrar
como usar <em>backtraces</em>, a forma de consertar o pânico é não requisitar um elemento
no índice 100 de um vetor que contém apenas três itens. Quando seu código entrar
em pânico no futuro, você precisará descobrir quais ações o seu código está tomando,
e com quais valores, que estão causando o pânico, e o que deveria ser feito em vez
disso.</p>
<p>Voltaremos ao <code>panic!</code> e veremos mais adiante no capítulo quando usá-lo, ou não,
para lidar com erros. Em seguida, olharemos como se recuperar de um erro usando
<code>Result</code>.</p>
<a class="header" href="print.html#erros-recuperáveis-com-result" id="erros-recuperáveis-com-result"><h2>Erros recuperáveis com <code>Result</code></h2></a>
<p>A maior parte dos erros não são sérios o suficiente para precisar que o
programa pare totalmente. Às vezes, quando uma função falha, é por uma
razão que nós podemos facilmente interpretar e responder. Por exemplo,
se tentamos abrir um arquivo e essa operação falhar porque o arquivo não
existe, nós podemos querer criar o arquivo em vez de terminar o processo.</p>
<p>Lembre-se do Capítulo 2, na seção “<a href="ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-the-result-type">Tratando Potenciais Falhas com o Tipo Result</a></p>
<!-- ignore -->”  que o enum `Result` é definido como tendo duas variantes,
`Ok` e `Err`, como mostrado a seguir:
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
#}</code></pre></pre>
<p>O <code>T</code> e <code>E</code> são parâmetros de tipos genéricos: nós os discutiremos em mais
detalhe no Capítulo 10. O que você precisa saber agora é que <code>T</code> representa
o tipo do valor que vai ser retornado dentro da variante <code>Ok</code> em caso de sucesso,
e <code>E</code> representa o tipo de erro que será retornado dentro da variante <code>Err</code>
em caso de falha. Por <code>Result</code> ter esses parâmetros de tipo genéricos, nós
podemos usar o tipo <code>Result</code> e as funções que a biblioteca padrão definiu sobre
ele em diversas situações em que o valor de sucesso e o valor de erro que
queremos retornar possam divergir.</p>
<p>Vamos chamar uma função que retorna um valor <code>Result</code> porque a função poderia
falhar: na Listagem 9-3 tentamos abrir um arquivo:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);
}
</code></pre></pre>
<p><span class="caption">Listagem 9-3: Abrindo um arquivo</span></p>
<p>Como sabemos que <code>File::open</code> retorna um <code>Result</code>? Poderíamos olhar na documentação
da API da biblioteca padrão, ou poderíamos perguntar para o compilador! Se damos à <code>f</code>
uma anotação de tipo que sabemos <em>não</em> ser o tipo retornado pela função e tentamos
compilar o código, o compilador nos dirá que os tipos não casam. A mensagem de erro
vai então nos dizer qual é, <em>de fato</em>, o tipo de <code>f</code>. Vamos tentar isso: nós sabemos que
o tipo retornado por <code>File::open</code> não é <code>u32</code>, então vamos mudar a declaração
<code>let f</code> para isso:</p>
<pre><code class="language-rust ignore">let f: u32 = File::open(&quot;hello.txt&quot;);
</code></pre>
<p>Tentar compilar agora nos dá a seguinte saída:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:4:18
  |
4 |     let f: u32 = File::open(&quot;hello.txt&quot;);
  |                  ^^^^^^^^^^^^^^^^^^^^^^^ expected u32, found enum
`std::result::Result`
  |
  = note: expected type `u32`
  = note:    found type `std::result::Result&lt;std::fs::File, std::io::Error&gt;`
</code></pre>
<p>Isso nos diz que o valor de retorno de <code>File::open</code> é um <code>Result&lt;T, E&gt;</code>.
O parâmetro genérico <code>T</code> foi preenchido aqui com o tipo do valor de sucesso,
<code>std::fs::File</code>, que é um <em>handle</em> de arquivo. O tipo de <code>E</code> usado no valor
de erro é <code>std::io::Error</code>.</p>
<p>Esse tipo de retorno significa que a chamada a <code>File::open</code> pode dar certo
e retornar para nós um <em>handle</em> de arquivo que podemos usar pra ler ou escrever
nele. Essa chamada de função pode também falhar: por exemplo, o arquivo pode não
existir ou talvez não tenhamos permissão para acessar o arquivo. A função <code>File::open</code>
precisa ter uma maneira de nos dizer se ela teve sucesso ou falhou e ao mesmo tempo
nos dar ou o <em>handle</em> de arquivo ou informação sobre o erro. Essa informação é
exatamente o que o enum <code>Result</code> comunica.</p>
<p>No caso em que <code>File::open</code> tem sucesso, o valor na variável <code>f</code> será uma instância
de <code>Ok</code> que contém um <em>handle</em> de arquivo. No caso em que ela falha, o valor em <code>f</code>
será uma instância de <code>Err</code> que contém mais informação sobre o tipo de erro que
aconteceu.</p>
<p>Devemos fazer com que o código na Listagem 9-3 faça diferentes ações dependendo
do valor retornado por <code>File::open</code>. A Listagem 9-4 mostra uma maneira de lidar
com o <code>Result</code> usando uma ferramenta básica: a expressão <code>match</code> que discutimos
no Capítulo 6.</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(error) =&gt; {
            panic!(&quot;Houve um problema ao abrir o arquivo: {:?}&quot;, error)
        },
    };
}
</code></pre></pre>
<p><span class="caption">Listagem 9-4: Usando uma expressão <code>match</code> para tratar as
variantes de <code>Result</code> que podemos encontrar.</span></p>
<p>Note que, como no enum <code>Option</code>, o enum <code>Result</code> e suas variantes foram importadas
no prelúdio, então não precisamos especificar <code>Result::</code> antes das variantes <code>Ok</code>
e <code>Err</code> nas linhas de <code>match</code>.</p>
<p>Aqui dizemos ao Rust que quando o resultado é <code>Ok</code> ele deve retornar o valor
interno <code>file</code> de dentro da variante <code>Ok</code> e nós então podemos atribuir este
valor de <em>handle</em> de arquivo à variável <code>f</code>. Depois do <code>match</code>, nós podemos então
usar o <em>handle</em> de arquivo para ler ou escrever.</p>
<p>A outra linha de <code>match</code> trata do caso em que recebemos um valor de <code>Err</code> de
<code>File::open</code>. Nesse exemplo, nós escolhemos chamar a macro <code>panic!</code>. Se não
há nenhum arquivo chamado <em>hello.txt</em> no diretório atual e rodarmos esse código,
veremos a seguinte saída da macro <code>panic!</code>:</p>
<pre><code class="language-text">thread 'main' panicked at 'Houve um problema ao abrir o arquivo: Error { repr:
Os { code: 2, message: &quot;No such file or directory&quot; } }', src/main.rs:9:12

</code></pre>
<p>Como sempre, essa saída nos diz exatamente o que aconteceu de errado.</p>
<a class="header" href="print.html#usando-match-com-diferentes-erros" id="usando-match-com-diferentes-erros"><h3>Usando <code>match</code> com Diferentes Erros</h3></a>
<p>O código na Listagem 9-4 chamará <code>panic!</code> não importa a razão pra <code>File::open</code>
ter falhado. O que queremos fazer em vez disso é tomar diferentes ações para diferentes
motivos de falha: se <code>File::open</code> falhou porque o arquivo não existe, nós
queremos criar um arquivo e retornar o <em>handle</em> para ele. Se <code>File::open</code>
falhou por qualquer outra razão, por exemplo porque não temos a permissão para
abrir o arquivo, nós ainda queremos chamar <code>panic!</code> da mesma maneira que fizemos
na Listagem 9-4. Veja a Listagem 9-5, que adiciona outra linha ao <code>match</code>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<!-- ignore this test because otherwise it creates hello.txt which causes other
tests to fail lol -->
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(ref error) if error.kind() == ErrorKind::NotFound =&gt; {
            match File::create(&quot;hello.txt&quot;) {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; {
                    panic!(
                        &quot;Tentou criar um arquivo e houve um problema: {:?}&quot;,
                        e
                    )
                },
            }
        },
        Err(error) =&gt; {
            panic!(
                &quot;Houve um problema ao abrir o arquivo: {:?}&quot;,
                error
            )
        },
    };
}
</code></pre>
<p><span class="caption">Listagem 9-5: Tratando diferentes tipos de erros de diversas
maneiras.</span></p>
<p>O tipo do valor que <code>File::open</code> retorna dentro da variante <code>Err</code> é <code>io::Error</code>,
que é uma struct fornecida pela biblioteca padrão. Essa struct tem o método
<code>kind</code> que podemos chamar para receber um valor de <code>io::ErrorKind</code>. <code>io::ErrorKind</code>
é um enum fornecido pela biblioteca padrão que tem variantes representanto diversos
tipos de erros que podem ocorrer em uma operação de <code>io</code>. A variante que queremos
usar é <code>ErrorKind::NotFound</code>, que indica que o arquivo que queremos abrir não existe
ainda.</p>
<p>A condição <code>if error.kind() == ErrorKind::NotFound</code> é chamada de um <em>match guard</em>:
é uma condição extra dentro de uma linha de <code>match</code> que posteriormente refina
o padrão da linha. Essa condição deve ser verdadeira para o código da linha ser
executado; caso contrário a análise de padrões vai continuar considerando as
próximas linhas no <code>match</code>. O <code>ref</code> no padrão é necessário para que o <code>error</code>
não seja movido para a condição do <em>guard</em>, mas meramente referenciado por ele.
A razão de <code>ref</code> ser utilizado em vez de <code>&amp;</code> para pegar uma referência vai ser
discutida em detalhe no Capítulo 18. Resumindo, no contexto de um padrão, <code>&amp;</code>
corresponde a uma referência e nos dá seu valor, enquanto <code>ref</code> corresponde a um valor
e nos dá uma referência a ele.</p>
<p>A condição que queremos checar no <em>match guard</em> é se o valor retornado pelo
<code>error.kind()</code> é a variante <code>NotFound</code> do enum <code>ErrorKind</code>. Se é, queremos
tentar criar um arquivo com <code>File::create</code>. No entanto, como <code>File::create</code>
pode também falhar, precisamos adicionar um <code>match</code> interno também. Quando
o arquivo não pode ser aberto, outro tipo de mensagem de erro será mostrada.
A última linha do <code>match</code> externo continua a mesma de forma que o programa
entre em pânico pra qualquer erro além do de arquivo ausente.</p>
<a class="header" href="print.html#atalhos-para-pânico-em-erro-unwrap-e-expect" id="atalhos-para-pânico-em-erro-unwrap-e-expect"><h3>Atalhos para Pânico em Erro: <code>unwrap</code> e <code>expect</code></h3></a>
<p>Usar <code>match</code> funciona bem o suficiente, mas pode ser um pouco verboso e nem
sempre comunica tão bem a intenção. O tipo <code>Result&lt;T, E&gt;</code> tem vários métodos
auxiliares definidos para fazer diversas tarefas. Um desses métodos, chamado
<code>unwrap</code>, é um método de atalho que é implementado justamente como o <code>match</code> que
escrevemos na Listagem 9-4. Se o valor de <code>Result</code> for da variante <code>Ok</code>, <code>unwrap</code>
vai retornar o valor dentro de <code>Ok</code>. Se o <code>Result</code> for da variante <code>Err</code>, <code>unwrap</code>
vai chamar a macro <code>panic!</code>. Aqui um exemplo de <code>unwrap</code> em ação:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).unwrap();
}
</code></pre></pre>
<p>Se rodarmos esse código sem um arquivo <em>hello.txt</em>, veremos uma mensagem de erro
da chamada de <code>panic!</code> que o método <code>unwrap</code> faz:</p>
<pre><code class="language-text">thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Error {
repr: Os { code: 2, message: &quot;No such file or directory&quot; } }',
/stable-dist-rustc/build/src/libcore/result.rs:868
</code></pre>
<p>Outro método, <code>expect</code>, que é semelhante a <code>unwrap</code>, nos deixa também escolher
a mensagem de erro do <code>panic!</code>. Usar <code>expect</code> em vez de <code>unwrap</code> e fornecer
boas mensagens de erros podem transmitir sua intenção e tornar a procura pela
fonte de pânico mais fácil. A sintaxe de <code>expect</code> é a seguinte:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).expect(&quot;Falhou ao abrir hello.txt&quot;);
}
</code></pre></pre>
<p>Nós usamos <code>expect</code> da mesma maneira que <code>unwrap</code>: para retornar o <em>handle</em> de arquivo
ou chamar a macro de <code>panic!</code>. A mensagem de erro usada por <code>expect</code> na sua chamada
de <code>panic!</code> será o parâmtero que passamos para <code>expect</code> em vez da mensagem padrão
que o <code>unwrap</code> usa. Aqui está como ela aparece:</p>
<pre><code class="language-text">thread 'main' panicked at 'Falhou ao abrir hello.txt: Error { repr: Os { code:
2, message: &quot;No such file or directory&quot; } }',
/stable-dist-rustc/build/src/libcore/result.rs:868
</code></pre>
<p>Como essa mensagem de erro começa com o texto que especificamos, <code>Falhou ao abrir hello.txt</code>, será mais fácil encontrar o trecho do código de onde vem essa mensagem de erro. Se usamos <code>unwrap</code> em diversos lugares, pode tomar mais tempo encontrar
exatamente qual dos <code>unwrap</code> está causando o pânico, dado que todas as chamadas
a <code>unwrap</code> chamam o print de pânico com a mesma mensagem.</p>
<a class="header" href="print.html#propagando-erros" id="propagando-erros"><h3>Propagando Erros</h3></a>
<p>Quando você está escrevendo uma função cuja implementação chama algo que pode
falhar, em vez de tratar o erro dentro dessa função, você pode retornar o
erro ao código que a chamou de forma que ele possa decidir o que fazer. Isso é
conhecido como <em>propagar</em> o erro e dá mais controle ao código que chamou sua
função, onde talvez haja mais informação sobre como tratar o erro
do que você tem disponível no contexto do seu código.</p>
<p>Por exemplo, a Listagem 9-6 mostra uma função que lê um nome de usuário de um arquivo.
Se o arquivo não existe ou não pode ser lido, essa função vai retornar esses erros
ao código que chamou essa função:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let f = File::open(&quot;hello.txt&quot;);

    let mut f = match f {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut s = String::new();

    match f.read_to_string(&amp;mut s) {
        Ok(_) =&gt; Ok(s),
        Err(e) =&gt; Err(e),
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 9-6: Uma função que retorna erros ao código que a chamou
usando <code>match</code></span></p>
<p>Vamos olhar primeiro ao tipo retornado pela função: <code>Result&lt;String, io::Error&gt;</code>.
Isso significa que a função está retornando um valor do tipo <code>Result&lt;T, E&gt;</code> onde
o parâmetro genérico <code>T</code> foi preenchido pelo tipo concreto <code>String</code> e o tipo genérico
<code>E</code> foi preenchido pelo tipo concreto <code>io::Error</code>. Se essa função tem sucesso sem
nenhum problema, o código que chama essa função vai receber um valor <code>Ok</code> que contém
uma <code>String</code>- o nome de usuário que essa função leu do arquivo. Se essa função
encontra qualquer problema, o código que a chama receberá um valor de <code>Err</code>
que contém uma instância de <code>io::Error</code>, que contém mais informação
sobre o que foi o problema. Escolhemos <code>io::Error</code> como o tipo de retorno
dessa função porque é este o tipo de erro retornado pelas
duas operações que estamos chamando no corpo dessa função que podem falhar:
a função <code>File::open</code> e o método <code>read_to_string</code>.</p>
<p>O corpo da função começa chamando a função <code>File::open</code>. Nós então tratamos
o valor de <code>Result</code> retornado usando um <code>match</code> semelhante ao da Listagem 9-4,
só que em vez de chamar <code>panic!</code> no caso de <code>Err</code>, retornamos mais cedo dessa função
e passamos o valor de erro de <code>File::open</code> de volta ao código que a chamou, como o
valor de erro da nossa função. Se <code>File::open</code> tem sucesso, nós guardamos o <em>handle</em> de
arquivo na variável <code>f</code> e continuamos.</p>
<p>Então, criamos uma nova <code>String</code> na variável <code>s</code> e chamamos o método <code>read_to_string</code>
no <em>handle</em> de arquivo <code>f</code> para ler o conteúdo do arquivo e armazená-lo em <code>s</code>. O método
<code>read_to_string</code> também retorna um <code>Result</code> porque ele pode falhar, mesmo que
<code>File::open</code> teve sucesso. Então precisamos de outro <code>match</code> para tratar esse
<code>Result</code>: se <code>read_to_string</code> teve sucesso, então nossa função teve sucesso, e nós
retornamos o nome de usuário lido do arquivo que está agora em <code>s</code>, encapsulado em um <code>Ok</code>.
Se <code>read_to_string</code> falhou, retornamos o valor de erro da mesma maneira que retornamos
o valor de erro no <code>match</code> que tratou o valor de retorno de <code>File::open</code>.
No entanto, não precisamos explicitamente escrever <code>return</code>, porque essa já é a
última expressão na função.</p>
<p>O código que chama nossa função vai então receber ou um valor <code>Ok</code> que
contém um nome de usuário ou um valor de <code>Err</code> que contém um <code>io::Error</code>. Nós
não sabemos o que o código que chamou nossa função fará com esses valores. Se o
código que chamou recebe um valor de <code>Err</code>, ele poderia chamar <code>panic!</code> e causar
um crash, usar um nome de usuário padrão, ou procurar o nome de usuário em outro
lugar que não um arquivo, por exemplo. Nós não temos informação o suficiente sobre
o que o código que chamou está de fato tentando fazer, então propagamos toda a
informação de sucesso ou erro para cima para que ele a trate apropriadamente.</p>
<p>Esse padrão de propagação de erros é tão comum em Rust que a linguagem disponibiliza
o operador de interrogação <code>?</code> para tornar isso mais fácil.</p>
<a class="header" href="print.html#um-atalho-para-propagar-erros-" id="um-atalho-para-propagar-erros-"><h4>Um Atalho Para Propagar Erros: <code>?</code></h4></a>
<p>A Listagem 9-7 mostra uma implementação de <code>read_username_from_file</code> que tem a
mesma funcionalidade que tinha na Listagem 9-6, mas esta implementação usa o operador
de interrogação:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut f = File::open(&quot;hello.txt&quot;)?;
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?;
    Ok(s)
}
#}</code></pre></pre>
<p><span class="caption">Listagem 9-7: Uma função que retorna erros para o código
que a chamou usando <code>?</code>.</span></p>
<p>O <code>?</code> colocado após um valor de <code>Result</code> é definido para funcionar quase
da mesma maneira que as expressões <code>match</code> que definimos para tratar o valor
de <code>Result</code> na Listagem 9-6. Se o valor de <code>Result</code> é um <code>Ok</code>, o valor dentro dele
vai ser retornado dessa expressão e o programa vai continuar. Se o valor
é um <code>Err</code>, o valor dentro dele vai ser retornado da função inteira como se
tivéssemos usado a palavra-chave <code>return</code> de modo que o valor de erro é propagado
ao código que chamou a função.</p>
<p>A única diferença entre a expressão <code>match</code> da Listagem 9-6 e o que o operador
de interrogação faz é que quando usamos o operador de interrogação, os valores
de erro passam pela função <code>from</code> definida no <em>trait</em> <code>From</code> na biblioteca
padrão. Vários tipos de erro implementam a função <code>from</code> para converter um
erro de um tipo em outro. Quando usado pelo operador de
interrogação, a chamada à função <code>from</code> converte o tipo de erro que o
operador recebe no tipo de erro definido no tipo de retorno da função em
que estamos usando <code>?</code>. Isso é útil quando partes de uma função podem falhar
por várias razões diferentes, mas a função retorna um tipo de erro que
representa todas as maneiras que a função pode falhar. Enquanto cada
tipo de erro implementar a função <code>from</code> para definir como se converter
ao tipo de erro retornado, o operador de interrogação lida com a conversão
automaticamente.</p>
<p>No contexto da Listagem 9-7, o <code>?</code> no final da chamada de <code>File::open</code> vai
retornar o valor dentro do <code>Ok</code> à variável <code>f</code>. Se um erro ocorrer, <code>?</code>
vai retornar mais cedo a função inteira e dar um valor de <code>Err</code> ao código
que a chamou. O mesmo se aplica ao <code>?</code> ao final da chamada de <code>read_to_string</code>.</p>
<p>O <code>?</code> elimina um monte de excesso e torna a implementação dessa
função mais simples. Poderíamos até encurtar ainda mais esse código
ao encadear chamadas de método imediatamente depois do <code>?</code>, como mostrado
na Listagem 9-8:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut s = String::new();

    File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut s)?;

    Ok(s)
}
#}</code></pre></pre>
<p><span class="caption">Listagem 9-8: Encadeando chamadas de método após o operador
de interrogação.</span></p>
<p>Nós movemos a criação da nova <code>String</code> em <code>s</code> para o começo da função;
essa parte não mudou. Em vez de criar uma variável <code>f</code>, nós encadeamos
a chamada para <code>read_to_string</code> diretamente ao resultado de
<code>File::open(&quot;hello.txt&quot;)?</code>. Nós ainda temos um <code>?</code> ao fim da chamada a
<code>read_to_string</code>, e ainda retornamos um valor de <code>Ok</code> contendo o nome de usuário
em <code>s</code> quando ambos os métodos <code>File::open</code> e <code>read_to_string</code> tiveram sucesso ao invés
de retornarem erros. Essa funcionalidade é novamente a mesma da Listagem 9-6 e
Listagem 9-7; essa é só uma maneira diferente e mais ergonômica de escrevê-la.</p>
<a class="header" href="print.html#-somente-pode-ser-usado-em-funções-que-retornam-result" id="-somente-pode-ser-usado-em-funções-que-retornam-result"><h4><code>?</code> Somente Pode Ser Usado em Funções Que Retornam Result</h4></a>
<p>O <code>?</code> só pode ser usado em funções que tem um tipo de retorno de <code>Result</code>,
porque está definido a funcionar da mesma maneira que a expressão <code>match</code> que
definimos na Listagem 9-6. A parte do <code>match</code> que requer um tipo de retorno de
<code>Result</code> é <code>return Err(e)</code>, então o tipo de retorno da função deve ser
um <code>Result</code> para ser compatível com esse <code>return</code>.</p>
<p>Vamos ver o que ocorre quando usamos <code>?</code> na função <code>main</code>, que como vimos, tem
um tipo de retorno de <code>()</code>:</p>
<pre><code class="language-rust ignore">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;)?;
}
</code></pre>
<p>Quando compilamos esse código recebemos a seguinte mensagem de erro:</p>
<pre><code class="language-text">error[E0277]: the `?` operator can only be used in a function that returns
`Result` (or another type that implements `std::ops::Try`)
 --&gt; src/main.rs:4:13
  |
4 |     let f = File::open(&quot;hello.txt&quot;)?;
  |             ------------------------
  |             |
  |             cannot use the `?` operator in a function that returns `()`
  |             in this macro invocation
  |
  = help: the trait `std::ops::Try` is not implemented for `()`
  = note: required by `std::ops::Try::from_error`
</code></pre>
<p>Esse erro aponta que só podemos usar o operador de interrogação em funções
que retornam <code>Result</code>. Em funções que não retornam <code>Result</code>, quando você chama
outras funções que retornam <code>Result</code>, você deve usar um <code>match</code> ou um dos métodos
de <code>Result</code> para tratá-lo em vez de usar <code>?</code> para potencialmente
propagar o erro ao código que a chamou.</p>
<p>Agora que discutimos os detalhes de chamar <code>panic!</code> ou retornar <code>Result</code>, vamos
retornar ao tópico de como decidir qual é apropriado para utilizar em quais
casos.</p>
<a class="header" href="print.html#entrar-em-panic-ou-não-entrar-em-panic" id="entrar-em-panic-ou-não-entrar-em-panic"><h2>Entrar em <code>panic!</code> ou Não Entrar em <code>panic!</code></h2></a>
<p>Então como você decide quando entrar em <code>panic!</code> e quando você deveria retornar
um <code>Result</code>? Quando o código entra em pânico, não há maneira de se recuperar. Você
poderia chamar <code>panic!</code> para qualquer situação de erro, tendo uma maneira de se recuperar
ou não, mas então você estaria decidindo no lugar do código que chama seu código
que a situação é irrecuperável. Quando você decide retornar um valor de <code>Result</code>,
você lhe dá opções em vez de tomar a decisão por ele. O código
que chama seu código pode tentar se recuperar de uma maneira que é apropriada para
a situação, ou ele pode decidir que um valor de <code>Err</code> nesse caso é irrecuperável,
chamando <code>panic!</code> e transformando seu erro recuperável em um irrecuperável.
Portanto, retornar <code>Result</code> é uma boa escolha padrão quando você está definindo
uma função que pode falhar.</p>
<p>Em algumas situações é mais apropriado escrever código que entra em pânico em vez
de retornar um <code>Result</code>, mas eles são menos comuns. Vamos explorar porque é apropriado
entrar em pânico em alguns exemplos, protótipos de código e testes; depois situações
em que você como humano pode saber que um método não vai falhar, mas que o compilador não
tem como saber; e concluir com algumas diretrizes sobre como decidir entrar ou
não em pânico em código de biblioteca.</p>
<a class="header" href="print.html#exemplos-protótipos-e-testes-são-todos-lugares-em-que-É-perfeitamente-ok-entrar-em-pânico" id="exemplos-protótipos-e-testes-são-todos-lugares-em-que-É-perfeitamente-ok-entrar-em-pânico"><h3>Exemplos, Protótipos, e Testes São Todos Lugares em que É Perfeitamente Ok Entrar em Pânico</h3></a>
<p>Quando você está escrevendo um exemplo para ilustrar algum conceito, ter código
de tratamento de erro robusto junto do exemplo pode torná-lo menos claro. Em exemplos,
é compreensível que uma chamada a um método como <code>unwrap</code> que poderia chamar <code>panic!</code>
apenas substitua a maneira como você trataria erros na sua aplicação,
que pode ser diferente baseado no que o resto do seu código está fazendo.</p>
<p>De forma semelhante, os métodos <code>unwrap</code> e <code>expect</code> são bem úteis ao fazer
protótipos, antes de você estar pronto para decidir como tratar erros. Eles deixam
marcadores claros no seu código para quando você estiver pronto para tornar
seu programa mais robusto.</p>
<p>Se uma chamada de método falha em um teste, queremos que o teste inteiro falhe,
mesmo se esse método não é a funcionalidade sendo testada. Como <code>panic!</code> é o modo
que um teste é marcado como falha, chamar <code>unwrap</code> ou <code>expect</code> é exatamente o que
deveria acontecer.</p>
<a class="header" href="print.html#casos-em-que-você-tem-mais-informação-que-o-compilador" id="casos-em-que-você-tem-mais-informação-que-o-compilador"><h3>Casos em que Você Tem Mais Informação Que o Compilador</h3></a>
<p>Seria também apropriado chamar <code>unwrap</code> quando você tem outra lógica que
assegura que o <code>Result</code> vai ter um valor <code>Ok</code>, mas essa lógica não é algo
que o compilador entenda. Você ainda vai ter um valor de <code>Result</code> que precisa
lidar: seja qual for a operação que você está chamando, ela ainda tem uma possibilidade
de falhar em geral, mesmo que seja logicamente impossível que isso ocorra nessa
situação particular. Se você consegue assegurar ao inspecionar manualmente o código que
você nunca tera uma variante <code>Err</code>, é perfeitamente aceitável chamar <code>unwrap</code>.
Aqui temos um exemplo:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::net::IpAddr;

let home = &quot;127.0.0.1&quot;.parse::&lt;IpAddr&gt;().unwrap();
#}</code></pre></pre>
<p>Nós estamos criando uma instância <code>IpAddr</code> ao analisar uma string <em>hardcoded</em>. Nós
podemos ver que <code>127.0.0.1</code> é um endereço de IP válido, então é aceitável usar
<code>unwrap</code> aqui. No entanto, ter uma string válida <em>hardcoded</em> não muda o tipo retornado
pelo método <code>parse</code>: ainda teremos um valor de <code>Result</code>, e o compilador ainda
vai nos fazer tratar o <code>Result</code> como se a variante <code>Err</code> fosse uma
possibilidade, porque o compilador não é inteligente o bastante para ver que essa string
é sempre um endereço IP válido. Se a string de endereço IP viesse de um usuário ao invés
de ser <em>hardcoded</em> no programa, e portanto, de fato tivesse uma possibilidade de falha, nós
definitivamente iríamos querer tratar o <code>Result</code> de uma forma mais robusta.</p>
<a class="header" href="print.html#diretrizes-para-tratamento-de-erro" id="diretrizes-para-tratamento-de-erro"><h3>Diretrizes para Tratamento de Erro</h3></a>
<p>É aconselhável fazer que seu código entre em <code>panic!</code> quando é possível que
ele entre em um mau estado. Nesse contexto, mau estado é quando
alguma hipótese, garantia, contrato ou invariante foi quebrada, tal como
valores inválidos, valores contraditórios, ou valores faltando que são passados
a seu código - além de um ou mais dos seguintes:</p>
<ul>
<li>O mau estado não é algo que é <em>esperado</em> que aconteça ocasionalmente.</li>
<li>Seu código após certo ponto precisa confiar que ele não está nesse mau estado.</li>
<li>Não há uma forma boa de codificar essa informação nos tipos que você usa.</li>
</ul>
<p>Se alguém chama seu código e passa valores que não fazem sentido, a melhor escolha
talvez seja entrar em <code>panic!</code> e alertar a pessoa usando sua biblioteca do bug no
código dela para que ela possa consertá-la durante o desenvolvimento. Similarmente,
<code>panic!</code> é em geral apropriado se você está chamando código externo que está fora
do seu controle e ele retorna um estado inválido que você não tem como consertar.</p>
<p>Quando se chega a um mau estado, mas isso é esperado que aconteça não importa
quão bem você escreva seu código, ainda é mais apropriado retornar um <code>Result</code>
a fazer uma chamada a <code>panic!</code>. Um exemplo disso é um <em>parser</em> recebendo dados
malformados ou uma requisição HTTP retornando um status que indique que você atingiu
um limite de taxa. Nesses casos, você deveria indicar que falha é uma possibilidade
esperada ao retornar um <code>Result</code> para propagar esses estados ruins para cima,
de forma que o código que chamou seu código pode decidir como tratar o problema.
Entrar em <code>panic!</code> não seria a melhor maneira de lidar com esses casos.</p>
<p>Quando seu código realiza operações em valores, ele deveria verificar que os valores
são válidos primeiro, e entrar em <code>panic!</code> caso não sejam. Isso é
em boa parte por razões de segurança: tentar operar em dados inválidos pode expor seu
código a vulnerabilidades. Essa é a principal razão para a biblioteca padrão entrar em
<code>panic!</code> se você tentar um acesso de memória fora dos limites: tentar acessar memória
que não pertence à estrutura de dados atual é um problema de segurança comum. Funções
frequentemente tem <em>contratos</em>: seu comportamento somente é garantido se os inputs cumprem
requerimentos específicos. Entrar em pânico quando o contrato é violado faz sentido
porque uma violação de contrato sempre indica um bug da parte do chamador, e não é o tipo
de erro que você quer que seja tratado explicitamente. De fato,
não há nenhuma maneira razoável para o código chamador se recuperar: os <em>programadores</em>
que precisam consertar o código. Contratos para uma função, especialmente quando uma
violação leva a pânico, devem ser explicados na documentação da API da função.</p>
<p>No entanto, ter várias checagens de erro em todas suas funções pode ser verboso
e irritante. Felizmente, você pode usar o sistema de tipos do Rust (e portanto a
checagem que o compilador faz) para fazer várias dessas checagens para você. Se
sua função tem um tipo particular como parâmetro, você pode continuar com a lógica
do seu código sabendo que o compilador já assegurou que você tem um valor válido.
Por exemplo, se você tem um tipo em vez de uma <code>Option</code>, seu programa espera
ter <em>algo</em> ao invés de <em>nada</em>. Seu código não precisa tratar dois casos para
as variantes <code>Some</code> e <code>None</code>: ele vai somente ter um caso para definitivamente ter
um valor. Um código que tente passar nada para sua função não vai nem compilar,
então sua função não precisa checar esse caso em tempo de execução. Outro exemplo é usar
um tipo de inteiro sem sinal como <code>u32</code>, que assegura que o parâmetro nunca é
negativo.</p>
<a class="header" href="print.html#criando-tipos-customizados-para-validação" id="criando-tipos-customizados-para-validação"><h3>Criando Tipos Customizados para Validação</h3></a>
<p>Vamos dar um passo além na ideia de usar o sistema de tipos de Rust para assegurar que temos
um valor válido e ver como criar um tipo customizado para validação.
Lembre do jogo de adivinhação no Capítulo 2 onde nosso código pedia ao usuário
para adivinhar um número entre 1 e 100. Nós nunca validamos que o chute do usuário
fosse entre esses números antes de compará-lo com o número secreto; nós somente
validamos que o chute era positivo. Nesse caso, as consequências não foram tão
drásticas: nosso output de &quot;Muito alto&quot; ou &quot;Muito baixo&quot; ainda estariam corretos. Seria
uma melhoria útil guiar o usuário para chutes válidos, e ter um comportamento distinto
quando um usuário chuta um número fora do limite e quando um usuário digita letras, por exemplo.</p>
<p>Uma maneira de fazer isso seria interpretar o chute como um <code>i32</code> em vez de
somente um <code>u32</code> para permitir números potenciamente negativos, e então adicionar
uma checagem se o número está dentro dos limites, conforme a seguir:</p>
<pre><code class="language-rust ignore">loop {
    // snip

    let palpite: i32 = match palpite.trim().parse() {
        Ok(num) =&gt; num,
        Err(_) =&gt; continue,
    };

    if palpite &lt; 1 || palpite &gt; 100 {
        println!(&quot;O número secreto vai estar entre 1 e 100.&quot;);
        continue;
    }

    match palpite.cmp(&amp;numero_secreto) {
    // snip
}
</code></pre>
<p>A expressão <code>if</code> checa se nosso valor está fora dos limites, informa o usuário
sobre o problema, e chama <code>continue</code> para começar a próxima iteração do loop
e pedir por outro chute. Depois da expressão <code>if</code> podemos proceder com as
comparações entre <code>palpite</code> e o número secreto sabendo que <code>palpite</code> está
entre 1 e 100.</p>
<p>No entanto, essa não é a solução ideal: se fosse absolutamente crítico que o
programa somente operasse em valores entre 1 e 100, e ele tivesse várias funções
com esse requisito, seria tedioso (e potencialmente impactante na performance)
ter uma checagem dessa em cada função.</p>
<p>Em vez disso, podemos fazer um novo tipo e colocar as validações em uma função
para criar uma instância do tipo em vez de repetir as validações em todo lugar.
Dessa maneira, é seguro para funções usarem o novo tipo nas suas assinaturas e
confidentemente usar os valores que recebem. A Listagem 9-9  mostra uma maneira de
definir um tipo <code>Palpite</code> que vai somente criar uma instância de <code>Palpite</code> se a função
<code>new</code> receber um valor entre 1 e 100:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Palpite {
    valor: u32,
}

impl Palpite {
    pub fn new(valor: u32) -&gt; Palpite {
        if valor &lt; 1 || valor &gt; 100 {
            panic!(&quot;Valor de chute deve ser entre 1 e 100, recebi {}.&quot;, valor);
        }

        Palpite {
            valor
        }
    }

    pub fn valor(&amp;self) -&gt; u32 {
        self.valor
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 9-9: Um tipo <code>Palpite</code> que somente funciona com valores
entre 1 e 100.</span></p>
<p>Primeiro, definimos uma struct chamada <code>Palpite</code> que tem um campo chamado <code>valor</code>
que guarda um <code>u32</code>. Isso é onde o número vai ser guardado.</p>
<p>Então nós implementamos uma função associada chamada <code>new</code> em <code>Palpite</code> que cria
instâncias de valores <code>Palpite</code>. A função <code>new</code> é definida a ter um parâmetro
chamado <code>valor</code> de tipo <code>u32</code> e retornar um <code>Palpite</code>. O código no corpo da função
<code>new</code> testa para ter certeza que <code>valor</code> está entre 1 e 100. Se <code>valor</code> não passa
nesse teste, fazemos uma chamada a <code>panic!</code>, que vai alertar ao programador que
está escrevendo o código chamando a função que ele tem um bug que precisa ser
corrigido, porque criar um <code>Palpite</code> com um <code>valor</code> fora desses limites violaria
o contrato em que <code>Palpite::new</code> se baseia. As condições em que <code>Palpite::new</code> pode
entrar em pânico devem ser discutidas na sua documentação da API voltada ao público;
no Capítulo 14 nós cobriremos convenções de documentação indicando a possibilidade de um <code>panic!</code>
na documentação de API. Se <code>valor</code> de fato passa no
teste, criamos um novo <code>Palpite</code> com o campo <code>valor</code> preenchido com o parâmetro
<code>valor</code> e retornamos o <code>Palpite</code>.</p>
<p>Em seguida, implementamos um método chamado <code>valor</code> que pega <code>self</code> emprestado, não
tem nenhum outro parâmetro, e retorna um <code>u32</code>. Esse é o tipo de método às vezes
chamado de <em>getter</em>, pois seu propósito é pegar um dado de um dos campos e o retornar.
Esse método público é necessário porque o campo <code>valor</code> da struct <code>Palpite</code> é privado.
É importante que o campo <code>valor</code> seja privado para que código usando a struct <code>Palpite</code>
não tenha permissão de definir o valor de <code>valor</code> diretamente: código de fora do módulo
<em>deve</em> usar a função <code>Palpite::new</code> para criar uma instância de <code>Palpite</code>, o que certifica
que não há maneira de um <code>Palpite</code> ter um <code>valor</code> que não foi checado pelas condições
definidas na função <code>Palpite::new</code>.</p>
<p>Uma função que tem um parâmetro ou retorna somente números entre 1 e 100 pode
então declarar na sua assinatura que ela recebe ou retorna um <code>Palpite</code> em vez
de um <code>u32</code> e não precisaria fazer nenhuma checagem adicional no seu corpo.</p>
<a class="header" href="print.html#resumo-5" id="resumo-5"><h2>Resumo</h2></a>
<p>As ferramentas de tratamento de erros de Rust são feitas para te ajudar a escrever
código mais robusto. A macro <code>panic!</code> sinaliza que seu programa está num estado que
não consegue lidar e deixa você parar o processo ao invés de tentar prosseguir com
valores inválidos ou incorretos. O enum <code>Result</code> usa o sistema de tipos de Rust para
indicar que operações podem falhar de uma maneira que seu código pode se recuperar.
Você pode usar <code>Result</code> para dizer ao código que chama seu código que ele precisa
tratar potenciais sucessos ou falhas também. Usar <code>panic!</code> e <code>Result</code> nas situações
apropriadas fará seu código mais confiável em face aos problemas inevitáveis.</p>
<p>Agora que você viu as maneiras úteis em que a biblioteca padrão usa genéricos com
os enums <code>Option</code> e <code>Result</code>, nós falaremos como genéricos funcionam e como você
pode usá-los em seu código no próximo capítulo.</p>
<p>#Tipos Genéricos, <em>Traits</em>, e Tempos de vida (<em>Lifetimes</em>)</p>
<p>Cada linguagem de programação tem ferramentas para lidar de forma efetiva com a
duplicação de conceitos; em Rust, uma dessas ferramentas são os tipos
genéricos. Tipos genéricos são substitutos abstratos para tipos concretos ou
para outras propriedades. Quando estamos escrevendo e compilando o código
podemos expressar propriedades de tipos genéricos, como seu comportamento ou
como eles se relacionam com outros tipos genéricos, sem precisar saber o que
realmente estará no lugar deles.</p>
<p>Do mesmo modo que uma função aceita parâmetros cujos valores não sabemos
para escrever código que será processado em múltiplos valores concretos, nós
podemos escrever funções que recebem parâmetros de alguns tipos genéricos ao
invés de tipos concretos como <code>i32</code> ou <code>String</code>. Nós já usamos tipos genéricos
no Capítulo 6 com <code>Option&lt;T&gt;</code>, no Capítulo 8 com <code>Vec&lt;T&gt;</code> e <code>HashMap&lt;K, V&gt;</code>, e
no Capítulo 9 com <code>Result&lt;T, E&gt;</code>. Nesse capítulo, vamos explorar como definir
nossos próprios tipos, funções e métodos usando tipos genéricos!</p>
<p>Primeiro, nós vamos revisar as mecânicas de extrair uma função que reduz
duplicação de código. Então usaremos a mesma mecânica para fazer uma função
genérica usando duas funções que só diferem uma da outra nos tipos dos seus
parâmetros. Nós vamos usar tipos genéricos em definições de struct e enum
também.</p>
<p>Depois disso, nós vamos discutir traits, que são um modo de definir
comportamento de uma forma genérica. Traits podem ser combinados com tipos
genéricos para restringir um tipo genérico aos tipos que tem um comportamento
particular ao invés de qualquer tipo.</p>
<p>Finalmente, nós discutiremos <em>tempos de vida</em>, que são um tipo de generalização
que nos permite dar ao compilador informações sobre como as referências são
relacionadas umas com as outras. Tempos de vida são as características em Rust
que nos permitem pegar valores emprestados em muitas situações e ainda ter a
aprovação do compilador de que as referências serão válidas.</p>
<a class="header" href="print.html#removendo-duplicação-por-meio-da-extração-de-uma-função" id="removendo-duplicação-por-meio-da-extração-de-uma-função"><h2>Removendo Duplicação por meio da Extração de uma Função</h2></a>
<p>Antes de entrar na sintaxe de tipos genéricos, vamos primeiro revisar uma
técnica para lidar com duplicatas que não usa tipos genéricos: extraindo uma
função. Uma vez que isso esteja fresco em nossas mentes, usaremos as mesmas
mecânicas com tipos genéricos para extrair uma função genérica! Do mesmo modo
que você reconhece código duplicado para extrair para uma função, você começará
a reconhecer código duplicado que pode usar tipos genéricos.</p>
<p>Considere um pequeno programa que acha o maior número em uma lsita, mostrado
na Listagem 10-1:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let lista_numero = vec![34, 50, 25, 100, 65];

    let mut maior = lista_numero[0];

    for numero in lista_numero {
        if numero &gt; maior {
            maior = numero;
        }
    }

    println!(&quot;O maior número é {}&quot;, maior);
#  assert_eq!(maior, 100);
}
</code></pre></pre>
<p><span class="caption">Listagem 10-1: Código para achar o maior número em uma
lista de números</span></p>
<p>Esse código recebe uma lista de inteiros, guardados aqui na variável
<code>lista_numero</code>. Coloca o primeiro item da lista na variável chamada <code>maior</code>.
Então ele itera por todos os números da lista, e se o valor atual é maior que
o número guardado em <code>maior</code>, substitui o valor em <code>maior</code>. Se o valor atual é
menor que o valor visto até então, <code>maior</code> não é mudado. Quando todos os items
da lista foram considerados, <code>maior</code> terá o maior valor, que nesse caso é 100.</p>
<p>Se nós precisássemos encontrar o maior número em duas listas diferentes de
números, nós poderíamos duplicar o código da Listagem 10-1 e usar a mesma
lógica nas duas partes do programa, como na Listagem 10-2:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let lista_numero = vec![34, 50, 25, 100, 65];

    let mut maior = lista_numero[0];

    for numero in lista_numero {
        if numero &gt; maior {
            maior = numero;
        }
    }

    println!(&quot;O maior número é {}&quot;, maior);

    let lista_numero = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut maior = lista_numero[0];

    for numero in lista_numero {
        if numero &gt; maior {
            maior = numero;
        }
    }

    println!(&quot;O maior número é {}&quot;, maior);
}
</code></pre></pre>
<p><span class="caption">Listagem 10-2: Código para encontrar o maior número em
duas listas de números</span></p>
<p>Ao passo que esse código funciona, duplicar código é tedioso e tende a causar
erros, e significa que temos múltiplos lugares para atualizar a lógica se
precisarmos mudá-lo.</p>
<p>Para eliminar essa duplicação, nós podemos criar uma abstração, que nesse caso
será na forma de uma função que opera em uma lista de inteiros passadas à
função como um parâmetro. Isso aumentará a clareza do nosso código e nos
permitirá comunicar e pensar sobre o conceito de achar o maior número em uma
lista independentemente do lugar no qual esse conceito é usado.</p>
<p>No programa na Listagem 10-3, nós extraímos o código que encontra o maior
número para uma função chamada <code>maior</code>. Esse programa pode achar o maior número
em duas listas de números diferentes, mas o código da lista 10-1 existe apenas
em um lugar:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn maior(list: &amp;[i32]) -&gt; i32 {
    let mut maior = list[0];

    for &amp;item in list.iter() {
        if item &gt; maior {
            maior = item;
        }
    }

    maior
}

fn main() {
    let lista_numero = vec![34, 50, 25, 100, 65];

    let resultado = maior(&amp;lista_numero);
    println!(&quot;O maior número é {}&quot;, resultado);
#    assert_eq!(resultado, 100);

    let lista_numero = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let resultado = maior(&amp;lista_numero);
    println!(&quot;O maior número é {}&quot;, resultado);
#    assert_eq!(resultado, 6000);
}
</code></pre></pre>
<p><span class="caption">Listagem 10-3: Código abstraído para encontrar o maior
numḿero em duas listas</span></p>
<p>A função tem o parâmetro, <code>list</code>, que representa qualquer corte concreto de
valores <code>i32</code> que podemos passar para uma função. O código na definição da
função opera na representação da <code>list</code> de qualquer <code>&amp;[i32]</code>. Quando nós
passamos a função <code>maior</code>, o código é executado com os valores específicos
que nós passamos.</p>
<p>As mecânicas que usamos da Listagem 10-2 para a Listagem 10-3 foram as
seguintes:</p>
<ol>
<li>Nós notamos que havia código duplicado.</li>
<li>Nós extraímos o código duplicado para o corpo da função, e especificamos as
entradas e os valores de retorno daquele código na assinatura da função.</li>
<li>Nós substituímos os dois locais concretos que tinham código duplicado para
chamar a função.</li>
</ol>
<p>Nós podemos usar os mesmos passos usando tipos genéricos para reduzir a
duplicação de código de diferentes modos em diferentes cenários. Do mesmo modo
que o corpo da função agora é operado em uma <code>list</code> abstrata ao invés de
valores concretos, códigos usando tipos genéricos operarão em tipos abstratos.
Os conceitos empoderando tipos genéricos são os mesmos conceitos que você já
conhece que empodera funções, só que aplicado de modos diferentes.</p>
<p>E se nós tivéssemos duas funções, uma que acha o maior item em um <em>slice</em> de
valores <code>i32</code> e um que acha o maior item em um corte de valores <code>char</code>? Como
nos livraríamos dessa duplicação? Vamos descobrir!</p>
<a class="header" href="print.html#tipos-genéricos-de-dados" id="tipos-genéricos-de-dados"><h2>Tipos Genéricos de Dados</h2></a>
<p>Usando tipos genéricos onde usualmente colocamos tipos, como em assinaturas de
funções ou estruturas, vamos criar definições que podemos usar muitos tipos
diferentes de tipos concretos de dados. Vamos dar uma olhada em como definir
funções, structs, enums e métodos usando tipos genéricos, e ao final dessa
seção discutiremos a performance do código usando tipos genéricos.</p>
<a class="header" href="print.html#usando-tipos-genéricos-de-dados-em-definições-de-funções" id="usando-tipos-genéricos-de-dados-em-definições-de-funções"><h3>Usando Tipos Genéricos de Dados em Definições de Funções</h3></a>
<p>Nós podemos definir funções que usam tipos genéricos na assinatura da função
onde os tipos de dados dos parâmetros e os retornos vão. Desse modo, o código
que escrevemos pode ser mais flexível e pode fornecer mais funcionalidades para
os chamadores da nossa função, e ainda diminuir duplicação de código.</p>
<p>Continuando com nossa função <code>maior</code>, a Listagem 10-4 mostra duas funções que
oferecem a mesma funcionalidade de encontrar o maior valor dado um corte. A
primeira função é a que extraímos na Listagem 10-3 que encontra o maior <code>ì32</code>
em um corte. A segunda função encontra o maior <code>char</code> em um corte:</p>
<p><span class="filename">Nome do Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn maior_i32(lista: &amp;[i32]) -&gt; i32 {
    let mut maior = list[0];

    for &amp;item in lista.iter() {
        if item &gt; maior {
            maior = item;
        }
    }

    maior
}

fn maior_char(lista: &amp;[char]) -&gt; char {
    let mut maior = lista[0];

    for &amp;item in lista.iter() {
        if item &gt; maior {
            maior = item;
        }
    }

    maior
}

fn main() {
    let lista_numero = vec![34, 50, 25, 100, 65];

    let resultado = maior_i32(&amp;lista_numero);
    println!(&quot;O maior número {}&quot;, resultado);
#    assert_eq!(resultado, 100);

    let lista_char = vec!['y', 'm', 'a', 'q'];

    let resultado = maior_char(&amp;lista_char);
    println!(&quot;O maior char é {}&quot;, resultado);
#    assert_eq!(resultado, 'y');
}
</code></pre></pre>
<p><span class="caption">Listing 10-4: Duas funções que diferem apenas em seus
nomes e nos tipos de suas assinaturas</span></p>
<p>Aqui as funções <code>maior_i32</code> e <code>maior_char</code> tem exatamente o mesmo corpo, então
seria bom se pudéssemos transformar essas duas funções em uma e nos livrar da
duplicação. Por sorte, nós podemos fazer isso introduzindo um parâmetro de
tipo genérico!</p>
<p>Para parametrizar os tipos na assinatura de uma função que vamos definir,
precisamos criar um nome para o tipo parâmetro, assim como damos nomes para os
valores dos parâmetros de uma função. Nós vamos escolher o nome <code>T</code>. Qualquer
identificador pode ser usado como um nome de tipo de parâmetro, mas estamos
escolhendo <code>T</code> porque a convenção de nomes de tipos de Rust é a CamelCase.
Nomes de parâmetros de tipos genéricos também tendem a ser curtos por
convenção, e frequentemente usam apenas uma letra. A abreviatura de &quot;tipo&quot;, <code>T</code>
é a escolha padrão feita por programadores Rust.</p>
<p>Quando usamos um parâmetro no corpo de uma função, nós temos que declarar o
parâmetro na assinatura para que o compilador saiba o que aquele nome no corpo
significa. Similarmente, quando usamos um tipo de nome de parâmetro em uma
assinatura de função, temos que declarar o tipo de nome de parâmetro antes de
usa-lo. Declarações de tipos de nomes vão em colchetes entre o nome da função e
a lista de paramêtros.</p>
<p>A assinatura da função da função genérica <code>maior</code> que vamos definir se parecerá
com isto:</p>
<pre><code class="language-rust ignore">fn maior&lt;T&gt;(lista: &amp;[T]) -&gt; T {
</code></pre>
<p>Nós leríamos isso como: a função <code>maior</code> é genérica sobre algum tipo <code>T</code>. Ela
tem um parâmetro chamado <code>lista</code>, e o tipo de <code>lista</code> é um corte dos valores
do tipo <code>T</code>. A função <code>maior</code> retornará um valor do mesmo tipo <code>T</code>.</p>
<p>A listagem 10-5 mostra a definição da função unificada <code>maior</code> usando um tipo
genérico de dado na sua assinatura, e mostra quando nós poderemos chamar a
função <code>maior</code> com ou um corte de valores de <code>i32</code> ou de valores <code>char</code>. Note
que esse código não compilará ainda!</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn maior&lt;T&gt;(lista: &amp;[T]) -&gt; T {
    let mut maior = lista[0];

    for &amp;item in lista.iter() {
        if item &gt; maior {
            maior = item;
        }
    }

    maior
}

fn main() {
    let lista_numero = vec![34, 50, 25, 100, 65];

    let resultado = maior(&amp;lista_numero);
    println!(&quot;The maior number is {}&quot;, resultado);

    let lista_char = vec!['y', 'm', 'a', 'q'];

    let resultado = maior(&amp;char_lista);
    println!(&quot;O maior char e {}&quot;, resultado);
}
</code></pre>
<p><span class="caption">Listagem 10-5: Uma definição para a função <code>maior</code> que
usa um tipo genérico como parâmetro mas não compila ainda</span></p>
<p>Se nós tentarmos compilar o código agora, nós receberemos esse erro:</p>
<pre><code class="language-text">error[E0369]: binary operation `&gt;` cannot be applied to type `T`
  |
5 |         if item &gt; maior {
  |            ^^^^
  |
note: an implementation of `std::cmp::PartialOrd` might be missing for `T`
</code></pre>
<p>A nota menciona <code>std::cmp::PartialOrd</code>, que é um <em>trait</em>. Nós vamos falar sobre
trait na próxima sessão, mas de forma breve, o que esse erro está dizendo é que
o corpo de <code>maior</code> não funcionará para todos os possíveis tipos que <code>T</code> poderia
ser; já que queremos comparar valores do tipo <code>T</code> no corpo, nós podemos apenas
usar tipos que sabem como ser ordenados. A biblioteca padrão definiu que o
trait <code>std::cmp::PartialOrd</code> que tipos podem implementar para habilitar
comparações. Vamos voltar a traits e em como especificar que um tipo genérico
tenha um trait em particular na próxima sessão, mas vamos deixar isso de lado
por um momento e explorar outros lugares que podemos usar parâmetros de tipos
genéricos primeiro.</p>
<a class="header" href="print.html#usando-tipos-de-dados-genéros-em-definições-de-structs" id="usando-tipos-de-dados-genéros-em-definições-de-structs"><h3>Usando Tipos de Dados Genéros em Definições de Structs</h3></a>
<p>Nós podemos definir structs para usar um parâmetro de tipo genérico em um ou
mais campos de um struct com a sintaxe <code>&lt;&gt;</code> também. A listagem 10-6 mostra a
definição e faz uso do struct <code>Ponto</code> que contém as coordenadas <code>x</code> e <code>y</code> com
valores de qualquer tipo:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Ponto&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let inteiro = Ponto { x: 5, y: 10 };
    let float = Ponto { x: 1.0, y: 4.0 };
}
</code></pre></pre>
<p><span class="caption">Listagem 10-6: Uma struct <code>Ponto</code> contém os valores <code>x</code> e
<code>y</code> do tipo <code>T</code></span></p>
<p>A sintaxe é similar a que se usa em definições de funções usando tipos
genéricos. Primeiro, nós temos que declarar o nome do tipo de parâmetro dentro
de colchetes angulares logo após o nome da struct. Então nós podemos usar tipos
genéricos na definição da struct onde nós especificaríamos tipos concretos de
dados.</p>
<p>Note que porque só usamos um tipo genérico na definição de <code>Ponto</code>, o que
estamos dizendo é que o struct <code>Ponto</code> é genérico sobre algum tipo <code>T</code>, e os
campos <code>x</code> e <code>y</code> são <em>ambos</em> do mesmo tipo, qualquer que seja. Se nós tentarmos
criar uma instância de um <code>Ponto</code> que possui valores de tipos diferentes, como
na Listagem 10-7, nosso código não compilará:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">struct Ponto&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let nao_funciona = Ponto { x: 5, y: 4.0 };
}
</code></pre>
<p><span class="caption">Listagem 10-7: Os campos <code>x</code> e <code>y</code> precisam ser do mesmo
tipo porque ambos tem o tipo genérico de dado <code>T</code></span></p>
<p>Se nós tentarmos compilar isso, receberemos o seguinte erro:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt;
  |
7 |     let nao_funciona = Point { x: 5, y: 4.0 };
  |                                         ^^^ expected integral variable, found
  floating-point variable
  |
  = note: expected type `{integer}`
  = note:    found type `{float}`
</code></pre>
<p>Quando atribuímos o valor de 5 para <code>x</code>, o compilador sabe que para essa
instância de <code>Ponto</code> o tipo genérico <code>T</code> será um número inteiro. Então quando
especificamos 4.0 para <code>y</code>, o qual é definido para ter o mesmo tipo de <code>x</code>, nós
temos um tipo de erro de incompatibilidade.</p>
<p>Se nós quisermos definir um struct de <code>Ponto</code> onde <code>x</code> e <code>y</code> têm tipos
diferentes e quisermos fazer com que esses tipos sejam genéricos, nós podemos
usar parâmetros múltiplos de tipos genéricos. Na listagem 10-8, nós mudamos a
definição do <code>Ponto</code> para os tipos genéricos <code>T</code> e <code>U</code>. O campo <code>x</code> é do tipo
<code>T</code>, e o campo <code>y</code> do tipo <code>U</code>:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Ponto&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let ambos_inteiros = Ponto { x: 5, y: 10 };
    let ambos_floats = Ponto { x: 1.0, y: 4.0 };
    let inteiro_e_float = Ponto { x: 5, y: 4.0 };
}
</code></pre></pre>
<p><span class="caption">Listagem 10-8: Um <code>Ponto</code> genérico sobre dois tipos <code>x</code> e
<code>y</code> podem ser valores de tipos diferentes</span></p>
<p>Agora todos as instâncias de <code>Ponto</code> são permitidas! Você pode usar quantos
parâmetros de tipos genéricos em uma definição quanto quiser, mas usar mais que
alguns começa a tornar o código difícil de ler e entender. Se você chegar em um
ponto que precisa usar muitos tipos genéricos, é provavelmente um sinal que seu
código poderia ser reestruturado e separado em partes menores.</p>
<a class="header" href="print.html#usando-tipos-de-dados-genéricos-em-definições-de-enum" id="usando-tipos-de-dados-genéricos-em-definições-de-enum"><h3>Usando Tipos de Dados Genéricos em Definições de Enum</h3></a>
<p>Similar a structs, enums podem ser definidos para conter tipos genéricos de
dados nas suas variantes. Nós usamos o enum <code>Option&lt;T&gt;</code> concedido pela
biblioteca padrão no capítulo 6, e agora a definição deve fazer mais sentido.
Vamos dar uma outra olhada:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Option&lt;T&gt; {
    Some(T),
    None,
}
#}</code></pre></pre>
<p>Em outras palavras, <code>Option&lt;T&gt;</code> é um enum genérico do tipo <code>T</code>. Ele têm duas
variantes: <code>Some</code>, que contém o valor do tipo <code>T</code>, e uma variante <code>None</code> que
não contém nenhum valor. A biblioteca padrão tem que ter apenas essa deifinição
para suportar a criação de valores desse enum que pode conter qualquer tipo
concreto. A ideia de um &quot;um valor opcional&quot; é um conceito mais abstrato que o
de um tipo específico, e Rust nos deixa expressar esse conceito abstrato sem
muitas duplicações.</p>
<p>Enum podem usar tipos múltiplos genéricos também. A definição do enum
<code>Resultado</code> que usamos no Capítulo 9 é um exemplo:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Resultado&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
#}</code></pre></pre>
<p>O enum <code>Resultado</code> é genérico sobre dois tipos, <code>T</code> e <code>E</code>. <code>Resultado</code> tem duas
variantes: <code>Ok</code>, que contém um valor do tipo <code>T</code>, e <code>Err</code>, que contém um valor
do tipo  <code>E</code>. Essa definição faz com que seja conveniente usar o enum
<code>Resultado</code> em qualquer lugar que tenhamos uma operação que possa ser bem
sucedida (e retornar um valor de algum tipo <code>T</code>) ou falhar (e retornar um erro
de algum tipo <code>E</code>). Lembre da Listagem 9-2 quando abrimos um arquivo: naquele
caso, <code>T</code> tinha o tipo <code>std::fs::File</code> quando o arquivo era aberto com sucesso
e <code>E</code> tinha o tipo <code>std::io::Error</code> quando havia problemas em abrir o arquivo.</p>
<p>Quando você reconhece situações no seu código com structs múltiplos ou
definições de enum que diferem apenas nos tipos de valores que eles contém,
você pode remover a duplicata usando o mesmo processo usado na definição de
funções para introduzir tipos genéricos.</p>
<a class="header" href="print.html#usando-tipos-genéricos-de-dados-em-definições-de-métodos" id="usando-tipos-genéricos-de-dados-em-definições-de-métodos"><h3>Usando Tipos Genéricos de Dados em Definições de Métodos</h3></a>
<p>Como fizemos no Capítulo 5, nós podemos implementar métodos em estruturas e
enums que têm tipos genéricos em suas definições. A Listagem 10-9 mostra o
struct <code>Ponto&lt;T&gt;</code> que definimos na Listagem 10-6. Nós, então, definimos um
método chamado <code>x</code> no <code>Ponto&lt;T&gt;</code> que retorna a referência para o dado no campo
<code>x</code>:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Ponto&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Ponto&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Ponto { x: 5, y: 10 };

    println!(&quot;p.x = {}&quot;, p.x());
}
</code></pre></pre>
<p><span class="caption">Listagem 10-9: Implementando um método chamado <code>x</code> na
struct <code>Ponto&lt;T&gt;</code> que retornará uma referência para o campo <code>x</code>, que é do tipo
<code>T</code>.</span></p>
<p>Note que temos que declarar <code>T</code> logo após <code>impl</code> para usar <code>T</code> no tipo
<code>Ponto&lt;T&gt;</code>. Declarar <code>T</code> como um tipo genérico depois e <code>impl</code> é como o Rust
sabe se o tipo dentro das chaves angulares em <code>Ponto</code> é um tipo genérico ou um
tipo concreto. Por exemplo, nós poderíamos escolher implementar métodos nas
instâncias de <code>Ponto&lt;f32&gt;</code> ao invés nas de <code>Ponto</code> com qualquer tipo genérico.
A listagem 10-10 mostra que não declaramos nada depois de <code>impl</code> nesse caso, já
que estamos usanod um tipo concreto, <code>f32</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Ponto&lt;T&gt; {
#     x: T,
#     y: T,
# }
#
impl Ponto&lt;f32&gt; {
    fn distancia_da_origem(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 10-10: Construindo um bloco de <code>impl</code> que só se
aplica a uma struct com o tipo específico usado pelo parâmetro de tipo genérico
<code>T</code></span></p>
<p>Esse código significa que o tipo <code>Ponto&lt;f32&gt;</code> terá um método chamado
<code>distancia_da_origem</code>, e outras instâncias do <code>Ponto&lt;T&gt;</code> onde <code>T</code> não é do tipo
<code>f32</code> não terá esse método definido. Esse método quão longe nosso ponto está
das coordenadas (0.0, 0.0) e usa operações matemáticas que só estão disponíveis
para tipos de ponto-flutuantes.</p>
<p>Parâmetros de tipos genéricos em uma definição de struct não são sempre os
parâmetros de tipos genéricos que você quer usar na assinatura de método
daquela struct. A Listagem 10-11 define um método <code>mistura</code> na estrutura
<code>Ponto&lt;T, U&gt;</code> da Listagem 10-8. O método recebe outro <code>Ponto</code> como parâmetro,
que pode ter tipos diferentes de <code>self</code> <code>Ponto</code> dos quais usamos no <code>mistura</code>.
O método cria uma nova instância de <code>Ponto</code> que possui o valor <code>x</code> de <code>self</code>
<code>Point</code> (que é um tipo de <code>T</code>) e o valor de <code>y</code> passado de <code>Ponto</code> (que é do
tipo <code>W</code>):</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Ponto&lt;T, U&gt; {
    x: T,
    y: U,
}

impl&lt;T, U&gt; Ponto&lt;T, U&gt; {
    fn mistura&lt;V, W&gt;(self, other: Ponto&lt;V, W&gt;) -&gt; Ponto&lt;T, W&gt; {
        Ponto {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Ponto { x: 5, y: 10.4 };
    let p2 = Ponto { x: &quot;Ola&quot;, y: 'c'};

    let p3 = p1.mistura(p2);

    println!(&quot;p3.x = {}, p3.y = {}&quot;, p3.x, p3.y);
}
</code></pre></pre>
<p><span class="caption">Listagem 10-11: Métodos que usam diferentes tipos
genéricos das suas definições de struct</span></p>
<p>No <code>main</code>, nós definimos um <code>Ponto</code> que tem um <code>i32</code> para o <code>x</code> (com o valor de
<code>5</code>) e um <code>f64</code> para <code>y</code> (com o valor de <code>10.4</code>). <code>p2</code> é um <code>Ponto</code> que tem um
pedaço de string <code>x</code> (com o valor <code>&quot;Ola&quot;</code>) e um <code>char</code> para <code>y</code> (com o valor
<code>c</code>). Chamando <code>mistura</code> no <code>p1</code> com o argumento <code>p2</code> nos dá <code>p3</code>, que terá um
<code>i32</code> para <code>x</code>, já que <code>x</code> veio de <code>p1</code>. <code>p3</code> terá um <code>char</code> para <code>y</code>, já que
<code>y</code> veio de <code>p2</code>. O <code>println!</code> irá imprimir <code>p3.x = 5, p3.y = c</code>.</p>
<p>Note que os parâmetro genéricos <code>T</code> e <code>U</code> são declarados depois de <code>impl</code>, já
que eles vão com a definição do struct. Os parâmetros genéricos <code>V</code> e <code>Ẁ</code> são
declarados depois de <code>fn mistura</code>, já que elés só são relevantes para esse
método.</p>
<a class="header" href="print.html#desempenho-do-código-usando-genéricos" id="desempenho-do-código-usando-genéricos"><h3>Desempenho do Código Usando Genéricos</h3></a>
<p>Você pode estar lendo essa seção e imaginando se há um custo no tempo de
execução para usar parâmetros de tipos genéricos. Boas notícias: o modo como
Rust implementa tipos genéricos significa que seu código não vai ser executado
mais devagar do que se você tivesse especificado tipos concretos ao invés de
tipos genéricos como parâmetros!</p>
<p>Rust consegue fazer isso realizando <em>monomorfização</em> de código usando tipos
genéricos em tempo de compilação. Monomorfização é o processo de transformar
código genérico em código específico substituindo os tipos genéricos pelos
tipos concretos que são realmente utilizados.</p>
<p>O que o compilador faz é o oposto dos passos que fizemos para criar uma função
de tipo genérico na Listagem 10-5. O compilador olhar para todos os lugares que
o código genérico é chamado e gera o código para os tipos concretos que o
código genérico é chamado.</p>
<p>Vamos trabalhar sobre o exemplo que usa o padrão de enum <code>Option</code> da
biblioteca:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let inteiro = Some(5);
let float = Some(5.0);
#}</code></pre></pre>
<p>Quando o Rust compilar esse código, ele vai fazer a monomorfização. O
compilador lerá os valores que foram passados para <code>Option</code> e ver que temos
dois tipos de <code>Option&lt;T&gt;</code>: um é <code>i32</code>, e o outro <code>f64</code>. Assim sendo, ele
expandirá a definição genérica de <code>Option&lt;T&gt;</code> para <code>Option_i32</code> e <code>Option_64</code>,
substituindo a definição genérica por definições específicas.</p>
<p>A versão monomorfizada do nosso código que o compilador gera é a seguinte, com
os usos da <code>Option</code> genérica substituídos pelas definições específicas criadas
pelo compilador:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let inteiro = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
</code></pre></pre>
<p>Nós podemos escrever códigos não duplicados usando tipos genéricos, e Rust vai
compila-lo em código que especifica o tipo em cada instância. Isso significa
que não pagamos nenhum custo em tempo de processamento para usar tipos
genéricos; quando o código roda, ele executa do mesmo modo como executaria se
tivéssemos duplicado cada definição particular a mão. O proccesso de
monomorfização é o que faz os tipos genéricos de Rust serem extremamente
eficientes em tempo de processamento.</p>
<a class="header" href="print.html#traits-definindo-comportamento-compartilhado" id="traits-definindo-comportamento-compartilhado"><h2>Traits: Definindo Comportamento Compartilhado</h2></a>
<p>Traits nos permitem usar outro tipo de abstração: eles nos permitem abstrair
sobre o comportamento que tipos têm em comum. Um <em>trait</em> diz ao compilador de
Rust sobre uma funcionalidade que um tipo particular possui e pode compartilhar
com outros tipos. Em situações onde nós usamos parâmetros de tipos genéricos,
nós podemos usar <em>limites de trait</em> para especificar, em tempo de compilação,
que o tipo genérico pode ser qualquer tipo que implementa um trait e por
conseguinte tem o comportamento que queremos usar nessa situação.</p>
<blockquote>
<p>Nota: <em>Traits</em> são similares a um recurso frequentemente chamado de
'interface' em outras linguagens, com algumas diferenças.</p>
</blockquote>
<a class="header" href="print.html#definindo-um-trait" id="definindo-um-trait"><h3>Definindo um Trait</h3></a>
<p>O comportamento de um tipo consiste nos métodos que podemos chamar para aquele
tipo. Tipos diferentes dividem o mesmo comportamento se podemos chamar os
mesmos métodos em todos esses tipos. Definições de traits são um modo de
agrupar métodos de assinaturas juntos a fim de definir um conjunto de
comportamentos para atingir algum propósito.</p>
<p>Por exemplo, digamos que temos múltiplos structs que contém vários tipos e
quantidades de texto: um struct <code>ArtigoDeNoticias</code>que contém uma notícia
preenchida em um lugar do mundo, e um <code>Tweet</code> que pode ter no máximo 140
caracteres em seu conteúdo além dos metadados como se ele foi um retweet ou uma
resposta a outro tweet.</p>
<p>Nós queremos fazer uma biblioteca agregadora de mídia que pode mostrar resumos
de dados que podem estar guardados em uma instância de <code>ArtigoDeNoticia</code> ou
<code>Tweet</code>. O comportamento que precisamos cada struct possua é que seja capaz de
ser resumido, e que nós possamos pedir pelo resumo chamando um método <code>resumo</code>
em uma instância. A Listagem 10-12 mostra a definição de um trait <code>Resumir</code> que
expressa esse conceito:</p>
<p><span class="filename">Nome do arquivo: lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Resumir {
    fn resumo(&amp;self) -&gt; String;
}
#}</code></pre></pre>
<p><span class="caption">Listagem 10-12: Definição de um trait <code>Resumir</code> que
consiste no comportamento fornecido pelo método <code>resumo</code></span></p>
<p>Nós declaramos um trait com a palavra-chave <code>trait</code>, e então o nome do trait,
nesse caso <code>Resumir</code>. Dentro de chaves declaramos a assinatura do método que
descreve o comportamento que tipos que implementam esse trait precisarão ter,
nesse caso <code>fn resumo(&amp;self) -&gt; String;</code>. Depois da assinatura do método ao
invés de fornecer uma implementação dentro de chaves, nós colocamos um ponto e
vírgula. Cada tipo que implementa esse trait precisa então fornecer seu próprio
comportamento customizado para o corpo do método, mas o compilador vai reforçar
que qualquer qualquer tipo que tenha o trait <code>Resumir</code> terá o método <code>resumo</code>
definido para ele com esse exata assinatura.</p>
<p>Um trait pode ter vários métodos no seu corpo, com os métodos das assinaturas
listados um por linha e cada linha terminando com um ponto e vírgula.</p>
<a class="header" href="print.html#implementando-um-trait-em-um-tipo" id="implementando-um-trait-em-um-tipo"><h3>Implementando um Trait em um Tipo</h3></a>
<p>Agora que deifnimos o trait <code>Resumir</code>, podemos implementa-lo nos tipos do nosso
agregador de mídias que queremos que tenham esse comportamento. A Listagem
10-13 mostra uma implementação do trait <code>Resumir</code> no struct <code>ArtigoNotícia</code> que
possui o título, o autor e a localização para criar e retornar o valor de
<code>resumo</code>. Para o struct <code>Tweet</code>, nós escolhemos definir <code>resumo</code> como o nome de
usuário seguido por todo o texto do tweet, assumindo que o conteúdo do tweet já
está limitado a 140 caracteres.</p>
<p><span class="filename">Nome do arquivo: lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub trait Resumir {
#     fn summary(&amp;self) -&gt; String;
# }
#
pub struct ArtigoDeNoticia {
    pub titulo: String,
    pub local: String,
    pub autor: String,
    pub conteudo: String,
}

impl Resumir for ArtigoDeNoticia {
    fn summary(&amp;self) -&gt; String {
        format!(&quot;{}, by {} ({})&quot;, self.titulo, self.autor, self.local)
    }
}

pub struct Tweet {
    pub nomeusuario: String,
    pub conteudo: String,
    pub resposta: bool,
    pub retweet: bool,
}

impl Resumir for Tweet {
    fn summary(&amp;self) -&gt; String {
        format!(&quot;{}: {}&quot;, self.nomeusuario, self.conteudo)
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 10-13: Implementando o trait <code>Resumir</code> nos tipos
<code>ArtigoDeNoticia</code> e <code>Tweet</code></span></p>
<p>Implementar um trait em um tipo é similar a implementar métodos que não estão
relacionados com um trait. A diferença está depois de <code>impl</code>, nós colocamos o
nome do trait que queremos implementar, então dizemos <code>for</code> e o nome do tipo
que queremos implementar. Dentro do bloco <code>impl</code>, nós colocamos as assinaturas
dos métodos que a definição do trait definiu, mas ao invés de colocar um ponto
e vírgula depois de cada assinatura, nós colocamos chaves e preenchemos o corpo
do método com o comportamento específico que queremos que os métodos dos traits
tenham para um tipo particular.</p>
<p>Uma vez que implementamos o trait, nós podemos chamar os métodos nas instâncias
de <code>ArtigoDeNoticia</code> e <code>Tweet</code> da mesma maneira que nós chamamos métodos que não
são parte de um trait:</p>
<pre><code class="language-rust ignore">let tweet = Tweet {
    nomeUsuario: String::from(&quot;horse_ebooks&quot;),
    conteudo: String::from(&quot;claro, como vocês provavelmente já sabem, 
    pessoas&quot;),
    resposta: false,
    retweet: false,
};

println!(&quot;1 novo tweet: {}&quot;, tweet.summary());
</code></pre>
<p>Isso irá imprimir <code>1 novo tweet: claro, como vocês provavelmente já sabem, pessoas</code></p>
<p>Note que porque nós definimos o trait <code>Resumir</code> e os tipos <code>ArtigoDeNoticia</code> e
<code>Tweet</code> todos na mesma <code>lib.rs</code> na listagem 10-13, eles estão todos no mesmo
escopo. Se essa <code>lib.rs</code> é para um crate nós chamamos <code>agregador</code>, e se outra
pessoa quiser usar a funcionalidade do nosso crate e implementar o trait
<code>Resumir</code> na sua struct <code>PrevisaoTempo</code>, o código deles precisaria importar o
trait <code>Resumir</code> no escopo deles primeiro antes deles poderem implementá-lo,
como na Listagem 10-14:</p>
<p><span class="filename">Nome do arquivo: lib.rs</span></p>
<pre><code class="language-rust ignore">extern crate aggregator;

use aggregator::Resumir;

struct PrevisaoTempo {
    alta_temp: f64,
    baixa_temp: f64,
    chance_de_chuva: f64,
}

impl Resumir for PrevisaoTempo {
    fn resumo(&amp;self) -&gt; String {
        format!(&quot;A alta será de {}, e a baixa de {}. A chance de precipitação é
        {}%.&quot;, self.alta_temp, self.baixa_temp, self.chance_de_chuva)
    }
}
</code></pre>
<p><span class="caption">Listagem 10-14: Trazendo o trait <code>Resumir</code> do nosso crate
<code>aggregator</code> para o escopo de outro crate</span></p>
<p>Esse código também assume que <code>Resumir</code> é um trait público, o que é verdade
porque colocamos a palavra-chave <code>pub</code> antes de <code>trait</code> na Listagem 10-12.</p>
<p>Uma restrição para se prestar atenção na implementação de traits: nós podemos
implementar um trait em um tipo desde que o trait ou o tipo forem locais para o
nosso crate. Em outras palavras, nós não estamos autorizados a implementar
traits externos em tipos externos. Nós não podemos implementar o trait
<code>Display</code> em <code>Vec</code>, por exemplo, já que ambos <code>Display</code> e <code>Vec</code> são definidos na
biblioteca padrão. Nós temos a permissão de implementar traits da biblioteca
padrão como <code>Display</code> em um tipo personalizado como <code>Tweet</code> como parte da
funcionalidade do nosso crate <code>aggregator</code>, já que nós já havíamos definido
<code>Resumir</code> lá. Essa restrição é parte do que é chamado de a <em>regra do ṍrfão</em>,
qual você pode procurar se estiver interessado nesse tipo de teoria. De forma
curta, é chamada de a regra do órfão porque o tipo pai não está presente. Sem
essa regra, dois crates poderiam implementar o mesmo trait para o mesmo tipo,
e as duas implementações entrariam em conflito: o Rust não saberia qual
implementação usar. Porque o Rust impõe a regra do órfão, os códigos de outras
pessoas não podem quebrar seu código e vice e versa.</p>
<a class="header" href="print.html#implementações-padrão" id="implementações-padrão"><h3>Implementações Padrão</h3></a>
<p>As vezes é útil ter um comportamento padrão pra alguns ou todos os métodos em
um trait, ao invés de fazer toda implementação em todo tipo e definir um
comportamento personalizado. Quando implementamos o trait em um tipo
particular, nós podemos escolher manter ou sobrescrever o comportamento padrão
de cada método.</p>
<p>A Listagem 10-15 mostra como poderíamos ter escolhido especificar uma string
padrão para o método <code>resumo</code> do trait <code>Resumir</code> ao invés de escolher de apenas
definir a assinatura do método como fizemos na Listagem 10-12:</p>
<p><span class="filename">Nome do arquivo: lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Resumir {
    fn resumo(&amp;self) -&gt; String {
        String::from(&quot;(Leia mais...)&quot;)
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 10-15: Definição de um trait <code>Resumir</code> com a
implementação padrão do método <code>resumo</code></span></p>
<p>Se nós quiséssemos usar a implementação padrão para resumir as instâncias de
<code>ArtigoDeNoticia</code> ao invés de definir uma implementação personalizada como
fizemos na Listagem 10-13, nós especificaríamos um bloco <code>impl</code> vazio:</p>
<pre><code class="language-rust ignore">impl Resumir for ArtigoDeNoticia {}
</code></pre>
<p>Mesmo que não estejamos mais escolhendo definir o método <code>resumo</code> diretamente
em <code>ArtigoDeNoticia</code>, já que o método <code>resumo</code> tem uma implementação padrão e
nós especificamos que <code>ArtigoDeNoticia</code> implementa o trait <code>Resumir</code>, nós ainda
podemos chamar o método <code>resumo</code> em uma instância de <code>ArtigoDeNoticia</code>:</p>
<pre><code class="language-rust ignore">let artigo = ArtigoDeNoticia {
    titulo: String::from(&quot;Os Penguins ganham a copa do campeonato Stanley&quot;),
    lugar: String::from(&quot;Pittsburgh, PA, USA&quot;),
    autor: String::from(&quot;Iceburgh&quot;),
    conteudo: String::from(&quot;Os Penguins de Pittsburgh são novamente o melhor
    time de hockey da NHL.&quot;),
};

println!(&quot;Novo artigo disponível! {}&quot;, artigo.summary());
</code></pre>
<p>Esse código imprime <code>Novo artigo disponível! (Leia mais...)</code></p>
<p>Mudando o trait <code>Resumir</code> para ter uma implementação padrão para <code>resumo</code> não
requer que nós mudemos nada na implementação de <code>Resumir</code> em <code>Tweet</code> na
Listagem 10-13 ou em <code>PrevisaoTempo</code> na Listagem 10-14: a sintaxe para sobrepor
uma implementação padrão é exatamente a mesma de uma sintaxe para implementar
um método de trait que não tem uma implementação padrão.</p>
<p>Implementações padrões são autorizadas a chamar outros métodos no mesmo trait,
mesmo se os outros métodos não tiverem uma implementação padrão. Desse modo, um
trait pode prover muitas funcionalidades úteis e apenas requerir implementações
para especificar uma pequena parte dele. Nós poderíamos escolher que o trait
<code>Resumir</code> também tivesse o método <code>resumo_autor</code> qual a implementação é
necessária, então um método <code>resumo</code> que tem a implementação padrão que chama
pelo método <code>resumo_autor</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Resumir {
    fn resumo_autor(&amp;self) -&gt; String;

    fn resumo(&amp;self) -&gt; String {
        format!(&quot;(Leia mais de {}...)&quot;, self.resumo_autor())
    }
}
#}</code></pre></pre>
<p>Para usar essa versão de <code>Resumir</code>, nós só precisamos definir <code>resumo_autor</code>
quando nós implementamos o trait em um tipo:</p>
<pre><code class="language-rust ignore">impl Resumir for Tweet {
    fn autor_resumo(&amp;self) -&gt; String {
        format!(&quot;@{}&quot;, self.nomeusuario)
    }
}
</code></pre>
<p>Uma vez que definimos <code>resumo_autor</code>, nós podemos chamar <code>resumo</code> em instâncias
do struct <code>Tweet</code>, e a implementação padrão de <code>resumo</code> chamará a definição de
<code>resumo_autor</code> que fornecemos.</p>
<pre><code class="language-rust ignore">let tweet = Tweet {
    nomeusuario: String::from(&quot;horse_ebooks&quot;),
    conteudo: String::from(&quot;claro, como vocês provavelmente já sabem, 
    pessoas&quot;),
    resposta: false,
    retweet: false,
};

println!(&quot;1 novo tweet: {}&quot;, tweet.resumo());
</code></pre>
<p>Isso irá imprimir <code>1 novo tweet: (Leia mais de @horse_ebooks...)</code>.</p>
<p>Note que não é possível chamar a implementação padrão de uma implementação
primordial.</p>
<a class="header" href="print.html#limites-de-traits" id="limites-de-traits"><h3>Limites de traits</h3></a>
<p>Agora que definimos traits e os implementamos em tipos, podemos usar traits com
parâmetros de tipos genéricos. Podemos restringir tipos genéricos para que ao
invés de serem qualquer tipo, o compilador tenha certeza que o tipo estará
limitado a aqueles tipos que implementam um trait em particular e por
consequência tenham o comportamento que precisamos que os tipos tenham. Isso é
chamado de especificar os <em>limites dos traits</em> em um tipo genérico.</p>
<p>Por exemplo, na Listagem 10-13, nós implementamos o trait <code>Resumir</code> nos tipos
<code>ArtigoDeNoticia</code> e <code>Tweet</code>. Nós podemos definir uma função <code>notificar</code> que chama
o método <code>resumo</code> no seu parâmetro <code>item</code>, que é do tipo genérico <code>T</code>. Para
ser possível chamar <code>resumo</code> em <code>item</code> sem receber um erro, podemos usar os
limites de traits em <code>T</code> para especificar que <code>item</code> precisa ser de um tipo que
implementa o trait <code>Resumir</code>:</p>
<pre><code class="language-rust ignore">pub fn notificar&lt;T: Resumir&gt;(item: T) {
    println!(&quot;Notícias de última hora! {}&quot;, item.resumo());
}
</code></pre>
<p>Limites de traits vão juntos com a declaração de um parâmetro de tipo genérico,
depois de uma vírgula e entre colchetes angulares. Por causa do limite de trait
em  <code>T</code>, nós podemos chamar <code>notificar</code> e passar qualquer instância de
<code>ArtigoDeNoticia</code> ou <code>Tweet</code>. O código externo da Listagem 10-14 que está
usando nosso crate <code>aggregator</code> pode chamar nossa função <code>notificar</code> e passar
uma instância de <code>PrevisaoTempo</code>, já que <code>Resumir</code> é implementado para
<code>PrevisaoTempo</code> também. O código que chama <code>notificar</code> com qualquer outro tipo,
como uma <code>String</code> ou um <code>i32</code>, não compilará, já que esses tipos não
implementam <code>Resumir</code>.</p>
<p>Nós podemos especificar múltiplos limites de traits em um tipo genérico usando
<code>+</code>. Se nós precisássemos ser capazes de usar mostrar formatação no tipo <code>T</code> em
uma função assim como no método <code>resumo</code>, nós podemos usar os limites de trait
<code>T: Resumir + Mostrar</code>. Isso signifca que <code>T</code> pode ser qualquer tipo que
implemente ambos <code>Resumir</code> e <code>Mostrar</code>.</p>
<p>Para funções que têm múltiplos parâmetros de tipos genéricos, cada tipo
genérico tem seu próprio limite de trait. Especificar muitas informações de
limites de trait dentro de chaves angulares entre o nome de uma função e sua
lista de parâmetros pode tornar o código difícil de ler, então há uma sintaxe
alternativa para especificar limites de traits que nos permite movê-los para
uma cláusula depois da assinatura da função. Então ao invés de:</p>
<pre><code class="language-rust ignore">fn alguma_funcao&lt;T: Mostrar + Clone, U: Clone + Debug&gt;(t: T, u: U) -&gt; i32 {
</code></pre>
<p>Nós podemos escrever isso com uma cláusula de <code>where</code>:</p>
<pre><code class="language-rust ignore">fn alguma_funcao&lt;T, U&gt;(t: T, u: U) -&gt; i32
    where T: Display + Clone,
          U: Clone + Debug
{
</code></pre>
<p>Isso é menos confuso e faz a assinatura da função ficar mais parecida à uma
função sem ter vários limites de trait, nela o nome da função, a lista de
parâmetros, e o tipo de retorno estão mais próximos.</p>
<a class="header" href="print.html#consertando-a-função-maior-com-limites-de-traits" id="consertando-a-função-maior-com-limites-de-traits"><h3>Consertando a Função <code>maior</code> com Limites de Traits</h3></a>
<p>Então qualquer hora que você queira usar um comportamento definido por um trait
em um tipo genérico, você precisa especificar aquele trait nos limites dos
parâmetros dos tipos genéricos. Agora podemos consertar a definição da função
<code>maior</code> que usa um parâmetro de tipo genérico da Listagem 10-5! Quando deixamos
esse código de lado, nós recebemos esse erro:</p>
<pre><code class="language-text">error[E0369]: binary operation `&gt;` cannot be applied to type `T`
  |
5 |         if item &gt; maior {
  |            ^^^^
  |
note: an implementation of `std::cmp::PartialOrd` might be missing for `T`
</code></pre>
<p>No corpo de <code>maior</code> nós queríamos ser capazes de comparar dois valores de tipo
<code>T</code> usando o operador maior-que. Esse operador é definido com o método padrão
na biblioteca padrão de trait <code>std::cmp::PartialOrd</code>. Então para que possamos
usar o operador maior-que, precisamos especificar <code>PartialOrd</code> nos limites do
trait  para <code>T</code> para que a função <code>maior</code> funcione em partes de qualquer tipo
que possa ser comparada. Não precisamos trazer <code>PartialOrd</code> para o escopo
porque está no prelúdio.</p>
<pre><code class="language-rust ignore">fn maior&lt;T: PartialOrd&gt;(list: &amp;[T]) -&gt; T {
</code></pre>
<p>Se tentarmos compilar isso, receberemos diferentes erros:</p>
<pre><code class="language-text">error[E0508]: cannot move out of type `[T]`, a non-copy array
 --&gt; src/main.rs:4:23
  |
4 |     let mut maior = list[0];
  |         -----------   ^^^^^^^ cannot move out of here
  |         |
  |         hint: to prevent move, use `ref maior` or `ref mut maior`

error[E0507]: cannot move out of borrowed content
 --&gt; src/main.rs:6:9
  |
6 |     for &amp;item in list.iter() {
  |         ^----
  |         ||
  |         |hint: to prevent move, use `ref item` or `ref mut item`
  |         cannot move out of borrowed content
</code></pre>
<p>A chave para esse erro é <code>cannot move out of type [T], a non-copy array</code>. Com
nossas versões não genéricas da função <code>maior</code>, nós estávamos apenas tentando
encontrar o maior <code>i32</code> ou <code>char</code>. Como discutimos no Capítulo 4, tipos como o
<code>i32</code> e <code>char</code> que têm um tamanho conhecido podem ser armazenados na pilha,
então eles implementam o trait <code>Copia</code>. Quando mudamos a função <code>maior</code> para
ser genérica, agora é possível que o parâmetro <code>list</code> poderia ter tipos nele
que não implementam o trait <code>Copia</code>, o que significa que não seríamos capazes
de mover o valor para fora de <code>list[0]</code> para a variável <code>maior</code>.</p>
<p>Se quisermos ser capazes de chamar esse código com tipos que são <code>Copia</code>, nós
podemos adicionar <code>Copia</code> para os limites de trait de <code>T</code>! A Listagem 10-16
mostra o código completo de uma função <code>maior</code> genérica que compilará desde que
os tipos dos valores nessa parte que passamos para <code>maior</code> implementem ambos os
traits <code>PartialOrd</code> e <code>Copia</code>, como <code>i32</code> e <code>char</code>:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn maior&lt;T: PartialOrd + Copy&gt;(list: &amp;[T]) -&gt; T {
    let mut maior = list[0];

    for &amp;item in list.iter() {
        if item &gt; maior {
            maior = item;
        }
    }

    maior
}

fn main() {
    let lista_numero = vec![34, 50, 25, 100, 65];

    let result = maior(&amp;lista_numero);
    println!(&quot;O maior número é {}&quot;, result);

    let lista_char = vec!['y', 'm', 'a', 'q'];

    let result = maior(&amp;lista_char);
    println!(&quot;O maior char é {}&quot;, result);
}
</code></pre></pre>
<p><span class="caption">Listagem 10-16: Uma definição funcional da função <code>maior</code>
que funciona em qualquer tipo genérico que implementa os traits <code>PartialOrd</code> e
<code>Copia</code></span></p>
<p>Se não quisermos restringir nossa função <code>maior</code> para apenas tipos que
implementam o trait <code>Copia</code>, podemos especificar que <code>T</code> tem o limite de trait
<code>Clone</code> ao invés de <code>Copia</code> e clonar cada valor na parte quando quisermos que a
função <code>maior</code> tenha domínio. Usando a função <code>clone</code> significa que
potencialmente estamos fazendo mais alocações no heap, porém, e alocações no
heap podem ser vagarosas se estivermos trabalhando com grande quantidade de
dados. Outro jeito que podemos implementar <code>maior</code> é para a função retornar uma
referência ao valor de <code>T</code> em uma parte. Se retornarmos o tipo de retorno para
ser <code>&amp;T</code> ao invés de <code>T</code> e mudar o corpo da função para retornar uma
referência, não precisaríamos usar os limites de traits <code>Clone</code> ou <code>Copia</code> e
nós não estaríamos fazendo nenhuma alocação de heap.
Tente implementar essas soluções alternativas você mesmo!</p>
<a class="header" href="print.html#usando-limites-de-trait-para-implementar-métodos-condicionalmente" id="usando-limites-de-trait-para-implementar-métodos-condicionalmente"><h3>Usando Limites de Trait para Implementar Métodos Condicionalmente</h3></a>
<p>Usando um limite de trait com um bloco <code>impl</code> que usa parâmetros de tipos
genéricos podemos implementar métodos condicionalmente apenas para tipos que
implementam os traits específicos. Por exemplo, o tipo <code>Par&lt;T&gt;</code> na listagem
10-17 sempre implementa o método <code>novo</code>, mas <code>Par&lt;T&gt;</code> implementa apenas o
<code>cmp_display</code> se seu tipo interno <code>T</code> implementa o trait <code>PartialOrd</code> que
permite a comparação e do trait <code>Display</code> que permite a impressão:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fmt::Display;

struct Par&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Par&lt;T&gt; {
    fn novo(x: T, y: T) -&gt; Self {
        Self {
            x,
            y,
        }
    }
}

impl&lt;T: Display + PartialOrd&gt; Par&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!(&quot;O maior membro é x = {}&quot;, self.x);
        } else {
            println!(&quot;O maior membro é y = {}&quot;, self.y);
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 10-17: Implementa métodos condicionalmente em um
tipo genérico dependendo dos limites de trait</span></p>
<p>Podemos também condicionalmente implementar um trait para qualquer tipo que
implementa um trait. Implementações de trait de qualquer tipo que satisfazem os
limites de trait são chamadas de <em>implementações cobertores</em>, e são
extesivamente utilizadas na biblioteca padrão de Rust. Por exemplo, a
biblioteca padrão implementa o trait <code>Display</code>. Esse bloco <code>impl</code> se parece com
este código:</p>
<pre><code class="language-rust ignore">impl&lt;T: Display&gt; ToString for T {
    // --snip--
}
</code></pre>
<p>Porque a biblioteca padrão tem essa implementação cobertor, podemos chamar
o método <code>to_string</code> definido pelo tipo <code>ToString</code> em qualquer tipo que
implemente o trait <code>Display</code>. Por exemplo, nós podemos transformar inteiros em
seus correspondentes valores de <code>String</code> do seguinte modo, já que inteiros
implementam <code>Display</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = 3.to_string();
#}</code></pre></pre>
<p>Implementações cobertor aparecem na documentação para traits na seção
&quot;Implementadores&quot;.</p>
<p>Traits e limites de traits nos deixam escrever código que usam parâmetros de
tipos genéricos para reduzir a duplicação, mas ainda sim especificam para o
compilador exatamente qual o comportamento que nosso código precisa que o tipo
genérico tenha. Porque demos a informação do limite de trait para o compilador,
ele pode checar que todos os tipos concretos usados no nosso código
proporcionam o comportamento correto. Em linguagens dinamicamente tipadas, se
nós tentássemos chamar um método em um tipo que não implementamos, nós
receberíamos um erro em tempo de execução. O Rust move esses erros para o temp
de compilação para que possamos ser forçados a resolver os problemas antes que
nosso código seja capaz de rodar. Além disso, nós não temos que escrever código
que checa o comportamento em tempo de execução já que já checamos em tempo de
compilação, o que melhora o desempenho comparado com outras linguagens sem ter
que abrir mão da flexibilidade de tipos genéricos.</p>
<p>Há outro tipo de tipos genéricos que estamos usando sem nem ao menos perceber
chamados <em>lifetimes</em>. Em vez de nos ajudar a garantir que um tipo tenha o
comportamento que precisamos, lifetimes nos ajudam a garantir que as
referências são válidas tanto quanto precisam ser. Vamos aprender como
lifetimes fazem isso.</p>
<a class="header" href="print.html#validating-references-with-lifetimes" id="validating-references-with-lifetimes"><h2>Validating References with Lifetimes</h2></a>
<p>Quandos falamos sobre referêcias no Capítulo 4, nós deixamos de fora um detalhe
importante: toda referência em Rust tem um <em>lifetime</em>, que é o escopo no qual
aquela referência é válida. A maior parte das vezes tempos de vida são implícitos e
inferidos, assim como a maior parte do tempo tipos são inferidos. Similarmente
quando temos que anotar tipos porque múltiplos tipos são possíveis, há casos em
que os tempos de vida das referências poderiam estar relacionados de alguns modos
diferentes, então Rust precisa que nós anotemos as relações usando parâmetros
genéricos de tempo de vida para que ele tenha certeza que as referênciais reais
usadas em tempo de execução serão definitivamente válidas.</p>
<p>Sim, é um pouco incomum, e será diferente de ferramentas que você usou em
outras linguagens de programação. Tempos de vida são, de alguns jeitos, a
característica mais distinta de Rust.</p>
<p>Tempos de vida são um tópico grande que não poderão ser cobertos inteiramente
nesse capítulo, então nós vamos cobrir algumas formas comuns que você pode
encontrar a sintaxe de tempo de vida nesse capítulo para que você se
familiarize com os conceitos. O Capítulo 19 conterá informações mais avançadas
sobre tudo que tempos de vida podem fazer.</p>
<a class="header" href="print.html#tempos-de-vida-previnem-referências-soltas" id="tempos-de-vida-previnem-referências-soltas"><h3>Tempos de Vida Previnem Referências Soltas</h3></a>
<p>O principal alvo de lifetimes é prevenir referências soltas, quais fazem com
que o programa referencie dados quais nós não estamos querendo referenciar.
Considere o programa na Listagem 10-18, com um escopo exterior e um interior.
O escopo exterior declara uma variável chamada <code>r</code> com nenhum valor inicial, e
o escopo interior declara uma variável chamada <code>x</code> com o valor inicial de 5.
Dentro do escopo interior, nós tentamos estabelecer o valor de <code>r</code> como uma
referência para <code>x</code>. Então, o escopo interior acaba, e nós tentamos imprimir o
valor de <code>r</code>:</p>
<pre><code class="language-rust ignore">{
    let r;

    {
        let x = 5;
        r = &amp;x;
    }

    println!(&quot;r: {}&quot;, r);
}
</code></pre>
<p><span class="caption">Listagem 10-18: Uma tentativa de usar uma refência cujo
valor saiu de escopo</span></p>
<blockquote>
<a class="header" href="print.html#variáveis-não-inicializadas-não-podem-ser-usadas" id="variáveis-não-inicializadas-não-podem-ser-usadas"><h4>Variáveis Não Inicializadas Não Podem Ser Usadas</h4></a>
<p>Os próximos exemplos declaram vaŕiáveis sem darem a elas um valor inicial,
então o nome da variável existe no escopo exterior. Isso pode parecer um
conflito com Rust não ter null. No entanto, se tentarmos usar uma variável
antes de atribuir um valor a ela, nós teremos um erro em tempo de compilação.
Tente!</p>
</blockquote>
<p>Quando compilarmos esse código, nós teremos um erro:</p>
<pre><code class="language-text">error: `x` does not live long enough
   |
6  |         r = &amp;x;
   |              - borrow occurs here
7  |     }
   |     ^ `x` dropped here while still borrowed
...
10 | }
   | - borrowed value needs to live until here
</code></pre>
<p>A variável <code>x</code> não &quot;vive o suficiente&quot;. Por que não? Bem, <code>x</code> vai sair de
escopo quando passarmos pela chaves na linha 7, terminando o escopo interior.
Mas <code>r</code> é válida para o escopo exterior; seu escopo é maior e dizemos que ela
&quot;vive mais tempo&quot;. Se Rust permitisse que esse código funcionasse, <code>r</code> estaria
fazendo uma referência à memória que foi desalocada quando <code>x</code> saiu de escopo,
e qualquer coisa que tentássemos fazer com <code>r</code> não funcionaria corretamente.
Então como o Rust determina que esse código não deve ser permitido?</p>
<a class="header" href="print.html#o-verificador-de-empréstimos" id="o-verificador-de-empréstimos"><h4>O Verificador de Empréstimos</h4></a>
<p>A parte do compilador chamada de <em>verificador de empréstimos</em> compara escopos
para determinar que todos os empréstimos são válidos. A Listagem 10-19 mostra o
mesmo exemplo da Listagem 10-18 com anotações mostrando os tempos de vida das
variáveis.</p>
<pre><code class="language-rust ignore">{
    let r;         // -------+-- 'a
                   //        |
    {              //        |
        let x = 5; // -+-----+-- 'b
        r = &amp;x;    //  |     |
    }              // -+     |
                   //        |
    println!(&quot;r: {}&quot;, r); // |
                   //        |
                   // -------+
}
</code></pre>
<p><span class="caption">Listagem 10-19: Anotações de tempos de vida de <code>r</code> e <code>x</code>,
chamadas de <code>a</code> e <code>b</code> respectivamente</span></p>
<p>Nós anotamos o tempo de vida de <code>r</code> com <code>a</code> e o tempo de vida de <code>x</code> com <code>b</code>.
Como você pode ver, o bloco interior de <code>'b</code> é bem menor que o bloco de tempo
de vida do exterior <code>'a'</code>. Em tempo de compilação, o Rust compara o tamanho dos
dois tempos de vida e vê que <code>r</code> tem um tempo de vida de <code>'a</code>, mas que ele se
refere a um objeto com um tempo de vida <code>'b</code>. O programa é rejeitado porque o
tempo de vida de <code>'b</code> é mais curto que o tempo de vida de <code>'a</code>: o sujeito da
referência não vive tanto quanto a referência.</p>
<p>Vamos olhar para o exemplo na Listagem 10-20 que não tenta fazer uma referência
solta e compila sem nenhum erro:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    let x = 5;            // -----+-- 'b
                          //      |
    let r = &amp;x;           // --+--+-- 'a
                          //   |  |
    println!(&quot;r: {}&quot;, r); //   |  |
                          // --+  |
}                         // -----+
#}</code></pre></pre>
<p><span class="caption">Listagem 10-20: Uma referência válida porque os dados têm
um tempo de vida maior do que o da referência</span></p>
<p>Aqui, <code>x</code> tem o tempo de vida de <code>'b</code>, que nesse caso tem um tempo de vida
maior que o de <code>'a</code>. Isso quer dizer que <code>r</code> pode referenciar <code>x</code>: o Rust sabe
que a referência em <code>r</code> será sempre válida enquanto <code>x</code> for válido.</p>
<p>Agora que mostramos onde os tempos de vida de referências estão em um exemplo
concreto e discutimos como Rust analisa tempos de vida para garantir que
referências sempre serão válidas, vamos falar sobre tempos de vidas genéricos
de parâmetros e retornar valores no contexto das funções.</p>
<a class="header" href="print.html#tempos-de-vida-génericos-em-funções" id="tempos-de-vida-génericos-em-funções"><h3>Tempos de Vida Génericos em Funções</h3></a>
<p>Vamos escrever uma função que retornará a mais longa de dois cortes de string.
Nós queremos ser capazes de chamar essa função passando para ela dois cortes
de strings, e queremos que retorne uma string. O código na Listagem 10-21
deve imprimir <code>A string mais longa é abcd</code> uma vez que tivermos implementado a
função <code>maior</code>:</p>
<p><span class="filename">Nome do Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let string1 = String::from(&quot;abcd&quot;);
    let string2 = &quot;xyz&quot;;

    let resultado = maior(string1.as_str(), string2);
    println!(&quot;A string mais longa é {}&quot;, resultado);
}
</code></pre>
<p><span class="caption">Listagem 10-21: Uma função <code>main</code> que chama pela função
<code>maior</code> para achar a mais longa entre duas strings</span></p>
<p>Note que queremos que a função pegue cortes de string (que são referências,
como falamos no Capítulo 4) já que não queremos que a função <code>maior</code> tome posse
de seus argumentos. Nós queremos que uma função seja capaz de aceitar cortes de
uma <code>String</code> (que é o tipo de variável <code>string1</code>) assim como literais de string
(que é o que a variável <code>strin2</code> contém).</p>
<p>Recorra à seção do Capítulo 4 &quot;Cortes de Strings como Parâmetros&quot; para mais
discussões sobre porque esses são os argumentos que queremos.</p>
<p>Se tentarmos implementar a função <code>maior</code> como mostrado na Listagem 10-22 ela
não vai compilar:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn maior(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre>
<p><span class="caption">Listagem 10-22: Uma implementação da função <code>maior</code> que
retorna o mais longo de dois cortes de string, mas ele não compila ainda</span></p>
<p>Ao invés disso recebemos o seguinte erro que fala sobre tempos de vida:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
   |
1  | fn maior(x: &amp;str, y: &amp;str) -&gt; &amp;str {
   |                                 ^ expected lifetime parameter
   |
   = help: this function's return type contains a borrowed value, but the
   signature does not say whether it is borrowed from `x` or `y`
</code></pre>
<p>O texto de ajuda está nos dizendo que o tipo de retorno precisa de um parâmetro
de tempo de vida genérico nele porque o Rust não pode dizer se a referência que
está sendo retornada se refere a <code>x</code> ou <code>y</code>. Atualmente, nós também não
sabemos, já que o bloco <code>if</code> no corpo dessa função retorna uma referência para
<code>x</code> e o bloco <code>else</code> retorna uma referência para <code>y</code>!</p>
<p>Enquanto estamos definindo essa função, não sabemos os valores concretos que
serão passados para essa função, então não sabemos se o caso <code>if</code> ou o caso
<code>else</code> será executado. Nós também não sabemos os tempos de vida concretos das
referências que serão passadas, então não podemos olhar para esses escopos como
fizemos nas Listagem 10-19 e 10-20 afim de determinar que a referência que
retornaremos sempre será válida. O verificador de empréstimos não consegue
determinar isso também porque não sabe como os tempos de vida de <code>x</code> e <code>y</code> se
relacionam com o tempo de vida do valor de retorno. Nós vamos adicionar
parâmetros genéricos de tempo de vida que definirão a relação entre as
referências para que o verificador de empréstimos possa fazer sua análise.</p>
<a class="header" href="print.html#sintaxe-de-anotação-de-tempo-de-vida" id="sintaxe-de-anotação-de-tempo-de-vida"><h3>Sintaxe de Anotação de Tempo de Vida</h3></a>
<p>Anotações de tempo de vida não mudam quanto tempo qualquer uma das referências
envolvidas viverão. Do mesmo modo que funções podem aceitar qualquer tipo de
assinatura que especifica um parâmetro de tipo genérico, funções podem aceitar
referências com qualquer tempo de vida quando a assinatura especificar um
parâmetro genérico de tempo de vida. O que anotações de tempo de vida fazem é
relacionar os tempos de vida de múltiplas referências uns com os outros.</p>
<p>Anotações de tempo de vida tem uma sintaxe levemente incomum: os nomes dos
parâmetros de tempos de vida precisam começar com uma apóstrofe <code>'</code>. Os nomes
dos parâmetros dos tempos de vida são usualmente todos em caixa baixa, e como
tipos genéricos, seu nome usualmente são bem curtos. <code>'a</code> é o nome que a maior
parte das pessoas usam por padrão. Parâmetros de anotações de tempos de vida
vão depois do <code>&amp;</code> de uma referência, e um espaço separa a anotação de tempo de
vida do tipo da referência.</p>
<p>Aqui vão alguns exemplos: nós temos uma referência para um <code>i32</code> sem um
parâmetro tempo de vida, uma referência para um <code>i32</code> que tem um parâmetro de
tempo de vida chamado <code>'a</code>:</p>
<pre><code class="language-rust ignore">&amp;i32        // uma referência
&amp;'a i32     // uma referência com um tempo de vida explícito
&amp;'a mut i32 // uma referência mutável com um tempo de vida explícito
</code></pre>
<p>Uma anotação de tempo de vida por si só não tem muito significado: anotações de
tempos de vida dizem ao Rust como os parâmetros genéricos de tempos de vida de
múltiplas referências se relacionam uns com os outros. Se tivermos uma função
com o parâmetro <code>primeiro</code> que é uma referência para um <code>i32</code> que tem um tempo
de vida de <code>'a</code>, e a função tem outro parâmetro chamado <code>segundo</code> que é outra
referência para um <code>i32</code> que também possui um tempo de vida <code>'a</code>, essas duas
anotações de tempo de vida com o mesmo nome indicam que as referências
<code>primeiro</code> e <code>segundo</code> precisam ambas viver tanto quanto o mesmo tempo de vida
genérico.</p>
<a class="header" href="print.html#anotações-de-tempo-de-vida-em-assinaturas-de-funções" id="anotações-de-tempo-de-vida-em-assinaturas-de-funções"><h3>Anotações de Tempo de Vida em Assinaturas de Funções</h3></a>
<p>Vamos olhar para anotações de tempo de vida no contexto da função <code>maior</code> que
estamos trabalhando. Assim como parâmetros de tipos genéricos, parâmetros de
tempos de vida genéricos precisam ser declarados dentro de colchetes angulares
entre o nome da função e a lista de parâmetros. A limitanção que queremos
dar ao Rust é que para as referências nos parâmetros e o valor de retorno devem
ter o mesmo tempo de vida, o qual nomearemos <code>'a</code> e adicionaremos para cada uma
das referências como mostrado na Listagem 10-23:</p>
<p><span class="filename">Nome do Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn maior&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 10-23: A definição da função <code>maior</code> especifica
todas as referências na assinatura como tendo o mesmo tempo de vida, <code>'a</code></span></p>
<p>Isso compilará e produzirá o resultado que queremos quando usada com a função
<code>main</code> na Listagem 10-21.</p>
<p>A assinatura de função agora diz que pra algum tempo de vida <code>'a</code>, a função
receberá dois parâmetros, ambos serão cortes de string que vivem pelo menos
tanto quanto o tempo de vida <code>'a</code>. A função retornará um corte de string que
também vai durar tanto quanto o tempo de vida <code>'a</code>. Esse é o contrato que
estamos dizendo ao Rust que queremos garantir.</p>
<p>Especificando os parâmetros de tempo de vida nessa assinatura de função, não
estamos modificando os tempos de vida de quaisquer valores passados ou
retornados, mas estamos dizendo que quaisqueres valores que não concordem com
esse contrato devem ser rejeitados pelo verificador de empréstimos. Essa função
não sabe (ou não precisa saber) exatamente quanto tempo <code>x</code> e <code>y</code> vão viver,
apenas precisa saber que existe algum escopo que pode ser substituído por <code>'a</code>
que irá satisfazer essa assinatura.</p>
<p>Quando estiver anotando tempos de vidas em funções, as anotações vão na
assinatura da função, e não no código no corpo da função. Isso acontece porque
o Rust consegue analisar o código dentro da função sem nenhuma ajuda, mas
quando uma função tem referências para ou de códigos de fora daquela função,
os tempos de vida dos argumentos ou os valores de retorno poderão ser
diferentes cada vez que a função é chamada. Isso seria incrivelmente custoso e
frequentemente impossível para o Rust descobrir. Nesse caso, precisamos anotar
os tempos de vida nós mesmos.</p>
<p>Quando referências concretas são passadas para <code>maior</code>, o tempo de vida
concreto que é substituído por <code>'a</code> é a parte do escopo de <code>x</code> que sobrepõe o
escopo de <code>y</code>. Já que escopos sempre se aninham, outra maneira de dizer isso é
que o tempo de vida genérico <code>'a</code> terá um tempo de vida concreto igual ao menor
dos tempos de vida de <code>x</code> e <code>y</code>. Porque nós anotamos a referência retornada com
o mesmo parâmetro <code>'a</code>, a referência retornada será portanto garantida de ser
válida tanto quanto for o tempo de vida mais curto de <code>x</code> e <code>y</code>.</p>
<p>Vamos ver como isso restringe o uso da função <code>maior</code> passando referências que
tem diferentes tempos de vida concretos. A Listagem 10-25 é um exemplo direto
que deve corresponder suas intuições de qualquer linguagem: <code>string1</code> é válida
até o final do escopo exterior, <code>strin2</code> é válida até o final do escopo, a
<code>string2</code> é válida até o final do escopo interior. Com o verificador de
empréstimos aprovando esse código; ele vai compilar e imprimir
<code>A string mais longa é</code>:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn maior&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
#     if x.len() &gt; y.len() {
#         x
#     } else {
#         y
#     }
# }
#
fn main() {
    let string1 = String::from(&quot;a string longa é longa&quot;);

    {
        let string2 = String::from(&quot;xyz&quot;);
        let resultado = maior(string1.as_str(), string2.as_str());
        println!(&quot;A string mais longa é {}&quot;, resultado);
    }
}
</code></pre></pre>
<p><span class="caption">Listagem 10-24: Usando a função <code>maior</code> com referências
para valores de <code>String</code> que tem tempos de vida concretos diferentes</span></p>
<p>Em seguida, vamos tentar um exemplo que vai mostrar que o tempo de vida da
referência em <code>resultado</code> precisa ser o menor dos tempos de vida dos dois
argumentos. Nós vamos mover a declaração da variável <code>resultado</code> para fora do
escopo interior, mas deixar a atribuição do valor para a variável <code>resultado</code>
dentro do escopo com <code>string2</code>. Em seguida, vamos mover o <code>println!</code> que usa o
<code>resultado</code> fora do escopo interior, depois que ele terminou. O código na
Listagem 10-25 não compilará:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let string1 = String::from(&quot;a string longa é longa&quot;);
    let resultado;
    {
        let string2 = String::from(&quot;xyz&quot;);
        resultado = longest(string1.as_str(), string2.as_str());
    }
    println!(&quot;A string mais longa é {}&quot;, resultado);
}
</code></pre>
<p><span class="caption">Listagem 10-25: A tentativa de usar <code>resultado</code> depois
que <code>string2</code> saiu de escopo não compilará</span></p>
<p>Se tentarmos compilar isso, receberemos esse erro:</p>
<pre><code class="language-text">error: `string2` does not live long enough
   |
6  |         resultadod = longest(string1.as_str(), string2.as_str());
   |                                            ------- borrow occurs here
7  |     }
   |     ^ `string2` dropped here while still borrowed
8  |     println!(&quot;The longest string is {}&quot;, result);
9  | }
   | - borrowed value needs to live until here
</code></pre>
<p>O erro está dizendo que para <code>resultado</code> ser válido para <code>println!</code>, a
<code>string2</code> teria que ser válida até o final do escopo exterior. Rust sabe disso
porque nós anotamos os tempos de vida dos parâmetros da função e retornamos
valores com o mesmo parâmetro do tempo de vida, <code>'a</code>.</p>
<p>Nós podemos olhar para esse código como humanos e ver que a <code>string1</code> é mais
longa, e portanto <code>resultado</code> conterá a referência para a <code>string1</code>. Porque a
<code>string1</code> não saiu de escopo ainda, a referência para <code>string1</code> ainda será
válida para o <code>println!</code>. No entanto, o que dissemos ao Rust com os parâmetros
de tempo de vida é que o tempo de vida da referência retornado pela função
<code>maior</code> é o mesmo que o menor dos tempos de vida das referências passadas.
Portanto, o verificador de empréstimos não permite o código da Listagem 10-25
como possível já que tem um referência inválida.</p>
<p>Tente fazer mais alguns experimentos que variam os valores e os tempos de vidas
das referências passadas para a função <code>maior</code> e como a referência retornada é
usada. Crie hipóteses sobre seus experimentos se eles vão passar pelo
verificador de empréstimos ou não antes de você compilar, e então cheque para
ver se você está certo!</p>
<a class="header" href="print.html#pensando-em-termos-de-tempos-de-vida" id="pensando-em-termos-de-tempos-de-vida"><h3>Pensando em Termos de Tempos de Vida</h3></a>
<p>O modo exato de especificar parâmetros de tempos de vida depende do que sua
função está fazendo. Por exemplo, se mudaramos a implementação da função
<code>maior</code> para sempre retornar o primeiro argumento ao invés do corte de string
mais longo, não precisaríamos especificar um tempo de vida no parâmetro <code>y</code>.
Este código compila:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;'a str {
    x
}
#}</code></pre></pre>
<p>Nesse exemplo, especificamos o tempo de vida do parâmetro <code>'a</code> para o parâmetro
<code>x</code> e o tipo de retorno, mas, não para o parâmetro <code>y</code>, já que o tempo de vida
de <code>y</code> não tem qualquer relação com o tempo de vida <code>x</code> ou o valor retornado.</p>
<p>Quando retornarmos uma referência de um uma função, o parâmetro de tempo de
vida para o tipo de retorno precisa combinar o parâmetro do tempo de vida de um
dos argumentos. Se a referência retornada <em>não</em> refere a nenhum dos argumentos,
a única outra possibilidade é que refira a um valor criado dentro da função, o
que seria uma referência solta já que o valor sairá de escopo no fim da função.
Considere essa tentativa da função <code>maior</code> que não compilará:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn maior&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
    let resultado = String::from(&quot;string muito longa&quot;);
    resultado.as_str()
}
</code></pre>
<p>Mesmo especificando um parâmetro de tempo de vida <code>'a</code> para o tipo de retorno,
essa implementação falha em compilar porque o valor de retorno do tempo de vida
não é relacionado com o tempo de vida dos parâmetros de forma alguma. Esta é a
mensagem de erro que recebemos:</p>
<pre><code class="language-text">error: `resultado` does not live long enough
  |
3 |     resultado.as_str()
  |     ^^^^^^ does not live long enough
4 | }
  | - borrowed value only lives until here
  |
note: borrowed value must be valid for the lifetime 'a as defined on the block
at 1:44...
  |
1 | fn maior&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
  |                                             ^
</code></pre>
<p>O problema é que <code>resultado</code> sairá de escopo e será limpo no final da função
<code>maior</code>, e estamos tentando retornar uma referência para <code>resultado</code> da função.
Não há nenhum modo que possamos especificar parâmetros de tempo de vida que
mudariam uma referência solta, e o Rust não nos deixará criar uma referência
solta. Nesse caso, a melhor solução seria retornar um tipo de dado com posse
ao invés de uma referência de modo que a função chamadora é então responsável
por limpar o valor.</p>
<p>Em última análise, a sintaxe de tempo de vida é sobre conectar tempos de vida
de vários argumentos e retornar valores de funções. Uma vez que estão
conectados, o Rust tem informação o suficiente para permitir operações seguras
de memória e não permitir operações que criariam ponteiros soltos ou outro tipo
de violação à segurança da memória.</p>
<a class="header" href="print.html#anotações-de-tempo-de-vida-em-definições-de-struct" id="anotações-de-tempo-de-vida-em-definições-de-struct"><h3>Anotações de Tempo de Vida em Definições de Struct</h3></a>
<p>Até agora, nós só definimos structs para conter tipos com posse. É possível
para structs manter referências, mas precisamos adicionar anotações de tempo de
vida em todas as referências na definição do struct. A Listagem 10-26 tem a
struct chamada <code>ExcertoImportante</code> que contém um corte de string:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct ExcertoImportante&lt;'a&gt; {
    parte: &amp;'a str,
}

fn main() {
    let romance = String::from(&quot;Chame-me Ishmael. Há alguns anos...&quot;);
    let primeira_sentenca = romance.split('.')
        .next()
        .expect(&quot;Não pôde achar um '.'&quot;);
    let i = ImportantExcerpt { parte: primeira_sentenca };
}
</code></pre></pre>
<p><span class="caption">Listagem 10-26: Um struct que contém uma referência,
então sua definição precisa de uma anotação de tempo de vida</span></p>
<p>Esse struct tem um campo, <code>parte</code>, que contém um corte de string, que é uma
referência. Assim como tipos genéricos de dados, temos que declarar o nome do
parâmetro genérico de tempo de vida dentro de colchetes angulares depois do
nome do struct para que possamos usar o parâmetro de tempo de vida no corpo da
definição do struct.</p>
<p>A função <code>main</code> cria uma instância da struct <code>ExcertoImportante</code> que contém uma
referência pra a primeira sentença da <code>String</code> com posse da variável <code>romance</code>.</p>
<a class="header" href="print.html#elisão-de-tempo-de-vida" id="elisão-de-tempo-de-vida"><h3>Elisão de Tempo de Vida</h3></a>
<p>Nessa seção, nós aprendemos que toda referência tem um tempo de vida, e nós
precisamos especificar os parâmetros dos tempos de vida para funções ou
estruturas que usam referências. No entanto, no Capítulo 4 nós tínhamos a
função na seção &quot;Cortes de Strings&quot;, mostradas novamente na Listagem 10-27, que
compilam sem anotações de tempo de vida:</p>
<p><span class="filename">Nome do arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn primeira_palavra(s: &amp;str) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
#}</code></pre></pre>
<p><span class="caption">Listagem 10-27: Uma função definida no Capítulo 4 que
compila sem anotações de tempo de vida, mesmo o parâmetro e o tipo de retorno
sendo referências</span></p>
<p>A razão pela qual essa função compila sem anotações de tempo de vida é
histórica: em versões mais antigas de pre Rust-1.0, isso não teria compilado.
Toda referência precisava de um tempo de vida explícito. Naquele tempo, a
assinatura da função teria sido escrita da seguinte forma:</p>
<pre><code class="language-rust ignore">fn primeira_palavra&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
</code></pre>
<p>Depois de escrever muito código em Rust, o time de Rust descobriu que os
programadores de Rust estavam digitando as mesmas anotações de tempo de vida
de novo e de novo. Essas situações eram previsíveis e seguiam alguns padrões
determinísticos. O time de Rust programou esses padrões no compilador de código
de Rust para que o verificador de empréstimos pode inferir os tempos de vida
dessas situações sem forçar o programador adicionar essas anotações
explicitamente.</p>
<p>Nós mencionamos essa parte da história de Rust porque é inteiramente possível
que mais padrões determinísticos surgirão e serão adicionado ao compilador. No
futuro, até menos anotações de tempo de vida serão necessárias.</p>
<p>Os padrões programados nas análises de referência de Rust são chamados de
<em>regras de elisão de tempo de vida</em>. Essas não são regras para o programador
seguir; as regras são um conjunto de casos particular que o compilador irá
considerar, e se seu código se encaixa nesses casos, você não precisa escrever
os tempos de vida explicitamente.</p>
<p>As regras de elisão não fornecem total inferência:  se o Rust aplicar as regras
de forma determinística ainda podem haver ambiguidades como quais tempos
de vida as referências restantes deveriam ter. Nesse caso, o compilador dará um
erro que pode ser solucionado adicionando anotações de tempo de vida que
correspondem com as suas intenções para como as referências se relacionam umas
com as outras.</p>
<p>Primeiro, algumas definições: Tempos de vida em parâmetros de funções ou
métodos são chamadas <em>tempos de vida de entrada</em>, e tempos de vida em valores
de retorno são chamados de <em>tempos de vida de saída</em>.</p>
<p>Agora, as regras que o compilador usa para descobrir quais referências de
tempos de vidas têm quando não há anotações explícitas. A primeira regra se
aplica a tempos de vida de entrada, e a segunda regra se aplica a tempos de
vida de saída. Se o compilador chega no fim das três regras e ainda há
referências que ele não consegue descobrir tempos de vida, o compilador irá
parar com um erro.</p>
<ol>
<li>
<p>Cada parâmetro que é uma referência tem seu próprio parâmetro de tempo de
vida. Em outras palavras, uma função com um parâmetro tem um parâmetro de
tempo de vida: <code>fn foo&lt;'a&gt;(x: &amp;'a i32)</code>, uma função com dois argumentos
recebe dois parâmetros de tempo de vida separados:
<code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)</code>, e assim por diante.</p>
</li>
<li>
<p>Se há exatamente uma entrada de parâmetro de tempo de vida, aquele tempo de
vida é atribuído para todos os parâmetros de saída do tempo de vida:
<code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code>.</p>
</li>
<li>
<p>Se há múltiplas entradas de parâmetros de tempo de vida, mas uma delas é
<code>&amp;self</code> ou <code>&amp;mut self</code> porque é um método, então o tempo de vida de <code>self</code> é
atribuído para todos os parâmetro de tempo de vida de saída. Isso melhora a
escrita de métodos</p>
</li>
</ol>
<p>Vamos fingir que somos o compilador e aplicamos essas regras para descobrir
quais os tempos de vida das referências na assinatura da função
<code>primeira_palavra</code> na Listagem 10-27. A assinatura começa sem nenhum tempo de
vida associado com as referências:</p>
<pre><code class="language-rust ignore">fn primeira_palavra(s: &amp;str) -&gt; &amp;str {
</code></pre>
<p>Então nós (como o compilador) aplicamos a primeira regra, que diz que cada
parâmetro tem sem próprio tempo de vida. Nós vamos chama-lo de <code>'a</code> como é
usual, então agora a assinatura é:</p>
<pre><code class="language-rust ignore">fn primeira_palavra&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;str {
</code></pre>
<p>À segunda regra, que se aplica porque existe apenas um tempo de vida. A
segunda regra diz que o tempo de vida de um parâmetro de entrada é atribuído
a um tempo de vida de saída, então agora a assinatura é:</p>
<pre><code class="language-rust ignore">fn primeira_palavra&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
</code></pre>
<p>Agora todas as referências nessa assinatura de função possuem tempos de vida, e
o compilador pode continuar sua análise sem precisar que o programador anote os
tempos de vida na assinatura dessa função.</p>
<p>Vamos fazer outro exemplo, dessa vez com a função <code>maior</code> que não tinha
parâmetros de tempo de vida quando começamos a trabalhar com ela na Listagem
10-22:</p>
<pre><code class="language-rust ignore">fn maior(x: &amp;str, y: &amp;str) -&gt; &amp;str {
</code></pre>
<p>Fingindo que somos o compilador novamente, vamos aplicar a primeira regra: cada
parâmetro tem seu próprio tempo de vida. Dessa vez temos dois parâmetros, então
temos dois tempos de vida:</p>
<pre><code class="language-rust ignore">fn maior&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;str {
</code></pre>
<p>Olhando para a segunda regra, ela não se aplica já que há mais de uma entrada
de tempo de vida. Olhando para a terceira regra, ela também não se aplica
porque isso é uma função e não um método, então nenhum dos parâmetros são
<code>self</code>. Então, acabaram as regras, mas não descobrimos qual é o tempo de vida
do tipo de retorno. É por isso que recebemos um erro quando tentamos
compilar o código da Listagem 10-22: o compilador usou as regras de elisão de
tempo de vida que sabia, mas ainda sim não conseguiu descobrir todos os tempos
de vida das referências na assinatura.</p>
<p>Porque a terceira regra só se aplica em assinaturas de métodos, vamos olhar
tempos de vida nesse contexto agora, e ver porque a terceira regra significa
que não temos que anotar tempos de vida em assinaturas de métodos muito
frequentemente.</p>
<a class="header" href="print.html#anotações-de-tempo-de-vida-em-definições-de-métodos" id="anotações-de-tempo-de-vida-em-definições-de-métodos"><h3>Anotações de Tempo de Vida em Definições de Métodos</h3></a>
<p>Quando implementamos métodos em uma struct com tempos de vida, a sintaxe é
novamente a mesma da de parâmetros de tipos genéricos que mostramos na Listagem
10-11: o lugar que parâmetros de tempos de vida são declarados e usados depende
se o parâmetro de tempo de vida é relacionado aos campos do struct ou aos
argumentos dos métodos e dos valores de retorno.</p>
<p>Nomes de tempos de vida para campos de estruturas sempre precisam ser
declarados após a palavra-chave <code>impl</code> e então usadas após o nome da struct,
já que esses tempos de vida são partes do tipo da struct.</p>
<p>Em assinaturas de métodos dentro do bloco <code>impl</code>, as referências podem estar
amarradas às referências de tempo de vida nos campos de struct, ou elas podem
ser independentes. Além disso, as regras de elisão de tempo de vida
constantemente fazem com que anotações não sejam necessárias em assinaturas de
métodos. Vamos ver alguns exemplos usando a struct chamada <code>ExcertoImportante</code>
que definimos na Listagem 10-26.</p>
<p>Primeiro, aqui há um método chamado <code>level</code>. O único parâmetro é uma referência
para <code>self</code>, e o valor de retorno é apenas um <code>i32</code>, não uma referência para
nada:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct ExcertoImportante&lt;'a&gt; {
#     part: &amp;'a str,
# }
#
impl&lt;'a&gt; ExcertoImportante&lt;'a&gt; {
    fn level(&amp;self) -&gt; i32 {
        3
    }
}
#}</code></pre></pre>
<p>A declaração do parâmetro de tempo de vida depois de <code>impl</code> e uso depois do
tipo de nome é obrigatório, mas nós não necessariamente precisamos de anotar o
tempo de vida da referência <code>self</code> por causa da primeira regra da elisão.</p>
<p>Aqui vai um exemplo onde a terceira regra da elisão de tempo de vida se aplica:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct ExcertoImportante&lt;'a&gt; {
#     part: &amp;'a str,
# }
#
impl&lt;'a&gt; ExcertoImportante&lt;'a&gt; {
    fn anuncio_e_parte_de_retorno(&amp;self, anuncio: &amp;str) -&gt; &amp;str {
        println!(&quot;Atenção por favor: {}&quot;, anuncio);
        self.part
    }
}
#}</code></pre></pre>
<p>Há dois tempos de vida de entrada, então o Rust aplica a primeira regra de
elisão de tempos de vida e dá ambos ao <code>&amp;self</code> e ao <code>anuncio</code> seus próprios
tempos de vida. Então, porque um dos parâmetros é <code>self</code>, o tipo de retorno
tem o tempo de vida de <code>&amp;self</code> e todos os tempos de vida foram contabilizados.</p>
<a class="header" href="print.html#o-tempo-de-vida-estático" id="o-tempo-de-vida-estático"><h3>O Tempo de Vida Estático</h3></a>
<p>Há <em>um</em> tipo especial de tempo de vida que precisamos discutir: <code>'static</code>. O
tempo de vida <code>static</code> é a duração completa do programa. Todos os literais de
string têm um tempo de vida <code>static</code>, o qual podemos escolher anotar como o
seguinte:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s: &amp;'static str = &quot;Eu tenho um tempo de vida estático.&quot;;
#}</code></pre></pre>
<p>O texto dessa string é guardado diretamente no binário do seu programa e o
binário do seu programa está sempre disponível. Logo, o tempo de vida de todas
as literais de string é <code>'static</code>.</p>
<p>Você pode ver sugestões de usar o tempo de vida <code>'static</code> em uma mensagem de
ajuda de erro, mas antes de especificar <code>'static</code> como o tempo de vida para uma
referência, pense sobre se a referência que você tem é uma que vive todo o
tempo de vida do seu programa ou não (ou mesmo se você quer que ele viva tanto,
se poderia). Na maior parte do tempo, o probléma no código é uma tentativa de
criar uma referência solta ou uma incompatibilidade dos tempos de vida
disponíveis, e a solução é consertar esses problemas, não especificar um tempo
de vida <code>'static</code>.</p>
<a class="header" href="print.html#parâmetros-de-tipos-genéricos-limites-de-trais-e-tempos-de-vida-juntos" id="parâmetros-de-tipos-genéricos-limites-de-trais-e-tempos-de-vida-juntos"><h3>Parâmetros de Tipos Genéricos, Limites de Trais e Tempos de Vida Juntos</h3></a>
<p>Vamos rapidamente olhar para a sintaxe de especificar parâmetros de tipos
genéricos, limites de traits e tempos de vida todos em uma função!</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fmt::Display;

fn maior_com_um_anuncio&lt;'a, T&gt;(x: &amp;'a str, y: &amp;'a str, ann: T) -&gt; &amp;'a str
    where T: Display
{
    println!(&quot;Anúncio! {}&quot;, ann);
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
#}</code></pre></pre>
<p>Essa é a função <code>maior</code> da Listagem 10-23 que retorna a maior de dois cortes de
string, mas com um argumento extra chamado <code>ann</code>. O tipo de <code>ann</code> é o tipo
genérico <code>T</code>, que pode ser preenchido por qualquer tipo que implemente o trait
<code>Display</code> como está especificado na cláusula <code>where</code>. Esse argumento extra será
impresso antes da função comparar os comprimentos dos cortes de string, que é
porque o trait de <code>Display</code> possui um limite. Porque tempos de vida são um tipo
genérico, a declaração de ambos os parâmetros de tempo de vida <code>'a</code> e o tipo
genérico <code>T</code> vão na mesma lista com chaves angulares depois do nome da função.</p>
<a class="header" href="print.html#sumário-1" id="sumário-1"><h2>Sumário</h2></a>
<p>Nós cobrimos várias coisas nesse capítulo! Agora que você sabe sobre parâmetros
de tipos genéricos, traits e limites de traits, e parâmetros genéricos de tempo
de vida, você está pronto para escrever código que não é duplicado mas pode ser
usado em muitas situações. Parâmetros de tipos genéricos significam que o
código pode ser aplicado a diferentes tipos. Traits e limites de traits
garantem que mesmo que os tipos sejam genéricos, esses tipos terão o
comportamento que o código precisa. Relações entre tempos de vida de
referências especificadas por anotações de tempo de vida garantem que esse
código flexível não terá referências soltas. E tudo isso acontece em tempo de
compilação para que a performace em tempo de execução não seja afetada!</p>
<p>Acredite ou não, há ainda mais para aprender nessas áreas: Capítulo 17
discutirá objetos de trait, que são outro modo de usar traits. O Capútulo 19
vai cobrir cenários mais complexos envolvendo anotações de tempo de vida. O
Capítulo 20 vai tratar de alguns tipos avançados de características do sistema.
Em seguida, porém, vamos falar sobre como escrever testes em Rust para que
possamos ter certeza que nosso código usando todas essas características está
funcionando do jeito que queremos!</p>
<a class="header" href="print.html#testing" id="testing"><h1>Testing</h1></a>
<a class="header" href="print.html#writing-tests" id="writing-tests"><h1>Writing tests</h1></a>
<a class="header" href="print.html#running-tests" id="running-tests"><h1>Running tests</h1></a>
<a class="header" href="print.html#test-organization" id="test-organization"><h1>Test Organization</h1></a>
<a class="header" href="print.html#um-projeto-de-es-criando-um-programa-de-linha-de-comando" id="um-projeto-de-es-criando-um-programa-de-linha-de-comando"><h1>Um projeto de E/S: Criando um Programa de Linha de Comando</h1></a>
<p>Este capítulo é um recapitulação de muitas habilidades que você aprendeu até agora e uma
exploração de mais alguns recursos da biblioteca padrão. Vamos construir uma
ferramenta que interage com arquivo de entrada/saída em linha de comando para praticar alguns dos
conceitos de Rust que você tem a disposição.</p>
<p>A velocidade, a segurança, a saída <em>binary-único</em> e o suporte multi-plataforma de Rust
fazem dela uma linguagem ideal para a criação de ferramentas de linha de comando. Assim,
para nosso projeto, criaremos nossa própria versão da ferramenta clássica de linha de comando <code>grep</code>
(<strong>g</strong>lobally search a <strong>r</strong>egular <strong>e</strong>xpression and <strong>p</strong>rint). No caso de uso mais simples,
o <code>grep</code> procura um arquivo especificado para uma string especificada. Para fazer isso, o <code>grep</code>
toma como argumento um nome de arquivo e uma string, e então lê o arquivo e localiza linhas naquele
arquivo que contém o argumento string. Em seguida, imprime essas linhas.</p>
<p>Ao longo do caminho, mostraremos como fazer com que nossa ferramenta de linha de comando use recursos do
terminal que muitas ferramentas de linha de comando usam. Leremos o valor de uma
variável de ambiente para permitir ao usuário configurar o comportamento de nossa ferramenta.
Também imprimiremos na saída de console de erro padrão (<code>stderr</code>) em vez da
saída padrão (<code>stdout</code>), por exemplo, o usuário pode redirecionar saída de sucesso
para um arquivo enquanto ainda está vendo mensagens de erro na tela.</p>
<p>Um membro da comunidade One Rust, Andrew Gallant, já criou uma versão completa
, e muito rápida do <code>grep</code>, chamada <code>ripgrep</code>. Em comparação, nossa
versão do <code>grep</code> será bastante simples, mas este capítulo lhe dará alguns dos
conhecimento básicos que você precisa para entender um projeto real como
<code>ripgrep</code>.</p>
<p>Nosso projeto <code>grep</code> combinará uma série de conceitos que você aprendeu até agora:</p>
<ul>
<li>Organizar código (usando o que aprendeu em módulos, Capítulo 7)</li>
<li>Usando vetores e strings (coleções, Capítulo 8)</li>
<li>Erros de manipulação (Capítulo 9)</li>
<li>Usando traits e lifetimes, quando apropriado (Capítulo 10)</li>
<li>Escrevendo testes (Capítulo 11)</li>
</ul>
<p>Também apresentamos brevemente closures, iterações e trait objects, que
os capítulos 13 e 17 abordarão em detalhes.</p>
<a class="header" href="print.html#aceitando-argumentos-em-linha-de-comando" id="aceitando-argumentos-em-linha-de-comando"><h2>Aceitando Argumentos em Linha de Comando</h2></a>
<p>Vamos criar um novo projeto usando, como sempre, <code>cargo new</code>. Chamaremos o nosso projeto
<code>minigrep</code> para distingui-lo da ferramenta<code>grep</code> que você já pode ter
no seu sistema.</p>
<pre><code class="language-text">$ cargo new --bin minigrep
     Created binary (application) `minigrep` project
$ cd minigrep
</code></pre>
<p>A primeira tarefa é fazer que <code>minigrep</code> aceite seus dois argumentos de linha de comando: o
nome de arquivo e uma string para procurar. Ou seja, queremos ser capazes de administrar o nosso
programa com <code>cargo run</code>, uma string para procurar e um caminho para um arquivo onde será feira a
procura, dessa forma:</p>
<pre><code class="language-text">$ cargo run searchstring example-filename.txt
</code></pre>
<p>Neste momento, o programa gerado por <code>cargo new</code> não pode processar os argumentos que nós
passamos. No entanto, algumas bibliotecas existentes no <a href="https://crates.io/">Crates.io</a>
que podem  nos ajudar a escrever um programa que aceite argumentos na linha de comando, mas
como você está aprendendo esses conceitos, vamos implementar essa capacidade
nós mesmos.</p>
<a class="header" href="print.html#lendo-os-valores-do-argumento" id="lendo-os-valores-do-argumento"><h3>Lendo os Valores do Argumento</h3></a>
<p>Para garantir que <code>minigrep</code> seja capaz de ler os valores dos argumentos da linha de comando, nós
precisamos de uma função fornecida na biblioteca padrão do Rust, que é
<code>std::env::args</code>. Esta função retorna um <em>iterador</em> da linha de comando
com os argumentos que foram passados à <code>minigrep</code>. Ainda não discutimos iteradores
(nós os cobrimos totalmente no Capítulo 13), mas por enquanto você só precisa saber dois
detalhes sobre iteradores: os iteradores produzem uma série de valores, e podemos chamar
a função <code>collect</code> em um iterador para transformá-lo em uma coleção, como um
vetor, contendo todos os elementos que o iterador produz.</p>
<p>Use o código na Listagem 12-1 para permitir que seu programa <code>minigrep</code> leia qualquer
argumento da linha de comando passados para ele e depois colete os valores em um vetor:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    println!(&quot;{:?}&quot;, args);
}
</code></pre></pre>
<p><span class="caption">Listagem 12-1: Coletando os argumentos da linha de comando
um vetor e imprimindo-os</span></p>
<p>Primeiro, trazemos o módulo <code>std::env</code> para o escopo com uma declaração <code>use</code>, então nós
podemos usar a função <code>args</code>. Observe que a função <code>std::env::args</code> é
aninhada em dois níveis de módulos. Como discutimos no Capítulo 7, nos casos em que
a função desejada está aninhada em mais de um módulo, é convenção
trazer o módulo pai para o escopo em vez da função. Como resultado, nós
podemos facilmente usar outras funções de <code>std::env</code>. Também é menos ambíguo que
adicionar <code>use std::env::args</code> e depois chamando a função com apenas <code>args</code>
porque <code>args</code> pode ser facilmente confundido com uma função definida no
módulo atual.</p>
<blockquote>
<a class="header" href="print.html#a-função-args-e-unicode-inválido" id="a-função-args-e-unicode-inválido"><h3>A Função <code>args</code> e Unicode Inválido</h3></a>
<p>Note que <code>std::env::args</code> emitirá pânico se algum argumento contiver código
Unicode inválido. Se o seu programa precisar aceitar argumentos que sejam
Unicode inválidos , use <code>std::env::args_os</code> em vez disso. Essa função retorna valores <code>OsString</code>
em vez de valores <code>String</code>. Nós escolhemos usar <code>std::env::args</code> aqui
por simplicidade, porque os valores de <code>OsString</code> diferem por plataforma e são mais
complexo para trabalhar do que os valores de <code>String</code>.</p>
</blockquote>
<p>Na primeira linha do <code>main</code>, chamamos <code>env::args</code>, e usamos <code>collect</code> imediatamente
para transformar o iterador em um vetor contendo todos os valores produzidos pelo
iterador. Podemos usar a função <code>collect</code> para criar muitos tipos de
coleções, então nós explicitamente anotamos o tipo de <code>args</code> para especificar que nós
queremos um vetor de strings. Embora raramente precisemos anotar tipos em
Rust, <code>collect</code> é uma função que muitas vezes você precisa anotar, porque Rust
não é capaz de inferir o tipo de coleção que deseja.</p>
<p>Finalmente, imprimimos o vetor usando o formatador de debug, <code>:?</code>. Vamos tentar executar
o código sem argumentos e depois com dois argumentos:</p>
<pre><code class="language-text">$ cargo run
--snip--
[&quot;target/debug/minigrep&quot;]

$ cargo run needle haystack
--snip--
[&quot;target/debug/minigrep&quot;, &quot;needle&quot;, &quot;haystack&quot;]
</code></pre>
<p>Observe que o primeiro valor no vetor é <code>&quot;target/debug/minigrep&quot;</code>, que
é o nome do nosso binário. Isso corresponde ao comportamento da lista de argumentos em
C, permitindo que os programas usem o nome pelo qual eles foram invocados em sua execução.
Geralmente, é conveniente ter acesso ao nome do programa, caso desejemos imprimi-lo em mensagens ou
alterar o comportamento do programa com base no alias da linha de comando que foi usado
para chamar o programa. Mas, para os fins deste capítulo, vamos ignorá-lo e salvar apenas
os dois argumentos que precisamos.</p>
<a class="header" href="print.html#salvando-os-valores-do-argumento-em-variáveis" id="salvando-os-valores-do-argumento-em-variáveis"><h3>Salvando os Valores do Argumento em Variáveis</h3></a>
<p>Imprimir o valor do vetor de argumentos ilustra que o programa é
capaz de acessar os valores especificados como argumentos da linha de comando. Agora precisamos
salvar os valores dos dois argumentos nas variáveis para que possamos usar esses valores
durante o resto do programa. Fazemos isso na Listagem 12-2:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let query = &amp;args[1];
    let filename = &amp;args[2];

    println!(&quot;Searching for {}&quot;, query);
    println!(&quot;In file {}&quot;, filename);
}
</code></pre></pre>
<p><span class="caption">Listagem 12-2: Criando variáveis para guardar o argumento de consulta
e argumento do nome do arquivo</span></p>
<p>Como vimos quando imprimimos o vetor, o nome do programa ocupa o primeiro
valor no vetor em <code>args[0]</code>, então estamos começando no índice <code>1</code>. O primeiro
argumento <code>minigrep</code> é a string que estamos procurando, então colocamos uma
referência ao primeiro argumento na variável <code>query</code>. O segundo argumento
será o nome do arquivo, então colocamos uma referência ao segundo argumento no
variável <code>filename</code>.</p>
<p>Imprimimos temporariamente os valores dessas variáveis para provar que o código funciona
como pretendemos. Vamos executar este programa novamente com os argumentos <code>test</code>
e <code>sample.txt</code>:</p>
<pre><code class="language-text">$ cargo run test sample.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep test sample.txt`
Searching for test
In file sample.txt
</code></pre>
<p>Ótimo, o programa está funcionando! Os valores dos argumentos que precisamos estão sendo
salvos nas variáveis certas. Mais tarde, adicionaremos algum tratamento de erro para lidar
com certas situações errôneas potenciais, como quando o usuário não fornece
argumentos; por enquanto, ignoraremos essa situação, e trabalharemos na adição das
funcinalidades de leitura dos arquivos.</p>
<a class="header" href="print.html#lendo-um-arquivo" id="lendo-um-arquivo"><h2>Lendo um Arquivo</h2></a>
<p>Agora vamos adicionar funcionalidades para ler o arquivo que é especificado no
argumento <code>filename</code> da linha de comando. Primeiro, precisamos de um arquivo de amostra para testá-lo:
o melhor tipo de arquivo a ser usado para garantir que o <code>minigrep</code> esteja funcionando é um ,com uma
pequena quantidade de texto, em várias linhas com algumas palavras repetidas. Listagem 12-3
tem um poema de Emily Dickinson que funcionará bem! Crie um arquivo chamado
<em>poem.txt</em> no diretório raiz do seu projeto e entre com o poema “I’m Nobody!
Who are you?”</p>
<p><span class="filename">Arquivo: poem.txt</span></p>
<pre><code class="language-text">I’m nobody! Who are you?
Are you nobody, too?
Then there’s a pair of us — don’t tell!
They’d banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p><span class="caption">Listagem 12-3: Um poema de Emily Dickinson fará um bom
caso de teste.</span></p>
<p>Com o texto no lugar, edite <em>src/main.rs</em> e adicione o código para abrir o arquivo, como
mostrado na Listagem 12-4:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::env;
use std::fs::File;
use std::io::prelude::*;

fn main() {
#     let args: Vec&lt;String&gt; = env::args().collect();
#
#     let query = &amp;args[1];
#     let filename = &amp;args[2];
#
#     println!(&quot;Searching for {}&quot;, query);
    // --snip--
    println!(&quot;In file {}&quot;, filename);

    let mut f = File::open(filename).expect(&quot;file not found&quot;);

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents)
        .expect(&quot;something went wrong reading the file&quot;);

    println!(&quot;With text:\n{}&quot;, contents);
}
</code></pre></pre>
<p><span class="caption">Listagem 12-4: Leitura do conteúdo do arquivo especificado
pelo segundo argumento</span></p>
<p>Primeiro, adicionamos mais instruções <code>use</code> para trazer partes relevantes da
biblioteca padrão: precisamos de <code>std::fs::File</code> para lidar com arquivos, e
<code>std::io::prelude::*</code> contém vários traits úteis para fazer E/S, incluindo
arquivo de E/S. Da mesma forma que Rust tem um prelúdio geral que traz certos
tipos e funções no escopo automaticamente, o módulo <code>std::io</code> possui o seu próprio
prelúdio de tipos e funções comuns que você precisará ao trabalhar com E/S. Ao contrário
do prelúdio padrão, devemos adicionar explicitamente uma instrução <code>use</code> para o prelúdio
de <code>std::io</code>.</p>
<p>Em <code>main</code>, adicionamos três declarações: primeiro, recebemos um identificador mutável para o
arquivo chamando a função <code>File::open</code> e transmitindo o valor da
variável <code>filename</code>. Em segundo lugar, criamos uma variável chamada <code>contents</code> e configuramos
para uma <code>String</code> mutável e vazia. Isso manterá o conteúdo do arquivo depois que nós
lê-lo. Terceiro, chamamos <code>read_to_string</code> no nosso arquivo e passamos um
referência mutável para <code>contents</code> como argumento.</p>
<p>Após essas linhas, adicionamos novamente uma declaração temporária <code>println!</code> que
imprime o valor do <code>contents</code> depois que o arquivo é lido, para que possamos verificar que o
o programa está funcionando até o momento.</p>
<p>Vamos executar este código com qualquer string como o primeiro argumento da linha de comando (porque
ainda não implementamos a parte de pesquisa) e o arquivo <em>poem.txt</em> como o
segundo argumento:</p>
<pre><code class="language-text">$ cargo run the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
I’m nobody! Who are you?
Are you nobody, too?
Then there’s a pair of us — don’t tell!
They’d banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p>Ótimo! O código lê e, em seguida, imprime o conteúdo do arquivo. Mas o código tem
algumas falhas. A função <code>main</code> tem múltiplas responsabilidades: geralmente,
as funções são mais claras e fáceis de manter se cada função for responsável
por apenas uma idéia. O outro problema é que também não estamos lidando com erros,
como poderíam ser. O programa ainda é pequeno, então essas falhas não são um grande problema,
mas à medida que o programa cresce, será mais difícil consertá-los de forma elegante. É uma boa
pratica começar a refatoração no início do desenvolvimento de um programa, porque são
muito mais fáceis de refatorar quantidades menores de código. Vamos fazer isso depois.</p>
<a class="header" href="print.html#refatoração-para-melhorar-a-modularidade-e-o-tratamento-de-erros" id="refatoração-para-melhorar-a-modularidade-e-o-tratamento-de-erros"><h2>Refatoração para Melhorar a Modularidade e o Tratamento de Erros</h2></a>
<p>Para melhorar o nosso programa, repararemos quatro problemas que têm a ver com a
estrutura do programa e como ele está tratando possíveis erros.</p>
<p>Primeiro, a nossa função <code>main</code> agora executa duas tarefas: analisa argumentos e
abre arquivos. Para uma função tão pequena, este não é um grande problema. No entanto, se
continuamos a desenvolver o nosso programa dentro de <code>main</code>, o número de tarefas separadas que
a função <code>main</code> manipula aumentarão. Com uma função ganhando responsabilidades,
torna-se mais difícil de raciocinar, mais difícil de testar e mais difícil de mudar
sem quebrar uma das suas partes. É melhor separar a funcionalidade para que cada
função seja responsável por uma tarefa.</p>
<p>Esta questão também se liga ao segundo problema: embora <code>query</code> e <code>filename</code>
sejam variáveis de configuração para o nosso programa, variáveis como <code>f</code> e <code>contents</code>
são usadas para executar a lógica do programa. Quanto maior o <code>main</code> se torna, mais
variáveis precisamos trazer no escopo; quanto mais variáveis temos no escopo,
mais difícil será acompanhar o objetivo de cada uma. É melhor agrupar
as variáveis de configuração em uma estrutura para tornar claro seu objetivo.</p>
<p>O terceiro problema é que usamos <code>expect</code> para imprimir uma mensagem de erro, ao
abrir um arquivo, falha, mas a mensagem de erro apenas imprime <code>file not found</code>.
Abrir um arquivo pode falhar de várias maneiras, além do arquivo faltando: como
exemplo, o arquivo pode existir, mas talvez não possamos ter permissão para abri-lo.
Agora, se estivermos nessa situação, imprimiríamos a mensagem de erro <code>file not found</code>
que daria ao usuário a informação errada!</p>
<p>O quarto problema, usamos <code>expect</code> repetidamente para lidar com diferentes erros, e se o usuário
executa o nosso programa sem especificar argumentos suficientes, eles terão erros <code>index out of bounds</code> do Rust, que não explica claramente o problema. Seria
melhor se todo o código de tratamento de erros estiver em um só lugar para futuros mantenedores
terem apenas um lugar para consultar, no código, se a lógica de tratamento de erros precisar de
mudança. Ter todo o código de tratamento de erros em um só lugar também assegurará que
estamos imprimindo mensagens que serão significativas para nossos usuários finais.</p>
<p>Vamos abordar esses quatro problemas refatorando nosso projeto.</p>
<a class="header" href="print.html#separação-de-responsabilidades-para-projetos-binários" id="separação-de-responsabilidades-para-projetos-binários"><h3>Separação de Responsabilidades para Projetos Binários</h3></a>
<p>O problema organizacional da atribuição de responsabilidade por múltiplas tarefas para
a função <code>main</code> é comum a muitos projetos binários. Como resultado, a comunidade Rust
desenvolveu um tipo de processo de orientação para dividir as
responsabilidades de um programa binário quando <code>main</code> começa a ficar grande. O processo tem
as seguintes etapas:</p>
<ul>
<li>
<p>Divida seu programa em um <em>main.rs</em> e um <em>lib.rs</em>, e mova a lógica
do seu programa para <em>lib.rs</em>.</p>
</li>
<li>
<p>Enquanto sua lógica de análise de linha de comando é pequena, ela pode permanecer em <em>main.rs</em>.</p>
</li>
<li>
<p>Quando a lógica de análise de linha de comando começa a ficar complicada, extraia
de <em>main.rs</em> e mova para <em>lib.rs</em>.</p>
</li>
<li>
<p>As responsabilidades que permanecem na função <code>main</code> depois desse processo
deve estar limitado a:</p>
<ul>
<li>Chamar a lógica de análise de linha de comando com os valores do argumento</li>
<li>Ajustar qualquer outra configuração</li>
<li>Chamando uma função <code>run</code> em <em>lib.rs</em></li>
<li>Manipulação do erro se <code>run</code> retornar um erro</li>
</ul>
</li>
</ul>
<p>Esse padrão é sobre separar responsabilidades: <em>main.rs</em> lida com a execução do
programa e <em>lib.rs</em> lida com toda a lógica da tarefa em questão. Porque nós
não podemos testar diretamente a função <code>main</code>, esta estrutura nos permite testar toda
lógica do programa, movendo-a para funções em <em>lib.rs</em>. O único código que
permanece em <em>main.rs</em> será pequeno o suficiente para verificar se está correto com
uma leitura rápida. Vamos retrabalhar o nosso programa seguindo este processo.</p>
<a class="header" href="print.html#extraindo-o-parseador-de-argumento" id="extraindo-o-parseador-de-argumento"><h4>Extraindo o Parseador de Argumento</h4></a>
<p>Vamos extrair a funcionalidade de análise de argumentos de <code>main</code> para <em>src/lib.rs</em>.
A listagem 12-5 mostra o novo início do <code>main</code> que chama uma nova
função <code>parse_config</code>, que iremos definir em <em>src/main.rs</em> por enquanto.</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let (query, filename) = parse_config(&amp;args);

    // --snip--
}

fn parse_config(args: &amp;[String]) -&gt; (&amp;str, &amp;str) {
    let query = &amp;args[1];
    let filename = &amp;args[2];

    (query, filename)
}
</code></pre>
<p><span class="caption">Listagem 12-5: Extraindo uma função <code>parse_config</code> de
<code>main</code></span></p>
<p>Ainda estamos coletando os argumentos da linha de comando em um vetor, mas em vez de
atribuir o valor do argumento no índice <code>1</code> para a variável <code>query</code> e o
valor do argumento no índice <code>2</code> para a variável <code>filename</code> dentro da função <code>main</code>
, passamos todo o vetor para a função <code>parse_config</code>. A
função <code>parse_config</code> mantém a lógica que determina qual argumento
vai em qual variável e passa os valores de volta para <code>main</code>. Ainda criamos
as variáveis <code>query</code> e <code>filename</code> no <code>main</code>, mas <code>main</code> não tem mais a
responsabilidade de determinar como os argumentos e as variáveis da linha de comando
correspondem.</p>
<p>Essa retrabalho pode parecer um exagero para o nosso pequeno programa, mas estamos refatorando
em pequenos passos incrementais. Depois de fazer essa alteração, execute o programa novamente para
verificar se a análise do argumento ainda funciona. É bom verificar seu progresso
constantemente, porque isso irá ajudá-lo a identificar a causa dos problemas quando eles
ocorrerem.</p>
<a class="header" href="print.html#agrupando-valores-de-configuração" id="agrupando-valores-de-configuração"><h4>Agrupando Valores de Configuração</h4></a>
<p>Podemos dar outro pequeno passo para melhorar ainda mais a função <code>parse_config</code>.
No momento, estamos retornando uma tupla, mas depois quebramos imediatamente a tupla
em partes individuais novamente. Este é um sinal de que talvez não tenhamos
a abstração certa ainda.</p>
<p>Outro indicador que mostra que há espaço para melhoria é a parte <code>config</code>
de <code>parse_config</code>, o que implica que os dois valores que retornamos estão relacionados e
ambos são parte de um valor de configuração. Atualmente, não estamos transmitindo esse
significado na estrutura dos dados, que não sejam o agrupamento dos dois valores em um
tupla: podemos colocar os dois valores em uma estrutura e dar a cada uma das estruturas
um nome significativo. Isso facilitará os futuros mantenedores
deste código para entender como os diferentes valores se relacionam entre si e
qual é o propósito deles.</p>
<blockquote>
<p>Nota: algumas pessoas chamam este anti-padrão de usar valores primitivos quando um
tipo complexo seria mais apropriado <em>primitive obsession</em> (obsessão primitiva).</p>
</blockquote>
<p>A Listagem 12-6 mostra a adição de uma estrutura chamada <code>Config</code> definida para ter
campos chamados <code>query</code> e <code>filename</code>. Também mudamos a função <code>parse_config</code>
para retornar uma instância da estrutura <code>Config</code> e atualizamos <code>main</code> para usar
os campos struct em vez de ter variáveis separadas:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic"># use std::env;
# use std::fs::File;
#
fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = parse_config(&amp;args);

    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    let mut f = File::open(config.filename).expect(&quot;file not found&quot;);

    // --snip--
}

struct Config {
    query: String,
    filename: String,
}

fn parse_config(args: &amp;[String]) -&gt; Config {
    let query = args[1].clone();
    let filename = args[2].clone();

    Config { query, filename }
}
</code></pre></pre>
<p><span class="caption">Listagem 12-6: Refatorando <code>parse_config</code> para retornar uma
instância de uma struct <code>Config</code></span></p>
<p>A assinatura do <code>parse_config</code> agora indica que ele retorna um valor <code>Config</code>.
No corpo de <code>parse_config</code>, onde costumávamos retornar trechos de strings com
referência a valores <code>String</code> em <code>args</code>, agora definimos <code>Config</code> para conter valores
<code>String</code> owned. A variável <code>args</code> em <code>main</code> é o owner do argumento de
valores e está apenas permitindo que a função <code>parse_config</code> os empreste (borrow), o que significa
que violaremos as regras de borrow do Rust se o <code>Config</code> tentasse se apropriar (ownership) dos
valores em <code>args</code>.</p>
<p>Podemos gerenciar os dados <code>String</code> de várias maneiras diferentes, mas o
mais fácil, embora ineficiente, o caminho é chamar o método <code>clone</code> nos
valores. Isso fará uma cópia completa dos dados para a instância <code>Config</code>
, que leva mais tempo e memória do que armazenar uma referência à string de
dados. No entanto, a clonagem dos dados também torna nosso código muito direto
porque não precisamos administrar as vidas das referências; nessa
circunstância, desistir de um pouco de desempenho para ganhar simplicidade é uma coisa que vale a pena
a troca.</p>
<blockquote>
<a class="header" href="print.html#os-prós-e-contras-de-usar-clone" id="os-prós-e-contras-de-usar-clone"><h3>Os Prós e Contras de Usar <code>clone</code></h3></a>
<p>Existe uma tendência entre muitos Rustaceos para evitar o uso de <code>clone</code> para consertar
problemas de ownership devido ao seu custo de tempo de execução. No Capítulo 13, você aprenderá
como usar métodos mais eficientes neste tipo de situação. Mas por agora,
é bom copiar algumas strings para continuar a fazer progresso porque iremos
fazer essas cópias apenas uma vez, e nosso nome de arquivo e seqüência de consulta são muito
pequenos. É melhor ter um programa de trabalho que seja um pouco ineficiente do que
tentar hiper-optimizar o código na sua primeira passagem. À medida que você se torna mais experiente
com Rust, será mais fácil começar com a solução mais eficiente, mas para
agora, é perfeitamente aceitável chamar <code>clone</code>.</p>
</blockquote>
<p>Atualizamos <code>main</code> para que ele coloque a instância de <code>Config</code> retornada por
<code>parse_config</code> em uma variável chamada <code>config</code>, e atualizamos o código
anteriormente usado para as variáveis separadas <code>query</code> e <code>filename</code> para que ele agora
,em vez disso, use os campos na estrutura <code>Config</code>.</p>
<p>Agora, nosso código transmite mais claramente que <code>query</code> e <code>filename</code> estão relacionados, e
seu objetivo é configurar como o programa funcionará. Qualquer código que use
esses valores sabem encontrá-los na instância <code>config</code> nos campos nomeados
para esse propósito.</p>
<a class="header" href="print.html#criando-um-construtor-para-config" id="criando-um-construtor-para-config"><h4>Criando um Construtor para <code>Config</code></h4></a>
<p>Até agora, nós extraímos a lógica responsável por analisar os argumentos da linha de
comando de <code>main</code> e colocá-los na função <code>parse_config</code>, o que nos ajudou a ver que os
valores <code>query</code> e <code>filename</code> estavam relacionados e essa relação deve ser transmitida
em nosso código. Nós então adicionamos uma estrutura <code>Config</code> para nomear o propósito
relacionado de <code>query</code> e <code>filename</code>, e para poder retornar os nomes dos valores como
nomes de campos struct a partir da função <code>parse_config</code>.</p>
<p>Então, agora que a finalidade da função <code>parse_config</code> é criar uma instância <code>Config</code>
, podemos alterar <code>parse_config</code> de ser uma função simples para um
função denominada <code>new</code> que está associada à estrutura <code>Config</code>. Fazendo essa
mudança tornará o código mais idiomático: podemos criar instâncias de tipos na
biblioteca padrão, como <code>String</code>, chamando <code>String::new</code>, e
mudando <code>parse_config</code> para uma função <code>new</code> associada a <code>Config</code>, iremos
ser capazes de criar instâncias de <code>Config</code> chamando <code>Config::new</code>. Listagem 12-7
mostra as mudanças que precisamos fazer:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic"># use std::env;
#
fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args);

    // --snip--
}

# struct Config {
#     query: String,
#     filename: String,
# }
#
// --snip--

impl Config {
    fn new(args: &amp;[String]) -&gt; Config {
        let query = args[1].clone();
        let filename = args[2].clone();

        Config { query, filename }
    }
}
</code></pre></pre>
<p><span class="caption">Listagem 12-7: Alterar <code>parse_config</code> para
<code>Config::new</code></span></p>
<p>Atualizamos <code>main</code> onde estávamos chamando <code>parse_config</code> para, em vez disso, chamar
<code>Config::new</code>. Alteramos o nome de <code>parse_config</code> para <code>new</code> e movemos para
dentro de um bloco <code>impl</code>, que associa a função <code>new</code> a <code>Config</code>. Experimente
compilar este código novamente para garantir que ele funciona.</p>
<a class="header" href="print.html#consertando-o-tratamento-de-erros" id="consertando-o-tratamento-de-erros"><h3>Consertando o Tratamento de Erros</h3></a>
<p>Agora vamos trabalhar em consertar o nosso tratamento de erros. Lembre-se de que tentar acessar
os valores no vetor <code>args</code> no índice <code>1</code> ou no índice <code>2</code> causará pânico no programa se
o vetor contiver menos de três itens. Tente executar o programa sem argumentos; Isso parecerá assim:</p>
<pre><code class="language-text">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep`
thread 'main' panicked at 'index out of bounds: the len is 1
but the index is 1', src/main.rs:29:21
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>A linha <code>index out of bounds: the len is 1 but the index is 1</code> é uma mensagem de erro
destinada aos programadores. Isso não ajudará os usuários finais a entender o que
aconteceu e o que eles deveriam fazer a respeito disso. Vamos consertar isso agora.</p>
<a class="header" href="print.html#melhorando-a-mensagem-de-erro" id="melhorando-a-mensagem-de-erro"><h4>Melhorando a Mensagem de Erro</h4></a>
<p>Na Listagem 12-8, adicionamos uma verificação na função <code>new</code> que verificará que o
pedaço é longo o suficiente antes de acessar os índices <code>1</code> e <code>2</code>. Se o pedaço não for
suficientemente longo, o programa gera um pânico e exibe uma mensagem de erro melhor do que a
mensagem <code>index out of bounds</code>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">// --snip--
fn new(args: &amp;[String]) -&gt; Config {
    if args.len() &lt; 3 {
        panic!(&quot;not enough arguments&quot;);
    }
    // --snip--
</code></pre>
<p><span class="caption">Listagem 12-8: Adicionando uma verificação para o número de
argumentos</span></p>
<p>Este código é semelhante à função <code>Guess::new</code> que escrevemos na Listagem 9-9 onde
chamamos <code>panic!</code> quando o argumento <code>value</code> estava fora do alcance válido de
valores. Em vez de verificar uma variedade de valores aqui, estamos checando que o
comprimento de <code>args</code> é pelo menos <code>3</code> e o resto da função pode operar sob
o pressuposto de que essa condição foi cumprida. Se <code>args</code> tiver menos de três
itens, essa condição será verdadeira, e chamamos a macro <code>panic!</code> para terminar o
programa imediatamente.</p>
<p>Com estas poucas linhas de código adicionais em <code>new</code>, vamos executar o programa sem nenhum
argumento novamente para ver como o erro parece agora:</p>
<pre><code class="language-text">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep`
thread 'main' panicked at 'not enough arguments', src/main.rs:30:12
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>Este resultado é melhor: agora temos uma mensagem de erro razoável. No entanto, nós também
temos informações estranhas que não queremos dar aos nossos usuários. Talvez usando
a técnica que usamos na Lista 9-9 não é a melhor para usar aqui: uma chamada para
<code>panic!</code> é mais apropriado para um problema de programação e não um problema de uso
, conforme discutido no Capítulo 9. Em vez disso, podemos usar outra técnica que você
aprendeu no Capítulo 9 - retornando um <code>Result</code> que indica sucesso
ou um erro.</p>
<a class="header" href="print.html#retornando-um-result-de-um-new-em-vez-de-chamar-panic" id="retornando-um-result-de-um-new-em-vez-de-chamar-panic"><h4>Retornando um <code>Result</code> de um <code>new</code> Em vez de Chamar <code>panic!</code></h4></a>
<p>Em vez disso, podemos retornar um valor <code>Result</code> que conterá uma instância <code>Config</code> em
caso bem-sucedido e descreverá o problema no caso de erro. Quando
<code>Config::new</code> está se comunicando com <code>main</code>, podemos usar o tipo <code>Result</code> para
sinalizar que não houve problema. Então podemos mudar <code>main</code> para converter uma variante <code>Err</code>
em um erro mais prático para os nossos usuários sem os demais textos
sobre <code>thread 'main'</code> e <code>RUST_BACKTRACE</code> que uma chamada para <code>panic!</code> causa.</p>
<p>A Listagem 12-9 mostra as mudanças que precisamos fazer para o valor de retorno de
<code>Config::new</code> e o corpo da função necessária para retornar um <code>Result</code>. Note
que isso não compilará até que atualizemos <code>main</code> também, o que faremos na
próxima listagem:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">impl Config {
    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        Ok(Config { query, filename })
    }
}
</code></pre>
<p><span class="caption">Listagem 12-9: Retornando um <code>Result</code> de
<code>Config::new</code></span></p>
<p>Nossa função <code>new</code> agora retorna um<code>Result</code> com uma instância <code>Config</code> no caso de sucesso
e um <code>&amp;'static str</code> no caso de erro. Lembre-se da seção “The Static Lifetime” no capítulo 10
que <code>&amp; 'static str</code> é o tipo de string literal, que é o nosso tipo de mensagem de erro por enquanto.</p>
<p>Fizemos duas mudanças no corpo da função <code>new</code>: em vez de chamar
<code>panic!</code> quando o usuário não passa argumentos suficientes, agora devolvemos um valor <code>Err</code>
, e nós wrapped (embalamos) o valor de retorno <code>Config</code> em um <code>Ok</code>. Estas alterações
fazem com que a função esteja conforme a sua nova assinatura de tipo.</p>
<p>Retornar um valor <code>Err</code> de <code>Config::new</code> permite que a função <code>main</code>
lide com o valor <code>Result</code> retornado da função <code>new</code> e saia do processo
de forma mais limpa no caso de erro.</p>
<a class="header" href="print.html#chamando-confignew-e-manipulação-de-erros" id="chamando-confignew-e-manipulação-de-erros"><h4>Chamando <code>Config::new</code> e Manipulação de Erros</h4></a>
<p>Para lidar com o caso de erro e imprimir uma mensagem amigável, precisamos atualizar
<code>main</code> para lidar com o <code>Result</code> sendo retornado por <code>Config::new</code>, conforme mostrado na
Listagem 12-10. Também assumiremos a responsabilidade de sair da linha de comando
com um código de erro diferente de zero do <code>panic!</code> e implementá-lo manualmente.
O status de saída diferente de zero, é uma convenção para sinalizar o processo que chamou nosso
programa que, o programa saiu com um estado de erro.</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::process;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        println!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    // --snip--
</code></pre>
<p><span class="caption">Listagem 12-10: Se ao criar um <code>Config</code> falha, saimos
com um código de erro</span></p>
<p>Nesta lista, usamos um método que não abordamos antes:
<code>unwrap_or_else</code>, que está definido em <code>Result &lt;T, E&gt;</code> pela biblioteca padrão.
Usar <code>unwrap_or_else</code> nos permite definir algum erro personalizado, não-<code>panic!</code> de
manipulação. Se o <code>Result</code> for um valor <code>Ok</code>, o comportamento deste método é semelhante
a <code>unwrap</code>: ele retorna o valor interno <code>Ok</code>. No entanto, se o valor
é um valor <code>Err</code>, este método chama o código na <em>closure</em>, que é uma
função anônima que definimos e passamos como um argumento para <code>unwrap_or_else</code>. Nós
entraremos em detalhes sobre closures no Capítulo 13. Por enquanto, você precisa apenas saber
que <code>unwrap_or_else</code> passará o valor interno do <code>Err</code>, que neste
caso é a string estática <code>not enough arguments</code> que adicionamos na Listagem 12-9,
para o nosso closure no argumento <code>err</code> que aparece entre os pipes verticais.
O código no closure pode então usar o valor <code>err</code> quando ele é executado.</p>
<p>Adicionamos uma nova linha de <code>use</code> para importar <code>process</code> da biblioteca padrão.
O código na closure que será executado no caso de erro são apenas duas linhas: nós
imprimos o valor de <code>err</code> e depois chamamos <code>process::exit</code>. A função <code>process::exit</code>
interromperá o programa imediatamente e retornará o número que foi
passado como o código de status de saída. Isso é semelhante ao manuseio baseado no <code>panic!</code>
que usamos na Listagem 12-8, mas já não obtemos todos os resultados extras. Vamos tentar
isto:</p>
<pre><code class="language-text">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48 secs
     Running `target/debug/minigrep`
Problem parsing arguments: not enough arguments
</code></pre>
<p>Ótimo! Este resultado é muito mais amigável para os nossos usuários.</p>
<a class="header" href="print.html#extraindo-a-lógica-do-main" id="extraindo-a-lógica-do-main"><h3>Extraindo a Lógica do <code>main</code></h3></a>
<p>Agora que terminamos de refatorar a análise da configuração, voltemos
a lógica do programa. Como afirmamos em “Separação de Responsabilidades para
Projetos Binários”, vamos extrair uma função chamada <code>run</code> que irá armazenar toda a lógica
atualmente na função <code>main</code> que não está envolvida com a configuração ou
manipulação de erros. Quando terminarmos, <code>main</code> será conciso e
fácil de verificar por inspeção, e poderemos fazer testes para todas as
outras lógicas.</p>
<p>Listagem 12-11 mostra a função extraída <code>run</code>. Por enquanto, estamos apenas fazendo
a pequena melhoria incremental da extração da função. Ainda estamos
definindo a função em <em>src/main.rs</em>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    // --snip--

    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    run(config);
}

fn run(config: Config) {
    let mut f = File::open(config.filename).expect(&quot;file not found&quot;);

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents)
        .expect(&quot;something went wrong reading the file&quot;);

    println!(&quot;With text:\n{}&quot;, contents);
}

// --snip--
</code></pre>
<p><span class="caption">Listagem 12-11: Extraindo uma função <code>run</code> contendo o
resto da lógica do programa</span></p>
<p>A função <code>run</code> agora contém toda a lógica restante de <code>main</code>, começando
por ler o arquivo. A função <code>run</code> pega a instância <code>Config</code> como um
argumento.</p>
<a class="header" href="print.html#retornando-erros-da-função-run" id="retornando-erros-da-função-run"><h4>Retornando Erros da Função <code>run</code></h4></a>
<p>Com a lógica do programa restante separada na função <code>run</code>, podemos
melhorar o tratamento de erros, como fizemos com <code>Config::new</code> na Listagem 12-9.
Em vez de permitir que o programa entre em pânico ao chamar <code>expect</code>, a função <code>run</code>
retornará um <code>Result&lt;T, E&gt;</code> quando algo der errado. Isso permitirá
nos permitirá consolidar ainda mais na lógica principal a manipulação de erros em uma
maneira fácil de usar. A Listagem 12-12 mostra as mudanças que precisamos fazer para a
assinatura e corpo de <code>run</code>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::error::Error;

// --snip--

fn run(config: Config) -&gt; Result&lt;(), Box&lt;Error&gt;&gt; {
    let mut f = File::open(config.filename)?;

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents)?;

    println!(&quot;With text:\n{}&quot;, contents);

    Ok(())
}
</code></pre>
<p><span class="caption">Listagem 12-12: Alterar a função <code>run</code> para retornar
<code>Result</code></span></p>
<p>Nós fizemos três mudanças significativas aqui. Primeiro, mudamos o tipo de retorno
da função <code>run</code> para <code>Result&lt;(), Box&lt;Error&gt;&gt;</code>. Esta função anteriormente
devolveu o tipo de unidade, <code>()</code>, e nós mantemos isso como o valor retornado <code>Ok</code> no
caso.</p>
<p>Para o tipo de erro, usamos o <em>trait object</em> <code>Box&lt;Error&gt;</code> (e nós trouxemos
<code>std::error::Error</code> no escopo com uma instrução <code>use</code> na parte superior). Vamos cobrir
objetos trait no Capítulo 17. Por enquanto, apenas saiba que <code>Box&lt;Error&gt;</code> significa que
a função retornará um tipo que implemente o trait <code>Error</code>, mas não temos
que especificar qual tipo em particular o valor de retorno será. Isso nos dá
flexibilidade para retornar valores de erro que podem ser de diferentes tipos em diferentes
casos de erro.</p>
<p>Em segundo lugar, removemos as chamadas para <code>expect</code> em favor de <code>?</code>, como falamos sobre
isso no Capítulo 9. Ao invés de <code>panic!</code> em um erro, <code>?</code> retornará o valor do erro
a partir da função atual para que o chamador lide com ele.</p>
<p>Em terceiro lugar, a função <code>run</code> agora retorna um valor <code>Ok</code> no caso de sucesso. Nós
declaramos o tipo de sucesso da função <code>run</code> como <code>()</code> na assinatura, que
significa que precisamos wrap (envolver) o valor do tipo de unidade no valor <code>Ok</code>. Esta sintaxe <code>Ok(())</code>
pode parecer um pouco estranha no início, mas usar <code>()</code> como este é o
maneira idiomática de indicar que chamamos <code>run</code> para seus efeitos colaterais somente;
ele não retorna o valor que precisamos.</p>
<p>Quando você executa este código, ele compilará, mas exibirá um aviso:</p>
<pre><code class="language-text">warning: unused `std::result::Result` which must be used
  --&gt; src/main.rs:18:5
   |
18 |     run(config);
   |     ^^^^^^^^^^^^
= note: #[warn(unused_must_use)] on by default
</code></pre>
<p>Rust nos diz que nosso código ignorou o valor <code>Result</code> e o valor de <code>Result</code>
pode indicar que ocorreu um erro. Mas não estamos checando para ver se ocorreu ou
não o erro, e o compilador nos lembra que provavelmente queríamos
tratar algum código de erros aqui! Vamos corrigir esse problema agora.</p>
<a class="header" href="print.html#manipulação-de-erros-retornados-de-run-em-main" id="manipulação-de-erros-retornados-de-run-em-main"><h4>Manipulação de Erros Retornados de <code>run</code> em <code>main</code></h4></a>
<p>Verificamos erros e lidaremos com eles usando uma técnica semelhante à nossa
manipulação de erros com <code>Config::new</code> na Listagem 12-10, mas com umas
diferenças:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    // --snip--

    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    if let Err(e) = run(config) {
        println!(&quot;Application error: {}&quot;, e);

        process::exit(1);
    }
}
</code></pre>
<p>Usamos <code>if let</code> em vez de <code>unwrap_or_else</code> para verificar se <code>run</code> retorna um valor
<code>Err</code> e chama <code>process::exit(1)</code> se o fizer. A função <code>run</code> não retorna
um valor que queremos <code>unwrap</code> da mesma forma que <code>Config::new</code>
retorna a instância <code>Config</code>. Porque <code>run</code> retorna <code>()</code> no caso de sucesso,
nós só nos preocupamos em detectar um erro, por isso não precisamos de <code>unwrap_or_else</code> para
devolver o valor unwrapped porque seria apenas <code>()</code>.</p>
<p>Os corpos das funções <code>if let</code> e <code>unwrap_or_else</code> são os mesmos em
ambos os casos: imprimimos o erro e saímos.</p>
<a class="header" href="print.html#dividindo-o-código-em-uma-crate-de-biblioteca" id="dividindo-o-código-em-uma-crate-de-biblioteca"><h3>Dividindo o Código em uma Crate de Biblioteca</h3></a>
<p>O nosso projeto <code>minigrep</code> parece estar bem até agora! Agora vamos dividir o
<em>src/main.rs</em> e colocar algum código no arquivo <em>src/lib.rs</em> para que possamos testá-lo
em um arquivo <em>src/main.rs</em> com menos responsabilidades.</p>
<p>Vamos mover todo o código que não é da função <code>main</code> de  <em>src/main.rs</em> para
<em>src/lib.rs</em>:</p>
<ul>
<li>A definição de função <code>run</code></li>
<li>As instruções relevantes <code>use</code></li>
<li>A definição de <code>Config</code></li>
<li>A definição da função <code>Config::new</code></li>
</ul>
<p>O conteúdo de <em>src/lib.rs</em> deve ter as assinaturas mostradas na Listagem 12-13
(omitimos o corpo das funções por brevidade). Observe que isso não irá
compilar até modificar o <em>src/main.rs</em> na listagem depois desta:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">use std::error::Error;
use std::fs::File;
use std::io::prelude::*;

pub struct Config {
    pub query: String,
    pub filename: String,
}

impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --snip--
    }
}

pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;Error&gt;&gt; {
    // --snip--
}
</code></pre>
<p><span class="caption">Listagem 12-13: movendo <code>Config</code> e <code>run</code> para
<em>src/lib.rs</em></span></p>
<p>Nós fizemos um uso liberal do <code>pub</code> aqui: no <code>Config</code>, seus campos e seu método <code>new</code>
, e na função <code>run</code>. Agora temos uma crate de biblioteca que tem uma
API pública que podemos testar!</p>
<p>Agora, precisamos trazer o código que nós movemos para <em>src/lib.rs</em> no escopo da
crate binária em <em>src/main.rs</em>, conforme mostrado na Listagem 12-14:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate minigrep;

use std::env;
use std::process;

use minigrep::Config;

fn main() {
    // --snip--
    if let Err(e) = minigrep::run(config) {
        // --snip--
    }
}
</code></pre>
<p><span class="caption">Listagem 12-14: Trazendo a crate <code>minigrep</code> para o
escopo de <em>src/main.rs</em></span></p>
<p>Para colocar a crate de biblioteca na crate binária, usamos <code>extern crate minigrep</code>. Em seguida, adicionaremos uma linha <code>use minigrep::Config</code> para trazer para o
escopo o tipo <code>Config</code>, e iremos prefixar a funão <code>run</code> com o nome da nossa crate. Agora
todas as funcionalidades devem estar conectadas e devem funcionar. Execute o programa com
<code>cargo run</code> e verifique se tudo funciona corretamente.</p>
<p>Ufa! Isso foi trabalhoso, mas nós nos preparamos para o sucesso no
futuro. Agora é muito mais fácil lidar com erros, e nós fizemos o código mais
modular. Quase todo o nosso trabalho será feito em <em>src/lib.rs</em> a partir daqui.</p>
<p>Vamos aproveitar desta nova recém-descoberta modularidade para fazer algo que seria
difícil com o código antigo, mas é fácil com o novo código: nós iremos
escreva alguns testes!</p>
<a class="header" href="print.html#desenvolvendo-a-biblioteca-de-funcionalidades-com-desenvolvimento-guiado-por-testes" id="desenvolvendo-a-biblioteca-de-funcionalidades-com-desenvolvimento-guiado-por-testes"><h2>Desenvolvendo a Biblioteca de Funcionalidades com Desenvolvimento Guiado por Testes</h2></a>
<p>Agora que extraímos a lógica em <em>src/lib.rs</em> e deixamos o argumento de
coleta e tratamento de erros em <em>src/main.rs</em>, é muito mais fácil escrever testes
para nosso código da funcionalidade principal. Podemos chamar funções diretamente com
vários argumentos e verificar valores de retorno sem ter que chamar o nosso binário
da linha de comando. Sinta-se livre para escrever alguns testes para
as funções <code>Config::new</code> e <code>run</code> por sua conta.</p>
<p>Nesta seção, adicionaremos a lógica de busca ao programa <code>minigrep</code>
usando o processo Desenvolvimento Guiado por Testes (Test Driven Development (TDD)).
Nessa técnica de desenvolvimento de software, segue estas etapas:</p>
<ol>
<li>Escreva um teste que falha e execute-o, para certificar-se de que ele falha pelo motivo
    esperado por você.</li>
<li>Escreva ou modifique o código apenas o suficiente para fazer passar no teste.</li>
<li>Refatore o código que você acabou de adicionar ou alterou e certifique-se de que os testes
    continuam a passar.</li>
<li>Repita a partir do passo 1!</li>
</ol>
<p>Este processo é apenas uma das muitas maneiras de escrever software, mas o TDD pode ajudar a conduzir
design de código também. Escrevendo o teste antes de escrever o código que faz o
teste passar, ajuda a manter uma alta cobertura de teste ao longo do processo.</p>
<p>Testaremos a implementação da funcionalidade que realmente fará
a busca da string de consulta no conteúdo do arquivo, e produzir uma lista de
linhas que correspondem à consulta. Vamos adicionar essa funcionalidade em uma função chamada
<code>search</code>.</p>
<a class="header" href="print.html#escrevendo-um-teste-de-falha" id="escrevendo-um-teste-de-falha"><h3>Escrevendo um Teste de Falha</h3></a>
<p>Porque não precisamos mais deles, vamos remover as instruções <code>println!</code> de
<em>src/lib.rs</em> e <em>src/main.rs</em> que costumávamos verificar o comportamento do programa.
Então, em <em>src/lib.rs</em>, adicionaremos um módulo <code>test</code> com uma função de teste, como nós
fizemos no Capítulo 11. A função de teste especifica o comportamento que queremos
para a função <code>search</code> tenha: receberá os parâmetros da consulta e o texto para realizar a
consulta, e retornará apenas as linhas do texto que contém a consulta.
A Listagem 12-15 mostra esse teste, que ainda não compilará:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
#      vec![]
# }
#
#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn one_result() {
        let query = &quot;duct&quot;;
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.&quot;;

        assert_eq!(
            vec![&quot;safe, fast, productive.&quot;],
            search(query, contents)
        );
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 12-15: Criando um teste de falha para a função <code>search</code>
que desejamos ter</span></p>
<p>Este teste procura a string “duct”. O texto que estamos procurando contém três
linhas, apenas uma das quais contém “duct.” Afirmamos que o valor retornado
a partir da função <code>search</code> contém apenas a linha que esperamos.</p>
<p>Não somos capazes de executar este teste e vê-lo falhar porque o teste nem mesmo
compila: a função <code>search</code> ainda não existe! Então, agora vamos adicionar código apenas o suficiente
para obter a compilação do teste, e executar, adicionando uma definição da função <code>search</code>
que sempre retorna um vetor vazio, como mostrado na Listagem 12-16. Então
o teste deve compilar e falhar porque um vetor vazio não corresponde a um vetor
contendo a linha <code>&quot;safe, fast, productive.&quot;</code>.</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    vec![]
}
#}</code></pre></pre>
<p><span class="caption">Listagem 12-16: Definindo apenas o suficiente da função <code>search</code>
para que nosso teste compile</span></p>
<p>Observe que precisamos de uma lifetime explícita <code>'a</code> definida na assinatura do
<code>search</code> e usada com o argumento <code>contents</code> e o valor de retorno. Lembre-se no
Capítulo 10 que os parâmetros de lifetime especificam qual o lifetime do argumento
conectado ao lifetime do valor de retorno. Neste caso, indicamos que
o vetor retornado deve conter pedaços de string que fazem referência a pedaços do
argumento <code>contents</code> (em vez do argumento <code>query</code>).</p>
<p>Em outras palavras, dizemos ao Rust que os dados retornados pela função <code>search</code>
irá viver enquanto os dados passarem para a função <code>search</code> no
argumento de <code>contents</code>. Isso é importante! Os dados referenciados <em>por</em> um pedaço precisa
ser válido para que a referência seja válida; se o compilador assume que estamos fazendo
pedaços de string de <code>query</code> em vez de <code>contents</code>, ele fará sua verificação de segurança
incorretamente.</p>
<p>Se esquecermos as anotações de lifetime e tentarmos compilar esta função, iremos
obter este erro:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt; src/lib.rs:5:51
  |
5 | pub fn search(query: &amp;str, contents: &amp;str) -&gt; Vec&lt;&amp;str&gt; {
  |                                                   ^ expected lifetime
parameter
  |
  = help: this function's return type contains a borrowed value, but the
  signature does not say whether it is borrowed from `query` or `contents`
</code></pre>
<p>Rust não consegue saber qual dos dois argumentos que precisamos, então precisamos informar
isto. Porque <code>contents</code> é o argumento que contém todo o nosso texto e nós
queremos retornar as partes desse texto que combinam, sabemos que o <code>contents</code> é o
argumento que deve ser conectado ao valor de retorno usando a sintaxe de lifetime.</p>
<p>Outras linguagens de programação não exigem que você conecte argumentos para retornar
valores na assinatura, por isso, embora isso possa parecer estranho, ele ficará
mais fácil ao longo do tempo. Você pode querer comparar este exemplo com a seção “Validando
Referências com Lifetimes” no Capítulo 10.</p>
<p>Agora vamos executar o teste:</p>
<pre><code class="language-text">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
--warnings--
    Finished dev [unoptimized + debuginfo] target(s) in 0.43 secs
     Running target/debug/deps/minigrep-abcabcabc

running 1 test
test test::one_result ... FAILED

failures:

---- test::one_result stdout ----
        thread 'test::one_result' panicked at 'assertion failed: `(left ==
right)`
left: `[&quot;safe, fast, productive.&quot;]`,
right: `[]`)', src/lib.rs:48:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.


failures:
    test::one_result

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Ótimo, o teste falha, exatamente como esperávamos. Vamos fazer o teste passar!</p>
<a class="header" href="print.html#escrevendo-código-para-passar-no-teste" id="escrevendo-código-para-passar-no-teste"><h3>Escrevendo Código para Passar no Teste</h3></a>
<p>Atualmente, nosso teste está falhando porque sempre devolvemos um vetor vazio. Para consertar
isso é preciso implementar <code>search</code>, nosso programa precisa seguir essas etapas:</p>
<ul>
<li>Iterar através de cada linha do conteúdo.</li>
<li>Verificar se a linha contém nossa string de consulta.</li>
<li>Se a tiver, adicione-a à lista de valores que estamos retornando.</li>
<li>Se não, não faça nada.</li>
<li>Retorna a lista de resultados que correspondem.</li>
</ul>
<p>Vamos trabalhar em cada passo, começando por iterar através de linhas.</p>
<a class="header" href="print.html#iterar-através-de-linhas-com-o-método-lines" id="iterar-através-de-linhas-com-o-método-lines"><h4>Iterar Através de Linhas com o Método <code>lines</code></h4></a>
<p>Rust tem um método útil para lidar com a iteração linha-a-linha de strings,
convenientemente chamado <code>lines</code>, que funciona como mostrado na Listagem 12-17. Observe que isso
ainda não compilará:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        // faça algo com line
    }
}
</code></pre>
<p><span class="caption">Listagem 12-17: Iterando para cada linha em <code>contents</code>
</span></p>
<p>O método <code>lines</code> retorna um iterador. Vamos falar sobre iteradores em profundidade no
Capítulo 13, mas lembre-se de que você viu essa maneira de usar um iterador na Listagem
3-4, onde usamos um loop <code>for</code> com um iterador para executar algum código em cada item
de uma coleção.</p>
<a class="header" href="print.html#pesquisando-cada-linha-para-a-consulta" id="pesquisando-cada-linha-para-a-consulta"><h4>Pesquisando Cada Linha para a Consulta</h4></a>
<p>Em seguida, verificamos se a linha atual contém nossa string de consulta.
Felizmente, as strings possuem um método útil chamado <code>contains</code> que faz isso para
nós! Adicione uma chamada ao método <code>contains</code> na função <code>search</code>, conforme mostrado na
Listagem 12-18. Observe que isso ainda não compilará ainda:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        if line.contains(query) {
            // do something with line
        }
    }
}
</code></pre>
<p><span class="caption">Listagem 12-18: Adicionando funcionalidade para ver se
a linha contém a string na <code>query</code></span></p>
<a class="header" href="print.html#armazenamento-de-linhas-correspondentes" id="armazenamento-de-linhas-correspondentes"><h4>Armazenamento de Linhas Correspondentes</h4></a>
<p>Nós também precisamos de uma maneira de armazenar as linhas que contêm nossa string de consulta. Por isso,
podemos fazer um vetor mutável antes do loop <code>for</code> e chamar o método <code>push</code>
para armazenar uma <code>line</code> no vetor. Após o loop <code>for</code>, devolvemos o vetor, como
mostrado na Listagem 12-19:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
</code></pre>
<p><span class="caption">Listagem 12-19: Armazenando as linhas que combinam para que possamos
devolvê-las</span></p>
<p>Agora, a função <code>search</code> deve retornar apenas as linhas que contêm<code>query</code>,
e nosso teste deve passar. Vamos executar o teste:</p>
<pre><code class="language-text">$ cargo test
--snip--
running 1 test
test test::one_result ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Nosso teste passou, então sabemos que funciona!</p>
<p>Neste ponto, poderíamos considerar oportunidades de refatorar
a implementação da função de pesquisa, mantendo os testes passando para
a mesma funcionalidade. O código na função de pesquisa não é muito ruim,
mas não tira proveito de algumas características úteis dos iteradores. Iremos
voltar para este exemplo no Capítulo 13, onde exploraremos iteradores em detalhes
e veremos como melhorá-lo.</p>
<a class="header" href="print.html#usando-a-função-search-na-funçãorun" id="usando-a-função-search-na-funçãorun"><h4>Usando a Função <code>search</code> na Função<code>run</code></h4></a>
<p>Agora que a função <code>search</code> está funcionando e testada, precisamos chamar <code>search</code>
da nossa função <code>run</code>. Precisamos passar o valor <code>config.query</code> e o
<code>contents</code> que <code>run</code> lê do arquivo para a função <code>search</code>. Então, <code>run</code>
irá imprimir cada linha retornada de <code>search</code>:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;Error&gt;&gt; {
    let mut f = File::open(config.filename)?;

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents)?;

    for line in search(&amp;config.query, &amp;contents) {
        println!(&quot;{}&quot;, line);
    }

    Ok(())
}
</code></pre>
<p>Ainda estamos usando um loop <code>for</code> para retornar cada linha de <code>search</code> e imprimi-lo.</p>
<p>Agora, todo o programa deve funcionar! Vamos tentar, primeiro, com uma palavra que
deve retornar exatamente uma linha do poema de Emily Dickinson, “frog”:</p>
<pre><code class="language-text">$ cargo run frog poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.38 secs
     Running `target/debug/minigrep frog poem.txt`
How public, like a frog
</code></pre>
<p>Legal! Agora vamos tentar uma palavra que combine várias linhas, como “body”:</p>
<pre><code class="language-text">$ cargo run body poem.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep body poem.txt`
I’m nobody! Who are you?
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>E, finalmente, vamos nos certificar de que não recebemos nenhuma linha quando buscamos uma
palavra que não está em qualquer lugar no poema, como “monomorphization”:</p>
<pre><code class="language-text">$ cargo run monomorphization poem.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep monomorphization poem.txt`
</code></pre>
<p>Excelente! Nós construímos nossa própria mini versão de uma ferramenta clássica e aprendemos muito
sobre como estruturar aplicativos. Também aprendemos um pouco sobre a entrada de arquivos
e saída, lifetimes, teste e análise de linha de comando.</p>
<p>Para completar este projeto, brevemente demonstraremos como trabalhar com
variáveis de ambiente e como imprimir em erro padrão, ambos
úteis quando você está escrevendo programas de linha de comando.</p>
<a class="header" href="print.html#trabalhando-com-variáveis-de-ambiente" id="trabalhando-com-variáveis-de-ambiente"><h2>Trabalhando com Variáveis de Ambiente</h2></a>
<p>Melhoraremos <code>minigrep</code> adicionando um recurso extra: uma opção para
pesquisa insensível às letras maiúsculas ou minúsculas, que o usuário poderá ativar através de
variável de ambiente. Poderíamos fazer deste recurso uma opção de linha de comando e exigir que
os usuários entram cada vez que eles querem que ele se aplique, mas, em vez disso, usaremos um
variável de ambiente. Isso permite que nossos usuários estabeleçam a variável de ambiente
uma vez e todas as suas buscas são insensíveis às maiúsculas e minúsculas naquela sessão do terminal.</p>
<a class="header" href="print.html#escrevendo-um-teste-de-falha-para-a-função-search-insensível-a-maiúsculas-e-minúsculas" id="escrevendo-um-teste-de-falha-para-a-função-search-insensível-a-maiúsculas-e-minúsculas"><h3>Escrevendo um Teste de Falha para a Função <code>search</code> insensível a Maiúsculas e Minúsculas</h3></a>
<p>Queremos adicionar uma nova função <code>search_case_insensitive</code> que chamaremos quando
a variável de ambiente estiver ativada. Seguiremos com o processo TDD, então
o primeiro passo é novamente escrever um teste de falha. Vamos adicionar um novo teste para a
nova função <code>search_case_insensitive</code> e renomear nosso antigo teste de
<code>one_result</code> para <code>case_sensitive</code> de forma a esclarecer as diferenças entre os dois
testes, conforme mostrado na Listagem 12-20:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn case_sensitive() {
        let query = &quot;duct&quot;;
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.
Duct tape.&quot;;

        assert_eq!(
            vec![&quot;safe, fast, productive.&quot;],
            search(query, contents)
        );
    }

    #[test]
    fn case_insensitive() {
        let query = &quot;rUsT&quot;;
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.
Trust me.&quot;;

        assert_eq!(
            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
            search_case_insensitive(query, contents)
        );
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 12-20: Adicionando um novo teste de falha para a
função insensível à maiúsculas e minúsculas que estamos prestes a adicionar</span></p>
<p>Note que também editamos o <code>contents</code> do antigo teste. Adicionamos uma nova linha
com o texto <code>“Duct tape”</code> usando um D maiúsculo que não deve corresponder à consulta
“duct” quando procuramos de forma sensível à maiúsculas e minúsculas. Alterando o teste antigo
desta forma, ajuda a garantir que não quebramos acidentalmente a diferenciação de maiúsculas e minúsculas
na funcionalidade de pesquisa que já implementamos. Este teste deve passar agora
e deve continuar a passar enquanto trabalhamos na pesquisa insensível à maiúsculas e minúsculas.</p>
<p>O novo teste para a pesquisa insensível usa “rUsT” para sua consulta. Na função
<code>search_case_insensitive</code> que estamos prestes a adicionar, a consulta “rUsT” deve
combinar a linha que contém “Rust:” com um R maiúsculo e também a linha “Trust
me.”, embora ambos tenham uma caixa (maiúsculas e minúsculas) diferente da consulta. Este é o nosso teste de
falha, e ele não compilará porque ainda não definimos a
função <code>search_case_insensitive</code>. Sinta-se livre para adicionar uma implementação
que sempre retorna um vetor vazio, semelhante à forma como fizemos para a função <code>search</code>
na Listagem 12-16 para ver a compilação e o teste falhar.</p>
<a class="header" href="print.html#implementando-a-função-search_case_insensitive" id="implementando-a-função-search_case_insensitive"><h3>Implementando a Função <code>search_case_insensitive</code></h3></a>
<p>A função <code>search_case_insensitive</code>, mostrada na Listagem 12-21, será quase
o mesmo que a função <code>search</code>. A única diferença é que vamos forçar minúsculas
para <code>query</code> e para cada <code>line</code>, qualquer que seja o caso dos argumentos de entrada,
eles serão sempre minúsculos quando verificamos se a linha contém a consulta:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn search_case_insensitive&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let query = query.to_lowercase();
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.to_lowercase().contains(&amp;query) {
            results.push(line);
        }
    }

    results
}
#}</code></pre></pre>
<p><span class="caption">Listagem 12-21: Definindo a função <code>search_case_insensitive</code>
para forçar caixa baixa na consulta antes de compará-las</span></p>
<p>Primeiro, caixa baixa na string <code>query</code> e a armazenamos em uma variável sombreada com
o mesmo nome. Chamar <code>to_lowercase</code> na consulta é necessário, portanto, não importa
se a consulta do usuário é “rust”, “RUST”, “Rust”, ou “rUsT”, trataremos a
consulta como se fosse “rust” sendo insensível ao caso.</p>
<p>Note que <code>query</code> é agora uma <code>String</code> ao invés de um fatia de string, porque chamar
<code>to_lowercase</code> cria novos dados em vez de referenciar dados existentes. Suponha que
a consulta é “rUsT”, por exemplo: essa fatia de string não contém minúsculas
“u” ou “t” para nós usarmos, então temos que alocar uma nova <code>String</code> contendo
“rust”. Quando passamos <code>query</code> como um argumento para o método <code>contains</code> agora, nós
precisamos adicionar um ampersand (&amp;) porque a assinatura de <code>contains</code> é definida para
uma fatia de string.</p>
<p>Em seguida, adicionamos uma chamada a <code>to_lowercase</code> em cada <code>line</code> antes de verificarmos se
contém <code>query</code> para passar para caixa baixa em todos os caracteres. Agora que convertemos <code>line</code>
e <code>query</code> para letras minúsculas, encontraremos correspondências, não importa qual seja o caso da
consulta.</p>
<p>Vamos ver se esta implementação passa nos testes:</p>
<pre><code class="language-text">running 2 tests
test test::case_insensitive ... ok
test test::case_sensitive ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Ótimo! Eles passaram. Agora, vamos chamar a nova função <code>search_case_insensitive</code>
da função <code>run</code>. Primeiro, adicionaremos uma opção de configuração ao
<code>Config</code> struct para alternar entre pesquisa sensível a maiúsculas e minúsculas.
Adicionar esse campo causará erros no compilador, já que não estamos inicializando
o campo em nenhum lugar:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Config {
    pub query: String,
    pub filename: String,
    pub case_sensitive: bool,
}
#}</code></pre></pre>
<p>Note que nós adicionamos o campo <code>case_sensitive</code> que contém um Booleano. Em seguida nós
precisamos da função <code>run</code> para verificar o valor do campo <code>case_sensitive</code> e usá-la
para decidir se devemos chamar a função <code>search</code> ou a
função <code>search_case_insensitive</code>, conforme mostrado na Listagem 12-22. Note que isso ainda
não irá compilar ainda:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::error::Error;
# use std::fs::File;
# use std::io::prelude::*;
#
# fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
#      vec![]
# }
#
# fn search_case_insensitive&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
#      vec![]
# }
#
# struct Config {
#     query: String,
#     filename: String,
#     case_sensitive: bool,
# }
#
pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;Error&gt;&gt; {
    let mut f = File::open(config.filename)?;

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents)?;

    let results = if config.case_sensitive {
        search(&amp;config.query, &amp;contents)
    } else {
        search_case_insensitive(&amp;config.query, &amp;contents)
    };

    for line in results {
        println!(&quot;{}&quot;, line);
    }

    Ok(())
}
#}</code></pre></pre>
<p><span class="caption">Listagem 12-22: Chamando  <code>search</code> ou
<code>search_case_insensitive</code> baseado no valor em <code>config.case_sensitive</code></span></p>
<p>Finalmente, precisamos verificar a variável de ambiente. As funções para
trabalhar com variáveis de ambiente estão no módulo <code>env</code> na biblioteca padrão
, por isso queremos trazer esse módulo para o escopo com uma linha <code>use std::env;</code>
no topo de <em>src/lib.rs</em>. Então vamos usar o método <code>var</code> do módulo <code>env</code>
para verificar uma variável de ambiente chamada <code>CASE_INSENSITIVE</code>, conforme
na Listagem 12-23:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::env;
# struct Config {
#     query: String,
#     filename: String,
#     case_sensitive: bool,
# }

// --snip--

impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        let case_sensitive = env::var(&quot;CASE_INSENSITIVE&quot;).is_err();

        Ok(Config { query, filename, case_sensitive })
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 12-23: Checando por uma variável de ambiente chamada
<code>CASE_INSENSITIVE</code></span></p>
<p>Aqui, criamos uma nova variável <code>case_sensitive</code>. Para definir seu valor, chamamos a
função <code>env::var</code> e passamos o nome da variável de ambiente <code>CASE_INSENSITIVE</code>
. O método <code>env::var</code> retorna um <code>Result</code> que será o sucesso
variante <code>Ok</code> que contém o valor da variável de ambiente se a
variável de ambiente está definida. Ele retornará a variante <code>Err</code> se a
variável de ambiente não está definida.</p>
<p>Estamos usando o método <code>is_err</code> no <code>Result</code> para verificar se é um erro
e, portanto, não definido, o que significa que <em>deveria</em> fazer uma pesquisa sensível a maiúsculas e minúsculas. Se
a variável de ambiente <code>CASE_INSENSITIVE</code> está configurada para qualquer coisa,<code>is_err</code> irá
retornar false e realizará uma pesquisa sem distinção entre maiúsculas e minúsculas. Nós não nos importamos com
o <em>valor</em> da variável de ambiente, apenas se está definido ou não,
estamos verificando <code>is_err</code> em vez de <code>unwrap</code>, <code>expect</code> ou qualquer um dos outros
métodos que vimos em <code>Result</code>.</p>
<p>Nós passamos o valor na variável <code>case_sensitive</code> para a instância <code>Config</code>
na função <code>run</code> pode ler esse valor e decidir se deve chamar <code>search</code> ou
<code>search_case_insensitive</code> conforme implementamos na Listagem 12-22.</p>
<p>Vamos tentar! Primeiro, executaremos nosso programa sem o conjunto de variáveis
de ambiente e com a consulta “to”, que deve corresponder a qualquer linha que contenha
a palavra “to” em todas as letras minúsculas:</p>
<pre><code class="language-text">$ cargo run to poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>Parece que isso ainda funciona! Agora, vamos executar o programa com <code>CASE_INSENSITIVE</code>
definido como <code>1</code> mas com a mesma consulta “to”; devemos pegar linhas que contenham “to”
que possam ter letras maiúsculas:</p>
<pre><code class="language-text">$ CASE_INSENSITIVE=1 cargo run to poem.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p>Se você estiver usando o PowerShell, precisará definir a variável de ambiente e
executar o programa em dois comandos em vez de um:</p>
<pre><code class="language-text">$ $env.CASE_INSENSITIVE=1
$ cargo run to poem.txt
</code></pre>
<p>Excelente, também temos linhas contendo “To”! Nosso programa <code>minigrep</code> agora pode fazer
busca insensível a maiúsculas e minúsculas controlada por uma variável de ambiente. Agora você
sabe como gerenciar as opções definidas usando argumentos de linha de comando ou variáveis de ambiente!</p>
<p>Alguns programas permitem argumentos <em>and</em> variáveis de ambiente para a mesma
configuração. Nesses casos, os programas decidem que um ou outro tenham
precedência. Para outro exercício por conta própria, tente controlar o caso
insensibilidade através de um argumento de linha de comando ou uma variável de ambiente
. Decida se o argumento da linha de comando ou a variável de ambiente
deve ter precedência se o programa for executado com um conjunto para diferenciação de maiúsculas e minúsculas
ou um conjunto para maiúsculas e minúsculas insensível.</p>
<p>O módulo <code>std::env</code> contém muitos mais recursos úteis para lidar com
variáveis de ambiente: confira sua documentação para ver o que está disponível.</p>
<a class="header" href="print.html#escrevendo-mensagens-de-erro-para-erro-padrão-em-vez-de-saída-padrão" id="escrevendo-mensagens-de-erro-para-erro-padrão-em-vez-de-saída-padrão"><h2>Escrevendo Mensagens de Erro para Erro Padrão em Vez de Saída Padrão</h2></a>
<p>No momento, estamos escrevendo toda a nossa saída para o terminal usando a função
<code>println!</code>. A maioria dos terminais fornece dois tipos de saída: <em>saída padrão</em>
(<code>stdout</code>) para informações gerais e <em>erro padrão</em> (<code>stderr</code>) para mensagens
de erro. Essa distinção permite que os usuários escolham direcionar a saída
bem-sucedida de um programa para um arquivo, mas ainda imprimir mensagens de erro na tela.</p>
<p>A função <code>println!</code> só é capaz de imprimir na saída padrão, então temos
que usar outra coisa para imprimir em erro padrão.</p>
<a class="header" href="print.html#verificando-onde-os-erros-são-escritos" id="verificando-onde-os-erros-são-escritos"><h3>Verificando Onde os Erros são Escritos</h3></a>
<p>Primeiro, vamos observar como o conteúdo impresso por <code>minigrep</code> está sendo
gravado na saída padrão, incluindo as mensagens de erro que desejamos gravar
no erro padrão. Faremos isso redirecionando o fluxo de saída padrão para um arquivo e,
ao mesmo tempo, causando um erro intencionalmente. Não redirecionamos o fluxo de
erros padrão, portanto, qualquer conteúdo enviado ao erro padrão continuará sendo exibido na tela.</p>
<p>Espera-se que os programas de linha de comando enviem mensagens de erro para o fluxo erro padrão
, para que ainda possamos ver mensagens de erro na tela, mesmo se redirecionarmos o fluxo
de saída padrão para um arquivo. Nosso programa não está bem comportado: estamos prestes a ver
que ele salva a saída da mensagem de erro em um arquivo!</p>
<p>A maneira de demonstrar este comportamento é rodando o programa com <code>&gt;</code> e o
nome do arquivo, <em>output.txt</em>, para o qual queremos redirecionar o fluxo de saída padrão.
Não passamos nenhum argumento, o que deve causar um erro:</p>
<pre><code class="language-text">$ cargo run &gt; output.txt
</code></pre>
<p>A sintaxe <code>&gt;</code> diz ao shell para gravar o conteúdo da saída padrão para
<em>output.txt</em> em vez da tela. Nós não vimos a mensagem de erro que estávamos
esperando impresso na tela, o que significa que deve ter acabado no
arquivo. Isto é o que o <em>output.txt</em> contém:</p>
<pre><code class="language-text">Problem parsing arguments: not enough arguments
</code></pre>
<p>Sim, nossa mensagem de erro está sendo impressa na saída padrão. É muito mais
útil que mensagens de erro como essa sejam impressas no erro padrão e que somente
os dados de uma execução bem-sucedida acabem no arquivo quando redirecionamos a
saída padrão dessa maneira. Nós vamos mudar isso.</p>
<a class="header" href="print.html#imprimindo-erros-em-padrão-de-erros" id="imprimindo-erros-em-padrão-de-erros"><h3>Imprimindo Erros em Padrão de Erros</h3></a>
<p>Usaremos o código da Listagem 12-24 para alterar a forma como as mensagens de erro são impressas.
Por causa da refatoração que fizemos anteriormente neste capítulo, todo o código que
imprime mensagens de erro está em uma função, <code>main</code>. A biblioteca padrão fornece a
macro <code>eprintln!</code> que imprime no fluxo de erro padrão, então vamos alterar os dois
locais que estávamos chamando <code>println!</code> para imprimir erros para usar <code>eprintln!</code>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        eprintln!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    if let Err(e) = minigrep::run(config) {
        eprintln!(&quot;Application error: {}&quot;, e);

        process::exit(1);
    }
}
</code></pre>
<p><span class="caption">Listagem 12-24: Escrevendo mensagens de erro para o erro padrão
em vez da saída padrão usando o <code>eprintln!</code></span></p>
<p>Depois de alterar <code>println!</code> para <code>eprintln!</code>, vamos executar o programa novamente
da mesma forma, sem argumentos e redirecionando a saída padrão com <code>&gt;</code>:</p>
<pre><code class="language-text">$ cargo run &gt; output.txt
Problem parsing arguments: not enough arguments
</code></pre>
<p>Agora vemos o erro na tela e o <em>output.txt</em> não contém nada, que é o
comportamento esperado dos programas de linha de comando.</p>
<p>Vamos executar o programa novamente com argumentos que não causam erro, mas ainda
redirecionamos a saída padrão para um arquivo, da seguinte forma:</p>
<pre><code class="language-text">$ cargo run to poem.txt &gt; output.txt
</code></pre>
<p>Não veremos nenhuma saída para o terminal e <em>output.txt</em> conterá nossos
resultados:</p>
<p><span class="filename">Arquivo: output.txt</span></p>
<pre><code class="language-text">Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>Isso demonstra que agora estamos usando a saída padrão para saída bem-sucedida e
erro padrão para saída de erro, apropriadamente.</p>
<a class="header" href="print.html#resumo-6" id="resumo-6"><h2>Resumo</h2></a>
<p>Neste capítulo, recapitulamos alguns dos principais conceitos que você aprendeu até agora
e abordamos como realizar operações de E/S comuns em um contexto Rust. Usando argumentos
de linha de comando, arquivos, variáveis de ambiente e a macro <code>eprintln!</code> para
erros de impressão, você está preparado para escrever aplicativos de linha de comando. Usando
os conceitos dos capítulos anteriores, seu código será bem organizado, armazenará dados de forma
eficaz nas estruturas de dados apropriadas, tratará erros com precisão e será bem testado.</p>
<p>Em seguida, exploraremos alguns recursos do Rust que foram influenciados por linguagens
funcionais: closures e iteradores.</p>
<a class="header" href="print.html#functional-language-features-in-rust" id="functional-language-features-in-rust"><h1>Functional Language Features in Rust</h1></a>
<a class="header" href="print.html#closures" id="closures"><h1>Closures</h1></a>
<a class="header" href="print.html#iterators" id="iterators"><h1>Iterators</h1></a>
<a class="header" href="print.html#improving-our-io-project" id="improving-our-io-project"><h1>Improving our I/O Project</h1></a>
<a class="header" href="print.html#performance" id="performance"><h1>Performance</h1></a>
<a class="header" href="print.html#more-about-cargo-and-cratesio" id="more-about-cargo-and-cratesio"><h1>More about Cargo and Crates.io</h1></a>
<a class="header" href="print.html#release-profiles" id="release-profiles"><h1>Release Profiles</h1></a>
<a class="header" href="print.html#publishing-a-crate-to-cratesio" id="publishing-a-crate-to-cratesio"><h1>Publishing a Crate to Crates.io</h1></a>
<a class="header" href="print.html#cargo-workspaces" id="cargo-workspaces"><h1>Cargo Workspaces</h1></a>
<a class="header" href="print.html#installing-binaries-from-cratesio-with-cargo-install" id="installing-binaries-from-cratesio-with-cargo-install"><h1>Installing Binaries from Crates.io with <code>cargo install</code></h1></a>
<a class="header" href="print.html#extending-cargo-with-custom-commands" id="extending-cargo-with-custom-commands"><h1>Extending Cargo with Custom Commands</h1></a>
<a class="header" href="print.html#ponteiros-inteligentes-smart-pointers" id="ponteiros-inteligentes-smart-pointers"><h1>Ponteiros Inteligentes (Smart Pointers)</h1></a>
<p>Um <em>ponteiro</em> é um conceito geral para uma variável que contém um endereço de
memória. Esse endereço se refere a, ou &quot;aponta para&quot;, algum outro dado. O tipo
mais comum de ponteiro em Rust é a referência, sobre a qual você aprendeu no
Capítulo 4. Referências são indicadas pelo símbolo <code>&amp;</code>, e pegam emprestado o
valor para o qual apontam. Elas não têm nenhuma outra habilidade senão
referir-se a dados. Além disso, elas não têm nenhum custo adicional e são o tipo
de ponteiro que usamos com maior frequência.</p>
<p><em>Ponteiros inteligentes</em> (<em>smart pointers</em>), por outro lado, são estruturas de
dados que agem como um ponteiro mas também têm metadados e habilidades
adicionais. O conceito de ponteiros inteligentes não é exclusivo do Rust: ele
teve origem no C++ e também existe em outras linguagens. No Rust, os diferentes
ponteiros inteligentes definidos na biblioteca padrão proveem funcionalidades
além daquelas providas pelas referências. Um exemplo que vamos explorar neste
capítulo é o tipo de ponteiro inteligente de <em>contagem de referências</em>
(<em>reference counting</em>). Esse ponteiro lhe permite ter múltiplos possuidores de
um dado. Ele mantém registro do número de possuidores e, quando não resta
nenhum, cuida de limpar o dado.</p>
<p>Em Rust, onde temos os conceitos de posse (<em>ownership</em>) e empréstimo
(<em>borrowing</em>), uma diferença adicional entre referências e ponteiros
inteligentes é que referências são ponteiros que apenas <em>pegam emprestados</em> os
dados; em contraste, em muitos casos, ponteiros inteligentes <em>têm posse</em> dos
dados aos quais apontam.</p>
<p>Nós já encontramos alguns ponteiros inteligentes neste livro, como <code>String</code> e
<code>Vec&lt;T&gt;</code> no Capítulo 8, apesar de não os termos chamado de ponteiros
inteligentes naquele momento. Ambos esses tipos contam como ponteiros
inteligentes porque eles têm posse de uma parte da memória e permitem que você a
manipule. Eles também têm metadados (como sua capacidade) e habilidades extras
ou garantias (como a garantia que <code>String</code> dá de que seus dados serão sempre
UTF-8 válido).</p>
<p>Ponteiros inteligentes normalmente são implementados usando structs. A
característica que distingue um ponteiro inteligente de uma struct qualquer é
que ele implementa as traits <code>Deref</code> e <code>Drop</code>. A trait <code>Deref</code> permite que uma
instância da struct do ponteiro inteligente se comporte como uma referência.
Assim podemos escrever código que funcione tanto com referências quanto com
ponteiros inteligentes. A trait <code>Drop</code> nos permite personalizar o código que é
executado quando uma instância do smart pointer sai de escopo. Neste capítulo,
discutiremos ambas as traits e demonstraremos porque são importantes para
ponteiros inteligentes.</p>
<p>Dado que os ponteiros inteligentes são um padrão de projeto (<em>design pattern</em>)
usado com frequência em Rust, este capítulo não irá cobrir todo ponteiro
inteligente que existe. Muitas bibliotecas têm seus próprios ponteiros
inteligentes, e você pode até mesmo criar seus próprios. Nós vamos cobrir os
ponteiros inteligentes mais comuns na biblioteca padrão:</p>
<ul>
<li><code>Box&lt;T&gt;</code>, para alocar valores no heap</li>
<li><code>Rc&lt;T&gt;</code>, um tipo com contagem de referências que permite posse múltipla</li>
<li><code>Ref&lt;T&gt;</code> e <code>RefMut&lt;T&gt;</code>, acessados através de <code>RefCell&lt;T&gt;</code>, um tipo que aplica
as regras de empréstimo em tempo de execução em vez de em tempo de compilação</li>
</ul>
<p>Além disso, vamos cobrir a pattern de <em>mutabilidade interior</em> (<em>interior
mutability</em>), onde um tipo imutável expõe uma API para modificar um valor
interno. Também vamos discutir <em>ciclos de referências</em>: como eles podem vazar
memória e como evitá-los.</p>
<p>Mergulhemos!</p>
<a class="header" href="print.html#boxt-aponta-para-dados-no-heap-e-tem-tamanho-conhecido" id="boxt-aponta-para-dados-no-heap-e-tem-tamanho-conhecido"><h2><code>Box&lt;T&gt;</code> Aponta para Dados no Heap e Tem Tamanho Conhecido</h2></a>
<p>O ponteiro inteligente mais simples é um <em>box</em> (literalmente, &quot;caixa&quot;), cujo
tipo é escrito <code>Box&lt;T&gt;</code>. <em>Boxes</em> (plural de <em>box</em>) lhe permitem armazenar dados
no heap em vez de na pilha. O que fica na pilha é o ponteiro para o dado no
heap. Confira o Capítulo 4 para rever a diferença entre pilha e heap.</p>
<p>Boxes não têm custo adicional de desempenho além de armazenar dados no heap em
vez de na pilha. Mas eles também não têm muitas habilidades a mais. Você irá
usá-los mais comumente nestas situações:</p>
<ul>
<li>Quando você tem um tipo cujo tamanho não é possível saber em tempo de
compilação, e você quer usar um valor desse tipo em um contexto que precisa
saber um tamanho exato;</li>
<li>Quando você tem uma quantidade grande de dados e você quer transferir a posse
mas garantir que os dados não serão copiados quando você o fizer;</li>
<li>Quando você quer possuir um valor e só se importa se é um tipo que implementa
uma trait específica, em vez de saber o tipo concreto.</li>
</ul>
<p>Vamos demonstrar a primeira situação nesta seção. Mas antes disso, vamos falar
um pouco mais sobre as outras duas situações: no segundo caso, transferir posse
de uma quantidade grande de dados pode levar muito tempo porque os dados são
copiados de um lado para o outro na pilha. Para melhorar o desempenho nessa
situação, podemos armazenar essa quantidade grande de dados no heap em um box.
Assim, apenas uma quantidade pequena de dados referentes ao ponteiro é copiada
na pilha, e os dados em si ficam em um lugar só no heap. O terceiro caso é
conhecido como um <em>objeto de trait</em> (<em>trait object</em>), e o Capítulo 17 dedica uma
seção inteira somente a esse tópico. Então o que você aprender aqui você irá
aplicar de novo no Capítulo 17!</p>
<a class="header" href="print.html#usando-um-boxt-para-armazenar-dados-no-heap" id="usando-um-boxt-para-armazenar-dados-no-heap"><h3>Usando um <code>Box&lt;T&gt;</code> para Armazenar Dados no Heap</h3></a>
<p>Antes de discutirmos esse caso de uso para o <code>Box&lt;T&gt;</code>, vamos cobrir a sintaxe e
como interagir com valores armazenados dentro de um <code>Box&lt;T&gt;</code>.</p>
<p>A Listagem 15-1 mostra como usar um box para armazenar um valor <code>i32</code> no heap:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let b = Box::new(5);
    println!(&quot;b = {}&quot;, b);
}
</code></pre></pre>
<p><span class="caption">Listagem 15-1: Armazenando um valor <code>i32</code> no heap usando
um box</span></p>
<p>Nós definimos a variável <code>b</code> como tendo o valor de um <code>Box</code> que aponta para o
valor <code>5</code>, que está alocado no heap. Esse programa irá imprimir <code>b = 5</code>; nesse
caso, podemos acessar o dado no box de um jeito similar ao que usaríamos se esse
dado estivesse na pilha. Da mesma forma que com qualquer valor possuído, quando
um box sai de escopo, como o <code>b</code> no fim da <code>main</code>, ele é desalocado. A
desalocação acontece para o box (armazenado na pilha) e para os dados aos quais
ele aponta (armazenados no heap).</p>
<p>Colocar um único valor no heap não é muito útil, então você normalmente não vai
usar boxes sozinhos desse jeito. Ter valores como um único <code>i32</code> na pilha, onde
são armazenados por padrão, é mais apropriado para a maioria das situações.
Vamos dar uma olhada em um caso onde o box nos possibilita definir tipos que não
poderíamos definir sem ele.</p>
<a class="header" href="print.html#boxes-possibilitam-tipos-recursivos" id="boxes-possibilitam-tipos-recursivos"><h3>Boxes Possibilitam Tipos Recursivos</h3></a>
<p>Em tempo de compilação, o Rust precisa saber quanto espaço um tipo ocupa. Um
<em>tipo recursivo</em> (<em>recursive type</em>), onde um valor pode ter como parte de si
mesmo outro valor do mesmo tipo, é um tipo cujo tamanho não se pode saber em
tempo de compilação. Como esse aninhamento de valores poderia em teoria
continuar infinitamente, o Rust não sabe quanto espaço um valor de um tipo
recursivo precisa. Porém, boxes têm um tamanho conhecido, então podemos ter
tipos recursivos inserindo um box em sua definição.</p>
<p>Vamos explorar a <em>lista ligada</em> (<em>cons list</em>), que é um tipo de dados comum em
linguagens de programação funcional, como um exemplo de tipo recursivo. O tipo
para lista ligada que vamos definir é bem básico exceto pela recursão; portanto,
os conceitos no exemplo que vamos trabalhar vão ser úteis sempre que você se
encontrar em situações mais complexas envolvendo tipos recursivos.</p>
<a class="header" href="print.html#mais-informações-sobre-a-cons-list" id="mais-informações-sobre-a-cons-list"><h4>Mais Informações sobre a Cons List</h4></a>
<p>A <em>cons list</em> é uma estrutura de dados que vem da linguagem de programação Lisp
e seus dialetos. Em Lisp, a função <code>cons</code> (abreviação de &quot;construction
function&quot;, função de construção) constrói um novo par a partir de seus dois
argumentos, que geralmente são um valor único e um outro par. Esses pares
contendo pares formam uma lista.</p>
<p>O conceito da função cons acabou se tornando parte do jargão mais geral de
programação funcional: &quot;to cons x onto y&quot; (&quot;consar&quot; x em y, grosso modo) em
inglês informalmente significa construir uma nova instância de um par, colocando
o elemento x no começo desse novo par, seguido pelo par y.</p>
<p>Cada item em uma cons list contém dois elementos: o valor do item atual e o
próximo item. O último item na lista contém apenas um valor chamado de <code>Nil</code>,
sem um próximo item. Uma cons list é produzida chamando-se recursivamente a
função <code>cons</code>. O nome canônico que denota o caso base da recursão é <code>Nil</code>. Note
que isso não é o mesmo que o conceito de &quot;null&quot; ou &quot;nil&quot; visto no Capítulo 6,
que é um valor inválido ou ausente.</p>
<p>Apesar de linguagens de programação funcionais usarem cons lists frequentemente,
essa não é uma estrutura de dados muito usada em Rust. Na maioria das vezes em
que você tem uma lista de itens em Rust, <code>Vec&lt;T&gt;</code> é uma escolha melhor. Outros
tipos recursivos <em>são</em> úteis em diversas situações. Mas começando com a cons
list, podemos explorar como boxes nos permitem definir um tipo recursivo sem
muita distração.</p>
<p>A Listagem 15-2 contém uma definição de um enum para a cons list. Note que este
código não compila ainda porque o tipo <code>List</code> não tem um tamanho conhecido, como
demonstraremos:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">enum List {
    Cons(i32, List),
    Nil,
}
</code></pre>
<p><span class="caption">Listagem 15-2: A primeira tentativa de definir um enum
para representar uma estrutura de dados <em>cons list</em> de valores <code>i32</code> </span></p>
<blockquote>
<p>Nota: estamos implementando uma cons list que guarda apenas valores <code>i32</code> para
os propósitos deste exemplo. Poderíamos tê-la implementado usando tipos
genéricos, conforme discutimos no Capítulo 10, para definir um tipo cons list
que poderia armazenar valores de qualquer tipo.</p>
</blockquote>
<p>A listagem 15-3 mostra como fica o uso do tipo <code>List</code> para armazenar a lista
<code>1, 2, 3</code>.</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">use List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}
</code></pre>
<p><span class="caption">Listagem 15-3: Usando o enum <code>List</code> para armazenar a lista
<code>1, 2, 3</code></span></p>
<p>O primeiro valor <code>Cons</code> contém <code>1</code> e outro valor <code>List</code>. Esse valor <code>List</code> é
outro <code>Cons</code> que contém <code>2</code> e outro valor <code>List</code>. Esse valor <code>List</code> é mais um
<code>Cons</code> que contém 3 e um valor <code>List</code>, que finalmente é <code>Nil</code>, a variante não
recursiva que sinaliza o final da lista.</p>
<p>Se tentarmos compilar o código na listagem 15-3, receberemos o erro mostrado na
listagem 15-4:</p>
<pre><code class="language-text">erro[E0072]: tipo recursivo `List` tem tamanho infinito
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^ tipo recursivo tem tamanho infinito
2 |     Cons(i32, List),
  |               ----- recursivo sem indireção
  |
  = ajuda: insira indireção (ex.: um `Box`, `Rc` ou `&amp;`) em algum lugar para
  tornar `List` representável
</code></pre>
<p><span class="caption">Listagem 15-4: O erro que recebemos quando tentamos
definir um enum recursivo</span></p>
<p>O erro diz que esse tipo &quot;tem tamanho infinito&quot;. A razão é que nós definimos
<code>List</code> com uma variante que é recursiva: ela contém um outro valor de si mesma
diretamente. Como resultado, o Rust não consegue determinar quanto espaço ele
precisa para armazenar um valor <code>List</code>. Vamos analizar por partes por que
recebemos esse erro: primeiro, vamos ver como o Rust decide quanto espaço
precisa para armazenar o valor de um tipo <em>não</em> recursivo.</p>
<a class="header" href="print.html#computando-o-tamanho-de-um-tipo-não-recursivo" id="computando-o-tamanho-de-um-tipo-não-recursivo"><h4>Computando o Tamanho de um Tipo Não Recursivo</h4></a>
<p>Recorde o enum <code>Mensagem</code> que definimos na Listagem 6-2 quando discutimos
definições de enums no Capítulo 6:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Mensagem {
    Sair,
    Mover { x: i32, y: i32 },
    Escrever(String),
    MudarCor(i32, i32, i32),
}
#}</code></pre></pre>
<p>Para determinar quanto espaço alocar para um valor <code>Mensagem</code>, o Rust percorre
cada variante para ver qual precisa de mais espaço. O Rust vê que
<code>Mensagem::Sair</code> não precisa de nenhum espaço, <code>Mensagem::Mover</code> precisa de
espaço suficiente para armazenar dois valores <code>i32</code>, e assim por diante. Como
apenas uma variante será usada, o máximo de espaço de que um valor <code>Mensagem</code>
vai precisar é o espaço que levaria para armazenar a maior de suas variantes.</p>
<p>Contraste isso com o que acontece quando o Rust tenta determinar quanto espaço é
necessário para um tipo recursivo como o enum <code>List</code> na Listagem 15-2. O
compilador começa olhando a variante <code>Cons</code>, que contém um valor do tipo <code>i32</code> e
um valor do tipo <code>List</code>. Portanto, <code>Cons</code> precisa de uma quantidade de espaço
igual ao tamanho de um <code>i32</code> mais o tamanho de um <code>List</code>. Para determinar de
quanta memória o tipo <code>List</code> precisa, o compilador olha para suas variantes,
começando com a <code>Cons</code>. A variante <code>Cons</code> contém um valor do tipo <code>i32</code> e um
valor do tipo <code>List</code>, e esse processo continua infinitamente, conforme mostra a
Figura 15-1:</p>
<p><img alt="Uma cons list infinita" src="img/trpl15-01.svg" class="center"
style="width: 50%;" /></p>
<p><span class="caption">Figura 15-1: Uma <code>List</code> infinita feita de infinitas
variantes <code>Cons</code></span></p>
<a class="header" href="print.html#usando-boxt-para-conseguir-um-tipo-recursivo-de-tamanho-conhecido" id="usando-boxt-para-conseguir-um-tipo-recursivo-de-tamanho-conhecido"><h4>Usando <code>Box&lt;T&gt;</code> para Conseguir um Tipo Recursivo de Tamanho Conhecido</h4></a>
<p>Como o Rust não consegue descobrir quanto espaço alocar para tipos definidos
recursivamente, o compilador dá o erro na Listagem 15-4. Mas o erro inclui esta
útil sugestão:</p>
<pre><code class="language-text">  = ajuda: insira indireção (ex.: um `Box`, `Rc` ou `&amp;`) em algum lugar para
  tornar `List` representável
</code></pre>
<p>Nessa sugestão, &quot;indireção&quot; significa que, em vez de armazenar um valor
diretamente, devemos mudar a estrutura de dados para armazenar um ponteiro para
o valor.</p>
<p>Como um <code>Box&lt;T&gt;</code> é um ponteiro, o Rust sempre sabe de quanto espaço ele precisa:
o tamanho de um ponteiro não muda dependendo da quantidade de dados para a qual
ele aponta. Isso significa que podemos colocar um <code>Box&lt;T&gt;</code> dentro da variante
<code>Cons</code> em vez de outro valor <code>List</code> diretamente. O <code>Box&lt;T&gt;</code> vai apontar para o
próximo valor <code>List</code>, que vai estar no heap em vez de dentro da variante <code>Cons</code>.
Conceitualmente, ainda temos uma lista, criada de listas &quot;contendo&quot; outras
listas, mas essa implementação agora é mais como os itens estando um do lado do
outro do que um dentro do outro.</p>
<p>Podemos mudar a definição do enum <code>List</code> na Listagem 15-2 e o uso de <code>List</code> na
Listagem 15-3 para o código na Listagem 15-5, que compila:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use List::{Cons, Nil};

fn main() {
    let list = Cons(1,
        Box::new(Cons(2,
            Box::new(Cons(3,
                Box::new(Nil))))));
}
</code></pre></pre>
<p><span class="caption">Listagem 15-5: Definição de <code>List</code> que usa <code>Box&lt;T&gt;</code> para
ter um tamanho conhecido</span></p>
<p>A variante <code>Cons</code> vai precisar do tamanho de um <code>i32</code> mais o espaço para
armazenar os dados do ponteiro box. A variante <code>Nil</code> não armazena nenhum valor,
então ela precisa de menos espaço que a variante <code>Cons</code>. Agora sabemos que
qualquer valor <code>List</code> irá ocupar o tamanho de um <code>i32</code> mais o tamanho dos dados
de um ponteiro box. Usando um box, nós quebramos a cadeia recursiva, infinita,
para que o compilador pudesse determinar o espaço que ele precisa para
armarzenar um valor <code>List</code>. A Figura 15-2 mostra como ficou a variante <code>Cons</code>
agora:</p>
<p><img alt="Uma lista de Cons infinita" src="img/trpl15-02.svg" class="center" /></p>
<p><span class="caption">Figura 15-2: Um <code>List</code> que não tem tamanho infinito porque
<code>Cons</code> contém um <code>Box</code></span></p>
<p>Boxes apenas proveem a indireção e a alocação no heap; eles não têm nenhuma
outra habilidade especial, como as que vamos ver nos outros tipos de ponteiros
inteligentes. Eles também não têm nenhum dos custos adicionais de desempenho que
essas habilidades demandam, então eles podem ser úteis em casos como o da cons
list onde a indireção é a única funcionalidade de que precisamos. No Capítulo
17 também vamos ver mais casos de uso para as boxes.</p>
<p>O tipo <code>Box&lt;T&gt;</code> é um ponteiro inteligente porque ele implementa a trait <code>Deref</code>,
o que permite que valores <code>Box&lt;T&gt;</code> sejam usados como referências. Quando um
valor <code>Box&lt;T&gt;</code> sai de escopo, os dados do heap para os quais o box aponta também
são liberados porque o tipo implementa a trait <code>Drop</code>. Vamos explorar essas duas
traits em mais detalhe. Elas serão ainda mais importantes para a funcionalidade
provida pelos outros ponteiros inteligentes que vamos discutir no resto deste
capítulo.</p>
<a class="header" href="print.html#tratando-ponteiros-inteligentes-como-referências-normais-com-a-trait-deref" id="tratando-ponteiros-inteligentes-como-referências-normais-com-a-trait-deref"><h2>Tratando Ponteiros Inteligentes como Referências Normais com a Trait <code>Deref</code></h2></a>
<p>Implementar a trait <code>Deref</code> nos permite personalizar o comportamento do
<em>operador de desreferência</em> (<em>dereference operator</em>), <code>*</code> (que é diferente do
operador de multiplicação ou de glob). Implementando a <code>Deref</code> de tal modo que o
ponteiro inteligente possa ser tratado como uma referência normal, podemos
escrever código que opere sobre referências e usar esse código com ponteiros
inteligentes também.</p>
<p>Primeiro vamos ver como o <code>*</code> funciona com referências normais, e então vamos
tentar definir nosso próprio tipo a la <code>Box&lt;T&gt;</code> e ver por que o <code>*</code> não funciona
como uma referência no nosso tipo recém-criado. Vamos explorar como a trait
<code>Deref</code> torna possível aos ponteiros inteligentes funcionarem de um jeito
similar a referências. E então iremos dar uma olhada na funcionalidade de
<em>coerção de desreferência</em> (<em>deref coercion</em>) e como ela nos permite trabalhar
tanto com referências quanto com ponteiros inteligentes.</p>
<a class="header" href="print.html#seguindo-o-ponteiro-até-o-valor-com-" id="seguindo-o-ponteiro-até-o-valor-com-"><h3>Seguindo o Ponteiro até o Valor com <code>*</code></h3></a>
<p>Uma referência normal é um tipo de ponteiro, e um jeito de pensar sobre um
ponteiro é como uma seta até um valor armazenado em outro lugar. Na Listagem
15-6, nós criamos uma referência a um valor <code>i32</code> e em seguida usamos o operador
de desreferência para seguir a referência até o dado:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 5;
    let y = &amp;x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre></pre>
<p><span class="caption">Listagem 15-6: Usando o operador de desreferência para
seguir uma referência a um valor <code>i32</code></span></p>
<p>A variável <code>x</code> contém um valor <code>i32</code>, <code>5</code>. Nós setamos <code>y</code> igual a uma
referência a <code>x</code>. Podemos conferir (coloquialmente, &quot;assertar&quot;) que <code>x</code> é igual
a <code>5</code>. Contudo, se queremos fazer uma asserção sobre o valor em <code>y</code>, temos que
usar <code>*y</code> para seguir a referência até o valor ao qual <code>y</code> aponta (por isso
&quot;desreferência&quot;). Uma vez que desreferenciamos <code>y</code>, temos acesso ao valor
inteiro ao qual <code>y</code> aponta para podermos compará-lo com <code>5</code>.</p>
<p>Se em vez disso tentássemos escrever <code>assert_eq!(5, y);</code>, receberíamos este erro
de compilação:</p>
<pre><code class="language-text">erro[E0277]: a trait bound `{integer}: std::cmp::PartialEq&lt;&amp;{integer}&gt;` não foi
satisfeita
 --&gt; src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^^ não posso comparar `{integer}` com `&amp;{integer}`
  |
  = ajuda: a trait `std::cmp::PartialEq&lt;&amp;{integer}&gt;` não está implementada para
  `{integer}`
</code></pre>
<p>Comparar um número com uma referência a um número não é permitido porque eles
são de tipos diferentes. Devemos usar <code>*</code> para seguir a referência até o valor
ao qual ela está apontando.</p>
<a class="header" href="print.html#usando-boxt-como-uma-referência" id="usando-boxt-como-uma-referência"><h3>Usando <code>Box&lt;T&gt;</code> como uma Referência</h3></a>
<p>Podemos reescrever o código na Listagem 15-6 para usar um <code>Box&lt;T&gt;</code> em vez de uma
referência, e o operador de desreferência vai funcionar do mesmo jeito que na
Listagem 15-7:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre></pre>
<p><span class="caption">Listagem 15-7: Usando o operador de desreferência em um
<code>Box&lt;i32&gt;</code></span></p>
<p>A única diferença entre a Listagem 15-7 e a Listagem 15-6 é que aqui nós setamos
<code>y</code> para ser uma instância de um box apontando para o valor em <code>x</code> em vez de uma
referência apontando para o valor de <code>x</code>. Na última asserção, podemos usar o
operador de desreferência para seguir o ponteiro do box do mesmo jeito que
fizemos quando <code>y</code> era uma referência. A seguir, vamos explorar o que tem de
especial no <code>Box&lt;T&gt;</code> que nos permite usar o operador de desreferência, criando
nosso próprio tipo box.</p>
<a class="header" href="print.html#definindo-nosso-próprio-ponteiro-inteligente" id="definindo-nosso-próprio-ponteiro-inteligente"><h3>Definindo Nosso Próprio Ponteiro Inteligente</h3></a>
<p>Vamos construir um smart pointer parecido com o tipo <code>Box&lt;T&gt;</code> fornecido pela
biblioteca padrão para vermos como ponteiros inteligentes, por padrão, se
comportam diferente de referências. Em seguida, veremos como adicionar a
habilidade de usar o operador de desreferência.</p>
<p>O tipo <code>Box&lt;T&gt;</code> no fim das contas é definido como uma struct-tupla (<em>tuple
struct</em>) de um elemento, então a Listagem 15-8 define um tipo <code>MeuBox&lt;T&gt;</code> da
mesma forma. Também vamos definir uma função <code>new</code> como a definida no <code>Box&lt;T&gt;</code>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct MeuBox&lt;T&gt;(T);

impl&lt;T&gt; MeuBox&lt;T&gt; {
    fn new(x: T) -&gt; MeuBox&lt;T&gt; {
        MeuBox(x)
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 15-8: Definindo um tipo <code>MeuBox&lt;T&gt;</code></span></p>
<p>Definimos um struct chamado <code>MeuBox</code> e declaramos um parâmetro genérico <code>T</code>,
porque queremos que nosso tipo contenha valores de qualquer tipo. O tipo
<code>MeuBox</code> é uma struct-tupla de um elemento do tipo <code>T</code>. A função <code>MeuBox::new</code>
recebe um argumento do tipo <code>T</code> e retorna uma instância de <code>MeuBox</code> que contém o
valor passado.</p>
<p>Vamos tentar adicionar a função <code>main</code> da Listagem 15-7 à Listagem 15-8 e
alterá-la para usar o tipo <code>MeuBox&lt;T&gt;</code> que definimos em vez de <code>Box&lt;T&gt;</code>. O
código na Listagem 15-9 não irá compilar porque o Rust não sabe como
desreferenciar <code>MeuBox</code>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let x = 5;
    let y = MeuBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre>
<p><span class="caption">Listagem 15-9: Tentando usar o <code>MeuBox&lt;T&gt;</code> do mesmo jeito
que usamos referências e o <code>Box&lt;T&gt;</code></span></p>
<p>Aqui está o erro de compilação resultante:</p>
<pre><code class="language-text">erro[E0614]: tipo `MeuBox&lt;{integer}&gt;` não pode ser desreferenciado
  --&gt; src/main.rs:14:19
   |
14 |     assert_eq!(5, *y);
   |                   ^^
</code></pre>
<p>Nosso tipo <code>MeuBox&lt;T&gt;</code> não pode ser desreferenciado porque não implementamos
essa habilidade nele. Para habilitar desreferenciamento com o operador <code>*</code>,
temos que implementar a trait <code>Deref</code>.</p>
<a class="header" href="print.html#implementando-a-trait-deref-para-tratar-um-tipo-como-uma-referência" id="implementando-a-trait-deref-para-tratar-um-tipo-como-uma-referência"><h3>Implementando a Trait <code>Deref</code> para Tratar um Tipo como uma Referência</h3></a>
<p>Conforme discutimos no Capítulo 10, para implementar uma trait, precisamos
prover implementações para os métodos exigidos por ela. A trait <code>Deref</code>,
disponibilizada pela biblioteca padrão, requer que implementemos um método
chamado <code>deref</code> que pega emprestado <code>self</code> e retorna uma referência para os
dados internos. A Listagem 15-10 contém uma implementação de <code>Deref</code> que
agrega à definição de <code>MeuBox</code>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::ops::Deref;

# struct MeuBox&lt;T&gt;(T);
impl&lt;T&gt; Deref for MeuBox&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        &amp;self.0
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 15-10: Implementando <code>Deref</code> no
<code>MeuBox&lt;T&gt;</code></span></p>
<p>A sintaxe <code>type Target = T;</code> define um tipo associado para a trait <code>Deref</code> usar.
Tipos associados são um jeito ligeiramente diferente de declarar um parâmetro
genérico, mas você não precisa se preocupar com eles por ora; iremos cobri-los
em mais detalhe no Capítulo 19.</p>
<p>Nós preenchemos o corpo do método <code>deref</code> com <code>&amp;self.0</code> para que <code>deref</code> retorne
uma referência ao valor que queremos acessar com o operador <code>*</code>. A função <code>main</code>
na Listagem 15-9 que chama <code>*</code> no valor <code>MeuBox&lt;T&gt;</code> agora compila e as asserções
passam!</p>
<p>Sem a trait <code>Deref</code>, o compilador só consegue desreferenciar referências <code>&amp;</code>. O
método <code>deref</code> dá ao compilador a habilidade de tomar um valor de qualquer tipo
que implemente <code>Deref</code> e chamar o método <code>deref</code> para pegar uma referência <code>&amp;</code>,
que ele sabe como desreferenciar.</p>
<p>Quando entramos <code>*y</code> na Listagem 15-9, por trás dos panos o Rust na verdade
rodou este código:</p>
<pre><code class="language-rust ignore">*(y.deref())
</code></pre>
<p>O Rust substitui o operador <code>*</code> com uma chamada ao método <code>deref</code> e em seguida
uma desreferência comum, de modo que nós programadores não precisamos pensar
sobre se temos ou não que chamar o método <code>deref</code>. Essa funcionalidade do Rust
nos permite escrever código que funcione identicamente quando temos uma
referência comum ou um tipo que implementa <code>Deref</code>.</p>
<p>O fato de o método <code>deref</code> retornar uma referência ao valor, e a desreferência
comum fora dos parênteses em <code>*(y.deref())</code> ainda ser necessária, é devido ao
sistema de posse (<em>ownership</em>). Se o método <code>deref</code> retornasse o valor
diretamente em vez de uma referência ao valor, o valor seria movido para fora do
<code>self</code>. Nós não queremos tomar posse do valor interno do <code>MeuBox&lt;T&gt;</code> neste e na
maioria dos casos em que usamos o operador de desreferência.</p>
<p>Note que o <code>*</code> é substituído por uma chamada ao método <code>deref</code> e então uma
chamada ao <code>*</code> apenas uma vez, cada vez que digitamos um <code>*</code> no nosso código.
Como a substituição do <code>*</code> não entra em recursão infinita, nós terminamos com o
dado do tipo <code>i32</code>, que corresponde ao <code>5</code> em <code>assert_eq!</code> na Listagem 15-9.</p>
<a class="header" href="print.html#coerções-de-desreferência-implícitas-com-funções-e-métodos" id="coerções-de-desreferência-implícitas-com-funções-e-métodos"><h3>Coerções de Desreferência Implícitas com Funções e Métodos</h3></a>
<p><em>Coerção de desreferência</em> (<em>deref coercion</em>) é uma conveniência que o Rust
aplica a argumentos de funções e métodos. A coerção de desreferência converte
uma referência a um tipo que implementa <code>Deref</code> em uma referência a um tipo ao
qual a <code>Deref</code> pode converter o tipo original. A coerção de desreferência
acontece automaticamente quando passamos uma referência ao valor de um tipo
específico como argumento a uma função ou método e esse tipo não corresponde ao
tipo do parâmetro na definição da função ou método. Uma sequência de chamadas ao
método <code>deref</code> converte o tipo que providenciamos no tipo que o parâmetro exige.</p>
<p>A coerção de desreferência foi adicionada ao Rust para que programadores
escrevendo chamadas a métodos e funções não precisassem adicionar tantas
referências e desreferências explícitas com <code>&amp;</code> e <code>*</code>. A funcionalidade de
coerção de desreferência também nos permite escrever mais código que funcione
tanto com referências quanto com ponteiros inteligentes.</p>
<p>Para ver a coerção de desreferência em ação, vamos usar o tipo <code>MeuBox&lt;T&gt;</code> que
definimos na Listagem 15-8 e também a implementação de <code>Deref</code> que adicionamos
na Listagem 15-10. A Listagem 15-11 mostra a definição de uma função que tem um
parâmetro do tipo string slice:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn ola(nome: &amp;str) {
    println!(&quot;Olá, {}!&quot;, nome);
}
#}</code></pre></pre>
<p><span class="caption">Listagem 15-11: Uma função <code>ola</code> que tem um parâmetro
<code>nome</code> do tipo <code>&amp;str</code></span></p>
<p>Podemos chamar a função <code>ola</code> passando uma string slice como argumento, por
exemplo <code>ola(&quot;Rust&quot;);</code>. A coerção de desreferência torna possível chamar <code>ola</code>
com uma referência a um valor do tipo <code>MeuBox&lt;String&gt;</code>, como mostra a Listagem
15-12:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># use std::ops::Deref;
#
# struct MeuBox&lt;T&gt;(T);
#
# impl&lt;T&gt; MeuBox&lt;T&gt; {
#     fn new(x: T) -&gt; MeuBox&lt;T&gt; {
#         MeuBox(x)
#     }
# }
#
# impl&lt;T&gt; Deref for MeuBox&lt;T&gt; {
#     type Target = T;
#
#     fn deref(&amp;self) -&gt; &amp;T {
#         &amp;self.0
#     }
# }
#
# fn ola(name: &amp;str) {
#     println!(&quot;Olá, {}!&quot;, name);
# }
#
fn main() {
    let m = MeuBox::new(String::from(&quot;Rust&quot;));
    ola(&amp;m);
}
</code></pre></pre>
<p><span class="caption">Listagem 15-12: Chamando <code>ola</code> com uma referência a um
valor <code>MeuBox&lt;String&gt;</code>, o que só funciona por causa da coerção de
desreferência</span></p>
<p>Aqui estamos chamando a função <code>ola</code> com o argumento <code>&amp;m</code>, que é uma referência
a um valor <code>MeuBox&lt;String&gt;</code>. Como implementamos a trait <code>Deref</code> em <code>MeuBox&lt;T&gt;</code>
na Listagem 15-10, o Rust pode transformar <code>&amp;MeuBox&lt;String&gt;</code> em <code>&amp;String</code>
chamando <code>deref</code>. A biblioteca padrão provê uma implementação de <code>Deref</code> para
<code>String</code> que retorna uma string slice, documentada na API de <code>Deref</code>. O Rust
chama <code>deref</code> de novo para transformar o <code>&amp;String</code> em <code>&amp;str</code>, que corresponde à
definição da função <code>ola</code>.</p>
<p>Se o Rust não implementasse coerção de desreferência, teríamos que escrever o
código na Listagem 15-13 em vez do código na Listagem 15-12 para chamar <code>ola</code>
com um valor do tipo <code>&amp;MeuBox&lt;String&gt;</code>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># use std::ops::Deref;
#
# struct MeuBox&lt;T&gt;(T);
#
# impl&lt;T&gt; MeuBox&lt;T&gt; {
#     fn new(x: T) -&gt; MeuBox&lt;T&gt; {
#         MeuBox(x)
#     }
# }
#
# impl&lt;T&gt; Deref for MeuBox&lt;T&gt; {
#     type Target = T;
#
#     fn deref(&amp;self) -&gt; &amp;T {
#         &amp;self.0
#     }
# }
#
# fn ola(name: &amp;str) {
#     println!(&quot;Olá, {}!&quot;, name);
# }
#
fn main() {
    let m = MeuBox::new(String::from(&quot;Rust&quot;));
    ola(&amp;(*m)[..]);
}
</code></pre></pre>
<p><span class="caption">Listagem 15-13: O código que teríamos que escrever se o
Rust não tivesse coerção de desreferência</span></p>
<p>O <code>(*m)</code> desreferencia o <code>MeuBox&lt;String&gt;</code> em uma <code>String</code>. Então o <code>&amp;</code> e o
<code>[..]</code> obtêm uma string slice da <code>String</code> que é igual à string inteira para
corresponder à assinatura de <code>ola</code>. O código sem coerção de desreferência é mais
difícil de ler, escrever e entender com todos esses símbolos envolvidos. A
coerção de desreferência permite que o Rust lide com essas conversões
automaticamente para nós.</p>
<p>Quando a trait <code>Deref</code> está definida para os tipos envolvidos, o Rust analisa os
tipos e usa <code>Deref::deref</code> tantas vezes quanto necessário para chegar a uma
referência que corresponda ao tipo do parâmetro. O número de vezes que
<code>Deref::deref</code> precisa ser inserida é resolvido em tempo de compilação, então
não existe nenhuma penalidade em tempo de execução para tomar vantagem da
coerção de desreferência.</p>
<a class="header" href="print.html#como-a-coerção-de-desreferência-interage-com-a-mutabilidade" id="como-a-coerção-de-desreferência-interage-com-a-mutabilidade"><h3>Como a Coerção de Desreferência Interage com a Mutabilidade</h3></a>
<p>De modo semelhante a como usamos a trait <code>Deref</code> para redefinir <code>*</code> em
referências imutáveis, o Rust provê uma trait <code>DerefMut</code> para redefinir <code>*</code> em
referências mutáveis.</p>
<p>O Rust faz coerção de desreferência quando ele encontra tipos e implementações
de traits em três casos:</p>
<ul>
<li>De <code>&amp;T</code> para <code>&amp;U</code> quando <code>T: Deref&lt;Target=U&gt;</code>;</li>
<li>De <code>&amp;mut T</code> para <code>&amp;mut U</code> quando <code>T: DerefMut&lt;Target=U&gt;</code>;</li>
<li>De <code>&amp;mut T</code> para <code>&amp;U</code> quando <code>T: Deref&lt;Target=U&gt;</code>.</li>
</ul>
<p>Os primeiros dois casos são o mesmo exceto pela mutabilidade. O primeiro caso
afirma que se você tem uma <code>&amp;T</code>, e <code>T</code> implementa <code>Deref</code> para algum tipo <code>U</code>,
você pode obter um <code>&amp;U</code> de maneira transparente. O segundo caso afirma que a
mesma coerção de desreferência acontece para referências mutáveis.</p>
<p>O terceiro caso é mais complicado: o Rust também irá coagir uma referência
mutável a uma imutável. Mas o contrário <em>não</em> é possível: referências imutáveis
nunca serão coagidas a referências mutáveis. Por causa das regras de empréstimo,
se você tem uma referência mutável, ela deve ser a única referência àqueles
dados (caso contrário, o programa não compila). Converter uma referência mutável
a uma imutável nunca quebrará as regras de empréstimo. Converter uma referência
imutável a uma mutável exigiria que houvesse apenas uma referência imutável
àqueles dados, e as regras de empréstimo não garantem isso. Portanto, o Rust não
pode assumir que converter uma referência imutável a uma mutável seja possível.</p>
<a class="header" href="print.html#a-trait-drop-roda-código-durante-a-limpeza" id="a-trait-drop-roda-código-durante-a-limpeza"><h2>A Trait <code>Drop</code> Roda Código durante a Limpeza</h2></a>
<p>A segunda trait de importância para a pattern de ponteiros inteligentes é a
<code>Drop</code>, que nos permite personalizar o que acontece quando um valor está prestes
a sair de escopo. Nós podemos prover uma implementação da trait <code>Drop</code> para
qualquer tipo, e o código que especificarmos pode ser usado para liberar
recursos como arquivos ou conexões de rede. Estamos introduzindo <code>Drop</code> no
contexto de ponteiros inteligentes porque a funcionalidade da trait <code>Drop</code> é
usada quase sempre quando estamos implementando ponteiros inteligentes. Por
exemplo, o <code>Box&lt;T&gt;</code> customiza <code>Drop</code> para desalocar o espaço no heap para o qual
o box aponta.</p>
<p>Em algumas linguagens, a pessoa que está programando deve chamar código para
liberar memória ou recursos toda vez que ela termina de usar uma instância de um
ponteiro inteligente. Se ela esquece, o sistema pode ficar sobrecarregado e
falhar. No Rust, podemos especificar que um pedaço específico de código deva ser
rodado sempre que um valor sair de escopo, e o compilador irá inserir esse
código automaticamente. Assim, não precisamos cuidadosamente colocar código de
limpeza em todos os lugares de um programa em que uma instância de um tipo
específico deixa de ser usada, e ainda assim não vazaremos recursos!</p>
<p>Para especificar o código que vai rodar quando um valor sair de escopo, nós
implementamos a trait <code>Drop</code>. A trait <code>Drop</code> requer que implementemos um método
chamado <code>drop</code> que recebe uma referência mutável de <code>self</code>. Para ver quando o
Rust chama <code>drop</code>, vamos implementar <code>drop</code> com declarações de <code>println!</code> por
ora.</p>
<p>A Listagem 15-14 mostra uma struct <code>CustomSmartPointer</code>
(&quot;PonteiroInteligentePersonalizado&quot;) cuja única funcionalidade é que ela irá
imprimir <code>Destruindo CustomSmartPointer!</code> quando a instância sair de escopo.
Este exemplo demonstra quando o Rust roda a função <code>drop</code>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&amp;mut self) {
        println!(&quot;Destruindo CustomSmartPointer com dados `{}`!&quot;, self.data);
    }
}

fn main() {
    let c = CustomSmartPointer { data: String::from(&quot;alocado primeiro&quot;) };
    let d = CustomSmartPointer { data: String::from(&quot;alocado por último&quot;) };
    println!(&quot;CustomSmartPointers criados.&quot;);
}
</code></pre></pre>
<p><span class="caption">Listagem 15-14: Uma struct <code>CustomSmartPointer</code> que
implementa a trait <code>Drop</code> onde colocaríamos nosso código de limpeza</span></p>
<p>A trait <code>Drop</code> é incluída no prelúdio, então não precisamos importá-la. Nós
implementamos a trait <code>Drop</code> no <code>CustomSmartPointer</code> e providenciamos uma
implementação para o método <code>drop</code> que chama <code>println!</code>. O corpo da função
<code>drop</code> é onde você colocaria qualquer que fosse a lógica que você gostaria que
rodasse quando uma instância do seu tipo for sair de escopo. Aqui estamos
imprimindo um texto para demonstrar o momento em que o Rust chama <code>drop</code>.</p>
<p>Na <code>main</code>, nós criamos duas instâncias do <code>CustomSmartPointer</code> e então
imprimimos <code>CustomSmartPointers criados.</code>. No final da <code>main</code>, nossas instâncias
de <code>CustomSmartPointer</code> sairão de escopo, e o Rust irá chamar o código que
colocamos no método <code>drop</code>, imprimindo nossa mensagem final. Note que não
tivemos que chamar o método <code>drop</code> explicitamente.</p>
<p>Quando rodarmos esse programa, veremos a seguinte saída:</p>
<pre><code class="language-text">CustomSmartPointers criados.
Destruindo CustomSmartPointer com dados `alocado por último`!
Destruindo CustomSmartPointer com dados `alocado primeiro`!
</code></pre>
<p>O Rust chamou automaticamente <code>drop</code> para nós quando nossa instância saiu de
escopo, chamando o código que especificamos. Variáveis são destruídas na ordem
contrária à de criação, então <code>d</code> foi destruída antes de <code>c</code>. Esse exemplo serve
apenas para lhe dar um guia visual de como o método <code>drop</code> funciona, mas
normalmente você especificaria o código de limpeza que o seu tipo precisa rodar
em vez de imprimir uma mensagem.</p>
<a class="header" href="print.html#destruindo-um-valor-cedo-com-stdmemdrop" id="destruindo-um-valor-cedo-com-stdmemdrop"><h3>Destruindo um Valor Cedo com <code>std::mem::drop</code></h3></a>
<p>Infelizmente, não é simples desabilitar a funcionalidade automática de <code>drop</code>.
Desabilitar o <code>drop</code> normalmente não é necessário; o ponto todo da trait <code>Drop</code>
é que isso seja feito automaticamente. Mas ocasionalmente, você pode querer
limpar um valor cedo. Um exemplo é quando usamos ponteiros inteligentes que
gerenciam locks: você pode querer forçar o método <code>drop</code> que libera o lock a
rodar para que outro código no mesmo escopo possa adquiri-lo. O Rust não nos
deixa chamar o método <code>drop</code> da trait <code>Drop</code> manualmente; em vez disso, temos
que chamar a função <code>std::mem::drop</code> disponibilizada pela biblioteca padrão se
queremos forçar um valor a ser destruído antes do fim de seu escopo.</p>
<p>Vamos ver o que acontece quando tentamos chamar o método <code>drop</code> da trait <code>Drop</code>
manualmente, modificando a função <code>main</code> da Listagem 15-14, conforme mostra a
Listagem 15-15:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let c = CustomSmartPointer { data: String::from(&quot;algum dado&quot;) };
    println!(&quot;CustomSmartPointer criado.&quot;);
    c.drop();
    println!(&quot;CustomSmartPointer destruído antes do fim da main.&quot;);
}
</code></pre>
<p><span class="caption">Listagem 15-15: Tentando chamar o método <code>drop</code> da trait <code>Drop</code> manualmente para limpar cedo</span></p>
<p>Quando tentamos compilar esse código, recebemos este erro:</p>
<pre><code class="language-text">erro[E0040]: uso explícito de método destrutor
  --&gt; src/main.rs:14:7
   |
14 |     c.drop();
   |       ^^^^ chamadas explícitas a destrutores não são permitidas
</code></pre>
<p>Essa mensagem de erro afirma que não nos é permitido chamar explicitamente
<code>drop</code>. A mensagem de erro usa o termo <em>destrutor</em>, que é um termo geral de
programação para uma função que limpa uma instância. Um <em>destrutor</em> é análogo a
um <em>construtor</em>, que cria uma instância. A função <code>drop</code> em Rust é um destrutor
específico.</p>
<p>O Rust não nos deixa chamar <code>drop</code> explicitamente porque o <code>drop</code> ainda seria
chamado no valor ao final da <code>main</code>. Isso seria um erro de <em>liberação dupla</em>
(<em>double free</em>) porque o Rust estaria tentando limpar o mesmo valor duas vezes.</p>
<p>Nós não podemos desabilitar a inserção automática do <code>drop</code> quando um valor sai
de escopo, e também não podemos chamar o método <code>drop</code> explicitamente. Então, se
precisamos forçar um valor a ser limpo antes, podemos usar a função
<code>std::mem::drop</code>.</p>
<p>A função <code>std::mem::drop</code> é diferente do método <code>drop</code> na trait <code>Drop</code>. Nós a
chamamos passando como argumento o valor que queremos forçar a ser destruído
cedo. Essa função está no prelúdio, então podemos modificar a <code>main</code> na Listagem
15-14 para chamar a função <code>drop</code>, como mostra a Listagem 15-16:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># struct CustomSmartPointer {
#     data: String,
# }
#
# impl Drop for CustomSmartPointer {
#     fn drop(&amp;mut self) {
#         println!(&quot;Destruindo CustomSmartPointer!&quot;);
#     }
# }
#
fn main() {
    let c = CustomSmartPointer { data: String::from(&quot;algum dado&quot;) };
    println!(&quot;CustomSmartPointer criado.&quot;);
    drop(c);
    println!(&quot;CustomSmartPointer destruído antes do final da main.&quot;);
}
</code></pre></pre>
<p><span class="caption">Listagem 15-16: Chamando <code>std::mem::drop</code> para destruir um
valor explicitamente antes que ele saia de escopo</span></p>
<p>Rodar esse código irá imprimir o seguinte:</p>
<pre><code class="language-text">CustomSmartPointer criado.
Destruindo CustomSmartPointer com dados `algum dado`!
CustomSmartPointer destruído antes do final da main.
</code></pre>
<p>O texto <code>Destruindo CustomSmartPointer com dados `algum dado`!</code> é impresso
entre o texto <code>CustomSmartPointer criado.</code> e <code>CustomSmartPointer destruído antes do final da main.</code>, mostrando que o método <code>drop</code> é chamado para destruir o <code>c</code>
naquele ponto.</p>
<p>Podemos usar o código especificado em uma implementação da trait <code>Drop</code> de
várias maneiras para tornar a limpeza conveniente e segura: por exemplo,
poderíamos usá-lo para criar nosso próprio alocador de memória! Com a trait
<code>Drop</code> e o sistema de posse do Rust, não temos que lembrar de fazer a limpeza
porque o Rust faz isso automaticamente.</p>
<p>Também não temos que nos preocupar em acidentalmente limpar valores ainda em uso
porque isso causaria um erro de compilação: o sistema de posse que garante que
as referências são sempre válidas também garante que o <code>drop</code> é chamado apenas
uma vez quando o valor não está mais sendo usado.</p>
<p>Agora que examinamos o <code>Box&lt;T&gt;</code> e alguma características de ponteiros
inteligentes, vamos dar uma olhada em alguns outros ponteiros inteligentes
definidos na biblioteca padrão.</p>
<a class="header" href="print.html#rct-o-ponteiro-inteligente-com-contagem-de-referências" id="rct-o-ponteiro-inteligente-com-contagem-de-referências"><h2><code>Rc&lt;T&gt;</code>, o Ponteiro Inteligente com Contagem de Referências</h2></a>
<p>Na maioria dos casos, a posse é clara: você sabe exatamente qual variável tem
posse de um dado valor. Contudo, há casos onde um único valor pode ter múltiplos
possuidores. Por exemplo, em uma estrutura de dados em grafo, múltiplas arestas
podem apontar para o mesmo vértice, e esse vértice é conceitualmente possuído
por todas as arestas que apontam para ele. Um vértice não deveria ser liberado a
não ser que ele não tenha mais arestas apontando para ele.</p>
<p>Para permitir posse múltipla, o Rust tem um tipo chamado <code>Rc&lt;T&gt;</code>. Seu nome é uma
abreviação para <em>reference counting</em> (<em>contagem de referências</em>) que, como o
nome diz, mantém registro do número de referências a um valor para saber se ele
ainda está em uso ou não. Se há zero referências a um valor, ele pode ser
liberado sem que nenhuma referência se torne inválida.</p>
<p>Imagine o <code>Rc&lt;T&gt;</code> como uma TV numa sala de família. Quando uma pessoa entra para
assistir à TV, ela a liga. Outros podem entrar na sala e assistir à TV. Quando a
última pessoa sai da sala, ela desliga a TV porque essa não está mais em uso. Se
alguém desligasse a TV enquanto outros ainda estão assistindo, haveria revolta
entre os telespectadores restantes!</p>
<p>Nós usamos o tipo <code>Rc&lt;T&gt;</code> quando queremos alocar algum dado no heap para que
múltiplas partes do nosso programa o leiam, e não conseguimos determinar em
tempo de compilação qual parte irá terminar de usar o dado por último. Se
soubéssemos qual parte terminaria por último, poderíamos simplesmente tornar
aquela parte a possuidora do dado e as regras normais de posse aplicadas em
tempo de compilação teriam efeito.</p>
<p>Note que o <code>Rc&lt;T&gt;</code> serve apenas para cenários de thread única. Quando
discutirmos concorrência no Capítulo 16, cobriremos como fazer contagem de
referências em programas com múltiplas threads.</p>
<a class="header" href="print.html#usando-rct-para-compartilhar-dados" id="usando-rct-para-compartilhar-dados"><h3>Usando <code>Rc&lt;T&gt;</code> para Compartilhar Dados</h3></a>
<p>Vamos retornar ao nosso exemplo de <em>cons list</em> da Listagem 15-5. Lembre-se de
que a definimos usando o <code>Box&lt;T&gt;</code>. Desta vez, vamos criar duas listas que
compartilham ambas a posse de uma terceira lista, o que conceitualmente vai se
parecer com a Figura 15-3:</p>
<p><img alt="Duas listas que compartilham a posse de uma terceira lista" src="img/trpl15-03.svg" class="center" /></p>
<p><span class="caption">Figura 15-3: Duas listas, <code>b</code> e <code>c</code>, compartilhando posse
de uma terceira lista, <code>a</code></span></p>
<p>Vamos criar a lista <code>a</code> que contém 5 e depois 10. Então criaremos mais duas
listas: <code>b</code>, que começa com 3 e <code>c</code>, que começa com 4. Ambas as listas <code>b</code> e <code>c</code>
irão então continuar na lista <code>a</code> contendo 5 e 10. Em outras palavras, ambas as
listas irão compartilhar a primeira lista contendo 5 e 10.</p>
<p>Tentar implementar esse cenário usando nossa definição de <code>List</code> com <code>Box&lt;T&gt;</code>
não irá funcionar, como mostra a Listagem 15-17:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use List::{Cons, Nil};

fn main() {
    let a = Cons(5,
        Box::new(Cons(10,
            Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}
</code></pre>
<p><span class="caption">Listagem 15-17: Demonstrando que não é possível termos
duas listas usando <code>Box&lt;T&gt;</code> que tentam compartilhar posse de uma terceira
lista</span></p>
<p>Quando compilamos esse código, recebemos este erro:</p>
<pre><code class="language-text">erro[E0382]: uso de valor movido: `a`
  --&gt; src/main.rs:13:30
   |
12 |     let b = Cons(3, Box::new(a));
   |                              - valor movido para cá
13 |     let c = Cons(4, Box::new(a));
   |                              ^ valor usado aqui depois de movido
   |
   = nota: o valor é movido porque `a` tem tipo `List`, que não implementa
   a trait `Copy`
</code></pre>
<p>As variantes <code>Cons</code> têm posse dos dados que elas contêm, então quando criamos a
lista <code>b</code>, <code>a</code> é movida para dentro de <code>b</code>, e <code>b</code> toma posse de <code>a</code>. Então,
quando tentamos usar <code>a</code> de novo na criação de <code>c</code>, não somos permitidos porque
<code>a</code> foi movida.</p>
<p>Poderíamos mudar a definição de <code>Cons</code> para guardar referências, mas aí teríamos
que especificar parâmetros de tempo de vida (<em>lifetime parameters</em>). Fazendo
isso, estaríamos especificando que cada elemento da lista devesse viver por pelo
menos tanto tempo quanto a lista inteira. O <em>verificador de empréstimo</em> (<em>borrow
checker</em>) não nos deixaria compilar <code>let a = Cons(10, &amp;Nil);</code>, por exemplo,
porque o valor temporário <code>Nil</code> seria destruído antes que <code>a</code> pudesse receber
uma referência a ele.</p>
<p>Em vez disso, vamos mudar nossa definição de <code>List</code> para usar o <code>Rc&lt;T&gt;</code> no lugar
do <code>Box&lt;T&gt;</code>, como mostra a Listagem 15-18. Cada variante <code>Cons</code> agora vai conter
um valor e um <code>Rc&lt;T&gt;</code> apontando para uma <code>List</code>. Quando criarmos <code>b</code>, em vez de
tomar posse de <code>a</code>, iremos clonar o <code>Rc&lt;List&gt;</code> que <code>a</code> está segurando, o que
aumenta o número de referências de uma para duas e permite com que <code>a</code> e
<code>b</code>compartilhem posse dos dados naquele <code>Rc&lt;List&gt;</code>. Também vamos clonar <code>a</code>
quando criarmos <code>c</code>, o que aumenta o número de referências de duas para três.
Cada vez que chamarmos <code>Rc::clone</code>, a contagem de referências ao valor dentro do
<code>Rc&lt;List&gt;</code> irá aumentar, e ele não será liberado até que haja zero referências a
ele:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

use List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&amp;a));
    let c = Cons(4, Rc::clone(&amp;a));
}
</code></pre></pre>
<p><span class="caption">Listagem 15-18: Uma definição de <code>List</code> que usa o
<code>Rc&lt;T&gt;</code></span></p>
<p>Precisamos adicionar uma declaração <code>use</code> para trazer o <code>Rc&lt;T&gt;</code> ao escopo porque
ele não está no prelúdio. Na <code>main</code>, criamos a lista contendo 5 e 10 e a
armazenamos em um novo <code>Rc&lt;List&gt;</code> em <code>a</code>. Então quando criamos <code>b</code> e <code>c</code>,
chamamos a função <code>Rc::clone</code> e passamos uma referência ao <code>Rc&lt;List&gt;</code> em <code>a</code>
como argumento.</p>
<p>Poderíamos ter chamado <code>a.clone()</code> em vez de <code>Rc::clone(&amp;a)</code>, mas a convenção do
Rust é usar <code>Rc::clone</code> neste caso. A implementação de <code>Rc::clone</code> não faz uma
cópia profunda de todos os dados como faz a implementação de <code>clone</code> da maioria
dos tipos. A chamada a <code>Rc::clone</code> apenas incrementa a contagem de referências,
o que não leva muito tempo. Cópias profundas de dados podem levar muito tempo.
Usando <code>Rc::clone</code> para a contagem de referências, podemos distinguir
visualmente entre os clones de cópia profunda e os clones que incrementam a
contagem de referências. Quando estivermos procurando problemas de desempenho no
código, precisamos apenas considerar os clones de cópia profunda e podemos
ignorar as chamadas a <code>Rc::clone</code>.</p>
<a class="header" href="print.html#clonar-um-rct-aumenta-a-contagem-de-referências" id="clonar-um-rct-aumenta-a-contagem-de-referências"><h3>Clonar um <code>Rc&lt;T&gt;</code> Aumenta a Contagem de Referências</h3></a>
<p>Vamos mudar nosso exemplo de trabalho na Listagem 15-18 para podermos ver a
contagem de referências mudando conforme criamos e destruímos referências ao
<code>Rc&lt;List&gt;</code> em <code>a</code>.</p>
<p>Na Listagem 15-19, vamos mudar a <code>main</code> para que tenha um escopo interno em
volta da lista <code>c</code>; assim poderemos ver como a contagem de referências muda
quando <code>c</code> sai de escopo. Em cada ponto do programa onde a contagem de
referências muda, iremos imprimir seu valor, que podemos obter chamando a função
<code>Rc::strong_count</code>. Essa função se chama <code>strong_count</code> (<em>contagem das
referências fortes</em>) em vez de <code>count</code> (<em>contagem</em>) porque o tipo <code>Rc&lt;T&gt;</code> também
tem uma <code>weak_count</code> (<em>contagem das referências fracas</em>); veremos para que a
<code>weak_count</code> é usada na seção &quot;Evitando Ciclos de Referências&quot;.</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># enum List {
#     Cons(i32, Rc&lt;List&gt;),
#     Nil,
# }
#
# use List::{Cons, Nil};
# use std::rc::Rc;
#
fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!(&quot;contagem depois de criar a = {}&quot;, Rc::strong_count(&amp;a));
    let b = Cons(3, Rc::clone(&amp;a));
    println!(&quot;contagem depois de criar b = {}&quot;, Rc::strong_count(&amp;a));
    {
        let c = Cons(4, Rc::clone(&amp;a));
        println!(&quot;contagem depois de criar c = {}&quot;, Rc::strong_count(&amp;a));
    }
    println!(&quot;contagem depois que c sai de escopo = {}&quot;, Rc::strong_count(&amp;a));
}
</code></pre></pre>
<p><span class="caption">Listagem 15-19: Imprimindo a contagem de
referências</span></p>
<p>Esse código imprime o seguinte:</p>
<pre><code class="language-text">contagem depois de criar a = 1
contagem depois de criar b = 2
contagem depois de criar c = 3
contagem depois que c sai de escopo = 2
</code></pre>
<p>Podemos ver que o <code>Rc&lt;List&gt;</code> em <code>a</code> tem uma contagem de referências inicial de
um; depois, cada vez que chamamos <code>clone</code>, a contagem aumenta em um. Quando <code>c</code>
sai de escopo, a contagem diminui em um. Nós não temos que chamar uma função
para decrementar a contagem de referências como temos que fazer com a
<code>Rc::clone</code> para incrementá-la: a implementação da trait <code>Drop</code> diminui a
contagem automaticamente quando um valor <code>Rc&lt;T&gt;</code> sai de escopo.</p>
<p>O que não conseguimos ver nesse exemplo é que quando <code>b</code> e depois <code>a</code> saem de
escopo no final da <code>main</code>, a contagem se torna 0, e o <code>Rc&lt;List&gt;</code> é
liberado por completo nesse ponto. O uso do <code>Rc&lt;T&gt;</code> permite que um único valor
tenha múltiplos possuidores, e a contagem garante que o valor permaneça válido
enquanto algum dos possuidores ainda existir.</p>
<p>Por funcionar com referências imutáveis, o <code>Rc&lt;T&gt;</code> nos permite compartilhar
dados entre diversas partes do nosso programa <em>apenas para leitura</em>. Se o
<code>Rc&lt;T&gt;</code> nos deixasse ter múltiplas referências mutáveis também, nós poderíamos
violar uma das regras de empréstimo discutidas no Capítulo 4: múltiplos
empréstimos mutáveis do mesmo lugar podem causar corridas de dados (<em>data
races</em>) e inconsistências. Mas conseguir modificar dados é muito útil! Na
próxima seção, discutiremos a pattern de mutabilidade interior (<em>interior
mutability</em>) e o tipo <code>RefCell&lt;T&gt;</code> que podemos usar junto com um <code>Rc&lt;T&gt;</code> para
trabalhar com essa restrição de imutabilidade.</p>
<a class="header" href="print.html#refcellt-e-a-pattern-de-mutabilidade-interior" id="refcellt-e-a-pattern-de-mutabilidade-interior"><h2><code>RefCell&lt;T&gt;</code> e a Pattern de Mutabilidade Interior</h2></a>
<p><em>Mutabilidade interior</em> (<em>interior mutability</em>) é uma design pattern em Rust que
lhe permite modificar um dado mesmo quando há referências imutáveis a ele:
normalmente, esta ação é proibida pelas regras de empréstimo. Para fazer isso, a
pattern usa código <code>unsafe</code> (<em>inseguro</em>) dentro de uma estrutura de dados para
dobrar as regras normais do Rust que governam mutação e empréstimo. Nós ainda
não cobrimos código unsafe; faremos isso no Capítulo 19. Podemos usar tipos que
usam a pattern de mutabilidade interior quando podemos garantir que as regras de
empréstimo serão seguidas em tempo de execução, ainda que o compilador não o
possa garantir. O código <code>unsafe</code> envolvido é então embrulhado em uma API safe,
e o tipo exterior permanece imutável.</p>
<p>Para explorar este conceito, vamos ver o tipo <code>RefCell&lt;T&gt;</code> que segue a pattern
de mutabilidade interior.</p>
<a class="header" href="print.html#aplicando-regras-de-empréstimo-em-tempo-de-execução-com-o-refcellt" id="aplicando-regras-de-empréstimo-em-tempo-de-execução-com-o-refcellt"><h3>Aplicando Regras de Empréstimo em Tempo de Execução com o <code>RefCell&lt;T&gt;</code></h3></a>
<p>Diferente do <code>Rc&lt;T&gt;</code>, o tipo <code>RefCell&lt;T&gt;</code> representa posse única sobre o dado
que ele contém. Então o que torna o <code>RefCell&lt;T&gt;</code> diferente de um tipo como o
<code>Box&lt;T&gt;</code>? Lembre-se das regras de empréstimo que você aprendeu no Capítulo 4:</p>
<ul>
<li>Em qualquer momento, você pode ter <em>um dos</em> mas não ambos os seguintes: uma
única referência mutável <em>ou</em> qualquer número de referências imutáveis;</li>
<li>Referências devem sempre ser válidas.</li>
</ul>
<p>Com referências e com o <code>Box&lt;T&gt;</code>, as invariantes das regras de empréstimo são
aplicadas em tempo de compilação. Com o <code>RefCell&lt;T&gt;</code>, essas invariantes são
aplicadas <em>em tempo de execução</em>. Com referências, se você quebra essas regras,
você recebe um erro de compilação. Com o <code>RefCell&lt;T&gt;</code>, se você quebrar essas
regras, seu programa irá sofrer um <code>panic!</code> e terminar.</p>
<p>As vantagens de checar as regras de empréstimo em tempo de compilação são que
erros são pegos mais cedo no processo de desenvolvimento, e não há nenhum custo
de desempenho de execução porque toda a análise é completada de antemão. Por
esses motivos, checar as regras de empréstimo em tempo de compilação é a melhor
opção na maioria dos casos, e por isso este é o padrão do Rust.</p>
<p>A vantagem de checar as regras de empréstimo em tempo de execução,
alternativamente, é que certos cenários <em>memory-safe</em> (<em>seguros em termos de
memória</em>) são então permitidos, ao passo que seriam proibidos pelas checagens em
tempo de compilação. A análise estática, como a do compilador Rust, é
inerentemente conservadora. Algumas propriedades do programa são impossíveis de
detectar analisando o código: o exemplo mais famoso é o Problema da Parada, que
está além do escopo deste livro mas é um tópico interessante para pesquisa.</p>
<p>Como algumas análises são impossíveis, se o compilador Rust não consegue se
assegurar que o código obedece às regras de posse, ele pode rejeitar um programa
correto; neste sentido, ele é conservador. Se o Rust aceitasse um programa
incorreto, os usuários não poderiam confiar nas garantias que ele faz. Se, por
outro lado, o Rust rejeita um programa correto, o programador terá alguma
inconveniência, mas nada catastrófico pode acontecer. O tipo <code>RefCell&lt;T&gt;</code> é útil
quando você tem certeza que seu código segue as regras de empréstimo, mas o
compilador é incapaz de entender e garantir isso.</p>
<p>Assim como o <code>Rc&lt;T&gt;</code>, o <code>RefCell&lt;T&gt;</code> é apenas para uso em cenários de thread
única e lhe darão um erro de compilação se você tentar usá-lo em um contexto de
múltiplas threads. Falaremos sobre como obter a funcionalidade de um
<code>RefCell&lt;T&gt;</code> em um programa multithread no Capítulo 16.</p>
<p>Aqui está uma recapitulação das razões para escolher o <code>Box&lt;T&gt;</code>, o <code>Rc&lt;T&gt;</code> ou o
<code>RefCell&lt;T&gt;</code>:</p>
<ul>
<li>O <code>Rc&lt;T&gt;</code> permite múltiplos possuidores do mesmo dado; <code>Box&lt;T&gt;</code> e <code>RefCell&lt;T&gt;</code>
têm possuidores únicos.</li>
<li>O <code>Box&lt;T&gt;</code> permite empréstimos imutáveis ou mutáveis checados em tempo de
compilação; o <code>Rc&lt;T&gt;</code> permite apenas empréstimos imutáveis em tempo de
compilação; o <code>RefCell&lt;T&gt;</code> permite empréstimos imutáveis ou mutáveis checados
em tempo de execução.</li>
<li>Como o <code>RefCell&lt;T&gt;</code> permite empréstimos mutáveis checados em tempo de
execução, nós podemos modificar o valor dentro de um <code>RefCell&lt;T&gt;</code> mesmo quando
o <code>RefCell&lt;T&gt;</code> é imutável.</li>
</ul>
<p>Modificar o valor dentro de um valor imutável é a pattern de <em>mutabilidade
interior</em>. Vamos dar uma olhada em uma situação em que a mutabilidade interior é
útil e examinar como ela é possível.</p>
<a class="header" href="print.html#mutabilidade-interior-um-empréstimo-mutável-de-um-valor-imutável" id="mutabilidade-interior-um-empréstimo-mutável-de-um-valor-imutável"><h3>Mutabilidade Interior: Um Empréstimo Mutável de um Valor Imutável</h3></a>
<p>Uma consequência das regras de empréstimo é que quando temos um valor imutável,
nós não podemos pegá-lo emprestado mutavelmente. Por exemplo, este código não
compila:</p>
<pre><code class="language-rust ignore">fn main() {
    let x = 5;
    let y = &amp;mut x;
}
</code></pre>
<p>Quando tentamos compilar este código, recebemos o seguinte erro:</p>
<pre><code class="language-text">erro[E0596]: não posso pegar emprestado a variável local imutável `x` como
mutável
 --&gt; src/main.rs:3:18
  |
2 |     let x = 5;
  |         - considere mudar isto para `mut x`
3 |     let y = &amp;mut x;
  |                  ^ não posso pegar emprestado mutavelmente
</code></pre>
<p>Contudo, há situações em que seria útil para um valor modificar a si mesmo em
seus métodos, mas continuar parecendo imutável para código externo. Código fora
dos métodos do valor não teriam como modificá-lo. Usar o <code>RefCell&lt;T&gt;</code> é um jeito
de obter a habilidade de ter mutabilidade interior. Mas o <code>RefCell&lt;T&gt;</code> não dá a
volta nas regras de empréstimo por completo: o borrow checker no compilador
permite esta mutabilidade interior, e as regras de empréstimo são em vez disso
checadas em tempo de execução. Se violarmos as regras, receberemos um <code>panic!</code>
em vez de um erro de compilação.</p>
<p>Vamos trabalhar com um exemplo prático onde podemos usar o <code>RefCell&lt;T&gt;</code> para
modificar um valor imutável e ver por que isto é útil.</p>
<a class="header" href="print.html#um-caso-de-uso-para-a-mutabilidade-interior-objetos-simulados" id="um-caso-de-uso-para-a-mutabilidade-interior-objetos-simulados"><h4>Um Caso de Uso para a Mutabilidade Interior: Objetos Simulados</h4></a>
<p>Um <em>dublê de teste</em> (<em>test double</em>) é um conceito geral de programação para um
tipo usado no lugar de outro durante os testes. <em>Objetos simulados</em> (<em>mock
objects</em>) são tipos específicos de dublês de teste que registram o que acontece
durante o teste para que possamos confirmar que as ações corretas aconteceram.</p>
<p>Rust não tem objetos da mesma forma que outras linguagens, e não tem
funcionalidade de objetos simulados embutida na biblioteca padrão como algumas
outras linguagens. Contudo, certamente podemos criar uma struct que serve os
mesmos propósitos que um objeto simulado.</p>
<p>Eis o cenário que vamos testar: vamos criar uma biblioteca que acompanha um
valor contra um valor máximo e envia mensagens com base em quão próximo do valor
máximo o valor atual está. Esta biblioteca pode ser usada para acompanhar a cota
de um usuário para o número de chamadas de API que ele tem direito a fazer, por
exemplo.</p>
<p>Nossa biblioteca irá prover somente a funcionalidade de acompanhar quão perto do
máximo um valor está e o que as mensagens deveriam ser em quais momentos. As
aplicações que usarem nossa biblioteca terão a responsabilidade de prover o
mecanismo para enviar as mensagens: a aplicação pode pôr a mensagem na própria
aplicação, enviar um email, uma mensagem de texto, ou alguma outra coisa. A
biblioteca não precisa saber deste detalhe. Tudo que ela precisa é de algo que
implemente uma trait que iremos prover chamada <code>Mensageiro</code>. A
Listagem 15-20 mostra o código da biblioteca:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Mensageiro {
    fn enviar(&amp;self, msg: &amp;str);
}

pub struct AvisaLimite&lt;'a, T: 'a + Mensageiro&gt; {
    mensageiro: &amp;'a T,
    valor: usize,
    max: usize,
}

impl&lt;'a, T&gt; AvisaLimite&lt;'a, T&gt;
    where T: Mensageiro {
    pub fn new(mensageiro: &amp;T, max: usize) -&gt; AvisaLimite&lt;T&gt; {
        AvisaLimite {
            mensageiro,
            valor: 0,
            max,
        }
    }

    pub fn set_valor(&amp;mut self, valor: usize) {
        self.valor = valor;

        let porcentagem_do_max = self.valor as f64 / self.max as f64;

        if porcentagem_do_max &gt;= 0.75 &amp;&amp; porcentagem_do_max &lt; 0.9 {
            self.mensageiro.enviar(&quot;Aviso: Você usou mais de 75% da sua cota!&quot;);
        } else if porcentagem_do_max &gt;= 0.9 &amp;&amp; porcentagem_do_max &lt; 1.0 {
            self.mensageiro.enviar(&quot;Aviso urgente: Você usou mais de 90% da sua cota!&quot;);
        } else if porcentagem_do_max &gt;= 1.0 {
            self.mensageiro.enviar(&quot;Erro: Você excedeu sua cota!&quot;);
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 15-20: Uma biblioteca para acompanhar quão perto
do máximo um valor está e avisar quando o valor está em certos níveis</span></p>
<p>Uma parte importante deste código é que a trait <code>Mensageiro</code> tem um método
chamado <code>enviar</code> que recebe uma referência imutável a <code>self</code> e o texto da
mensagem. Esta é a interface que nosso objeto simulado precisa ter. A outra
parte importante é que queremos testar o comportamento do método <code>set_valor</code> no
<code>AvisaLimite</code>. Podemos mudar o que passamos para o parâmetro <code>valor</code>, mas o
<code>set_valor</code> não retorna nada sobre o qual possamos fazer asserções. Queremos
poder dizer que se criarmos um <code>AvisaLimite</code> com algo que implemente a trait
<code>Mensageiro</code> e um valor específico de <code>max</code>, quando passarmos diferentes números
para o <code>valor</code>, o mensageiro receberá o comando para enviar as mensagens
apropriadas.</p>
<p>Precisamos de um objeto simulado que, em vez de enviar um email ou mensagem de
texto quando chamarmos <code>enviar</code>, irá apenas registrar as mensagens que recebeu
para enviar. Podemos criar uma nova instância do objeto simulado, criar um
<code>AvisaLimite</code> que use o objeto simulado, chamar o método <code>set_valor</code> no
<code>AvisaLimite</code>, e então verificar se o objeto simulado tem as mensagens que
esperamos. A Listagem 15-21 mostra uma tentativa de implementar um objeto
simulado para fazer exatamente isto, mas que o borrow checker não permite:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    use super::*;

    struct MensageiroSimulado {
        mensagens_enviadas: Vec&lt;String&gt;,
    }

    impl MensageiroSimulado {
        fn new() -&gt; MensageiroSimulado {
            MensageiroSimulado { mensagens_enviadas: vec![] }
        }
    }

    impl Mensageiro for MensageiroSimulado {
        fn enviar(&amp;self, mensagem: &amp;str) {
            self.mensagens_enviadas.push(String::from(mensagem));
        }
    }

    #[test]
    fn envia_uma_mensagem_de_aviso_de_acima_de_75_porcento() {
        let mensageiro_simulado = MensageiroSimulado::new();
        let mut avisa_limite = AvisaLimite::new(&amp;mensageiro_simulado, 100);

        avisa_limite.set_valor(80);

        assert_eq!(mensageiro_simulado.mensagens_enviadas.len(), 1);
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 15-21: Uma tentativa de implementar um
<code>MensageiroSimulado</code> que não é permitida pelo borrow checker</span></p>
<p>Este código de teste define uma struct <code>MensageiroSimulado</code> que tem um campo
<code>mensagens_enviadas</code> com um <code>Vec</code> de valores <code>String</code> para registrar as
mensagens que ele recebe para enviar. Também definimos uma função associada
<code>new</code> para facilitar a criação de novos valores <code>MensageiroSimulado</code> que começam
com uma lista vazia de mensagens. Então implementamos a trait <code>Mensageiro</code> para
o <code>MensageiroSimulado</code> para que possamos passar um <code>MensageiroSimulado</code> a um
<code>AvisaLimite</code>. Na definição do método <code>enviar</code>, nós pegamos a mensagem passada
como parâmetro e a armazenamos na lista <code>mensagens_enviadas</code> do
<code>MensageiroSimulado</code>.</p>
<p>No teste, estamos testando o que acontece quando o <code>AvisaLimite</code> recebe o
comando para setar o <code>valor</code> para algo que é mais do que 75 porcento do valor
<code>max</code>. Primeiro, criamos um novo <code>MensageiroSimulado</code>, que irá começar com uma
lista vazia de mensagens. Então criamos um novo <code>AvisaLimite</code> e lhe damos uma
referência ao novo <code>MensageiroSimulado</code> e um valor <code>max</code> de 100. Nós chamamos o
método <code>set_valor</code> no <code>AvisaLimite</code> com um valor de 80, que é mais do que 75
porcento de 100. Então conferimos se a lista de mensagens que o
<code>MensageiroSimulado</code> está registrando agora tem uma mensagem nela.</p>
<p>Entretanto, há um problema neste teste, conforme abaixo:</p>
<pre><code class="language-text">erro[E0596]: não posso pegar emprestado o campo imutável
             `self.mensagens_enviadas` como mutável
  --&gt; src/lib.rs:52:13
   |
51 |         fn send(&amp;self, message: &amp;str) {
   |                 ----- use `&amp;mut self` aqui para torná-lo mutável
52 |             self.sent_messages.push(String::from(message));
   |             ^^^^^^^^^^^^^^^^^^ não posso pegar emprestado mutavelmente um
                                    campo imutável
</code></pre>
<p>Não podemos modificar o <code>MensageiroSimulado</code> para registrar as mensagens porque
o método <code>enviar</code> recebe uma referência imutável a <code>self</code>. Também não podemos
seguir a sugestão do texto de erro e usar <code>&amp;mut self</code> em vez disso porque a
assinatura de <code>enviar</code> não corresponderia à assinatura na definição da trait
<code>Mensageiro</code> (fique à vontade para tentar e ver qual mensagem de erro você
recebe).</p>
<p>Esta é uma situação em que a mutabilidade interior pode ajudar! Vamos armazenas
as <code>mensagens_enviadas</code> dentro de um <code>RefCell&lt;T&gt;</code>, e então o método <code>enviar</code>
poderá modificar <code>mensagens_enviadas</code> para armazenar as mensagens que já vimos.
A Listagem 15-22 mostra como fica isto:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MensageiroSimulado {
        mensagens_enviadas: RefCell&lt;Vec&lt;String&gt;&gt;,
    }

    impl MensageiroSimulado {
        fn new() -&gt; MensageiroSimulado {
            MensageiroSimulado { mensagens_enviadas: RefCell::new(vec![]) }
        }
    }

    impl Mensageiro for MensageiroSimulado {
        fn enviar(&amp;self, mensagem: &amp;str) {
            self.mensagens_enviadas.borrow_mut().push(String::from(mensagem));
        }
    }

    #[test]
    fn envia_uma_mensagem_de_aviso_de_acima_de_75_porcento() {
        // --snip--
#         let mensageiro_simulado = MensageiroSimulado::new();
#         let mut avisa_limite = AvisaLimite::new(&amp;mensageiro_simulado, 100);
#         avisa_limite.set_valor(75);

        assert_eq!(mensageiro_simulado.mensagens_enviadas.borrow().len(), 1);
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 15-22: Usando <code>RefCell&lt;T&gt;</code> para modificar um
valor interno enquanto o valor externo é considerado imutável</span></p>
<p>O campo <code>mensagens_enviadas</code> agora é do tipo <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> em vez de
<code>Vec&lt;String&gt;</code>. Na função <code>new</code>, nós criamos uma nova instância de
<code>RefCell&lt;Vec&lt;String&gt;&gt;</code> em torno do vetor vazio.</p>
<p>Para a implementação do método <code>enviar</code>, o primeiro parâmetro ainda é um
empréstimo imutável de <code>self</code>, que corresponde à definição da trait. Nós
chamamos <code>borrow_mut</code> no <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> em <code>self.mensagens_enviadas</code>
para obter uma referência mutável ao valor dentro do <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>, que
é o vetor. Então podemos chamar <code>push</code> na referência mutável ao vetor para
registrar as mensagens enviadas durante o teste.</p>
<p>A última mudança que temos que fazer é na asserção: para ver quantos itens estão
no vetor interno, chamamos <code>borrow</code> no <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> para obter uma
referência imutável ao vetor.</p>
<p>Agora que você viu como usar o <code>RefCell&lt;T&gt;</code>, vamos nos aprofundar em como ele
funciona!</p>
<a class="header" href="print.html#o-refcellt-registra-empréstimos-em-tempo-de-execução" id="o-refcellt-registra-empréstimos-em-tempo-de-execução"><h4>O <code>RefCell&lt;T&gt;</code> Registra Empréstimos em Tempo de Execução</h4></a>
<p>Quando estamos criando referências imutáveis e mutáveis, usamos as sintaxes <code>&amp;</code>
e <code>&amp;mut</code>, respectivamente. Com o <code>RefCell&lt;T&gt;</code>, usamos os métodos <code>borrow</code> e
<code>borrow_mut</code>, que são parte da API safe que pertence ao <code>RefCell&lt;T&gt;</code>. O método
<code>borrow</code> retorna o ponteiro inteligente <code>Ref&lt;T&gt;</code>, e o <code>borrow_mut</code> retorna o
ponteiro inteligente <code>RefMut&lt;T&gt;</code>. Ambos os tipos implementam <code>Deref</code>, então
podemos tratá-los como referências normais.</p>
<p>O tipo <code>RefCell&lt;T&gt;</code> mantém registro de quantos ponteiros inteligentes <code>Ref&lt;T&gt;</code> e
<code>RefMut&lt;T&gt;</code> estão atualmente ativos. Cada vez que chamamos <code>borrow</code>, o
<code>RefCell&lt;T&gt;</code> aumenta seu contador de quantos empréstimos imutáveis estão ativos.
Quando um valor <code>Ref&lt;T&gt;</code> sai de escopo, o contador de empréstimos imutáveis
diminui em um. Assim como as regras de empréstimo em tempo de compilação, o
<code>RefCell&lt;T&gt;</code> nos permite ter vários empréstimos imutáveis ou um empréstimo
mutável em um dado momento.</p>
<p>Se tentarmos violar estas regras, em vez de receber um erro do compilador como
iríamos com referências, a implementação de <code>RefCell&lt;T&gt;</code> chamará <code>panic!</code> em
tempo de execução. A Listagem 15-23 mostra uma modificação da implementação do
<code>enviar</code> da Listagem 15-22. Estamos deliberadamente tentando criar dois
empréstimos mutáveis ativos para o mesmo escopo para ilustrar que o <code>RefCell&lt;T&gt;</code>
nos impede de fazer isto em tempo de execução:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Mensageiro for MensageiroSimulado {
    fn enviar(&amp;self, mensagem: &amp;str) {
        let mut emprestimo_um = self.mensagens_enviadas.borrow_mut();
        let mut emprestimo_dois = self.mensagens_enviadas.borrow_mut();

        emprestimo_um.push(String::from(mensagem));
        emprestimo_dois.push(String::from(mensagem));
    }
}
</code></pre>
<p><span class="caption">Listagem 15-23: Criando duas referências mutáveis no mesmo
escopo para ver que o <code>RefCell&lt;T&gt;</code> irá &quot;entrar em pânico&quot; (i.e., executar
<code>panic!</code>)</span></p>
<p>Nós criamos uma variável <code>emprestimo_um</code> para o ponteiro inteligente <code>RefMut&lt;T&gt;</code>
retornado por <code>borrow_mut</code>. Então criamos outro empréstimo mutável da mesma
forma na variável <code>emprestimo_dois</code>. Isto resulta em duas referências mutáveis
no mesmo escopo, o que não é permitido. Quando rodarmos os testes para nossa
biblioteca, o código na Listagem 15-23 irá compilar sem nenhum erro, mas o teste
irá falhar:</p>
<pre><code class="language-text">---- tests::envia_uma_mensagem_de_aviso_de_acima_de_75_porcento stdout ----
    thread 'tests::envia_uma_mensagem_de_aviso_de_acima_de_75_porcento' entrou
    em pânico em
    'já emprestado: BorrowMutError', src/libcore/result.rs:906:4
nota: Rode com `RUST_BACKTRACE=1` para um backtrace.
</code></pre>
<p>Note como o código entrou em pânico com a mensagem <code>já emprestado: BorrowMutError</code>. É assim que o <code>RefCell&lt;T&gt;</code> lida com violações das regras de
empréstimo em tempo de execução.</p>
<p>Pegar erros de empréstimo em tempo de execução em vez de em tempo de compilação
significa encontrar defeitos no nosso código mais tarde no processo de
desenvolvimento, e possivelmente nem mesmo até que nosso código já tenha sido
implantado em produção. Além disso, nosso código irá incorrer em uma pequena
penalidade de desempenho de execução como resultado de manter registro dos
empréstimos em tempo de execução em vez de compilação. Ainda assim, usar o
<code>RefCell&lt;T&gt;</code> nos torna possível escrever um objeto simulado que pode se
modificar para registrar as mensagens que ele já viu enquanto o usamos em um
contexto onde apenas valores imutáveis são permitidos. Podemos usar o
<code>RefCell&lt;T&gt;</code>, apesar de seus trade-offs, para obter mais funcionalidade do que
referências regulares nos dão.</p>
<a class="header" href="print.html#conseguindo-múltiplos-possuidores-de-dados-mutáveis-pela-combinação-de-rct-e-refcellt" id="conseguindo-múltiplos-possuidores-de-dados-mutáveis-pela-combinação-de-rct-e-refcellt"><h3>Conseguindo Múltiplos Possuidores de Dados Mutáveis pela Combinação de <code>Rc&lt;T&gt;</code> e <code>RefCell&lt;T&gt;</code></h3></a>
<p>Um jeito comum de usar o <code>RefCell&lt;T&gt;</code> é em combinação com o <code>Rc&lt;T&gt;</code>. Lembre-se
de que o <code>Rc&lt;T&gt;</code> nos permite ter múltiplos possuidores de algum dado, mas ele só
nos permite acesso imutável a esse dado. Se temos um <code>Rc&lt;T&gt;</code> que contém um
<code>RefCell&lt;T&gt;</code>, podemos ter um valor que pode ter múltiplos possuidores <em>e</em> que
podemos modificar!</p>
<p>Por exemplo, lembre-se da cons list na Listagem 15-18 onde usamos o <code>Rc&lt;T&gt;</code> para
nos permitir que múltiplas listas compartilhassem posse de outra lista. Como o
<code>Rc&lt;T&gt;</code> guarda apenas valores imutáveis, nós não podemos modificar nenhum dos
valores na lista uma vez que os criamos. Vamos adicionar o <code>RefCell&lt;T&gt;</code> para
ganhar a habilidade de mudar os valores nas listas. A Listagem 15-24 mostra que,
usando um <code>RefCell&lt;T&gt;</code> na definição do <code>Cons</code>, podemos modificar o valor
armazenado em todas as listas:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}

use List::{Cons, Nil};
use std::rc::Rc;
use std::cell::RefCell;

fn main() {
    let valor = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&amp;valor), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(6)), Rc::clone(&amp;a));
    let c = Cons(Rc::new(RefCell::new(10)), Rc::clone(&amp;a));

    *valor.borrow_mut() += 10;

    println!(&quot;a depois = {:?}&quot;, a);
    println!(&quot;b depois = {:?}&quot;, b);
    println!(&quot;c depois = {:?}&quot;, c);
}
</code></pre></pre>
<p><span class="caption">Listagem 15-24: Usando <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> para criar uma
<code>List</code> que podemos modificar</span></p>
<p>Nós criamos um valor que é uma instância de <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> e o armazenamos
em uma variável chamada <code>valor</code> para que possamos acessá-lo diretamente mais
tarde. Então criamos uma <code>List</code> em <code>a</code> com uma variante <code>Cons</code> que guarda
<code>valor</code>.</p>
<p>Nós embrulhamos a lista <code>a</code> em um <code>Rc&lt;T&gt;</code> para que, quando criarmos as listas
<code>b</code> e <code>c</code>, elas possam ambas se referir a <code>a</code>, que é o que fizemos na Listagem
15-18.</p>
<p>Depois de criarmos as listas em <code>a</code>, <code>b</code> e <code>c</code>, adicionamos 10 ao valor em
<code>valor</code>. Fazemos isto chamando <code>borrow_mut</code> em <code>valor</code>, o que usa a
funcionalidade de desreferência automática que discutimos no Capítulo 5 (veja a
seção &quot;Onde está o operador <code>-&gt;</code>?&quot;) para desreferenciar o <code>Rc&lt;T&gt;</code> ao valor
interno <code>RefCell&lt;T&gt;</code>. O método <code>borrow_mut</code> retorna um ponteiro inteligente
<code>RefMut&lt;T&gt;</code> no qual usamos o operador de desreferência e modificamos o valor
interno.</p>
<p>Quando imprimimos <code>a</code>, <code>b</code> e <code>c</code>, podemos ver que todos eles têm o valor
modificado de 15 em vez de 5:</p>
<pre><code class="language-text">a depois = Cons(RefCell { value: 15 }, Nil)
b depois = Cons(RefCell { value: 6 }, Cons(RefCell { value: 15 }, Nil))
c depois = Cons(RefCell { value: 10 }, Cons(RefCell { value: 15 }, Nil))
</code></pre>
<p>Esta técnica é bem bacana! Usando um <code>RefCell&lt;T&gt;</code>, temos uma <code>List</code>
exteriormente imutável. Mas podemos usar os métodos no <code>RefCell&lt;T&gt;</code> que dão
acesso a sua mutabilidade interior para que possamos modificar nossos dados
quando precisarmos. As checagens em tempo de execução das regras de empréstimo
nos protegem de corridas de dados, e às vezes vale a pena trocar um pouco de
velocidade por esta flexibilidade nas nossas estruturas de dados.</p>
<p>A biblioteca padrão tem outros tipos que proveem mutabilidade interior, como o
<code>Cell&lt;T&gt;</code>, que é parecido, exceto que em vez de dar referências ao valor
interno, o valor é copiado para dentro e para fora do <code>Cell&lt;T&gt;</code>. Tem também o
<code>Mutex&lt;T&gt;</code>, que oferece mutabilidade interior que é segura de usar entre
threads; vamos discutir seu uso no Capítulo 16. Confira a documentação da
biblioteca padrão para mais detalhes sobre as diferenças entre estes tipos.</p>
<a class="header" href="print.html#ciclos-de-referências-podem-vazar-memória" id="ciclos-de-referências-podem-vazar-memória"><h2>Ciclos de Referências Podem Vazar Memória</h2></a>
<p>As garantias de segurança de memória do Rust tornam <em>difícil</em> mas não impossível
acidentalmente criar memória que nunca é liberada (conhecida como um <em>vazamento
de memória</em>, ou <em>memory leak</em>). O Rust garante em tempo de compilação que não
haverá corridas de dados, mas não garante a prevenção de vazamentos de memória
por completo da mesma forma, o que significa que vazamentos de memória são
<em>memory safe</em> em Rust. Podemos ver que o Rust permite vazamentos de memória
usando <code>Rc&lt;T&gt;</code> e <code>RefCell&lt;T&gt;</code>: é possível criar referências onde os itens se
referem uns aos outros em um ciclo. Isso cria vazamentos de memória porque a
contagem de referências de cada item no ciclo nunca chegará a 0, e os valores
nunca serão destruídos.</p>
<a class="header" href="print.html#criando-um-ciclo-de-referências" id="criando-um-ciclo-de-referências"><h3>Criando um Ciclo de Referências</h3></a>
<p>Vamos dar uma olhada em como um ciclo de referências poderia acontecer e como
preveni-lo, começando com a definição do enum <code>List</code> e um método <code>tail</code>
(<em>cauda</em>) na Listagem 15-25:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<!-- A fn main escondida (primeira linha) está aqui para desabilitar o wrapping
automático em uma fn main que os doc tests fazem; o `use List` falha se esta
listagem é colocada dentro de uma main -->
<pre><pre class="playpen"><code class="language-rust"># fn main() {}
use std::rc::Rc;
use std::cell::RefCell;
use List::{Cons, Nil};

#[derive(Debug)]
enum List {
    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
    Nil,
}

impl List {
    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
        match *self {
            Cons(_, ref item) =&gt; Some(item),
            Nil =&gt; None,
        }
    }
}
</code></pre></pre>
<p><span class="caption">Listagem 15-25: Uma definição de cons list que contém um
<code>RefCell&lt;T&gt;</code> para que possamos modificar ao que se refere uma variante
<code>Cons</code></span></p>
<p>Estamos usando outra variação da definição de <code>List</code> da Listagem 15-5. O segundo
elemento na variante <code>Cons</code> agora é um <code>RefCell&lt;Rc&lt;List&gt;&gt;</code>, o que significa que
em vez de ter a habilidade de modificar o valor <code>i32</code> como fizemos na Listagem
15-24, queremos modificar a <code>List</code> à qual a variante <code>Cons</code> está apontando.
Também estamos adicionando um método <code>tail</code> para nos facilitar o acesso ao
segundo item quando tivermos uma variante <code>Cons</code>.</p>
<p>Na Listagem 15-26, estamos adicionando uma função <code>main</code> que usa as definições
da Listagem 15-25. Este código cria uma lista em <code>a</code> e uma lista em <code>b</code> que
aponta para a lista em <code>a</code>, e depois modifica a lista em <code>a</code> para apontar para
<code>b</code>, o que cria um ciclo de referências. Temos declarações de <code>println!</code> ao
longo do caminho para mostrar quais são as contagens de referências em vários
pontos do processo:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># use List::{Cons, Nil};
# use std::rc::Rc;
# use std::cell::RefCell;
# #[derive(Debug)]
# enum List {
#     Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
#     Nil,
# }
#
# impl List {
#     fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
#         match *self {
#             Cons(_, ref item) =&gt; Some(item),
#             Nil =&gt; None,
#         }
#     }
# }
#
fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!(&quot;a: contagem de referências inicial = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;a: próximo item = {:?}&quot;, a.tail());

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&amp;a))));

    println!(&quot;a: contagem de referências depois da criação de b = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;b: contagem de referências inicial = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;b: próximo item = {:?}&quot;, b.tail());

    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::clone(&amp;b);
    }

    println!(&quot;b: contagem de referências depois de mudar a = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;a: contagem de referências depois de mudar a = {}&quot;, Rc::strong_count(&amp;a));

    // Descomente a próxima linha para ver que temos um ciclo; ela irá
    // estourar a pilha
    // println!(&quot;a: próximo item = {:?}&quot;, a.tail());
}
</code></pre></pre>
<p><span class="caption">Listagem 15-26: Criando um ciclo de referências de dois
valores <code>List</code> apontando um para o outro</span></p>
<p>Nós criamos uma instância de <code>Rc&lt;List&gt;</code> segurando um valor <code>List</code> na variável
<code>a</code> com a lista inicial de <code>5, Nil</code>. Então criamos uma instância de <code>Rc&lt;List&gt;</code>
segurando outro valor <code>List</code> na variável <code>b</code> que contém o valor 10 e aponta para
a lista em <code>a</code>.</p>
<p>Nós modificamos <code>a</code> para que aponte para <code>b</code> em vez de <code>Nil</code>, o que cria um
ciclo. Fazemos isso usando o método <code>tail</code> para obter uma referência ao
<code>RefCell&lt;Rc&lt;List&gt;&gt;</code> em <code>a</code>, a qual colocamos na variável <code>link</code>. Então usamos o
método <code>borrow_mut</code> no <code>RefCell&lt;Rc&lt;List&gt;&gt;</code> para modificar o valor interno: de um
<code>Rc&lt;List&gt;</code> que guarda um valor <code>Nil</code> para o <code>Rc&lt;List&gt;</code> em <code>b</code>.</p>
<p>Quando rodamos esse código, mantendo o último <code>println!</code> comentado por ora,
obtemos esta saída:</p>
<pre><code class="language-text">a: contagem de referências inicial = 1
a: próximo item = Some(RefCell { value: Nil })
a: contagem de referências depois da criação de b = 2
b: contagem de referências inicial = 1
b: próximo item = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
b: contagem de referências depois de mudar a = 2
a: contagem de referências depois de mudar a = 2
</code></pre>
<p>A contagem de referências das instâncias de <code>Rc&lt;List&gt;</code> em ambos <code>a</code> e <code>b</code> é 2
depois que mudamos a lista em <code>a</code> para apontar para <code>b</code>. No final da <code>main</code>, o
Rust tentará destruir <code>b</code> primeiro, o que diminuirá em 1 a contagem em cada uma
das instâncias de <code>Rc&lt;List&gt;</code> em <code>a</code> e <code>b</code>.</p>
<p>Contudo, como a variável <code>a</code> ainda está se referindo ao <code>Rc&lt;List&gt;</code> que estava em
<code>b</code>, ele terá uma contagem de 1 em vez de 0, então a memória que ele tem no heap
não será destruída. A memória irá ficar lá com uma contagem de 1, para sempre.
Para visualizar esse ciclo de referências, criamos um diagrama na Figura 15-4:</p>
<p><img alt="Ciclo de referências de listas" src="img/trpl15-04.svg" class="center"
/></p>
<p><span class="caption">Figura 15-4: Um ciclo de referências das listas <code>a</code> e <code>b</code>
apontando uma para a outra</span></p>
<p>Se você descomentar o último <code>println!</code> e rodar o programa, o Rust tentará
imprimir esse ciclo com <code>a</code> apontando para <code>b</code> apontando para <code>a</code> e assim por
diante até estourar a pilha.</p>
<p>Nesse exemplo, logo depois que criamos o ciclo de referências, o programa
termina. As consequências desse ciclo não são muito graves. Se um programa mais
complexo aloca um monte de memória em um ciclo e não a libera por muito tempo,
ele acaba usando mais memória do que precisa e pode sobrecarregar o sistema,
fazendo com que fique sem memória disponível.</p>
<p>Criar ciclos de referências não é fácil de fazer, mas também não é impossível.
Se você tem valores <code>RefCell&lt;T&gt;</code> que contêm valores <code>Rc&lt;T&gt;</code> ou combinações
aninhadas de tipos parecidas, com mutabilidade interior e contagem de
referências, você deve se assegurar de que não está criando ciclos; você não
pode contar com o Rust para pegá-los. Criar ciclos de referências seria um erro
de lógica no seu programa, e você deve usar testes automatizados, revisões de
código e outras práticas de desenvolvimento de software para minimizá-los.</p>
<p>Outra solução para evitar ciclos de referências é reorganizar suas estruturas de
dados para que algumas referências expressem posse e outras não. Assim, você
pode ter ciclos feitos de algumas relações de posse e algumas relações de não
posse, e apenas as relações de posse afetam se um valor pode ou não ser
destruído. Na Listagem 15-25, nós sempre queremos que as variantes <code>Cons</code>
possuam sua lista, então reorganizar a estrutura de dados não é possível. Vamos
dar uma olhada em um exemplo usando grafos feitos de vértices pais e vértices
filhos para ver quando relações de não posse são um jeito apropriado de evitar
ciclos de referências.</p>
<a class="header" href="print.html#prevenindo-ciclos-de-referência-transforme-um-rct-em-um-weakt" id="prevenindo-ciclos-de-referência-transforme-um-rct-em-um-weakt"><h3>Prevenindo Ciclos de Referência: Transforme um <code>Rc&lt;T&gt;</code> em um <code>Weak&lt;T&gt;</code></h3></a>
<p>Até agora, demonstramos que chamar <code>Rc::clone</code> aumenta a <code>strong_count</code>
(<em>contagem de referências fortes</em>) de uma instância <code>Rc&lt;T&gt;</code>, e que a instância
<code>Rc&lt;T&gt;</code> só é liberada se sua <code>strong_count</code> é 0. Também podemos criar uma
<em>referência fraca</em> (<em>weak reference</em>) ao valor dentro de uma instância <code>Rc&lt;T&gt;</code>
chamando <code>Rc::downgrade</code> e passando-lhe uma referência ao <code>Rc&lt;T&gt;</code>. Quando
chamamos <code>Rc::downgrade</code>, nós obtemos um ponteiro inteligente do tipo <code>Weak&lt;T&gt;</code>.
Em vez de aumentar em 1 a <code>strong_count</code> na instância <code>Rc&lt;T&gt;</code>, chamar
<code>Rc::downgrade</code> aumenta em 1 a <code>weeak_count</code> (<em>contagem de referências fracas</em>).
O tipo <code>Rc&lt;T&gt;</code> usa a <code>weak_count</code> para registrar quantas referências <code>Weak&lt;T&gt;</code>
existem, parecido com a <code>strong_count</code>. A diferença é que a <code>weak_count</code> não
precisa ser 0 para a instância <code>Rc&lt;T&gt;</code> ser destruída.</p>
<p>Referências fortes são o modo como podemos compartilhar posse de uma instância
<code>Rc&lt;T&gt;</code>. Referências fracas não expressam uma relação de posse. Elas não irão
causar um ciclo de referências porque qualquer ciclo envolvendo algumas
referências fracas será quebrado uma vez que a contagem de referências fortes
dos valores envolvidos for 0.</p>
<p>Como o valor ao qual o <code>Weak&lt;T&gt;</code> faz referência pode ter sido destruído, para
fazer qualquer coisa com ele, precisamos nos assegurar de que ele ainda exista.
Fazemos isso chamando o método <code>upgrade</code> na instância <code>Weak&lt;T&gt;</code>, o que nos
retornará uma <code>Option&lt;Rc&lt;T&gt;&gt;</code>. Iremos obter um resultado de <code>Some</code> se o valor do
<code>Rc&lt;T&gt;</code> ainda não tiver sido destruído e um resultado de <code>None</code> caso ele já
tenha sido destruído. Como o <code>upgrade</code> retorna uma <code>Option&lt;T&gt;</code>, o Rust irá
garantir que lidemos com ambos os casos <code>Some</code> e <code>None</code>, e não haverá um
ponteiro inválido.</p>
<p>Como exemplo, em vez de usarmos uma lista cujos itens sabem apenas a respeito do
próximo item, iremos criar uma árvore cujos itens sabem sobre seus itens filhos
<em>e</em> sobre seus itens pais.</p>
<a class="header" href="print.html#criando-uma-estrutura-de-dados-em-Árvore-um-vertice-com-vértices-filhos" id="criando-uma-estrutura-de-dados-em-Árvore-um-vertice-com-vértices-filhos"><h4>Criando uma Estrutura de Dados em Árvore: Um <code>Vertice</code> com Vértices Filhos</h4></a>
<p>Para começar, vamos construir uma árvore com vértices que saibam apenas sobre
seus vértices filhos. Iremos criar uma estrutura chamada <code>Vertice</code> que contenha
seu próprio valor <code>i32</code>, além de referências para seus valores filhos do tipo
<code>Vertice</code>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::rc::Rc;
use std::cell::RefCell;

#[derive(Debug)]
struct Vertice {
    valor: i32,
    filhos: RefCell&lt;Vec&lt;Rc&lt;Vertice&gt;&gt;&gt;,
}
#}</code></pre></pre>
<p>Queremos que um <code>Vertice</code> tenha posse de seus filhos, e queremos compartilhar
essa posse com variáveis para que possamos acessar cada <code>Vertice</code> da árvore
diretamente. Para fazer isso, definimos os itens do <code>Vec&lt;T&gt;</code> para serem valores
do tipo <code>Rc&lt;Vertice&gt;</code>. Também queremos modificar quais vértices são filhos de
outro vértice, então temos um <code>RefCell&lt;T&gt;</code> em <code>filhos</code> em volta do
<code>Vec&lt;Rc&lt;Vertice&gt;&gt;</code>.</p>
<p>Em seguida, iremos usar nossa definição de struct e criar uma instância de
<code>Vertice</code> chamada <code>folha</code> com o valor 3 e nenhum filho, e outra instância
chamada <code>galho</code> com o valor 5 e <code>folha</code> como um de seus filhos, como mostra a
Listagem 15-27:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># use std::rc::Rc;
# use std::cell::RefCell;
#
# #[derive(Debug)]
# struct Vertice {
#     valor: i32,
#     filhos: RefCell&lt;Vec&lt;Rc&lt;Vertice&gt;&gt;&gt;,
# }
#
fn main() {
    let folha = Rc::new(Vertice {
        valor: 3,
        filhos: RefCell::new(vec![]),
    });

    let galho = Rc::new(Vertice {
        valor: 5,
        filhos: RefCell::new(vec![Rc::clone(&amp;folha)]),
    });
}
</code></pre></pre>
<p><span class="caption">Listagem 15-27: Criando um vértice <code>folha</code> sem filhos e um
vértice <code>galho</code> com <code>folha</code> como um de seus filhos</span></p>
<p>Nós clonamos o <code>Rc&lt;Vertice&gt;</code> em <code>folha</code> e armazenamos o resultado em <code>galho</code>, o
que significa que o <code>Vertice</code> em <code>folha</code> agora tem dois possuidores: <code>folha</code> e
<code>galho</code>. Podemos ir de <code>galho</code> para <code>folha</code> através de <code>galho.filhos</code>, mas não
temos como ir de <code>folha</code> para <code>galho</code>. O motivo é que <code>folha</code> não tem referência
a <code>galho</code> e não sabe que eles estão relacionados. Queremos que <code>folha</code> saiba que
<code>galho</code> é seu pai. Faremos isso em seguida.</p>
<a class="header" href="print.html#adicionando-uma-referência-de-um-filho-para-o-seu-pai" id="adicionando-uma-referência-de-um-filho-para-o-seu-pai"><h4>Adicionando uma Referência de um Filho para o Seu Pai</h4></a>
<p>Para tornar o vértice filho ciente de seu pai, precisamos adicionar um campo
<code>pai</code> a nossa definição da struct <code>Vertice</code>. O problema é decidir qual deveria
ser o tipo de <code>pai</code>. Sabemos que ele não pode conter um <code>Rc&lt;T&gt;</code> porque isso
criaria um ciclo de referências com <code>folha.pai</code> apontando para <code>galho</code> e
<code>galho.filhos</code> apontando para <code>folha</code>, o que faria com que seus valores de
<code>strong_count</code> nunca chegassem a 0.</p>
<p>Pensando sobre as relações de outra forma, um vértice pai deveria ter posse de
seus filhos: se um vértice pai é destruído, seus vértices filhos também deveriam
ser. Entretanto, um filho não deveria ter posse de seu pai: se destruirmos um
vértice filho, o pai ainda deveria existir. Esse é um caso para referências
fracas!</p>
<p>Então em vez de <code>Rc&lt;T&gt;</code>, faremos com que o tipo de <code>pai</code> use <code>Weak&lt;T&gt;</code>, mais
especificamente um <code>RefCell&lt;Weak&lt;Vertice&gt;&gt;</code>. Agora nossa definição da struct
<code>Vertice</code> fica assim:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::rc::{Rc, Weak};
use std::cell::RefCell;

#[derive(Debug)]
struct Vertice {
    valor: i32,
    pai: RefCell&lt;Weak&lt;Vertice&gt;&gt;,
    filhos: RefCell&lt;Vec&lt;Rc&lt;Vertice&gt;&gt;&gt;,
}
#}</code></pre></pre>
<p>Agora um vértice pode se referir a seu vértice pai, mas não tem posse dele. Na
Listagem 15-28, atualizamos a <code>main</code> com essa nova definição para que o vértice
<code>folha</code> tenha um jeito de se referir a seu pai, <code>galho</code>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># use std::rc::{Rc, Weak};
# use std::cell::RefCell;
#
# #[derive(Debug)]
# struct Vertice {
#     valor: i32,
#     pai: RefCell&lt;Weak&lt;Vertice&gt;&gt;,
#     filhos: RefCell&lt;Vec&lt;Rc&lt;Vertice&gt;&gt;&gt;,
# }
#
fn main() {
    let folha = Rc::new(Vertice {
        valor: 3,
        pai: RefCell::new(Weak::new()),
        filhos: RefCell::new(vec![]),
    });

    println!(&quot;pai de folha = {:?}&quot;, folha.pai.borrow().upgrade());

    let galho = Rc::new(Vertice {
        valor: 5,
        pai: RefCell::new(Weak::new()),
        filhos: RefCell::new(vec![Rc::clone(&amp;folha)]),
    });

    *folha.pai.borrow_mut() = Rc::downgrade(&amp;galho);

    println!(&quot;pai de folha = {:?}&quot;, folha.pai.borrow().upgrade());
}
</code></pre></pre>
<p><span class="caption">Listagem 15-28: Um vértice <code>folha</code> com uma referência
<code>Weak</code> a seu vértice pai <code>galho</code></span></p>
<p>Criar o vértice <code>folha</code> é semelhante a como o criamos na Listagem 15-27, com
exceção do campo <code>pai</code>: <code>folha</code> começa sem um pai, então criamos uma instância
nova e vazia de uma referência <code>Weak&lt;Vertice&gt;</code>.</p>
<p>Nesse ponto, quando tentamos obter uma referência ao pai de <code>folha</code> usando o
método <code>upgrade</code>, recebemos um valor <code>None</code>. Vemos isso na saída do primeiro
comando <code>println!</code>:</p>
<pre><code class="language-text">pai de folha = None
</code></pre>
<p>Quando criamos o vértice <code>galho</code>, ele também tem uma nova referência
<code>Weak&lt;Vertice&gt;</code> no campo <code>pai</code>, porque <code>galho</code> não tem um vértice pai. Nós ainda
temos <code>folha</code> como um dos filhos de <code>galho</code>. Uma vez que temos a instância de
<code>Vertice</code> em <code>galho</code>, podemos modificar <code>folha</code> para lhe dar uma referência
<code>Weak&lt;Vertice&gt;</code> a seu pai. Usamos o método <code>borrow_mut</code> do
<code>RefCell&lt;Weak&lt;Vertice&gt;&gt;</code> no campo <code>pai</code> de <code>folha</code>, e então usamos a função
<code>Rc::downgrade</code> para criar uma referência <code>Weak&lt;Vertice&gt;</code> a <code>galho</code> a partir do
<code>Rc&lt;Vertice&gt;</code> em <code>galho</code>.</p>
<p>Quando imprimimos o pai de <code>folha</code> de novo, dessa vez recebemos uma variante
<code>Some</code> contendo <code>galho</code>: agora <code>folha</code> tem acesso a seu pai! Quando imprimimos
<code>folha</code>, nós também evitamos o ciclo que eventualmente terminou em um estouro de
pilha como o que tivemos na Listagem 15-26: as referências <code>Weak&lt;Vertice&gt;</code> são
impressas como <code>(Weak)</code>:</p>
<pre><code class="language-text">pai de folha = Some(Vertice { valor: 5, pai: RefCell { valor: (Weak) },
filhos: RefCell { valor: [Vertice { valor: 3, pai: RefCell { valor: (Weak) },
filhos: RefCell { valor: [] } }] } })
</code></pre>
<p>A falta de saída infinita indica que esse código não criou um ciclo de
referências. Também podemos perceber isso olhando para os valores que obtemos ao
chamar <code>Rc::strong_count</code> e <code>Rc::weak_count</code>.</p>
<a class="header" href="print.html#visualizando-mudanças-a-strong_count-e-weak_count" id="visualizando-mudanças-a-strong_count-e-weak_count"><h4>Visualizando Mudanças a <code>strong_count</code> e <code>weak_count</code></h4></a>
<p>Para ver como os valores de <code>strong_count</code> e <code>weak_count</code> das instâncias de
<code>Rc&lt;Vertice&gt;</code> mudam, vamos criar um novo escopo interno e mover a criação de
<code>galho</code> para dentro dele. Fazendo isso, podemos ver o que acontece quando
<code>galho</code> é criado e depois destruído quando sai de escopo. As modificações são
mostradas na Listagem 15-29:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># use std::rc::{Rc, Weak};
# use std::cell::RefCell;
#
# #[derive(Debug)]
# struct Vertice {
#     valor: i32,
#     pai: RefCell&lt;Weak&lt;Vertice&gt;&gt;,
#     filhos: RefCell&lt;Vec&lt;Rc&lt;Vertice&gt;&gt;&gt;,
# }
#
fn main() {
    let folha = Rc::new(Vertice {
        valor: 3,
        pai: RefCell::new(Weak::new()),
        filhos: RefCell::new(vec![]),
    });

    println!(
        &quot;folha: fortes = {}, fracas = {}&quot;,
        Rc::strong_count(&amp;folha),
        Rc::weak_count(&amp;folha),
    );

    {
        let galho = Rc::new(Vertice {
            valor: 5,
            pai: RefCell::new(Weak::new()),
            filhos: RefCell::new(vec![Rc::clone(&amp;folha)]),
        });

        *folha.pai.borrow_mut() = Rc::downgrade(&amp;galho);

        println!(
            &quot;galho: fortes = {}, fracas = {}&quot;,
            Rc::strong_count(&amp;galho),
            Rc::weak_count(&amp;galho),
        );

        println!(
            &quot;folha: fortes = {}, fracas = {}&quot;,
            Rc::strong_count(&amp;folha),
            Rc::weak_count(&amp;folha),
        );
    }

    println!(&quot;pai de folha = {:?}&quot;, folha.pai.borrow().upgrade());
    println!(
        &quot;folha: fortes = {}, fracas = {}&quot;,
        Rc::strong_count(&amp;folha),
        Rc::weak_count(&amp;folha),
    );
}
</code></pre></pre>
<p><span class="caption">Listagem 15-29: Criando <code>galho</code> em um escopo interno e
examinando contagens de referências fortes e fracas</span></p>
<p>Depois que <code>folha</code> é criada, seu <code>Rc&lt;Vertice&gt;</code> tem uma <em>strong count</em> de 1 e uma
<em>weak count</em> de 0. Dentro do escopo interno, criamos <code>galho</code> e o associamos a
<code>folha</code>. Nesse ponto, quando imprimimos as contagens, o <code>Rc&lt;Vertice&gt;</code> em <code>galho</code>
tem uma strong count de 1 e uma weak count de 1 (porque <code>folha.pai</code> aponta para
<code>galho</code> com uma <code>Weak&lt;Vertice&gt;</code>). Quando imprimirmos as contagens de <code>folha</code>,
veremos que ela terá uma strong count de 2, porque <code>galho</code> agora tem um clone do
<code>Rc&lt;Vertice&gt;</code> de <code>folha</code> armazenado em <code>galho.filhos</code>, mas ainda terá uma weak
count de 0.</p>
<p>Quando o escopo interno termina, <code>galho</code> sai de escopo e a strong count do
<code>Rc&lt;Vertice&gt;</code> diminui para 0, e então seu <code>Vertice</code> é destruído. A weak count de
1 por causa de <code>folha.pai</code> não tem nenhuma influência sobre se <code>Vertice</code> é
destruído ou não, então não temos nenhum vazamento de memória!</p>
<p>Se tentarmos acessar o pai de <code>folha</code> depois do fim do escopo, receberemos
<code>None</code> de novo. No fim do programa, o <code>Rc&lt;Vertice&gt;</code> em <code>folha</code> tem uma strong
count de 1 e uma weak count de 0, porque a variável <code>folha</code> agora é de novo a
única referência ao <code>Rc&lt;Vertice&gt;</code>.</p>
<p>Toda a lógica que gerencia as contagens e a destruição de valores faz parte de
<code>Rc&lt;T&gt;</code> e <code>Weak&lt;T&gt;</code> e suas implementações da trait <code>Drop</code>. Ao especificarmos na
definição de <code>Vertice</code> que a relação de um filho para o seu pai deva ser uma
referência <code>Weak&lt;T&gt;</code>, somos capazes de ter vértices pai apontando para para
vértices filho e vice-versa sem criar ciclos de referência e vazamentos de
memória.</p>
<a class="header" href="print.html#resumo-7" id="resumo-7"><h2>Resumo</h2></a>
<p>Esse capítulo cobriu como usar ponteiros inteligentes para fazer garantias e
trade-offs diferentes daqueles que o Rust faz por padrão com referências
normais. O tipo <code>Box&lt;T&gt;</code> tem um tamanho conhecido e aponta para dados alocados
no heap. O tipo <code>Rc&lt;T&gt;</code> mantém registro do número de referências a dados no
heap, para que eles possam ter múltiplos possuidores. O tipo <code>RefCell&lt;T&gt;</code> com
sua mutabilidade interior nos dá um tipo que podemos usar quando precisamos de
um tipo imutável mas precisamos mudar um valor interno ao tipo; ele também
aplica as regras de empréstimo em tempo de execução em vez de em tempo de
compilação.</p>
<p>Também foram discutidas as traits <code>Deref</code> e <code>Drop</code> que tornam possível muito da
funcionalidade dos ponteiros inteligentes. Exploramos ciclos de referências que
podem causar vazamentos de memória e como preveni-los usando <code>Weak&lt;T&gt;</code>.</p>
<p>Se esse capítulo tiver aguçado seu interesse e você quiser implementar seus
próprios ponteiros inteligentes, dê uma olhada no &quot;Rustnomicon&quot; em
<em>https://doc.rust-lang.org/stable/nomicon/</em> para mais informação útil.</p>
<p>Em seguida, conversaremos sobre concorrência em Rust. Você irá até aprender
sobre alguns novos ponteiros inteligentes.</p>
<a class="header" href="print.html#concurrency" id="concurrency"><h1>Concurrency</h1></a>
<a class="header" href="print.html#rust-é-uma-linguagem-orientada-a-objetos" id="rust-é-uma-linguagem-orientada-a-objetos"><h1>Rust é uma linguagem orientada a objetos?</h1></a>
<p>A programação orientada a objetos (POO) é uma maneira de modelar programas. Objetos vieram
da Simula nos anos 60. Esses objetos influenciaram a arquitetura de programação de
Alan Kay, onde os objetos passam mensagens uns aos outros. Ele criou o termo
programação orientada a objetos em 1967 para descrever essa arquitetura. Muitas
definições concorrentes descrevem o que é POO; algumas definições classificariam
Rust como orientada a objetos, mas outras definições não. Nesse capítulo, iremos
explorar certas características que são comumente consideradas orientda a objetos
e como essas características se traduzem no Rust. Então, mostraremos
como implementar um padrão de design orientado a objetos em Rust e discutir as
vantagens de fazer versus implementar uma solução usando alguns
pontos fortes do Rust.</p>
<a class="header" href="print.html#-o-que-significa-orientado-a-objetos" id="-o-que-significa-orientado-a-objetos"><h1>🇧🇷 O que significa orientado a objetos?</h1></a>
<a class="header" href="print.html#usando-objetos-trait-que-permitem-valores-de-tipos-diferentes" id="usando-objetos-trait-que-permitem-valores-de-tipos-diferentes"><h2>Usando objetos trait que permitem valores de tipos diferentes</h2></a>
<p>No Capítulo 8, mencionamos que uma limitação dos vetores é que eles apenas podem
armazenar elementos do mesmo tipo. Criamos uma solução alternativa na Listagem 8-10, onde
definimos um enum chamado <code>SpreadsheetCell</code> que tinha variantes para conter inteiros, flutuantes
e texto. Isso significa que poderiamos armazenar diferentes tipos de dados em cada célula e
ainda ter um vetor que representasse uma linha de células. Isso é uma solução ótima
quando nossos itens intercambiáveis são um conjunto fixo de tipos que sabemos
quando nosso código é compilado.</p>
<p>No entanto, algumas vezes queremos que nosso usuário de biblioteca seja capaz de estender o conjunto de
tipos que são válidos em uma situação específica. Para mostrar como podemos alcançar
isso, criaremos um exemplo de ferramenta de interface gráfica (GUI) que interage
através de uma lista de itens, chamando um método <code>desenhar</code> em cada um para desenhá-lo
na tela - uma técnica comum para ferramentas GUI. Criaremos uma crate chamada
<code>gui</code> que contém a estrutura da biblioteca GUI. Essa crate pode incluir
alguns tipos para as pessoas usarem, como um <code>Button</code> ou <code>TextField</code>. Além disso,
usuários de <code>gui</code>vão querer criar seus próprios tipos que podem ser desenhados: por
exemplo, um programados pode adicionar uma <code>Image</code> e outro pode adicionar um
<code>SelectBox</code>.</p>
<p>Não implementamos uma biblioteca gráfica completa para esse exemplo, mas mostraremos
como as peças se encaixariam. No momento de escrever a biblioteca, não podemos
saber e definir todos os tipos que outros programadores podem querer criar. Mas sabemos
que <code>gui</code> precisa manter o controle de diferentes valores de diferentes tipos e ele
precisa chamar o método <code>desenhar</code> em cada um desses diferentes tipos de valores. Não
é necessário saber exatamente o que acontecerá quando chamarmos o método <code>desenhar</code>,
apenas que o valor tera este método disponível para executarmos.</p>
<p>Para fazer isso em uma linguagem com herança, podemos definir uma classe chamada
<code>Component</code> que possui um método chamado <code>desenhar</code>. As outras classes, como as
<code>Button</code>, <code>Image</code> e <code>SelectBox</code>, herdam de <code>Component</code> e, assim,
herdam o método <code>desenhar</code>. Cada uma pode sobrescrever o método <code>desenhar</code> para definir
seu comportamento próprio, mas o framework poderia tratar todos esses tipos se
eles fossem instâncias de <code>Component</code> e chamar <code>desenhar</code> neles. Mas como Rust
não tem herança, precisamos de outra maneira para estruturar a biblioteca <code>gui</code> para
perminir que os usuários o estendam com novos tipos.</p>
<a class="header" href="print.html#definindo-um-trait-para-componentes-comuns" id="definindo-um-trait-para-componentes-comuns"><h3>Definindo um Trait para componentes comuns</h3></a>
<p>Para implementar o comportamento que queremos que <code>gui</code> tenha, definiremos um trait chamado
<code>Draw</code> que terá um método chamado <code>desenhar</code>. Então podemos definir um vetor
que tenha um <em>objeto trait</em>. Um objeto trait aponta para uma instância de um tipo que
implmenta o trait que especificamos. Criamos um objeto trait especificando alguns
tipos de ponteiros, como uma referência <code>&amp;</code> ou um ponteiro <code>Box&lt;T&gt;</code> e
especificando um trait relevante (falaremos sobre o motimo pelo qual os objetos trait
devem ser usados no Capítulo 19, na seção &quot;Tipos e tamanhos dimensionados dinamicamente&quot;).
Podemos usar objetos trait no lugar de um tipo genérico ou concreto. Onde quer que usemos
um objeto trait, o sistema de tipos do Rust irá garantir em tempo de compilação que qualquer
valor usado nesse contexto implementará o trait de um objeto trait.
Consequentemente, não precisamos saber todos os possíveis tipos em tempo de compilação.</p>
<p>Mencionamos que em Rust evitamos de chamar estruturas e enums de
&quot;objetos&quot; para distingui-los dos objetos de outras linguagens. Em uma estrutura ou
enum, o dado nos campos e o comportamento no bloco <code>impl</code> são
separados, enquanto em outras linguagens o dado e o comportamento são combinados em um
conceito muitas vezes chamado de objeto. No entanto, objetos trait <em>são</em> mais como
objetos em outras linguagens no sentido de combinar dados e comportamento.
Mas objetos trait diferem de objetos tradicionais, pois não podemos adicionar dados
a um objeto trait. Objetos trait geralmente não são proveitosas como um objeto de outras
linguagens: sua finalidade é simplemente possibilitar a abstração entre
comportamento comum.</p>
<p>Listagem 17-3 mostra como definir um trait chamado <code>Draw</code> com um método chamado
<code>desenhar</code>:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Draw {
    fn desenhar(&amp;self);
}
#}</code></pre></pre>
<p><span class="caption">Listagem 17-3: Definição do trait <code>Draw</code></span></p>
<p>Essa sintaxe deve parecer familiar de outras discussões de como definir traits
do Capítulo 10. Em seguida, vem uma nova sintaxe: A Listagem 17-4 define uma estrutuca chamada
<code>Janela</code> que contém um vetor chamado <code>componentes</code>. Esse vetor é do tipo
<code>Box&lt;Draw&gt;</code>, que é um objeto trait: é um substituto para qualquer tipo dentro de um
<code>Box</code> que implementa o trait <code>Draw</code>.</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub trait Draw {
#     fn desenhar(&amp;self);
# }
#
pub struct Janela {
    pub componentes: Vec&lt;Box&lt;Draw&gt;&gt;,
}
#}</code></pre></pre>
<p><span class="caption">Listagem 17-4: Definição da estrutura <code>Janela</code> com um
campo <code>componentes</code> que contém um vetor de objetos trait que implementam o
trait <code>Draw</code></span></p>
<p>Na estrutura <code>Janela</code>, definiremos um método chamado <code>executar</code> que irá chamar o
método <code>desenhar</code> em cada item do <code>componentes</code>, como mostrado na Listagem 17-5:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub trait Draw {
#     fn desenhar(&amp;self);
# }
#
# pub struct Janela {
#     pub componentes: Vec&lt;Box&lt;Draw&gt;&gt;,
# }
#
impl Janela {
    pub fn executar(&amp;self) {
        for component in self.componentes.iter() {
            component.desenhar();
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 17-5: Implementando um método<code>executar</code> na <code>Janela</code>
que chama o método <code>desenhar</code> para cada componente</span></p>
<p>Isso funciona de forma diferente do que definir uma estrutura que usa um parâmetro de tipo
genérico com trait bounds. Um parâmetro de tipo genérico pode
apenas ser substituido por um tipo concreto de cada vez, enquanto objetos trait permitem vários tipos
concretos para preencher o objeto trait em tempo de execução. Por exemplo, poderíamos
ter definido a estrutura <code>Janela</code> usando um tipo genérico e um trait bounds
como na Listagem 17-6:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub trait Draw {
#     fn desenhar(&amp;self);
# }
#
pub struct Janela&lt;T: Draw&gt; {
    pub componentes: Vec&lt;T&gt;,
}

impl&lt;T&gt; Janela&lt;T&gt;
    where T: Draw {
    pub fn executar(&amp;self) {
        for component in self.componentes.iter() {
            component.desenhar();
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 17-6: Uma implementação alternativa da estrutura <code>Janela</code>
e seu método <code>executar</code> usando genéricos e trait bounds</span></p>
<p>Isso nos restringe a uma instância de <code>Janela</code> que tem uma lista de componentes, todos
do tipo <code>Button</code> ou do tipo <code>TextField</code>. Se você tiver somente coleções do mesmo tipo,
usar genéricos e  trait bounds é preferível, porque as
definições serão monomorfizadas em tempo de compilação para os tipos concretos.</p>
<p>Por outro lado, com o método usando objetos trait, uma instância de <code>Janela</code>
pode conter um <code>Vec</code> que contém um <code>Box&lt;Button&gt;</code> assim como um <code>Box&lt;TextField&gt;</code>.
Vamos ver como isso funciona e falaremos sobre as impliciações do desempenho
em tempo de compilação.</p>
<a class="header" href="print.html#implementando-o-trait" id="implementando-o-trait"><h3>Implementando o Trait</h3></a>
<p>Agora, adicionaremos alguns tipos que implementam o trait <code>Draw</code>. Forneceremos o
tipo <code>Button</code>. Novamente, a implementação de uma biblioteca gráfica está além do escopo
deste livro, então o método <code>desenhar</code> não terá nenhum implementação útil.
Para imaginar como a implementação pode parecerm uma estrutura <code>Button</code>
pode ter os campos <code>largura</code>, <code>altura</code> e <code>label</code>, como mostra  a Listagem 17-7:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub trait Draw {
#     fn desenhar(&amp;self);
# }
#
pub struct Button {
    pub largura: u32,
    pub altura: u32,
    pub label: String,
}

impl Draw for Button {
    fn desenhar(&amp;self) {
        // Código para realmente desenhar um botão
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 17-7: Uma estrutura <code>Button</code> que implementa o
trait <code>Draw</code></span></p>
<p>Os campos <code>largura</code>, <code>altura</code> e <code>label</code> do <code>Button</code> serão diferentes
de campos de outros componentes, como o tipo <code>TextField</code>, que pode ter esses campos,
mais um campo <code>placeholder</code>. Para cada um dos tipo, queremos que desenhar na
tela o que implementamos no trait <code>Draw</code>, mas usará códigos diferentes no
método <code>desenhar</code> para definir como desenhar aquele tipo em específico, como o <code>Button</code> tem
aqui (sem o atual código da interface gráfica que está além do escopo desse capítulo).
<code>Button</code>, por exemplo, pode ter um bloco <code>impl</code> adicional,
contêndo métodos reladionados com o que acontece quando um usuário clica no botão. Esses tipos de
métodos não se aplicam a tipos como <code>TextField</code>.</p>
<p>Se alguém estiver usando nossa biblioteca para implementar a estrutura <code>SelectBox</code> que tem
os campos <code>largura</code>, <code>altura</code> e <code>opcoes</code>, eles implementam o
trait <code>Draw</code> no tipo <code>SelectBox</code>, como mostra a Listagem 17-8:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate gui;
use gui::Draw;

struct SelectBox {
    largura: u32,
    altura: u32,
    opcoes: Vec&lt;String&gt;,
}

impl Draw for SelectBox {
    fn desenhar(&amp;self) {
        // Código para realmente desenhar um select box
    }
}
</code></pre>
<p><span class="caption">Listagem 17-8: Outro crate usando <code>gui</code> e implementando
o trait <code>Draw</code> na estrutura <code>SelectBox</code></span></p>
<p>Os usuários da nosso biblioteca agoora podem escrever suas funções <code>main</code> para criar uma
instância de <code>Janela</code>. Para a instância de <code>Janela</code>, eles podem adicionar um <code>SelectBox</code> e um <code>Button</code>
colocando cada um em um <code>Box&lt;T&gt;</code> para se tornar um objeto trait. Eles podem chamar o
método <code>executar</code> na instância de <code>Janela</code>, que irá chamar o <code>desenhar</code> para cada um dos
componentes. A Listagem 17-9 mostra essa implementação:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">use gui::{Janela, Button};

fn main() {
    let screen = Janela {
        componentes: vec![
            Box::new(SelectBox {
                largura: 75,
                altura: 10,
                opcoes: vec![
                    String::from(&quot;Yes&quot;),
                    String::from(&quot;Maybe&quot;),
                    String::from(&quot;No&quot;)
                ],
            }),
            Box::new(Button {
                largura: 50,
                altura: 10,
                label: String::from(&quot;OK&quot;),
            }),
        ],
    };

    screen.executar();
}
</code></pre>
<p><span class="caption">Listagem 17-9: Usando objetos trait para armazenar valores
de tipos diferentes que implmentam trait semelhantes.</span></p>
<p>Quando escrevemos uma biblioteca, não sabemos o que alguém pode adicionar ao
tipo <code>SelectBox</code>, mas nossa implementação de <code>Janela</code> foi capaz de operar no
novo tipo e desenhá-lo, porque <code>SelectBox</code> implementa o tipo <code>Draw</code>, o que
significa que ele implementa o método <code>desenhar</code>.</p>
<p>Esse conceito - de se preocupar apenas com as mensagem que um valor responde
em vez do tipo concreto de valores - é similar ao conceito <em>duck typing</em>
em linguagens dinâmicamente tipadas: se anda como um pato e é como um pato,
então deve ser um pato! Na implementação do <code>executar</code> na <code>Janela</code> na Listagem
17-5, <code>executar</code> não precisa saber qual é o tipo concreto que cada componente é.
Ele não verifica se um componente é uma instância de <code>Button</code> ou
um <code>SelectBox</code>, apenas chama o método <code>desenhar</code> do componente. Especificando
<code>Box&lt;Draw&gt;</code> como o tipo dos valores do vetor <code>componentes</code>, definimos
<code>Janela</code> por precisarmos de valores nos quais podemos chamar o método <code>desenhar</code>.</p>
<p>A vantagem de usar objetos trait e o sistema de tipos do Rust para escrever códigos
semelhante ao código usando duck typing é que nunca precisamos verificar se um valor
implementa umm método em particular no tempo de execução ou se preocupar com erros se
um valor não implementa um método, mas nós o chamamos mesmo assim. Rust não irá compilar nosso
código se os valores não implementarem os traits que o objeto trait precisa.</p>
<p>Por exemplo, a Listagem 17-10 mostra o que acontece se tentarmos criar uma <code>Janela</code>
com uma <code>String</code> como um componente:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate gui;
use gui::Janela;

fn main() {
    let screen = Janela {
        componentes: vec![
            Box::new(String::from(&quot;Hi&quot;)),
        ],
    };

    screen.executar();
}
</code></pre>
<p><span class="caption">Listagem 17-10: Tentativa de usar um tipo que não
implementa o trait do objeto trait.</span></p>
<p>Obteremos esse erro, porque <code>String</code> não implementa o trait <code>Draw</code>:</p>
<pre><code class="language-text">error[E0277]: the trait bound `std::string::String: gui::Draw` is not satisfied
  --&gt; src/main.rs:7:13
   |
 7 |             Box::new(String::from(&quot;Hi&quot;)),
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait gui::Draw is not
   implemented for `std::string::String`
   |
   = note: required for the cast to the object type `gui::Draw`
</code></pre>
<p>Esse erro nos permite saber se estamos passando algo para <code>Janela</code> que não
pretenderíamos passar e que deveríamos passar um tipo diferente ou devemos implementar
<code>Draw</code> na <code>String</code>, para que <code>Janela</code> possa chamar <code>desenhar</code> nela.</p>
<a class="header" href="print.html#objetos-trait-executam-despacho-dinâmico" id="objetos-trait-executam-despacho-dinâmico"><h3>Objetos trait executam despacho dinâmico</h3></a>
<p>Lembre-se da seção &quot;Desempenho de código usando genéricos&quot; no Capítulo 10, nossa
discussão sobre o processo de monomorfização realizado pelo compilador quando
usamos trait bounds em genéricos: o compilador gera implementações não genéricas
de funções e métodos para cada tipo concreto que usamos no lugar
de um parâmetro de tipo genérico. O código que resulta da monomorfização
está fazendo <em>despacho estático</em>, que é quando o compilador sabe qual método você está
chamando em tempo de compilação. Isso é oposto ao <em>despacho dinâmico</em>, que é quando
o compilador não sabe dizer que método você está chamando em tempo de compilação. Nos casos
de despacho dinâmico, o compilador emite códigos que, em tempo de execução, descobrirá qual método
chamar.</p>
<p>Quando usamos objetos trait, o Rust deve usar despacho dinâmico. O compilador não
sabe todos os tipos que podem ser usados com código que está usando os objetos trait,
por isso não sabe qual método implementado em que tipo chamar.
Em vez disso, em tempo de execução, Rust usa os ponteiros dentro de objeto trait para saber
que método, específico, deve chamar. Há um custo de tempo de execução quando essa pesquisa ocorre,
que não ocorre com despacho estático. Dispacho dinâmico também impede que o
compilador escolha inline o código de um método, o que, por vezes, impede
algumas otimizações. No entanto, conseguimos uma maior flexibilidade no código que escrevemos
na Listagem 17-5 e foram capazes de suportar na Listagem 17-9, é uma desvantagem
a se considerar.</p>
<a class="header" href="print.html#a-segurança-do-objeto-é-necessário-para-objetos-trait" id="a-segurança-do-objeto-é-necessário-para-objetos-trait"><h3>A segurança do objeto é necessário para objetos trait</h3></a>
<p>Você apenas pode fazer <em>objetos traits seguros</em> em objetos traits. Algumas regras complexas
determinam todas as propriedades que fazem um objeto trait seguro, mas em prática, apenas
duas regras são relevantes. Um trait é um objeto seguro se todos os métodos definidos no
trait tem as seguintes propriedades:</p>
<ul>
<li>O retorno não é do tipo <code>Self</code>.</li>
<li>Não há parâmetros de tipo genérico.</li>
</ul>
<p>A palavra-chave <code>Self</code> é um pseudônimo para o tipo que estamos implementando o trait ou
método. Os objetos trait devem ser seguros, porque depois de usar um objeto trait,
o Rust não conhece mais o tipo concreto que está implementando aquele trait.
Se um método trait renorna o tipo concreto <code>Self</code>, mas um objeto trait esquece
o tipo exato que `Self é, não há como o método usar o tipo concreto
original. O mesmo é verdade para parâmetros de tipo genérico que  são preenchidos com
um parâmetro de tipo concreto, quando o trait é usado: os tipos concretos fazem
parte do tipo que implementa o trait. Quando o tipo é esquecido através
do uso de um objeto trait, não há como saber  que tipo preenchem os parâmetros de
tipo genérico.</p>
<p>Um exemplo de trait cujos métodos não são seguros para objetos
é o trait <code>Clone</code> da biblioteca padrão. A assinatura do método <code>clone</code> é o trait <code>Clone</code>
se parece com isso:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Clone {
    fn clone(&amp;self) -&gt; Self;
}
#}</code></pre></pre>
<p>O tipo <code>String</code> implemento o trait <code>Clone</code> e quando chamamos o método <code>clone</code>
numa instância de <code>String</code>, obtemos de retorno uma instância de <code>String</code>.
Da mesma forma, se chamarmos <code>clone</code> numa instância de <code>Vec</code>, retornamos uma instância
de <code>Vec</code>. A assinatura de do <code>clone</code> precisa saber que tipo terá o
<code>Self</code>, porque esse é o tipo de retorno.</p>
<p>O compilador indicará quando você estiver tentando fazer algo que viole as
regras de segurança de objetos em relação a objetos trait. Por exemplo, digamos
que tentamos implementar a estrutuda da Listagem 17-4 para manter os tipos que
implementam o trait <code>Clone</code> em vez do trait <code>Draw</code>, desta forma:</p>
<pre><code class="language-rust ignore">pub struct Janela {
    pub componentes: Vec&lt;Box&lt;Clone&gt;&gt;,
}
</code></pre>
<p>Teremos o seguinte erro:</p>
<pre><code class="language-text">error[E0038]: the trait `std::clone::Clone` cannot be made into an object
 --&gt; src/lib.rs:2:5
  |
2 |     pub componentes: Vec&lt;Box&lt;Clone&gt;&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::clone::Clone` cannot be
made into an object
  |
  = note: the trait cannot require that `Self : Sized`
</code></pre>
<p>Esse erro significa que você não pode usar esse trait como um objeto trait dessa maneira. Se
estiver interessado em mais detalhes sobre segurança de objetos, veja <a href="https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md">Rust RFC 255</a>.</p>
<a class="header" href="print.html#implementando-um-padrão-de-projeto-orientado-a-objetos" id="implementando-um-padrão-de-projeto-orientado-a-objetos"><h2>Implementando um padrão de projeto orientado a objetos</h2></a>
<p>O <em>padrão de estado</em> é um padrão de projeto orientado a objetos. O ponto crucial do padrão
é que um valor tem algun estado interno, que é representado por um conjunto
de <em>objetos de estado</em> e o comportamento do valor é alterado com base no estado
interno. Os objetos de estado compartilham funcionalidade: em Rust, é claro, usamos
estruturas e traits em vez de de objetos e herança. Cada objeto de estado é
responsável por seu próprio comportamento e por administrar quando dev mudar para outro
estado. O valor que contém um objeto de estado não sabe nada sobre o
comportamento diferente dos estados ou quando fazer transição entre os estados.</p>
<p>Usando o padrão de estados significa que quando os requisitos do negócio do programa
mudam, não precisamos mudar o código do valor que detém o estado ou o
código que usa o valor. Precisamos apenas atualizar o código dentro de um dos
objetos de estados para mudar suas regras ou talvez adicionar mais objetos de estados. Vamos ver
um exemplo de padrão de projeto de estados e como usá-lo no Rust.</p>
<p>Implementaremos um fluxo de trabalho de postagens de maneira incremental. A funcionalidade
final do blog será assim:</p>
<ol>
<li>Uma postagem no blog começa como um rascunho vazio.</li>
<li>Quando o rascunho é concluído, é necessária uma revisão da postagem.</li>
<li>Quando a postagem é aprovada, ela é aprovada.</li>
<li>Apenas postagens de blog publicadas retornam conteúdo para impressão, portanto, postagens não aprovadas não podem ser
publicadas por acidente.</li>
</ol>
<p>Quaisquer outras tentativas de mudança em uma postagem não deve ter efeito. Por exemplo, se
tentarmos aprovar um rascunho de postagem no blog antes de solicitarmos uma revisão, a postagem
a postagem deve permanecer em rascunho não publicado.</p>
<p>Listagem 17-11 mostra esse fluxo de trabalho em forma de código: este é um exemplo de uso de
API que implementaremos em um biblioteca crate chamada <code>blog</code>. Isso ainda não foi compilado,
porque não tempos implementado o crate <code>blog</code>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate blog;
use blog::Postagem;

fn main() {
    let mut post = Postagem::new();

    post.add_texto(&quot;Eu comi uma salada no almoço de hoje&quot;);
    assert_eq!(&quot;&quot;, post.conteudo());

    post.solicitar_revisao();
    assert_eq!(&quot;&quot;, post.conteudo());

    post.aprovar();
    assert_eq!(&quot;Eu comi uma salada no almoço de hoje&quot;, post.conteudo());
}
</code></pre>
<p><span class="caption">Listagem 17-11: Código que demonstra o desejado
comportamento que queremos que o nosso crate<code>blog</code> tenha</span></p>
<p>Queremos permitir que o usuário crie uma nova postagem de blog com <code>Postagem :: new</code>.
Então, queremos permitir que o texto seja adicionado à postagem do blog enquanto ela estiver no estado de
rascunho. Se tentarmos obter o conteúdo da postagem imediatamente, antes da aprovação,
nada deve acontecer porque a postagem ainda é um rascunho. Adicionamos
<code>assert_eq!</code> no código para fins de demonstração. Um excelente teste unitário para
isso seria afirmar que uma postagem do blog em rascunho retorna uma string vazia do método
<code>conteudo</code>, mas não vamos escrever testes para este exemplo.</p>
<p>Em seguida, queremos possibilitar uma solicitação de revisão para a postagem e queremos que o
<code>conteudo</code> retorne uma string vazia enquanto aguarda a revisão. Quand a postagem
for aprovada, deve ser publicada, significa que o texto da postagem
será retornada quando o <code>conteudo</code> for chamado.</p>
<p>Observe que o único tipo com o qual estamos interagindo, do crate, é o
tipo <code>Postagem</code>. Esse tipo usará padrão de estados e terá um valor que será
um dos três estados de objeto, representam os vários estados em que uma postagem pode estar
em - rascunho, esperando por revisão ou publicada. Mudar de um estado para outro será
gerenciado internamente com o tipo <code>Postagem</code>. Os estados mudam em
resposta aos métodos chamados pelos usuários da bibliotéca sobre a instância <code>Postagem</code>,
mas eles não precisam gerenciar as alterações de estados diretamente. Além disso, usuários não podem
cometer erros nos estados, como publicar uma postagem antes de revisá-la.</p>
<a class="header" href="print.html#definindo-postagem-e-criando-uma-nova-instância-no-estado-de-rascunho" id="definindo-postagem-e-criando-uma-nova-instância-no-estado-de-rascunho"><h3>Definindo <code>Postagem</code> e criando uma nova instância no estado de rascunho</h3></a>
<p>Vamos começar a implementação da biblioteca! Sabemos que precisamos da
estrutura pública <code>Postagem</code> que contenha algum conteúdo, por isso começaremos com a
definição da estrutura e a função pública <code>new</code> associada para criar uma
instância de <code>Postagem</code>, como mostra a Listageḿ 17-12. Também faremos um trait privado
<code>Estado</code>. Então o <code>Postagem</code> conterá um objeto trait <code>Box&lt;Estado&gt;</code> dentro de um
<code>Opcao</code> em um campo privado, chamado <code>estado</code>. Você verá porquê o <code>Opcao</code>
é necessário.</p>
<p>O trait <code>Estado</code> define o comportamento compartilhado por diferentes estados de postagem e os
estados <code>Rascunho</code>, <code>RevisaoPendente</code> e <code>Publicado</code> implementarão todos os
trait <code>Estado</code>. Por equanto, o trait não tem nenhum método; e começaremos definindo
apenas o estado <code>Rascunho</code>, porque esse é o estado em que queremos uma postagem inicialmente:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Postagem {
    estado: Opcao&lt;Box&lt;Estado&gt;&gt;,
    conteudo: String,
}

impl Postagem {
    pub fn new() -&gt; Postagem {
        Postagem {
            estado: Some(Box::new(Rascunho {})),
            conteudo: String::new(),
        }
    }
}

trait Estado {}

struct Rascunho {}

impl Estado for Rascunho {}
#}</code></pre></pre>
<p><span class="caption">Listagem 17-12: Definição da estrutura <code>Postagem</code> e a função <code>new</code>,
que cria uma nova instância de <code>Postagem</code>, um trait <code>Estado</code> e uma
estrutura <code>Rascunho</code></span></p>
<p>Quando criamos um novo <code>Postagem</code>, definimos seu campo <code>estado</code> como um valor <code>Some</code>, que
conterá um <code>Box</code>. Este <code>Box</code> aponta para uma nova instância da estrutura <code>Rascunho</code>. Isso
garante que sempre criamos uma nova instância de <code>Postagem</code>, ela começará como um
rascunho. Como o campo <code>estado</code> do <code>Postagem</code> é privado, não há como
criar um <code>Postagem</code> em qualquer outro estado!</p>
<a class="header" href="print.html#armazenando-o-texto-do-conteúdo-do-post" id="armazenando-o-texto-do-conteúdo-do-post"><h3>Armazenando o texto do conteúdo do post</h3></a>
<p>Na função <code>Postagem::new</code>, definimos o campo <code>conteudo</code> como uma novo
<code>String</code> vazia. Listagem 17-11 mostrou que queremos poder chamar o método chamado
<code>add_texto</code> e passar um <code>&amp;str</code> que é então adicionado ao conteúdo do texto da
postagem do blog. Implementamos isso como uma método, em vez de expor o campo <code>conteudo</code>
como <code>pub</code>. Isso significa que podemos implementar um método posteriormente que controlará
como os dados do campo <code>conteudo</code> são lidos. O método <code>add_texto</code> é bastante direto,
então vamos adicionar a implementação na Listagem 17-13 ao bloco
<code>impl Postagem</code>:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Postagem {
#     conteudo: String,
# }
#
impl Postagem {
    // --recorte--
    pub fn add_texto(&amp;mut self, text: &amp;str) {
        self.conteudo.push_str(text);
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 17-13: Implementando o método <code>add_texto</code> para adicionar o
texto ao <code>conteudo</code> da postagem</span></p>
<p>O método <code>add_texto</code> usa uma referência mutável ao <code>self</code>, porque estamos
mudando a instância <code>Postagem</code> que estamos chamando a partir de<code>add_texto</code>. Então chamamos
<code>push_str</code> na <code>String</code> em <code>conteudo</code> e passamos o argumento <code>text</code> para adicionar ao <code>conteudo</code>
salvo. Esse comportamento não depende do estado em que a postagem está,
portanto, não faz parte do padrão de estados. O método <code>add_texto</code> não interage
com o campo <code>estado</code>, mas faz parte do comportamento que queremos
suportar.</p>
<a class="header" href="print.html#garantindo-que-o-conteúdo-de-um-rascunho-de-postagem-esteja-vazio" id="garantindo-que-o-conteúdo-de-um-rascunho-de-postagem-esteja-vazio"><h3>Garantindo que o conteúdo de um rascunho de postagem esteja vazio</h3></a>
<p>Mesmo depois que chamamos <code>add_texto</code> e adicionamos algum conteúdo para nossa postagem, ainda
queremos que o método <code>conteudo</code> retorne um pedaço de string vazia, porque a postagem ainda
está no está de rascunho, como mostrado na linha 8 da Listagem 17-11. Por hora, vamos
implementar o método <code>conteudo</code> com a coisa mais simples que atenderá a esse
requisito: sempre retornando um pedaço de string vazia. Mudaremos isso mais tarde,
quando implementaremos a possibilidade de mudar o estado de uma postagem para que ela possa ser publicada.
Até agora, postagens apenas podem estar no estado de rascunho, portanto, o conteúdo da publicação deve estar
vazio. Listagem 17-14 mostra essa implementação substituta:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Postagem {
#     conteudo: String,
# }
#
impl Postagem {
    // --recorte--
    pub fn conteudo(&amp;self) -&gt; &amp;str {
        &quot;&quot;
    }
}
#}</code></pre></pre>
<p><span class="caption">LIstagem 17-14: Adicionando temporária para
o método <code>conteudo</code> do <code>Postagem</code> que sempre retorna uma string vazia</span></p>
<p>Como o método <code>conteudo</code> adicionado, tudo na Listagem 17-11 até a linha 8
funciona como prentendido.</p>
<a class="header" href="print.html#solicitando-uma-revisão-da-postagem-que-altera-seu-estado" id="solicitando-uma-revisão-da-postagem-que-altera-seu-estado"><h3>Solicitando uma revisão da postagem que altera seu estado</h3></a>
<p>Em seguida, nós precisamos adicionar funcionalidade para solicitar uma revisão da postagem, que deve
mudar seu estado de <code>Rascunho</code> para <code>RevisaoPendente</code>. Listagem 17-15 mostra este código:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Postagem {
#     estado: Opcao&lt;Box&lt;Estado&gt;&gt;,
#     conteudo: String,
# }
#
impl Postagem {
    // --recorte--
    pub fn solicitar_revisao(&amp;mut self) {
        if let Some(s) = self.estado.take() {
            self.estado = Some(s.solicitar_revisao())
        }
    }
}

trait Estado {
    fn solicitar_revisao(self: Box&lt;Self&gt;) -&gt; Box&lt;Estado&gt;;
}

struct Rascunho {}

impl Estado for Rascunho {
    fn solicitar_revisao(self: Box&lt;Self&gt;) -&gt; Box&lt;Estado&gt; {
        Box::new(RevisaoPendente {})
    }
}

struct RevisaoPendente {}

impl Estado for RevisaoPendente {
    fn solicitar_revisao(self: Box&lt;Self&gt;) -&gt; Box&lt;Estado&gt; {
        self
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 17-15: Implementando método <code>solicitar_revisao</code> no
<code>Postagem</code> e no trait <code>Estado</code></span></p>
<p>Nós fornecemos ao <code>Postagem</code> um método público chamado <code>solicitar_revisao</code> que irá tormar uma referência
mutável para <code>self</code>. Em seguida, chamamos internamente o método <code>solicitar_revisao</code>
do estado atual do <code>Postagem</code> e esse segundo método <code>solicitar_revisao</code> consome o
estado atual e retorna um novo estado.</p>
<p>Adicionamos o método <code>solicitar_revisao</code> para o trait <code>Estado</code>; todos os tipos
que implementam o trait, agora precisarão implementar o método <code>solicitar_revisao</code>.
Note que em vez de ter <code>self</code>, <code>&amp;self</code> ou <code>&amp;mut self</code> como
primeiro parâmetro do método, temos <code>self: Box&lt;Self&gt;</code>. Essa sintaxe significa que
o método é apenas válido quando chamado em um <code>Box</code> contendo o tipo. Essa sintaxe apropria-se
do <code>Box&lt;Self&gt;</code>, invalidando o antigo estado para que o valor de estado do
<code>Postagem</code> possa se transfor em um novo estado.</p>
<p>Para consumir o antigo estado, o método <code>solicitar_revisao</code> precisa apropriar-se
do valor do estado. Este é o lugar onde o <code>Opcao</code> no campo <code>estado</code> do <code>Postagem</code>:
chamamos o método <code>take</code> para tirar o valor de <code>Some</code> do campo <code>estado</code>
e deixar um <code>None</code> no lugar, porque Rust não nos permite ter
campos não preenchidos nas estruturas. Isso nos permite mover o valor do <code>estado</code> para fora
do <code>Postagem</code> em vez de pedir emprestado. Em seguida, definiremos o valor do <code>estado</code> da postagem como
resultado da operação.</p>
<p>Precisamos definir o <code>estado</code> como <code>None</code> temporariamente em vez de configurá-la diretamente
com o código <code>self.estado = self.estado.solicitar_revisao();</code> para obter a posse do
valor de <code>estado</code>. Isso garante que o <code>Postagem</code> não pode usar o antigo valor do <code>estado</code> depois
de transformá-lo em um novo estado.</p>
<p>O método <code>solicitar_revisao</code> no <code>Rascunho</code> precisa retornar uma nova instância em caixa de
uma nova estrutura <code>RevisaoPendente</code>, que representa o estado quando uma postagem está aguardando
uma revisão. A estrutura <code>RevisaoPendente</code> também implementa o método <code>solicitar_revisao</code>,
mas não faz nenhuma transformação. Em vez disso, ele retorna a si mesmo, porque
quando solicitamos uma revisão em uma publicação já no estado <code>RevisaoPendente</code>, ele deve
permanecer no estado <code>RevisaoPendente</code>.</p>
<p>Agora podemos começar a ver as vantagens do padrçao de estados: o método
<code>solicitar_revisao</code> no <code>Postagem</code> é o mesmo, não importa seu valor <code>estado</code>. Cada
estado é responsável por suas próprias regras.</p>
<p>Deixaremos o método <code>conteudo</code> do <code>Postagem</code> como está, retornando uma string
vazia. Agora podemos ter um <code>Postagem</code> no estado <code>RevisaoPendente</code>, bem como no estado
<code>Rascunho</code>, mas queremos o mesmo comportamento no estado <code>RevisaoPendente</code>.
Listagem 17-11 agora funciona até a linha 11!</p>
<a class="header" href="print.html#adicionando-o-método-aprovar-que-muda-o-coportamento-do-conteudo" id="adicionando-o-método-aprovar-que-muda-o-coportamento-do-conteudo"><h3>Adicionando o método <code>aprovar</code> que muda o coportamento do <code>conteudo</code></h3></a>
<p>O método <code>aprovar</code> será semelhante ao método <code>solicitar_revisao</code>: ele
definirá <code>estado</code> com um valor que o estado atual diz que deve ter quando esse
estado é aprovado, como mostra a Listagem 17-16:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Postagem {
#     estado: Opcao&lt;Box&lt;Estado&gt;&gt;,
#     conteudo: String,
# }
#
impl Postagem {
    // --recorte--
    pub fn aprovar(&amp;mut self) {
        if let Some(s) = self.estado.take() {
            self.estado = Some(s.aprovar())
        }
    }
}

trait Estado {
    fn solicitar_revisao(self: Box&lt;Self&gt;) -&gt; Box&lt;Estado&gt;;
    fn aprovar(self: Box&lt;Self&gt;) -&gt; Box&lt;Estado&gt;;
}

struct Rascunho {}

impl Estado for Rascunho {
#     fn solicitar_revisao(self: Box&lt;Self&gt;) -&gt; Box&lt;Estado&gt; {
#         Box::new(RevisaoPendente {})
#     }
#
    // --recorte--
    fn aprovar(self: Box&lt;Self&gt;) -&gt; Box&lt;Estado&gt; {
        self
    }
}

struct RevisaoPendente {}

impl Estado for RevisaoPendente {
#     fn solicitar_revisao(self: Box&lt;Self&gt;) -&gt; Box&lt;Estado&gt; {
#         self
#     }
#
    // --recorte--
    fn aprovar(self: Box&lt;Self&gt;) -&gt; Box&lt;Estado&gt; {
        Box::new(Publicado {})
    }
}

struct Publicado {}

impl Estado for Publicado {
    fn solicitar_revisao(self: Box&lt;Self&gt;) -&gt; Box&lt;Estado&gt; {
        self
    }

    fn aprovar(self: Box&lt;Self&gt;) -&gt; Box&lt;Estado&gt; {
        self
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 17-16: Implementando o método <code>aprovar</code> no
<code>Postagem</code> e o trait <code>Estado</code></span></p>
<p>Adicionamos o método <code>aprovar</code> para o trait <code>Estado</code> e adicionamos uma nova estrutura que
implementa <code>Estado</code>, o estado <code>Publicado</code>.</p>
<p>Semelhante ao <code>solicitar_revisao</code>, se chamarmos o método <code>aprovar</code> no <code>Rascunho</code>, ele
não terá efeito, porque ele retornará <code>self</code>. Quando chamamos <code>aprovar</code> do
<code>RevisaoPendente</code>, ele retorna uma nova instância em caixa da estrutura <code>Publicado</code>.
A estrutura <code>Publicado</code> implementa o trait <code>Estado</code> e, tanto para
o método <code>solicitar_revisao</code> quanto para o <code>aprovar</code>, ele retorna si próprio., porque
a postagem deve permanecer no estado <code>Publicado</code> nesses casos.</p>
<p>Agora, precisamos atualizar o método <code>conteudo</code> do <code>Postagem</code>: se o estado for
<code>Publicado</code>, queremos que retorne o valor do campo <code>conteudo</code> da publicação;
caso contrário, queremos que retorne uma string vazia, como mostra a Listagem 17-17:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# trait Estado {
#     fn conteudo&lt;'a&gt;(&amp;self, post: &amp;'a Postagem) -&gt; &amp;'a str;
# }
# pub struct Postagem {
#     estado: Opcao&lt;Box&lt;Estado&gt;&gt;,
#     conteudo: String,
# }
#
impl Postagem {
    // --recorte--
    pub fn conteudo(&amp;self) -&gt; &amp;str {
        self.estado.as_ref().unwrap().conteudo(&amp;self)
    }
    // --recorte--
}
#}</code></pre></pre>
<p><span class="caption">Listagem 17-17: Atualizando o método <code>conteudo</code> do <code>Postagem</code> para
encarregar o método <code>conteudo</code> em <code>Estado</code></span></p>
<p>Porque o objetivo é manter todos essas regras dentro das estruturas que implementam
<code>Estado</code>, chamamos o método <code>conteudo</code>no valor em <code>estado</code> e passamos a instância
da postagem (que é, <code>self</code>) como um argumento. Então retornamos o valor que é
retornado usando o método <code>conteudo</code> do valor do <code>estado</code>.</p>
<p>Nós chamamos o método <code>as__ref</code> do <code>Opcao</code> porque queremos uma referência ao valor
do <code>Opcao</code> em vez da propriedade do valor. Como <code>estado</code>
é um <code>Opcao&lt;Box&lt;Estado&gt;&gt;</code>, quando chamamos <code>as_ref</code>, um <code>Opcao&lt;Box&lt;Estado&gt;&gt;</code> é
retornado. Se não chamarmos <code>as__ref</code>, receberíamos um erro,
porque não podemos obter <code>estado</code> emprestado do <code>&amp;self</code> do parâmetro da função.</p>
<p>Então chamamos o método <code>unwrap</code>, que sabemos que nunca vai entrar em pânico, porque sabemos
que os métodos em <code>Postagem</code>garantem que o <code>estado</code> sempre conterá um valor <code>Some</code>
quando esses métodos forem realizados. Esse é um dos casos sobre os quais falamos na
seção &quot;Casos em que Você Tem Mais Informação Que o Compilador&quot; do Capítulo
9, quando sabemos que um valor <code>None</code> nunca é possível, mesmo que o compilador não
consiga ententer isso.</p>
<p>Nesse momento, quando chamamos <code>conteudo</code> no <code>&amp;Box&lt;Estado&gt;</code>, a coerção deref terá
efeito no <code>&amp;</code> e no <code>Nox</code>, então finalmente o método
<code>conteudo</code> é chamado no tipo que implementa o trait <code>Estado</code>. Isso significa que precisamos adicionar
<code>conteudo</code> à definição do trait <code>Estado</code> e que é onde colocaremos
a lógica de qual conteúdo retornar, dependendo do estado que temos, como mostra
a Listagem 17-18:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Postagem {
#     conteudo: String
# }
trait Estado {
    // --recorte--
    fn conteudo&lt;'a&gt;(&amp;self, post: &amp;'a Postagem) -&gt; &amp;'a str {
        &quot;&quot;
    }
}

// --recorte--
struct Publicado {}

impl Estado for Publicado {
    // --recorte--
    fn conteudo&lt;'a&gt;(&amp;self, post: &amp;'a Postagem) -&gt; &amp;'a str {
        &amp;post.conteudo
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 17-18: Adicionando o método <code>conteudo</code> ao trait
<code>Estado</code></span></p>
<p>Adicionamos uma implementação padrão para o método <code>conteudo</code>, que retorna uma
string vazia. Isso significa que não preciamos implementar <code>conteudo</code> nas estruturas <code>Rascunho</code> e
<code>RevisaoPendente</code>. A estrutura <code>Publicado</code> irá sobrepor o método <code>conteudo</code>
e retornar o valor do <code>post.conteudo</code>.</p>
<p>Observe que precisamos anotações de vida útil nesse método, como discutimos no
Capítulo 10. Estamos fazendo uma referência a um <code>post</code> como argumento e retornando uma
referência a parte desse <code>post</code>, então o tempo de vida útil da referência retornada é
relacionada ao tempo de vida útil do argumento <code>post</code>.</p>
<p>E estamos prontos - tudo da Listagem 17-11 agora funcionam! Nós implementamos o padrão de estados
com as regras do fluxo de trabalho da postagem no blog. A lógica relacionada
às regras vive nos objetos de estados, em vez de estar espalhada por todo o <code>Postagem</code>.</p>
<a class="header" href="print.html#vantagens-e-desvantagens-do-padrão-de-estados" id="vantagens-e-desvantagens-do-padrão-de-estados"><h3>Vantagens e desvantagens do padrão de estados</h3></a>
<p>Mostramos que o Rust é capaz de implementar o padrão de estado orientação a objetos
para encapsular os diferentes tipos de comportamentos que um post deve ter em
cada estado. Os métodos do <code>Postagem</code> não sabem nada sobre os vários comportamentos. A
maneira como organizamos o código, nós só temos de procurar num só lugar pra conhecer as
diferentes formas como uma postagem pode comportar-se: a implementação do trait <code>Estado</code>
na estrutura <code>Publicado</code>.</p>
<p>Se fôssemos criar uma implementação alternativa que não usasse o padrão
de estados, poderíamos usar instruções <code>match</code> nos métodos do <code>Postagem</code> ou
mesmo no código <code>main</code>, que verifica o estado da postagem e muda o comportamento
nesses locais. Isso significaria que teríamos que procurar em vários lugares para
entender todas as implicações de uma postagem estar no estado publicado! Isso só
aumentaria o número de estados que adicionamos: cada uma dessas instruções <code>match</code>
precisaria de outra ramificação.</p>
<p>Com o padrão de de estados, os métodos de <code>Postagem</code> e os locais que usam <code>Postagem</code> não
precisam da instrução <code>match</code> e para adicionar um novo estado, apenas precisamos adicionar uma nova estrutura e
implementar os métodos trait nessa estrutura.</p>
<p>A implementação usando o padrão de estados é fácil de estender para adicionar mais
funcionalidades. Para ver a simplicidade de manter o código que usa padrão de
estados, tente usar essas sugestões:</p>
<ul>
<li>Adicionar um método <code>reject</code> que altere o estado de postagem de <code>RevisaoPendente</code> de volta
para <code>Rascunho</code>.</li>
<li>Requer duas chamadas para <code>aprovar</code> antes que o estado possa ser alterado para <code>Publicado</code>.</li>
<li>Permitir que os usuários adicinem conteúdo de texto somente quando uma postagem estiver no estado <code>Rascunho</code>.
Dica: Ter o objeto de estado responsável pelo que pode mudar sobre o
conteúdo, mas não responsável por modificar o <code>Postagem</code>.</li>
</ul>
<p>Uma desvantagem do padrão de estados é que como os estados implementam as
transições entre estados, alguns dos estados estão acoplados uns aos outros. Se adicionarmos
outros estados entre <code>RevisaoPendente</code> e <code>Publicado</code>, como um <code>Scheduled</code>,
teríamos que mudar o código de <code>RevisaoPendente</code> para fazer a transição para
<code>Scheduled</code>. Seria menos trabalhoso se <code>RevisaoPendente</code> não precisasse de
mudanças com a adição de um novo estado, mas isso significaria mudar para
outro padrão de projetos.</p>
<p>Outra desvantagem é que nós duplicamos algumas lógicas. Para eleminar parte da
duplicação, podemos tentar fazer a implementação padrão dos métodos
<code>solicitar_revisao</code> e <code>aprovar</code> no trait <code>Estado</code>, que retorna <code>self</code>;
no entanto, isso violaria a segurança dos objetos, porque o trait não sabe
exatamente o que é o <code>self</code> concreto. Queremos que seja possível usar <code>Estado</code> como um
objeto trait, entao precisamos que seus métodos sejam objetos seguros.</p>
<p>Outra duplicação inclui a implementação semelhante dos métodos <code>solicitar_revisao</code>
e <code>aprovar</code> do <code>Postagem</code>. Ambos os métodos delegam a implementação do
mesmo método sobre o valor do campo <code>estado</code> do <code>Opcao</code> e definem  o novo
valor do campo <code>estado</code> para o resultado. Se tivéssemos muitos métodos no <code>Postagem</code>
que seguissem  esse padrão, poderíamos considerar a definição de uma macro para eliminar
a repetição (veja o Apêndice D, Macros).</p>
<p>Ao implementar o padrão de estados exatamente como ele é definido para linguagens orientada a objetos,
não estamos aproveitando ao máximo os pontos fortes do Rust como
poderíamos. Vamos ver algumas mudanças que podemos fazer no o crate <code>blog</code>, que pode tornar
estados e transições inválidas em erros em tempo de compilação.</p>
<a class="header" href="print.html#codificando-estados-e-comportamento-como-tipo" id="codificando-estados-e-comportamento-como-tipo"><h3>Codificando estados e comportamento como tipo</h3></a>
<p>Mostraremos como repensar o padrão de estados para obter um conjunto diferente de
compensações. Em vez de encapsular completamente os estados e transições para que o
código externo não tenha conhecimento dele, codificaremos os estados em diferentes
tipos. Consequentemente, o sistema de verificação de tipo do Rust impedirá que as tentativas de usar
mensagens de rascunho, em que apenas as postagens publicadas sejam permitidas, emitem um erro do compilador.</p>
<p>Vamos considerar a primeira parte do <code>main</code> na Listagem 17-11:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let mut post = Postagem::new();

    post.add_texto(&quot;Eu comi uma salada no almoço de hoje&quot;);
    assert_eq!(&quot;&quot;, post.conteudo());
}
</code></pre>
<p>Ainda permitimos a criação de novas postagens no estado de rascunho, usando <code>Postagem::new</code>
e a capacidade de adicionar texto ao conteúdo da postagem. Mas em vez de ter um
método <code>conteudo</code> em um rascunho, que retorna uma string vazia, vamos fazer com que as
mensagens de rascunho não tenham o método <code>conteudo</code>. Dessa forma, se tentarmos pegar o
conteúdo de uma postagem de rascunho, receberemos um erro do compilador informando que o método
não existe. Como resultado, será possível exibir , acidentalmente,
o conteúdo do rascunho em produção, porque esse código nem será compilado.
Listagem 17-19 mostra a definição de uma estrutura <code>Postagem</code>, uma estrutura <code>RascunhoPostagem</code> e
métodos em cada um deles:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Postagem {
    conteudo: String,
}

pub struct RascunhoPostagem {
    conteudo: String,
}

impl Postagem {
    pub fn new() -&gt; RascunhoPostagem {
        RascunhoPostagem {
            conteudo: String::new(),
        }
    }

    pub fn conteudo(&amp;self) -&gt; &amp;str {
        &amp;self.conteudo
    }
}

impl RascunhoPostagem {
    pub fn add_texto(&amp;mut self, text: &amp;str) {
        self.conteudo.push_str(text);
    }
}
#}</code></pre></pre>
<p><span class="caption">Arquivo 17-19: Uma <code>Postagem</code> com um método <code>conteudo</code>e um
<code>RascunhoPostagem</code> sem um método <code>conteudo</code></span></p>
<p>Ambas as estruturas <code>Postagem</code> e <code>RascunhoPostagem</code> têm um campo <code>conteudo</code> privado, que
armazena o texto da postagem do blog. As estruturas não têm mais o campo <code>estado</code> porque
estamos movendo a codificação do estado para os tipos de cada estrutura. A estrutura <code>Postagem</code>
representará uma postagem publicada e tem um método <code>conteudo</code> que
retorna o <code>conteudo</code>.</p>
<p>Nós ainta temos uma função <code>Postagem::new</code>, mas ao invés de retornar uma instância de
<code>Postagem</code>, ela retorna uma instância de <code>RascunhoPostagem</code>. Como <code>conteudo</code> é privado
e não há nenhuma função que retorne <code>Postagem</code>, não é possível criar uma
instância de <code>Postagem</code> agora.</p>
<p>A estrutura <code>RascunhoPostagem</code> tem um método <code>add_texto</code> para que possamos adicionar texto ao <code>conteudo</code>
como antes, mas note que <code>RascunhoPostagem</code> não possui um método <code>conteudo</code> definido!
Então, agora, o programa garante que todas as postagens iniciem como rascunhos e, rascunho
não têm seu conteúdo disponível para exibição. Qualquer tentativa de contornar essas
restrições resultará em um erro de compilador.</p>
<a class="header" href="print.html#implementando-transações-como-transformações-em-diferentes-tipos" id="implementando-transações-como-transformações-em-diferentes-tipos"><h4>Implementando transações como transformações em diferentes tipos</h4></a>
<p>Então, como conseguimos uma publicar uma postagem? Queremos impor a regra de que um
rascunho tenha de ser revisada e aprovada antes dela poder ser publicada. Uma postagem no estado de
revisão pendente ainda não deve exibir nenhum conteúdo. Vamos implementar essas restrições
adicionando outra estrutura, <code>RevisaoPendentePostagem</code>, definindo o método
<code>solicitar_revisao</code> no <code>RascunhoPostagem</code> para retornar um <code>RevisaoPendentePostagem</code> e
definindo um método <code>aprovar</code> no <code>RevisaoPendentePostagem</code> para retornar um <code>Postagem</code>, como
mostra a Listagem 17-20:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Postagem {
#     conteudo: String,
# }
#
# pub struct RascunhoPostagem {
#     conteudo: String,
# }
#
impl RascunhoPostagem {
    // --recorte--

    pub fn solicitar_revisao(self) -&gt; RevisaoPendentePostagem {
        RevisaoPendentePostagem {
            conteudo: self.conteudo,
        }
    }
}

pub struct RevisaoPendentePostagem {
    conteudo: String,
}

impl RevisaoPendentePostagem {
    pub fn aprovar(self) -&gt; Postagem {
        Postagem {
            conteudo: self.conteudo,
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 17-20: Uma <code>RevisaoPendentePostagem</code> que é criado
chamando <code>solicitar_revisao</code> no <code>RascunhoPostagem</code> e um método <code>aprovar</code> que transforma um
<code>RevisaoPendentePostagem</code> em um <code>Postagem</code> publicado</span></p>
<p>Os métodos <code>solicitar_revisao</code> e <code>aprovar</code> tomam posso do <code>self</code>, consumindo
as instâncias <code>RascunhoPostagem</code> e <code>RevisaoPendentePostagem</code> e transformando-os
em <code>RevisaoPendentePostagem</code> e <code>Postagem</code> publicado respectivamente. Dessa forma,
não teremos instâncias <code>RascunhoPostagem</code> remanecentes após chamarmos
<code>solicitar_revisao</code> e, assim por diante. A estrutura <code>RevisaoPendentePostagem</code> não tem um método
<code>conteudo</code> definido dele, portanto, tentar ler seu conteúdo
resulta em um erro do compilador. como em <code>RascunhoPostagem</code>. Porque o único modo de ter uma
instância pública de <code>Postagem</code> que tenha um método <code>conteudo</code> definico é chamar o
método <code>aprovar</code> em <code>RevisaoPendentePostagem</code> e a única maneura de obter
<code>RevisaoPendentePostagem</code> é chamar o método <code>solicitar_revisao</code> em <code>RascunhoPostagem</code>,
agora codificamos o fluxo de trabalho da postagem do blog em um sistema de tipos.</p>
<p>Mas também temos que fazer algumas pequenas mudanças no<code>main</code>. Os métodos <code>solicitar_revisao</code> e
<code>aprovar</code> retornam novas instâncias em vez de modificar a estrutura para qual são chamadas,
então precisamos adicionar mais <code>let post</code> shadowing para salvar
as instâncias retornadas. Também não temos certeza se o conteúdo do rascunho e da
postagem em revisão é uma string vazia, nem precisamos delas: não podemos
compilar código que tente usar o conteúdo da postagem nesses estados.
O código atualizado na <code>main</code> é mostradp na Listagem 17-21:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate blog;
use blog::Postagem;

fn main() {
    let mut post = Postagem::new();

    post.add_texto(&quot;Eu comi uma salada no almoço de hoje&quot;);

    let post = post.solicitar_revisao();

    let post = post.aprovar();

    assert_eq!(&quot;Eu comi uma salada no almoço de hoje&quot;, post.conteudo());
}
</code></pre>
<p><span class="caption">Listagem 17-21: Modificações na <code>main</code> para usar a nova
implementação do fluxo de trabalho da psotagem no blog</span></p>
<p>As mudanças que precisamos fazer na <code>main</code>reatribuir <code>post</code>, o que significa que essa
implementação não segue mais o padrão de estados orientado a objetos:
as transformações entre os estados não são mais encapsuladas inteiramente
dentro da implementação do <code>Postagem</code>. No entanto, nosso ganho é que estados inválidos agora
são impossíveis por causa do sistema de tipos e a verificação de tipos que acontecem em
tempo de compilação! Isso garante que certos bugs, como o conteúdo de uma postagem
não publicada sendo exibida, será descoberta antes de chegar em
produção.</p>
<p>Experimente as tarefas sugeridas como requisitos adicionais que mencionamos no
inícion dessa seção sobre o crate <code>blog</code> como está após a Listagem 17-20 para ver
o que você acha sobre o design desta versão do código. Observe que algumas tarefas
podem ser concluídas já neste design!</p>
<p>Vimos que, embora o Rust seja capas de implementar o padrão de projetos orientado a objetos,
outros padrões, como codificar estados em sistema de tipos,
também estão disponíveis. Esses padrões têm diferentes vantagens e desvantagens. Apesar
de você poder estar bastante familiarizado com o padrão orientado a objetos, repensar
o problema para aproveitar os recursos do Rust pode fornecer benefícios, como evitar
alguns bugs em tempo de compilação. Padrões orientados a objetos nem sempre serão a
melhor solução em Rust devido certos recursos, como propriedade, que
as linguagens orientadas a objetos não têm.</p>
<a class="header" href="print.html#resumo-8" id="resumo-8"><h2>Resumo</h2></a>
<p>Não importa se você acha que Rust é uma linguagem orientada a objetos depois
de ler este capítulo, você agora sabe que pode usar objetos trait para obter alguns
recursos orientado a objetos em Rust. O despacho dinâmico pode dar ao seu código alguma
flexibilidade em troca de um pouco de desempenho em tempo de execução. Você pode usar essa
flexibilidade para implementar padrão orientado a objetos que podem ajudar na manutenção
de seu código. Rust também tem outros recursos, como propriedade, que
linguagens orientadas aobjetos não têm. Um padrão orientado a objetos nem sempre
é a melhor maneira de aproveitar os pontos fortes do Rust, mas é uma opção disponível.</p>
<p>Em seguida, veremos os padrões, que são outros dos recursos que permitem
muita flexibilidade. Veremos brevemente eles ao longo do livro, mas ainda não vimos a capacidade total deles. Vamos lá!</p>
<a class="header" href="print.html#patterns" id="patterns"><h1>Patterns</h1></a>
<a class="header" href="print.html#more-lifetimes" id="more-lifetimes"><h1>More Lifetimes</h1></a>
<a class="header" href="print.html#advanced-type-system-features" id="advanced-type-system-features"><h1>Advanced Type System Features</h1></a>
<a class="header" href="print.html#appendix" id="appendix"><h1>Appendix</h1></a>
<a class="header" href="print.html#keywords" id="keywords"><h1>Keywords</h1></a>
<a class="header" href="print.html#operators" id="operators"><h1>Operators</h1></a>
<a class="header" href="print.html#derivable-traits" id="derivable-traits"><h1>Derivable Traits</h1></a>
<a class="header" href="print.html#nightly-rust" id="nightly-rust"><h1>Nightly Rust</h1></a>
<a class="header" href="print.html#macros" id="macros"><h1>Macros</h1></a>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if (getComputedStyle(document.querySelector(".fa")).fontFamily !== "FontAwesome") {
                var link = document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = '_FontAwesome/css/font-awesome.css';
                document.head.insertBefore(link, document.head.firstChild)
            }
        </script>

        

        

        

        
        <script>
            document.addEventListener('DOMContentLoaded', function() {
                window.print();
            })
        </script>
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
