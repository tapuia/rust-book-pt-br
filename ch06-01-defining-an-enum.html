<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>ğŸ‡§ğŸ‡· Definindo uma Enum - </title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme;
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            document.querySelector('html').classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="ch01-00-introduction.html"><strong aria-hidden="true">1.</strong> ğŸ‡§ğŸ‡· IntroduÃ§Ã£o</a></li><li><ol class="section"><li><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> ğŸ‡§ğŸ‡· InstalaÃ§Ã£o</a></li><li><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> ğŸ‡§ğŸ‡· OlÃ¡, Mundo!</a></li></ol></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> ğŸ‡§ğŸ‡· Jogo de AdivinhaÃ§Ã£o</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> ğŸ‡§ğŸ‡· Conceitos Comuns de ProgramaÃ§Ã£o</a></li><li><ol class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> ğŸ‡§ğŸ‡· VariÃ¡veis e Mutabilidade</a></li><li><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> ğŸ‡§ğŸ‡· Tipos de dados</a></li><li><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> ğŸ‡§ğŸ‡· FunÃ§Ãµes</a></li><li><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> ğŸ‡§ğŸ‡· ComentÃ¡rios</a></li><li><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> ğŸ‡§ğŸ‡· Controle de fluxo</a></li></ol></li><li><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> ğŸ‡§ğŸ‡· Entendendo Ownership</a></li><li><ol class="section"><li><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> ğŸ‡§ğŸ‡· O Que Ã‰ Ownership?</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> ğŸ‡§ğŸ‡· ReferÃªncias e Borrowing</a></li><li><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> ğŸ‡§ğŸ‡· Slices</a></li></ol></li><li><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> ğŸ‡§ğŸ‡· Structs</a></li><li><ol class="section"><li><a href="ch05-01-method-syntax.html"><strong aria-hidden="true">5.1.</strong> Method Syntax</a></li></ol></li><li><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> ğŸ‡§ğŸ‡· Enums e Casamento de PadrÃµes</a></li><li><ol class="section"><li><a href="ch06-01-defining-an-enum.html" class="active"><strong aria-hidden="true">6.1.</strong> ğŸ‡§ğŸ‡· Definindo uma Enum</a></li><li><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> ğŸ‡§ğŸ‡· Operador match</a></li><li><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> ğŸ‡§ğŸ‡· Controle de Fluxo Conciso com if let</a></li></ol></li><li><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> ğŸ‡§ğŸ‡· MÃ³dulos</a></li><li><ol class="section"><li><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> ğŸ‡§ğŸ‡· mod e o Sistema de Arquivos</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> ğŸ‡§ğŸ‡· Controlando a Visibilidade com pub</a></li><li><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> ğŸ‡§ğŸ‡· Importando nomes com use</a></li></ol></li><li><a href="ch08-00-fundamental-collections.html"><strong aria-hidden="true">8.</strong> Fundamental Collections</a></li><li><ol class="section"><li><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> ğŸ‡§ğŸ‡· Vetores</a></li><li><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> ğŸ‡§ğŸ‡· Strings</a></li><li><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> ğŸ‡§ğŸ‡· Hash Maps</a></li></ol></li><li><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> ğŸ‡§ğŸ‡· Tratamento de Erros</a></li><li><ol class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> ğŸ‡§ğŸ‡· Erros IrrecuperÃ¡veis com panic!</a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> ğŸ‡§ğŸ‡· Erros recuperÃ¡veis com Result</a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> ğŸ‡§ğŸ‡· Entrar em panic! ou NÃ£o Entrar em panic!</a></li></ol></li><li><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> ğŸ‡§ğŸ‡· Tipos GenÃ©ricos, Traits, e Tempos de vida (Lifetimes)</a></li><li><ol class="section"><li><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> ğŸ‡§ğŸ‡· Tipos GenÃ©ricos de Dados</a></li><li><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> ğŸ‡§ğŸ‡· Traits: Definindo Comportamento Compartilhado</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> ğŸ‡§ğŸ‡· Validating References with Lifetimes</a></li></ol></li><li><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Writing tests</a></li><li><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Running tests</a></li><li><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project</a></li><li><ol class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Improving Error Handling and Modularity</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Testing the Library's Functionality</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing to stderr instead of stdout</a></li></ol></li><li><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features in Rust</a></li><li><ol class="section"><li><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures</a></li><li><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Iterators</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving our I/O Project</a></li><li><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performance</a></li></ol></li><li><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Release Profiles</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> ğŸ‡§ğŸ‡· Ponteiros Inteligentes (Smart Pointers)</a></li><li><ol class="section"><li><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> ğŸ‡§ğŸ‡· Box<T> Aponta para Dados no Heap e Tem Tamanho Conhecido</a></li><li><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> ğŸ‡§ğŸ‡· Tratando Ponteiros Inteligentes como ReferÃªncias Normais com a Trait Deref</a></li><li><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> ğŸ‡§ğŸ‡· A Trait Drop Roda CÃ³digo durante a Limpeza</a></li><li><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> ğŸ‡§ğŸ‡· Rc<T>, o Ponteiro Inteligente com Contagem de ReferÃªncias</a></li><li><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> ğŸ‡§ğŸ‡· RefCell<T> e a Pattern de Mutabilidade Interior</a></li><li><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> ğŸ‡§ğŸ‡· Ciclos de ReferÃªncias Podem Vazar MemÃ³ria</a></li></ol></li><li><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrency</a></li><li><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> ğŸ‡§ğŸ‡· Rust Ã© uma linguagem orientada a objetos?</a></li><li><ol class="section"><li><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> ğŸ‡§ğŸ‡· O que significa orientado a objetos?</a></li><li><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> ğŸ‡§ğŸ‡· Usando objetos trait que permitem valores de tipos diferentes</a></li><li><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> ğŸ‡§ğŸ‡· Implementando um padrÃ£o de projeto orientado a objetos</a></li></ol></li><li><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns</a></li><li><a href="ch19-00-more-lifetimes.html"><strong aria-hidden="true">19.</strong> More Lifetimes</a></li><li><a href="ch20-00-advanced-types.html"><strong aria-hidden="true">20.</strong> Advanced Type System Features</a></li><li><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> Keywords</a></li><li><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> Operators</a></li><li><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> Derivable Traits</a></li><li><a href="appendix-04-nightly-rust.html"><strong aria-hidden="true">21.4.</strong> Nightly Rust</a></li><li><a href="appendix-05-macros.html"><strong aria-hidden="true">21.5.</strong> Macros</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="submenu">
                                <li><button class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li><button class="theme" id="rust">Rust</button></li>
                                <li><button class="theme" id="coal">Coal</button></li>
                                <li><button class="theme" id="navy">Navy</button></li>
                                <li><button class="theme" id="ayu">Ayu</button></li>
                            </ul>
                        </div>

                        <h1 class="menu-title"></h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="ch06-01-defining-an-enum.html#definindo-uma-enum" id="definindo-uma-enum"><h2>Definindo uma Enum</h2></a>
<p>Vamos ver um caso em que enums podem ser mais apropriadas do que structs e
descobrir como elas podem ser Ãºteis. Digamos que estamos trabalhando com
endereÃ§os IP. Atualmente, existem duas versÃµes do protocolo IP que sÃ£o mais
utilizadas: a quatro e a seis. Estas sÃ£o as Ãºnicas possibilidades para um
endereÃ§o IP com que o nosso programa vai trabalhar: nÃ³s podemos <em>enumerar</em>
todos os possÃ­veis valores, Ã© daÃ­ que vem o nome enumeraÃ§Ã£o.</p>
<p>Um endereÃ§o IP qualquer pode ser ou da versÃ£o quatro ou da versÃ£o seis, mas
nunca das duas ao mesmo tempo. Esta propriedade dos endereÃ§os IP faz com que a
enum seja bem apropriada para este caso, pois enums sÃ³ podem assumir o valor de
uma de suas variantes. Os endereÃ§os de ambas as versÃµes, seja quatro ou seis,
ainda sÃ£o, fundamentalmente, endereÃ§os IP, e deveriam ser tratados pelo mesmo
tipo no cÃ³digo em situaÃ§Ãµes que se aplicam a qualquer versÃ£o de endereÃ§o IP.</p>
<p>Podemos expressar esse conceito em cÃ³digo definindo uma enum <code>VersaoIp</code> e
listando os possÃ­veis tipos de que um endereÃ§o IP pode ser: <code>V4</code> e <code>V6</code>. Estas
sÃ£o as chamadas <em>variantes</em> da enum:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum VersaoIp {
    V4,
    V6,
}
#}</code></pre></pre>
<p><code>VersaoIp</code> Ã© um tipo de dados que agora nÃ³s podemos usar em qualquer lugar no
nosso cÃ³digo.</p>
<a class="header" href="ch06-01-defining-an-enum.html#valores-de-uma-enum" id="valores-de-uma-enum"><h3>Valores de uma Enum</h3></a>
<p>Podemos criar instÃ¢ncias de cada uma das duas variantes de <code>VersaoIp</code>, da
seguinte forma:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum VersaoIp {
#     V4,
#     V6,
# }
#
let quatro = VersaoIp::V4;
let seis = VersaoIp::V6;
#}</code></pre></pre>
<p>Repare que as variantes pertencem ao <em>namespace</em> da enum, e se usa <code>::</code> para
separar os dois. Isso Ã© Ãºtil porque agora ambos os valores <code>VersaoIp::V4</code> e
<code>VersaoIp::V6</code> sÃ£o do mesmo tipo: <code>VersaoIp</code>. Agora nÃ³s podemos, por exemplo,
definir uma funÃ§Ã£o que usa qualquer <code>VersaoIp</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum VersaoIp {
#     V4,
#     V6,
# }
#
fn rotear(versao_ip: VersaoIp) { }
#}</code></pre></pre>
<p>E podemos ainda chamar esta funÃ§Ã£o passando qualquer uma das variantes:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum VersaoIp {
#     V4,
#     V6,
# }
#
# fn rotear(versao_ip: VersaoIp) { }
#
rotear(VersaoIp::V4);
rotear(VersaoIp::V6);
#}</code></pre></pre>
<p>O uso de enums tem ainda mais vantagens. Pensando mais a fundo sobre o nosso
tipo de endereÃ§o IP, ainda nÃ£o temos uma forma de representar o <em>endereÃ§o</em> em
si, apenas sabemos qual a <em>versÃ£o</em> dele. Tendo em vista o que vocÃª acabou de
aprender sobre structs no CapÃ­tulo 5, vocÃª poderia abordar esse problema assim
como visto na Listagem 6-1:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum VersaoIp {
    V4,
    V6,
}

struct EnderecoIp {
    versao: VersaoIp,
    endereco: String,
}

let local = EnderecoIp {
    versao: VersaoIp::V4,
    endereco: String::from(&quot;127.0.0.1&quot;),
};

let loopback = EnderecoIp {
    versao: VersaoIp::V6,
    endereco: String::from(&quot;::1&quot;),
};
#}</code></pre></pre>
<p><span class="caption">Listagem 6-1: RepresentaÃ§Ã£o do endereÃ§o e da variante
<code>VersaoIp</code> de um endereÃ§o IP usando uma <code>struct</code></span></p>
<p>Aqui nÃ³s definimos uma struct <code>EnderecoIp</code> que tem dois membros: <code>versao</code>, do
tipo <code>VersaoIp</code> (que definimos anteriormente) e <code>endereco</code>, do tipo <code>String</code>.
Temos duas instÃ¢ncias dessa struct. A primeira, <code>local</code>, tem o valor
<code>VersaoIp::V4</code> como sua <code>versao</code>, e um endereÃ§o associado igual a <code>127.0.0.1</code>.
A segunda instÃ¢ncia, <code>loopback</code>, tem como sua <code>versao</code> a outra variante de
<code>VersaoIp</code>, <code>V6</code>, e o endereÃ§o <code>::1</code> associado a ela. NÃ³s usamos uma struct
para encapsular os valores de <code>versao</code> e <code>endereco</code>, agora a variante estÃ¡
associada ao valor.</p>
<p>Podemos representar o mesmo conceito de uma forma mais concisa usando apenas
uma enum, em vez de uma enum dentro de uma struct, colocando dados dentro de
cada variante da enum, diretamente. Esta nova definiÃ§Ã£o da enum <code>EnderecoIp</code>
diz que ambas as variantes, <code>V4</code> e <code>V6</code>, terÃ£o uma <code>String</code> associada:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum EnderecoIp {
    V4(String),
    V6(String),
}

let local = EnderecoIp::V4(String::from(&quot;127.0.0.1&quot;));

let loopback = EnderecoIp::V6(String::from(&quot;::1&quot;));
#}</code></pre></pre>
<p>Podemos anexar dados a cada variante da enum diretamente, assim nÃ£o existe mais
a necessidade de uma struct adicional.</p>
<p>HÃ¡ uma outra vantagem de se usar uma enum em vez de uma struct: cada variante
pode conter dados de diferentes tipos e quantidades. Os endereÃ§os IP da versÃ£o
quatro tÃªm sempre quatro componentes numÃ©ricas, cada uma com valor de 0 a 255.
Se quisÃ©ssemos representar endereÃ§os <code>V4</code> como quatro valores <code>u8</code>, e ao mesmo
tempo manter os endereÃ§os <code>V6</code> como uma <code>String</code>, nÃ£o poderÃ­amos usar uma
struct. JÃ¡ as enums podem facilmente atender a este caso:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum EnderecoIp {
    V4(u8, u8, u8, u8),
    V6(String),
}

let local = EnderecoIp::V4(127, 0, 0, 1);

let loopback = EnderecoIp::V6(String::from(&quot;::1&quot;));
#}</code></pre></pre>
<p>Acabamos de ver algumas possibilidades que poderÃ­amos usar para representar
endereÃ§os IP das duas versÃµes por meio de uma enum. Acontece que essa
necessidade de representar endereÃ§os IP, incluindo sua versÃ£o, Ã© tÃ£o comum que
a biblioteca padrÃ£o jÃ¡ possui uma definiÃ§Ã£o que podemos usar! (<a href="https://doc.rust-lang.org/std/net/enum.IpAddr.html">Veja a
documentaÃ§Ã£o em inglÃªs</a><!-- ignore -->). Vamos ver como a biblioteca
padrÃ£o define <code>IpAddr</code>: ele tem basicamente a mesma enum e as mesmas variantes
que nÃ³s definimos e usamos anteriormente, mas os dados do endereÃ§o sÃ£o
embutidos dentro das variantes na forma de duas structs separadas, que sÃ£o
definidas de um jeito diferente pra cada variante.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Ipv4Addr {
    // detalhes omitidos
}

struct Ipv6Addr {
    // detalhes omitidos
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
#}</code></pre></pre>
<p>Esse cÃ³digo mostra que vocÃª pode colocar qualquer tipo de dados dentro de uma
variante de enum: strings, tipos numÃ©ricos ou structs, por exemplo. VocÃª pode
atÃ© mesmo incluir outra enum! AlÃ©m disso, os tipos definidos pela biblioteca
padrÃ£o nÃ£o sÃ£o tÃ£o mais complicados do que o que talvez vocÃª pensaria em fazer.</p>
<p>Repare que, mesmo havendo um <code>IpAddr</code>definido pela biblioteca padrÃ£o, nÃ³s ainda
podemos criar e utilizar nossa prÃ³pria definiÃ§Ã£o (com o mesmo nome, inclusive)
sem nenhum conflito, porque nÃ£o trouxemos a definiÃ§Ã£o da biblioteca padrÃ£o para
dentro do nosso escopo. Falaremos mais sobre a inclusÃ£o de tipos em um escopo
no CapÃ­tulo 7.</p>
<p>Vamos ver outro exemplo de uma enum na Listagem 6-2: esta tem uma grande
variedade de tipos embutidos nas suas variantes:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Mensagem {
    Sair,
    Mover { x: i32, y: i32 },
    Escrever(String),
    MudarCor(i32, i32, i32),
}
#}</code></pre></pre>
<p><span class="caption">Listagem 6-2: Enum <code>Mensagem</code>, cujas variantes contÃªm,
cada uma, diferentes tipos e quantidades de dados</span></p>
<p>Esta enum tem quatro variantes de diferentes tipos:</p>
<ul>
<li><code>Sair</code> nÃ£o tem nenhum dado associado.</li>
<li><code>Mover</code> contÃ©m uma struct anÃ´nima.</li>
<li><code>Escrever</code> contÃ©m uma Ãºnica <code>String</code>.</li>
<li><code>MudarCor</code> contÃ©m trÃªs valores do tipo <code>i32</code>.</li>
</ul>
<p>Definir uma enum com variantes iguais Ã s da Listagem 6-2 Ã© similar a definir
diferentes tipos de struct, exceto que a enum nÃ£o usa a palavra-chave <code>struct</code>,
e todas as variantes sÃ£o agrupadas dentro do tipo <code>Mensagem</code>. As structs
seguintes podem guardar os mesmos dados que as variantes da enum anterior:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct MensagemSair; // unit struct
struct MensagemMover {
    x: i32,
    y: i32,
}
struct MensagemEscrever(String); // tuple struct
struct MensagemMudarCor(i32, i32, i32); // tuple struct
#}</code></pre></pre>
<p>Mas se usarmos structs diferentes, cada uma tendo seu prÃ³prio tipo, nÃ£o vamos
conseguir tÃ£o facilmente definir uma funÃ§Ã£o que possa receber qualquer um
desses tipos de mensagens, assim como fizemos com a enum <code>Mensagem</code>, definida
na Listagem 6-2, que consiste em um tipo Ãºnico.</p>
<p>HÃ¡ mais uma similaridade entre enums e structs: da mesma forma como podemos
definir mÃ©todos em structs usando <code>impl</code>, tambÃ©m podemos definir mÃ©todos em
enums. Aqui estÃ¡ um mÃ©todo chamado <code>invocar</code>, que poderia ser definido na nossa
enum <code>Mensagem</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum Mensagem {
#     Sair,
#     Mover { x: i32, y: i32 },
#     Escrever(String),
#     MudarCor(i32, i32, i32),
# }
#
impl Mensagem {
    fn invocar(&amp;self) {
        // o corpo do mÃ©todo Ã© definido aqui
    }
}

let m = Mensagem::Escrever(String::from(&quot;olÃ¡&quot;));
m.invocar();
#}</code></pre></pre>
<p>O corpo do mÃ©todo usaria o valor <code>self</code> para obter a mensagem sobre a qual o
mÃ©todo foi chamado. Neste exemplo, criamos a variÃ¡vel <code>m</code>, que contÃ©m o valor
<code>Mensagem::Escrever(String::from(&quot;olÃ¡&quot;))</code>, e Ã© isso que <code>self</code> vai ser no corpo
do mÃ©todo <code>invocar</code> quando <code>m.invocar()</code> for executado.</p>
<p>Vamos ver agora outra enum da biblioteca padrÃ£o que tambÃ©m Ã© muito Ãºtil e
comum: <code>Option</code>.</p>
<a class="header" href="ch06-01-defining-an-enum.html#a-enum-option-e-suas-vantagens-sobre-valores-nulos" id="a-enum-option-e-suas-vantagens-sobre-valores-nulos"><h3>A Enum <code>Option</code> e Suas Vantagens Sobre Valores Nulos</h3></a>
<p>Na seÃ§Ã£o anterior, vimos como a enum <code>EnderecoIp</code> nos permite usar o sistema de
tipos do Rust para codificar em nosso programa mais informaÃ§Ã£o do que apenas os
dados que queremos representar. Essa seÃ§Ã£o explora um caso de estudo da
<code>Option</code>, que Ã© outra enum definida pela biblioteca padrÃ£o. O tipo <code>Option</code> Ã©
muito utilizado, pois engloba um cenÃ¡rio muito comum, em que um valor pode ser
algo ou pode nÃ£o ser nada. Expressar esse conceito por meio do sistema de tipos
significa que o compilador pode verificar se vocÃª tratou, ou nÃ£o, todos os
casos que deveriam ser tratados, podendo evitar <em>bugs</em> que sÃ£o extremamente
comuns em outras linguagens de programaÃ§Ã£o.</p>
<p>O <em>design</em> de uma linguagem de programaÃ§Ã£o Ã© geralmente tratado em termos de
quais caracterÃ­sticas sÃ£o incluÃ­das, mas as que sÃ£o excluÃ­das tambÃ©m tÃªm
importÃ¢ncia. Rust nÃ£o tem o valor nulo (<em>null</em>) que outras linguagens tÃªm. O
valor nulo quer dizer que nÃ£o hÃ¡ nenhum valor. Em linguagens que tÃªm essa
caracterÃ­stica, as variÃ¡veis sempre estÃ£o em um dos dois estados: nulo ou nÃ£o
nulo.</p>
<p>Em uma conferÃªncia, Tony Hoare, inventor do valor nulo, disse o seguinte:</p>
<blockquote>
<p>Eu o chamo meu erro de um bilhÃ£o de dÃ³lares. Naquela Ã©poca, eu estava
projetando o primeiro sistema abrangente de tipos para referÃªncias em uma
linguagem orientada a objetos. Meu objetivo era garantir que todo uso de
referÃªncias deveria ser absolutamente seguro, com verificaÃ§Ã£o automÃ¡tica
feita pelo compilador. Mas nÃ£o pude resistir Ã  tentaÃ§Ã£o de colocar uma
referÃªncia nula, simplesmente porque era tÃ£o fÃ¡cil de implementar. Isso tem
provocado inÃºmeros erros, vulnerabilidades, e falhas de sistemas que
provavelmente causaram um bilhÃ£o de dÃ³lares de dor e danos nos Ãºltimos
quarenta anos.</p>
</blockquote>
<p>O problema com valores nulos Ã© que, se vocÃª tentar usar um valor nulo como se
fosse nÃ£o nulo, vai acontecer algum tipo de erro. Pelo fato dessa propriedade
de nulo e nÃ£o nulo ser tÃ£o sutil, Ã© extremamente fÃ¡cil cometer esse tipo de
erro.</p>
<p>PorÃ©m, o conceito que o valor nulo tenta expressar ainda Ã© Ãºtil: um valor nulo
representa algo que, por algum motivo, estÃ¡ invÃ¡lido ou ausente no momento.</p>
<p>O problema, na verdade, nÃ£o estÃ¡ no conceito, mas na implementaÃ§Ã£o em
particular. Por isso, Rust nÃ£o possui valores nulos, mas sim uma enum que
engloba o conceito de um valor estar presente ou ausente. Esta enum Ã© a
<code>Option&lt;T&gt;</code>, que estÃ¡ definida na biblioteca padrÃ£o da seguinte forma:
(<a href="https://doc.rust-lang.org/std/option/enum.Option.html">Veja a documentaÃ§Ã£o em inglÃªs</a><!-- ignore -->).</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Option&lt;T&gt; {
    Some(T), // algum valor
    None, // nenhum valor
}
#}</code></pre></pre>
<p>A enum <code>Option&lt;T&gt;</code> Ã© tÃ£o Ãºtil que ela jÃ¡ vem inclusa no prelÃºdio: vocÃª nÃ£o
precisa trazÃª-la explicitamente para o seu escopo. AlÃ©m disso, o mesmo ocorre
com suas variantes: vocÃª pode usar <code>Some</code> e <code>None</code> diretamente sem prefixÃ¡-las
com <code>Option::</code>. <code>Option&lt;T&gt;</code> continua sendo uma enum como qualquer outra, e
<code>Some(T)</code> e <code>None</code> ainda sÃ£o variantes do tipo <code>Option&lt;T&gt;</code>.</p>
<p>A sintaxe do <code>&lt;T&gt;</code> Ã© uma caracterÃ­stica do Rust de que nÃ£o falamos ainda.
Trata-se de um parÃ¢metro de tipo genÃ©rico, vamos abordÃ¡-lo com mais detalhe no
CapÃ­tulo 10. Por ora, tudo que vocÃª precisa saber Ã© que <code>&lt;T&gt;</code> significa que a
variante <code>Some</code> da enum <code>Option</code> pode conter um dado de qualquer tipo. Aqui vÃ£o
alguns exemplos de <code>Option</code> contendo tipos de nÃºmero e texto:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let algum_numero = Some(5);
let algum_texto = Some(&quot;um texto&quot;);

let numero_ausente: Option&lt;i32&gt; = None;
#}</code></pre></pre>
<p>Se usamos <code>None</code> em vez de <code>Some</code>, precisamos dizer ao Rust qual Ã© o tipo de
<code>Option&lt;T&gt;</code> que nÃ³s temos, porque o compilador nÃ£o consegue inferir qual tipo
estarÃ¡ contido na variante <code>Some</code> apenas olhando para um valor <code>None</code>.</p>
<p>Quando temos um <code>Some</code>, sabemos que um valor estÃ¡ presente, contido dentro do
<code>Some</code>. JÃ¡ quando temos um <code>None</code>, de certa forma, significa o mesmo que um
valor nulo: nÃ£o temos um valor que seja vÃ¡lido. EntÃ£o por que a <code>Option&lt;T&gt;</code> Ã©
tÃ£o melhor que usar um valor nulo?</p>
<p>Em resumo, Ã© porque <code>Option&lt;T&gt;</code> e <code>T</code> (podendo <code>T</code> ser de qualquer tipo) sÃ£o
tipos diferentes, por isso, o compilador nÃ£o vai permitir usar um valor do tipo
<code>Option&lt;T&gt;</code> como se ele definitivamente tivesse um valor vÃ¡lido. Por exemplo,
o cÃ³digo seguinte nÃ£o vai compilar, porque ele estÃ¡ tentando somar um <code>i8</code> a um
<code>Option&lt;i8&gt;</code>:</p>
<pre><code class="language-rust ignore">let x: i8 = 5;
let y: Option&lt;i8&gt; = Some(5);

let soma = x + y;
</code></pre>
<p>Quando executamos esse cÃ³digo, temos uma mensagem de erro como essa:</p>
<pre><code class="language-text">error[E0277]: the trait bound `i8: std::ops::Add&lt;std::option::Option&lt;i8&gt;&gt;` is
not satisfied
 --&gt;
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + std::option::Option&lt;i8&gt;`
  |
</code></pre>
<p>Intenso! O que essa mensagem quer dizer Ã© que o Rust nÃ£o consegue entender como
somar um <code>i8</code> e um <code>Option&lt;i8&gt;</code>, porque eles sÃ£o de tipos diferentes. Quando
temos um valor de um tipo como <code>i8</code> em Rust, o compilador tem certeza de que
temos sempre um valor vÃ¡lido. Podemos prosseguir com confianÃ§a, sem ter de
verificar se o valor Ã© nulo antes de usÃ¡-lo. Somente quando temos um
<code>Option&lt;i8&gt;</code> (ou qualquer que seja o tipo com que estamos trabalhando), vamos
ter de nos preocupar com a possibilidade de nÃ£o haver um valor, e o compilador
vai se certificar de que nÃ³s estamos tratando este caso antes de usar o valor.</p>
<p>Em outras palavras, vocÃª tem que converter um <code>Option&lt;T&gt;</code> em um <code>T</code> antes de
poder executar operaÃ§Ãµes com ele. Geralmente, isso ajuda a detectar um dos
problemas mais comuns com valores nulos: assumir que algo nÃ£o Ã© nulo quando,
na verdade, ele Ã©.</p>
<p>SÃ³ de nÃ£o ter que se preocupar com a possibilidade de ter deixado um valor nulo
escapar jÃ¡ lhe dÃ¡ mais confianÃ§a em seu cÃ³digo. Pra ter um valor que pode ser
nulo em algum momento, vocÃª precisa, explicitamente, marcÃ¡-lo como sendo do
tipo <code>Option&lt;T&gt;</code>. A partir daÃ­, sempre que for usar o valor, vocÃª serÃ¡ obrigado
a tratar, de forma explÃ­cita, o caso do valor sendo nulo. Sempre que houver um
valor que nÃ£o seja um <code>Option&lt;T&gt;</code>, vocÃª <em>pode</em> assumir, com seguranÃ§a, que o
valor nÃ£o Ã© nulo. Esta foi uma decisÃ£o deliberada de projeto do Rust para
limitar as sutilezas dos valores nulos e aumentar a seguranÃ§a do cÃ³digo.</p>
<p>EntÃ£o, como obter o valor <code>T</code> da variante <code>Some</code> quando se tem um <code>Option&lt;T&gt;</code>,
para que se possa usar seu valor? A enum <code>Option&lt;T&gt;</code> possui diversos mÃ©todos
que sÃ£o Ãºteis em uma variedade de situaÃ§Ãµes, vocÃª pode pesquisÃ¡-los na
<a href="https://doc.rust-lang.org/std/option/enum.Option.html">documentaÃ§Ã£o</a><!-- ignore --> (em inglÃªs). SerÃ¡ extremamente Ãºtil na sua
jornada com Rust se familizarizar com os mÃ©todos da enum <code>Option&lt;T&gt;</code>.</p>
<p>Em geral, pra usar um valor <code>Option&lt;T&gt;</code>, queremos ter um cÃ³digo que trate cada
uma das variantes. Queremos um cÃ³digo que sÃ³ serÃ¡ executado quando tivermos um
valor <code>Some(T)</code>, e esse cÃ³digo terÃ¡ permissÃ£o para usar o valor <code>T</code> que estÃ¡
embutido. Queremos tambÃ©m um outro cÃ³digo que seja executado se tivermos um
valor <code>None</code>, e esse cÃ³digo nÃ£o terÃ¡ um valor <code>T</code> disponÃ­vel. A expressÃ£o
<code>match</code> Ã© uma instruÃ§Ã£o de controle de fluxo que faz exatamente isso quando
usada com enums: ela executa cÃ³digos diferentes dependendo de qual variante
tiver a enum, e esse cÃ³digo poderÃ¡ usar os dados contidos na variante
encontrada.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch06-00-enums.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch06-02-match.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="ch06-00-enums.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="ch06-02-match.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if (getComputedStyle(document.querySelector(".fa")).fontFamily !== "FontAwesome") {
                var link = document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = '_FontAwesome/css/font-awesome.css';
                document.head.insertBefore(link, document.head.firstChild)
            }
        </script>

        

        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
