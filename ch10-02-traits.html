<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>🇧🇷 Traits: Definindo Comportamento Compartilhado - </title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme;
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            document.querySelector('html').classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="ch01-00-introduction.html"><strong aria-hidden="true">1.</strong> 🇧🇷 Introdução</a></li><li><ol class="section"><li><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> 🇧🇷 Instalação</a></li><li><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> 🇧🇷 Olá, Mundo!</a></li></ol></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> 🇧🇷 Jogo de Adivinhação</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> 🇧🇷 Conceitos Comuns de Programação</a></li><li><ol class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> 🇧🇷 Variáveis e Mutabilidade</a></li><li><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> 🇧🇷 Tipos de dados</a></li><li><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> 🇧🇷 Funções</a></li><li><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> 🇧🇷 Comentários</a></li><li><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> 🇧🇷 Controle de fluxo</a></li></ol></li><li><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> 🇧🇷 Entendendo Ownership</a></li><li><ol class="section"><li><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> 🇧🇷 O Que É Ownership?</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> 🇧🇷 Referências e Borrowing</a></li><li><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> 🇧🇷 Slices</a></li></ol></li><li><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> 🇧🇷 Structs</a></li><li><ol class="section"><li><a href="ch05-01-method-syntax.html"><strong aria-hidden="true">5.1.</strong> Method Syntax</a></li></ol></li><li><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> 🇧🇷 Enums e Casamento de Padrões</a></li><li><ol class="section"><li><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> 🇧🇷 Definindo uma Enum</a></li><li><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> 🇧🇷 Operador match</a></li><li><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> 🇧🇷 Controle de Fluxo Conciso com if let</a></li></ol></li><li><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> 🇧🇷 Módulos</a></li><li><ol class="section"><li><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> 🇧🇷 mod e o Sistema de Arquivos</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> 🇧🇷 Controlando a Visibilidade com pub</a></li><li><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> 🇧🇷 Importando nomes com use</a></li></ol></li><li><a href="ch08-00-fundamental-collections.html"><strong aria-hidden="true">8.</strong> Fundamental Collections</a></li><li><ol class="section"><li><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> 🇧🇷 Vetores</a></li><li><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> 🇧🇷 Strings</a></li><li><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> 🇧🇷 Hash Maps</a></li></ol></li><li><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> 🇧🇷 Tratamento de Erros</a></li><li><ol class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> 🇧🇷 Erros Irrecuperáveis com panic!</a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> 🇧🇷 Erros recuperáveis com Result</a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> 🇧🇷 Entrar em panic! ou Não Entrar em panic!</a></li></ol></li><li><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> 🇧🇷 Tipos Genéricos, Traits, e Tempos de vida (Lifetimes)</a></li><li><ol class="section"><li><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> 🇧🇷 Tipos Genéricos de Dados</a></li><li><a href="ch10-02-traits.html" class="active"><strong aria-hidden="true">10.2.</strong> 🇧🇷 Traits: Definindo Comportamento Compartilhado</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> 🇧🇷 Validating References with Lifetimes</a></li></ol></li><li><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Writing tests</a></li><li><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Running tests</a></li><li><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project</a></li><li><ol class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Improving Error Handling and Modularity</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Testing the Library's Functionality</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing to stderr instead of stdout</a></li></ol></li><li><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features in Rust</a></li><li><ol class="section"><li><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures</a></li><li><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Iterators</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving our I/O Project</a></li><li><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performance</a></li></ol></li><li><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Release Profiles</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> 🇧🇷 Ponteiros Inteligentes (Smart Pointers)</a></li><li><ol class="section"><li><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> 🇧🇷 Box<T> Aponta para Dados no Heap e Tem Tamanho Conhecido</a></li><li><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> 🇧🇷 Tratando Ponteiros Inteligentes como Referências Normais com a Trait Deref</a></li><li><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> 🇧🇷 A Trait Drop Roda Código durante a Limpeza</a></li><li><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> 🇧🇷 Rc<T>, o Ponteiro Inteligente com Contagem de Referências</a></li><li><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> 🇧🇷 RefCell<T> e a Pattern de Mutabilidade Interior</a></li><li><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> 🇧🇷 Ciclos de Referências Podem Vazar Memória</a></li></ol></li><li><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrency</a></li><li><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> 🇧🇷 Rust é uma linguagem orientada a objetos?</a></li><li><ol class="section"><li><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> 🇧🇷 O que significa orientado a objetos?</a></li><li><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> 🇧🇷 Usando objetos trait que permitem valores de tipos diferentes</a></li><li><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> 🇧🇷 Implementando um padrão de projeto orientado a objetos</a></li></ol></li><li><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns</a></li><li><a href="ch19-00-more-lifetimes.html"><strong aria-hidden="true">19.</strong> More Lifetimes</a></li><li><a href="ch20-00-advanced-types.html"><strong aria-hidden="true">20.</strong> Advanced Type System Features</a></li><li><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> Keywords</a></li><li><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> Operators</a></li><li><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> Derivable Traits</a></li><li><a href="appendix-04-nightly-rust.html"><strong aria-hidden="true">21.4.</strong> Nightly Rust</a></li><li><a href="appendix-05-macros.html"><strong aria-hidden="true">21.5.</strong> Macros</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="submenu">
                                <li><button class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li><button class="theme" id="rust">Rust</button></li>
                                <li><button class="theme" id="coal">Coal</button></li>
                                <li><button class="theme" id="navy">Navy</button></li>
                                <li><button class="theme" id="ayu">Ayu</button></li>
                            </ul>
                        </div>

                        <h1 class="menu-title"></h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="ch10-02-traits.html#traits-definindo-comportamento-compartilhado" id="traits-definindo-comportamento-compartilhado"><h2>Traits: Definindo Comportamento Compartilhado</h2></a>
<p>Traits nos permitem usar outro tipo de abstração: eles nos permitem abstrair
sobre o comportamento que tipos têm em comum. Um <em>trait</em> diz ao compilador de
Rust sobre uma funcionalidade que um tipo particular possui e pode compartilhar
com outros tipos. Em situações onde nós usamos parâmetros de tipos genéricos,
nós podemos usar <em>limites de trait</em> para especificar, em tempo de compilação,
que o tipo genérico pode ser qualquer tipo que implementa um trait e por
conseguinte tem o comportamento que queremos usar nessa situação.</p>
<blockquote>
<p>Nota: <em>Traits</em> são similares a um recurso frequentemente chamado de
'interface' em outras linguagens, com algumas diferenças.</p>
</blockquote>
<a class="header" href="ch10-02-traits.html#definindo-um-trait" id="definindo-um-trait"><h3>Definindo um Trait</h3></a>
<p>O comportamento de um tipo consiste nos métodos que podemos chamar para aquele
tipo. Tipos diferentes dividem o mesmo comportamento se podemos chamar os
mesmos métodos em todos esses tipos. Definições de traits são um modo de
agrupar métodos de assinaturas juntos a fim de definir um conjunto de
comportamentos para atingir algum propósito.</p>
<p>Por exemplo, digamos que temos múltiplos structs que contém vários tipos e
quantidades de texto: um struct <code>ArtigoDeNoticias</code>que contém uma notícia
preenchida em um lugar do mundo, e um <code>Tweet</code> que pode ter no máximo 140
caracteres em seu conteúdo além dos metadados como se ele foi um retweet ou uma
resposta a outro tweet.</p>
<p>Nós queremos fazer uma biblioteca agregadora de mídia que pode mostrar resumos
de dados que podem estar guardados em uma instância de <code>ArtigoDeNoticia</code> ou
<code>Tweet</code>. O comportamento que precisamos cada struct possua é que seja capaz de
ser resumido, e que nós possamos pedir pelo resumo chamando um método <code>resumo</code>
em uma instância. A Listagem 10-12 mostra a definição de um trait <code>Resumir</code> que
expressa esse conceito:</p>
<p><span class="filename">Nome do arquivo: lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Resumir {
    fn resumo(&amp;self) -&gt; String;
}
#}</code></pre></pre>
<p><span class="caption">Listagem 10-12: Definição de um trait <code>Resumir</code> que
consiste no comportamento fornecido pelo método <code>resumo</code></span></p>
<p>Nós declaramos um trait com a palavra-chave <code>trait</code>, e então o nome do trait,
nesse caso <code>Resumir</code>. Dentro de chaves declaramos a assinatura do método que
descreve o comportamento que tipos que implementam esse trait precisarão ter,
nesse caso <code>fn resumo(&amp;self) -&gt; String;</code>. Depois da assinatura do método ao
invés de fornecer uma implementação dentro de chaves, nós colocamos um ponto e
vírgula. Cada tipo que implementa esse trait precisa então fornecer seu próprio
comportamento customizado para o corpo do método, mas o compilador vai reforçar
que qualquer qualquer tipo que tenha o trait <code>Resumir</code> terá o método <code>resumo</code>
definido para ele com esse exata assinatura.</p>
<p>Um trait pode ter vários métodos no seu corpo, com os métodos das assinaturas
listados um por linha e cada linha terminando com um ponto e vírgula.</p>
<a class="header" href="ch10-02-traits.html#implementando-um-trait-em-um-tipo" id="implementando-um-trait-em-um-tipo"><h3>Implementando um Trait em um Tipo</h3></a>
<p>Agora que deifnimos o trait <code>Resumir</code>, podemos implementa-lo nos tipos do nosso
agregador de mídias que queremos que tenham esse comportamento. A Listagem
10-13 mostra uma implementação do trait <code>Resumir</code> no struct <code>ArtigoNotícia</code> que
possui o título, o autor e a localização para criar e retornar o valor de
<code>resumo</code>. Para o struct <code>Tweet</code>, nós escolhemos definir <code>resumo</code> como o nome de
usuário seguido por todo o texto do tweet, assumindo que o conteúdo do tweet já
está limitado a 140 caracteres.</p>
<p><span class="filename">Nome do arquivo: lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub trait Resumir {
#     fn summary(&amp;self) -&gt; String;
# }
#
pub struct ArtigoDeNoticia {
    pub titulo: String,
    pub local: String,
    pub autor: String,
    pub conteudo: String,
}

impl Resumir for ArtigoDeNoticia {
    fn summary(&amp;self) -&gt; String {
        format!(&quot;{}, by {} ({})&quot;, self.titulo, self.autor, self.local)
    }
}

pub struct Tweet {
    pub nomeusuario: String,
    pub conteudo: String,
    pub resposta: bool,
    pub retweet: bool,
}

impl Resumir for Tweet {
    fn summary(&amp;self) -&gt; String {
        format!(&quot;{}: {}&quot;, self.nomeusuario, self.conteudo)
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 10-13: Implementando o trait <code>Resumir</code> nos tipos
<code>ArtigoDeNoticia</code> e <code>Tweet</code></span></p>
<p>Implementar um trait em um tipo é similar a implementar métodos que não estão
relacionados com um trait. A diferença está depois de <code>impl</code>, nós colocamos o
nome do trait que queremos implementar, então dizemos <code>for</code> e o nome do tipo
que queremos implementar. Dentro do bloco <code>impl</code>, nós colocamos as assinaturas
dos métodos que a definição do trait definiu, mas ao invés de colocar um ponto
e vírgula depois de cada assinatura, nós colocamos chaves e preenchemos o corpo
do método com o comportamento específico que queremos que os métodos dos traits
tenham para um tipo particular.</p>
<p>Uma vez que implementamos o trait, nós podemos chamar os métodos nas instâncias
de <code>ArtigoDeNoticia</code> e <code>Tweet</code> da mesma maneira que nós chamamos métodos que não
são parte de um trait:</p>
<pre><code class="language-rust ignore">let tweet = Tweet {
    nomeUsuario: String::from(&quot;horse_ebooks&quot;),
    conteudo: String::from(&quot;claro, como vocês provavelmente já sabem, 
    pessoas&quot;),
    resposta: false,
    retweet: false,
};

println!(&quot;1 novo tweet: {}&quot;, tweet.summary());
</code></pre>
<p>Isso irá imprimir <code>1 novo tweet: claro, como vocês provavelmente já sabem, pessoas</code></p>
<p>Note que porque nós definimos o trait <code>Resumir</code> e os tipos <code>ArtigoDeNoticia</code> e
<code>Tweet</code> todos na mesma <code>lib.rs</code> na listagem 10-13, eles estão todos no mesmo
escopo. Se essa <code>lib.rs</code> é para um crate nós chamamos <code>agregador</code>, e se outra
pessoa quiser usar a funcionalidade do nosso crate e implementar o trait
<code>Resumir</code> na sua struct <code>PrevisaoTempo</code>, o código deles precisaria importar o
trait <code>Resumir</code> no escopo deles primeiro antes deles poderem implementá-lo,
como na Listagem 10-14:</p>
<p><span class="filename">Nome do arquivo: lib.rs</span></p>
<pre><code class="language-rust ignore">extern crate aggregator;

use aggregator::Resumir;

struct PrevisaoTempo {
    alta_temp: f64,
    baixa_temp: f64,
    chance_de_chuva: f64,
}

impl Resumir for PrevisaoTempo {
    fn resumo(&amp;self) -&gt; String {
        format!(&quot;A alta será de {}, e a baixa de {}. A chance de precipitação é
        {}%.&quot;, self.alta_temp, self.baixa_temp, self.chance_de_chuva)
    }
}
</code></pre>
<p><span class="caption">Listagem 10-14: Trazendo o trait <code>Resumir</code> do nosso crate
<code>aggregator</code> para o escopo de outro crate</span></p>
<p>Esse código também assume que <code>Resumir</code> é um trait público, o que é verdade
porque colocamos a palavra-chave <code>pub</code> antes de <code>trait</code> na Listagem 10-12.</p>
<p>Uma restrição para se prestar atenção na implementação de traits: nós podemos
implementar um trait em um tipo desde que o trait ou o tipo forem locais para o
nosso crate. Em outras palavras, nós não estamos autorizados a implementar
traits externos em tipos externos. Nós não podemos implementar o trait
<code>Display</code> em <code>Vec</code>, por exemplo, já que ambos <code>Display</code> e <code>Vec</code> são definidos na
biblioteca padrão. Nós temos a permissão de implementar traits da biblioteca
padrão como <code>Display</code> em um tipo personalizado como <code>Tweet</code> como parte da
funcionalidade do nosso crate <code>aggregator</code>, já que nós já havíamos definido
<code>Resumir</code> lá. Essa restrição é parte do que é chamado de a <em>regra do ṍrfão</em>,
qual você pode procurar se estiver interessado nesse tipo de teoria. De forma
curta, é chamada de a regra do órfão porque o tipo pai não está presente. Sem
essa regra, dois crates poderiam implementar o mesmo trait para o mesmo tipo,
e as duas implementações entrariam em conflito: o Rust não saberia qual
implementação usar. Porque o Rust impõe a regra do órfão, os códigos de outras
pessoas não podem quebrar seu código e vice e versa.</p>
<a class="header" href="ch10-02-traits.html#implementações-padrão" id="implementações-padrão"><h3>Implementações Padrão</h3></a>
<p>As vezes é útil ter um comportamento padrão pra alguns ou todos os métodos em
um trait, ao invés de fazer toda implementação em todo tipo e definir um
comportamento personalizado. Quando implementamos o trait em um tipo
particular, nós podemos escolher manter ou sobrescrever o comportamento padrão
de cada método.</p>
<p>A Listagem 10-15 mostra como poderíamos ter escolhido especificar uma string
padrão para o método <code>resumo</code> do trait <code>Resumir</code> ao invés de escolher de apenas
definir a assinatura do método como fizemos na Listagem 10-12:</p>
<p><span class="filename">Nome do arquivo: lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Resumir {
    fn resumo(&amp;self) -&gt; String {
        String::from(&quot;(Leia mais...)&quot;)
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 10-15: Definição de um trait <code>Resumir</code> com a
implementação padrão do método <code>resumo</code></span></p>
<p>Se nós quiséssemos usar a implementação padrão para resumir as instâncias de
<code>ArtigoDeNoticia</code> ao invés de definir uma implementação personalizada como
fizemos na Listagem 10-13, nós especificaríamos um bloco <code>impl</code> vazio:</p>
<pre><code class="language-rust ignore">impl Resumir for ArtigoDeNoticia {}
</code></pre>
<p>Mesmo que não estejamos mais escolhendo definir o método <code>resumo</code> diretamente
em <code>ArtigoDeNoticia</code>, já que o método <code>resumo</code> tem uma implementação padrão e
nós especificamos que <code>ArtigoDeNoticia</code> implementa o trait <code>Resumir</code>, nós ainda
podemos chamar o método <code>resumo</code> em uma instância de <code>ArtigoDeNoticia</code>:</p>
<pre><code class="language-rust ignore">let artigo = ArtigoDeNoticia {
    titulo: String::from(&quot;Os Penguins ganham a copa do campeonato Stanley&quot;),
    lugar: String::from(&quot;Pittsburgh, PA, USA&quot;),
    autor: String::from(&quot;Iceburgh&quot;),
    conteudo: String::from(&quot;Os Penguins de Pittsburgh são novamente o melhor
    time de hockey da NHL.&quot;),
};

println!(&quot;Novo artigo disponível! {}&quot;, artigo.summary());
</code></pre>
<p>Esse código imprime <code>Novo artigo disponível! (Leia mais...)</code></p>
<p>Mudando o trait <code>Resumir</code> para ter uma implementação padrão para <code>resumo</code> não
requer que nós mudemos nada na implementação de <code>Resumir</code> em <code>Tweet</code> na
Listagem 10-13 ou em <code>PrevisaoTempo</code> na Listagem 10-14: a sintaxe para sobrepor
uma implementação padrão é exatamente a mesma de uma sintaxe para implementar
um método de trait que não tem uma implementação padrão.</p>
<p>Implementações padrões são autorizadas a chamar outros métodos no mesmo trait,
mesmo se os outros métodos não tiverem uma implementação padrão. Desse modo, um
trait pode prover muitas funcionalidades úteis e apenas requerir implementações
para especificar uma pequena parte dele. Nós poderíamos escolher que o trait
<code>Resumir</code> também tivesse o método <code>resumo_autor</code> qual a implementação é
necessária, então um método <code>resumo</code> que tem a implementação padrão que chama
pelo método <code>resumo_autor</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Resumir {
    fn resumo_autor(&amp;self) -&gt; String;

    fn resumo(&amp;self) -&gt; String {
        format!(&quot;(Leia mais de {}...)&quot;, self.resumo_autor())
    }
}
#}</code></pre></pre>
<p>Para usar essa versão de <code>Resumir</code>, nós só precisamos definir <code>resumo_autor</code>
quando nós implementamos o trait em um tipo:</p>
<pre><code class="language-rust ignore">impl Resumir for Tweet {
    fn autor_resumo(&amp;self) -&gt; String {
        format!(&quot;@{}&quot;, self.nomeusuario)
    }
}
</code></pre>
<p>Uma vez que definimos <code>resumo_autor</code>, nós podemos chamar <code>resumo</code> em instâncias
do struct <code>Tweet</code>, e a implementação padrão de <code>resumo</code> chamará a definição de
<code>resumo_autor</code> que fornecemos.</p>
<pre><code class="language-rust ignore">let tweet = Tweet {
    nomeusuario: String::from(&quot;horse_ebooks&quot;),
    conteudo: String::from(&quot;claro, como vocês provavelmente já sabem, 
    pessoas&quot;),
    resposta: false,
    retweet: false,
};

println!(&quot;1 novo tweet: {}&quot;, tweet.resumo());
</code></pre>
<p>Isso irá imprimir <code>1 novo tweet: (Leia mais de @horse_ebooks...)</code>.</p>
<p>Note que não é possível chamar a implementação padrão de uma implementação
primordial.</p>
<a class="header" href="ch10-02-traits.html#limites-de-traits" id="limites-de-traits"><h3>Limites de traits</h3></a>
<p>Agora que definimos traits e os implementamos em tipos, podemos usar traits com
parâmetros de tipos genéricos. Podemos restringir tipos genéricos para que ao
invés de serem qualquer tipo, o compilador tenha certeza que o tipo estará
limitado a aqueles tipos que implementam um trait em particular e por
consequência tenham o comportamento que precisamos que os tipos tenham. Isso é
chamado de especificar os <em>limites dos traits</em> em um tipo genérico.</p>
<p>Por exemplo, na Listagem 10-13, nós implementamos o trait <code>Resumir</code> nos tipos
<code>ArtigoDeNoticia</code> e <code>Tweet</code>. Nós podemos definir uma função <code>notificar</code> que chama
o método <code>resumo</code> no seu parâmetro <code>item</code>, que é do tipo genérico <code>T</code>. Para
ser possível chamar <code>resumo</code> em <code>item</code> sem receber um erro, podemos usar os
limites de traits em <code>T</code> para especificar que <code>item</code> precisa ser de um tipo que
implementa o trait <code>Resumir</code>:</p>
<pre><code class="language-rust ignore">pub fn notificar&lt;T: Resumir&gt;(item: T) {
    println!(&quot;Notícias de última hora! {}&quot;, item.resumo());
}
</code></pre>
<p>Limites de traits vão juntos com a declaração de um parâmetro de tipo genérico,
depois de uma vírgula e entre colchetes angulares. Por causa do limite de trait
em  <code>T</code>, nós podemos chamar <code>notificar</code> e passar qualquer instância de
<code>ArtigoDeNoticia</code> ou <code>Tweet</code>. O código externo da Listagem 10-14 que está
usando nosso crate <code>aggregator</code> pode chamar nossa função <code>notificar</code> e passar
uma instância de <code>PrevisaoTempo</code>, já que <code>Resumir</code> é implementado para
<code>PrevisaoTempo</code> também. O código que chama <code>notificar</code> com qualquer outro tipo,
como uma <code>String</code> ou um <code>i32</code>, não compilará, já que esses tipos não
implementam <code>Resumir</code>.</p>
<p>Nós podemos especificar múltiplos limites de traits em um tipo genérico usando
<code>+</code>. Se nós precisássemos ser capazes de usar mostrar formatação no tipo <code>T</code> em
uma função assim como no método <code>resumo</code>, nós podemos usar os limites de trait
<code>T: Resumir + Mostrar</code>. Isso signifca que <code>T</code> pode ser qualquer tipo que
implemente ambos <code>Resumir</code> e <code>Mostrar</code>.</p>
<p>Para funções que têm múltiplos parâmetros de tipos genéricos, cada tipo
genérico tem seu próprio limite de trait. Especificar muitas informações de
limites de trait dentro de chaves angulares entre o nome de uma função e sua
lista de parâmetros pode tornar o código difícil de ler, então há uma sintaxe
alternativa para especificar limites de traits que nos permite movê-los para
uma cláusula depois da assinatura da função. Então ao invés de:</p>
<pre><code class="language-rust ignore">fn alguma_funcao&lt;T: Mostrar + Clone, U: Clone + Debug&gt;(t: T, u: U) -&gt; i32 {
</code></pre>
<p>Nós podemos escrever isso com uma cláusula de <code>where</code>:</p>
<pre><code class="language-rust ignore">fn alguma_funcao&lt;T, U&gt;(t: T, u: U) -&gt; i32
    where T: Display + Clone,
          U: Clone + Debug
{
</code></pre>
<p>Isso é menos confuso e faz a assinatura da função ficar mais parecida à uma
função sem ter vários limites de trait, nela o nome da função, a lista de
parâmetros, e o tipo de retorno estão mais próximos.</p>
<a class="header" href="ch10-02-traits.html#consertando-a-função-maior-com-limites-de-traits" id="consertando-a-função-maior-com-limites-de-traits"><h3>Consertando a Função <code>maior</code> com Limites de Traits</h3></a>
<p>Então qualquer hora que você queira usar um comportamento definido por um trait
em um tipo genérico, você precisa especificar aquele trait nos limites dos
parâmetros dos tipos genéricos. Agora podemos consertar a definição da função
<code>maior</code> que usa um parâmetro de tipo genérico da Listagem 10-5! Quando deixamos
esse código de lado, nós recebemos esse erro:</p>
<pre><code class="language-text">error[E0369]: binary operation `&gt;` cannot be applied to type `T`
  |
5 |         if item &gt; maior {
  |            ^^^^
  |
note: an implementation of `std::cmp::PartialOrd` might be missing for `T`
</code></pre>
<p>No corpo de <code>maior</code> nós queríamos ser capazes de comparar dois valores de tipo
<code>T</code> usando o operador maior-que. Esse operador é definido com o método padrão
na biblioteca padrão de trait <code>std::cmp::PartialOrd</code>. Então para que possamos
usar o operador maior-que, precisamos especificar <code>PartialOrd</code> nos limites do
trait  para <code>T</code> para que a função <code>maior</code> funcione em partes de qualquer tipo
que possa ser comparada. Não precisamos trazer <code>PartialOrd</code> para o escopo
porque está no prelúdio.</p>
<pre><code class="language-rust ignore">fn maior&lt;T: PartialOrd&gt;(list: &amp;[T]) -&gt; T {
</code></pre>
<p>Se tentarmos compilar isso, receberemos diferentes erros:</p>
<pre><code class="language-text">error[E0508]: cannot move out of type `[T]`, a non-copy array
 --&gt; src/main.rs:4:23
  |
4 |     let mut maior = list[0];
  |         -----------   ^^^^^^^ cannot move out of here
  |         |
  |         hint: to prevent move, use `ref maior` or `ref mut maior`

error[E0507]: cannot move out of borrowed content
 --&gt; src/main.rs:6:9
  |
6 |     for &amp;item in list.iter() {
  |         ^----
  |         ||
  |         |hint: to prevent move, use `ref item` or `ref mut item`
  |         cannot move out of borrowed content
</code></pre>
<p>A chave para esse erro é <code>cannot move out of type [T], a non-copy array</code>. Com
nossas versões não genéricas da função <code>maior</code>, nós estávamos apenas tentando
encontrar o maior <code>i32</code> ou <code>char</code>. Como discutimos no Capítulo 4, tipos como o
<code>i32</code> e <code>char</code> que têm um tamanho conhecido podem ser armazenados na pilha,
então eles implementam o trait <code>Copia</code>. Quando mudamos a função <code>maior</code> para
ser genérica, agora é possível que o parâmetro <code>list</code> poderia ter tipos nele
que não implementam o trait <code>Copia</code>, o que significa que não seríamos capazes
de mover o valor para fora de <code>list[0]</code> para a variável <code>maior</code>.</p>
<p>Se quisermos ser capazes de chamar esse código com tipos que são <code>Copia</code>, nós
podemos adicionar <code>Copia</code> para os limites de trait de <code>T</code>! A Listagem 10-16
mostra o código completo de uma função <code>maior</code> genérica que compilará desde que
os tipos dos valores nessa parte que passamos para <code>maior</code> implementem ambos os
traits <code>PartialOrd</code> e <code>Copia</code>, como <code>i32</code> e <code>char</code>:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn maior&lt;T: PartialOrd + Copy&gt;(list: &amp;[T]) -&gt; T {
    let mut maior = list[0];

    for &amp;item in list.iter() {
        if item &gt; maior {
            maior = item;
        }
    }

    maior
}

fn main() {
    let lista_numero = vec![34, 50, 25, 100, 65];

    let result = maior(&amp;lista_numero);
    println!(&quot;O maior número é {}&quot;, result);

    let lista_char = vec!['y', 'm', 'a', 'q'];

    let result = maior(&amp;lista_char);
    println!(&quot;O maior char é {}&quot;, result);
}
</code></pre></pre>
<p><span class="caption">Listagem 10-16: Uma definição funcional da função <code>maior</code>
que funciona em qualquer tipo genérico que implementa os traits <code>PartialOrd</code> e
<code>Copia</code></span></p>
<p>Se não quisermos restringir nossa função <code>maior</code> para apenas tipos que
implementam o trait <code>Copia</code>, podemos especificar que <code>T</code> tem o limite de trait
<code>Clone</code> ao invés de <code>Copia</code> e clonar cada valor na parte quando quisermos que a
função <code>maior</code> tenha domínio. Usando a função <code>clone</code> significa que
potencialmente estamos fazendo mais alocações no heap, porém, e alocações no
heap podem ser vagarosas se estivermos trabalhando com grande quantidade de
dados. Outro jeito que podemos implementar <code>maior</code> é para a função retornar uma
referência ao valor de <code>T</code> em uma parte. Se retornarmos o tipo de retorno para
ser <code>&amp;T</code> ao invés de <code>T</code> e mudar o corpo da função para retornar uma
referência, não precisaríamos usar os limites de traits <code>Clone</code> ou <code>Copia</code> e
nós não estaríamos fazendo nenhuma alocação de heap.
Tente implementar essas soluções alternativas você mesmo!</p>
<a class="header" href="ch10-02-traits.html#usando-limites-de-trait-para-implementar-métodos-condicionalmente" id="usando-limites-de-trait-para-implementar-métodos-condicionalmente"><h3>Usando Limites de Trait para Implementar Métodos Condicionalmente</h3></a>
<p>Usando um limite de trait com um bloco <code>impl</code> que usa parâmetros de tipos
genéricos podemos implementar métodos condicionalmente apenas para tipos que
implementam os traits específicos. Por exemplo, o tipo <code>Par&lt;T&gt;</code> na listagem
10-17 sempre implementa o método <code>novo</code>, mas <code>Par&lt;T&gt;</code> implementa apenas o
<code>cmp_display</code> se seu tipo interno <code>T</code> implementa o trait <code>PartialOrd</code> que
permite a comparação e do trait <code>Display</code> que permite a impressão:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fmt::Display;

struct Par&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Par&lt;T&gt; {
    fn novo(x: T, y: T) -&gt; Self {
        Self {
            x,
            y,
        }
    }
}

impl&lt;T: Display + PartialOrd&gt; Par&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!(&quot;O maior membro é x = {}&quot;, self.x);
        } else {
            println!(&quot;O maior membro é y = {}&quot;, self.y);
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 10-17: Implementa métodos condicionalmente em um
tipo genérico dependendo dos limites de trait</span></p>
<p>Podemos também condicionalmente implementar um trait para qualquer tipo que
implementa um trait. Implementações de trait de qualquer tipo que satisfazem os
limites de trait são chamadas de <em>implementações cobertores</em>, e são
extesivamente utilizadas na biblioteca padrão de Rust. Por exemplo, a
biblioteca padrão implementa o trait <code>Display</code>. Esse bloco <code>impl</code> se parece com
este código:</p>
<pre><code class="language-rust ignore">impl&lt;T: Display&gt; ToString for T {
    // --snip--
}
</code></pre>
<p>Porque a biblioteca padrão tem essa implementação cobertor, podemos chamar
o método <code>to_string</code> definido pelo tipo <code>ToString</code> em qualquer tipo que
implemente o trait <code>Display</code>. Por exemplo, nós podemos transformar inteiros em
seus correspondentes valores de <code>String</code> do seguinte modo, já que inteiros
implementam <code>Display</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = 3.to_string();
#}</code></pre></pre>
<p>Implementações cobertor aparecem na documentação para traits na seção
&quot;Implementadores&quot;.</p>
<p>Traits e limites de traits nos deixam escrever código que usam parâmetros de
tipos genéricos para reduzir a duplicação, mas ainda sim especificam para o
compilador exatamente qual o comportamento que nosso código precisa que o tipo
genérico tenha. Porque demos a informação do limite de trait para o compilador,
ele pode checar que todos os tipos concretos usados no nosso código
proporcionam o comportamento correto. Em linguagens dinamicamente tipadas, se
nós tentássemos chamar um método em um tipo que não implementamos, nós
receberíamos um erro em tempo de execução. O Rust move esses erros para o temp
de compilação para que possamos ser forçados a resolver os problemas antes que
nosso código seja capaz de rodar. Além disso, nós não temos que escrever código
que checa o comportamento em tempo de execução já que já checamos em tempo de
compilação, o que melhora o desempenho comparado com outras linguagens sem ter
que abrir mão da flexibilidade de tipos genéricos.</p>
<p>Há outro tipo de tipos genéricos que estamos usando sem nem ao menos perceber
chamados <em>lifetimes</em>. Em vez de nos ajudar a garantir que um tipo tenha o
comportamento que precisamos, lifetimes nos ajudam a garantir que as
referências são válidas tanto quanto precisam ser. Vamos aprender como
lifetimes fazem isso.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch10-01-syntax.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch10-03-lifetime-syntax.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="ch10-01-syntax.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="ch10-03-lifetime-syntax.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if (getComputedStyle(document.querySelector(".fa")).fontFamily !== "FontAwesome") {
                var link = document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = '_FontAwesome/css/font-awesome.css';
                document.head.insertBefore(link, document.head.firstChild)
            }
        </script>

        

        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
