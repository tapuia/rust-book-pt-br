<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>üáßüá∑ Traits: Definindo Comportamento Compartilhado - </title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme;
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            document.querySelector('html').classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="ch01-00-introduction.html"><strong aria-hidden="true">1.</strong> üáßüá∑ Introdu√ß√£o</a></li><li><ol class="section"><li><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> üáßüá∑ Instala√ß√£o</a></li><li><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> üáßüá∑ Ol√°, Mundo!</a></li></ol></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> üáßüá∑ Jogo de Adivinha√ß√£o</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> üáßüá∑ Conceitos Comuns de Programa√ß√£o</a></li><li><ol class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> üáßüá∑ Vari√°veis e Mutabilidade</a></li><li><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> üáßüá∑ Tipos de dados</a></li><li><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> üáßüá∑ Fun√ß√µes</a></li><li><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> üáßüá∑ Coment√°rios</a></li><li><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> üáßüá∑ Controle de fluxo</a></li></ol></li><li><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> üáßüá∑ Entendendo Ownership</a></li><li><ol class="section"><li><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> üáßüá∑ O Que √â Ownership?</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> üáßüá∑ Refer√™ncias e Borrowing</a></li><li><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> üáßüá∑ Slices</a></li></ol></li><li><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> üáßüá∑ Structs</a></li><li><ol class="section"><li><a href="ch05-01-method-syntax.html"><strong aria-hidden="true">5.1.</strong> Method Syntax</a></li></ol></li><li><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> üáßüá∑ Enums e Casamento de Padr√µes</a></li><li><ol class="section"><li><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> üáßüá∑ Definindo uma Enum</a></li><li><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> üáßüá∑ Operador match</a></li><li><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> üáßüá∑ Controle de Fluxo Conciso com if let</a></li></ol></li><li><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> üáßüá∑ M√≥dulos</a></li><li><ol class="section"><li><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> üáßüá∑ mod e o Sistema de Arquivos</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> üáßüá∑ Controlando a Visibilidade com pub</a></li><li><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> üáßüá∑ Importando nomes com use</a></li></ol></li><li><a href="ch08-00-fundamental-collections.html"><strong aria-hidden="true">8.</strong> Fundamental Collections</a></li><li><ol class="section"><li><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> üáßüá∑ Vetores</a></li><li><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> üáßüá∑ Strings</a></li><li><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> üáßüá∑ Hash Maps</a></li></ol></li><li><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> üáßüá∑ Tratamento de Erros</a></li><li><ol class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> üáßüá∑ Erros Irrecuper√°veis com panic!</a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> üáßüá∑ Erros recuper√°veis com Result</a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> üáßüá∑ Entrar em panic! ou N√£o Entrar em panic!</a></li></ol></li><li><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> üáßüá∑ Tipos Gen√©ricos, Traits, e Tempos de vida (Lifetimes)</a></li><li><ol class="section"><li><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> üáßüá∑ Tipos Gen√©ricos de Dados</a></li><li><a href="ch10-02-traits.html" class="active"><strong aria-hidden="true">10.2.</strong> üáßüá∑ Traits: Definindo Comportamento Compartilhado</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> üáßüá∑ Validating References with Lifetimes</a></li></ol></li><li><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Writing tests</a></li><li><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Running tests</a></li><li><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project</a></li><li><ol class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Improving Error Handling and Modularity</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Testing the Library's Functionality</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing to stderr instead of stdout</a></li></ol></li><li><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features in Rust</a></li><li><ol class="section"><li><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures</a></li><li><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Iterators</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving our I/O Project</a></li><li><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performance</a></li></ol></li><li><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Release Profiles</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> üáßüá∑ Ponteiros Inteligentes (Smart Pointers)</a></li><li><ol class="section"><li><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> üáßüá∑ Box<T> Aponta para Dados no Heap e Tem Tamanho Conhecido</a></li><li><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> üáßüá∑ Tratando Ponteiros Inteligentes como Refer√™ncias Normais com a Trait Deref</a></li><li><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> üáßüá∑ A Trait Drop Roda C√≥digo durante a Limpeza</a></li><li><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> üáßüá∑ Rc<T>, o Ponteiro Inteligente com Contagem de Refer√™ncias</a></li><li><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> üáßüá∑ RefCell<T> e a Pattern de Mutabilidade Interior</a></li><li><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> üáßüá∑ Ciclos de Refer√™ncias Podem Vazar Mem√≥ria</a></li></ol></li><li><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrency</a></li><li><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> üáßüá∑ Rust √© uma linguagem orientada a objetos?</a></li><li><ol class="section"><li><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> üáßüá∑ O que significa orientado a objetos?</a></li><li><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> üáßüá∑ Usando objetos trait que permitem valores de tipos diferentes</a></li><li><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> üáßüá∑ Implementando um padr√£o de projeto orientado a objetos</a></li></ol></li><li><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns</a></li><li><a href="ch19-00-more-lifetimes.html"><strong aria-hidden="true">19.</strong> More Lifetimes</a></li><li><a href="ch20-00-advanced-types.html"><strong aria-hidden="true">20.</strong> Advanced Type System Features</a></li><li><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> Keywords</a></li><li><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> Operators</a></li><li><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> Derivable Traits</a></li><li><a href="appendix-04-nightly-rust.html"><strong aria-hidden="true">21.4.</strong> Nightly Rust</a></li><li><a href="appendix-05-macros.html"><strong aria-hidden="true">21.5.</strong> Macros</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="submenu">
                                <li><button class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li><button class="theme" id="rust">Rust</button></li>
                                <li><button class="theme" id="coal">Coal</button></li>
                                <li><button class="theme" id="navy">Navy</button></li>
                                <li><button class="theme" id="ayu">Ayu</button></li>
                            </ul>
                        </div>

                        <h1 class="menu-title"></h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="ch10-02-traits.html#traits-definindo-comportamento-compartilhado" id="traits-definindo-comportamento-compartilhado"><h2>Traits: Definindo Comportamento Compartilhado</h2></a>
<p>Traits nos permitem usar outro tipo de abstra√ß√£o: eles nos permitem abstrair
sobre o comportamento que tipos t√™m em comum. Um <em>trait</em> diz ao compilador de
Rust sobre uma funcionalidade que um tipo particular possui e pode compartilhar
com outros tipos. Em situa√ß√µes onde n√≥s usamos par√¢metros de tipos gen√©ricos,
n√≥s podemos usar <em>limites de trait</em> para especificar, em tempo de compila√ß√£o,
que o tipo gen√©rico pode ser qualquer tipo que implementa um trait e por
conseguinte tem o comportamento que queremos usar nessa situa√ß√£o.</p>
<blockquote>
<p>Nota: <em>Traits</em> s√£o similares a um recurso frequentemente chamado de
'interface' em outras linguagens, com algumas diferen√ßas.</p>
</blockquote>
<a class="header" href="ch10-02-traits.html#definindo-um-trait" id="definindo-um-trait"><h3>Definindo um Trait</h3></a>
<p>O comportamento de um tipo consiste nos m√©todos que podemos chamar para aquele
tipo. Tipos diferentes dividem o mesmo comportamento se podemos chamar os
mesmos m√©todos em todos esses tipos. Defini√ß√µes de traits s√£o um modo de
agrupar m√©todos de assinaturas juntos a fim de definir um conjunto de
comportamentos para atingir algum prop√≥sito.</p>
<p>Por exemplo, digamos que temos m√∫ltiplos structs que cont√©m v√°rios tipos e
quantidades de texto: um struct <code>ArtigoDeNoticias</code>que cont√©m uma not√≠cia
preenchida em um lugar do mundo, e um <code>Tweet</code> que pode ter no m√°ximo 140
caracteres em seu conte√∫do al√©m dos metadados como se ele foi um retweet ou uma
resposta a outro tweet.</p>
<p>N√≥s queremos fazer uma biblioteca agregadora de m√≠dia que pode mostrar resumos
de dados que podem estar guardados em uma inst√¢ncia de <code>ArtigoDeNoticia</code> ou
<code>Tweet</code>. O comportamento que precisamos cada struct possua √© que seja capaz de
ser resumido, e que n√≥s possamos pedir pelo resumo chamando um m√©todo <code>resumo</code>
em uma inst√¢ncia. A Listagem 10-12 mostra a defini√ß√£o de um trait <code>Resumir</code> que
expressa esse conceito:</p>
<p><span class="filename">Nome do arquivo: lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Resumir {
    fn resumo(&amp;self) -&gt; String;
}
#}</code></pre></pre>
<p><span class="caption">Listagem 10-12: Defini√ß√£o de um trait <code>Resumir</code> que
consiste no comportamento fornecido pelo m√©todo <code>resumo</code></span></p>
<p>N√≥s declaramos um trait com a palavra-chave <code>trait</code>, e ent√£o o nome do trait,
nesse caso <code>Resumir</code>. Dentro de chaves declaramos a assinatura do m√©todo que
descreve o comportamento que tipos que implementam esse trait precisar√£o ter,
nesse caso <code>fn resumo(&amp;self) -&gt; String;</code>. Depois da assinatura do m√©todo ao
inv√©s de fornecer uma implementa√ß√£o dentro de chaves, n√≥s colocamos um ponto e
v√≠rgula. Cada tipo que implementa esse trait precisa ent√£o fornecer seu pr√≥prio
comportamento customizado para o corpo do m√©todo, mas o compilador vai refor√ßar
que qualquer qualquer tipo que tenha o trait <code>Resumir</code> ter√° o m√©todo <code>resumo</code>
definido para ele com esse exata assinatura.</p>
<p>Um trait pode ter v√°rios m√©todos no seu corpo, com os m√©todos das assinaturas
listados um por linha e cada linha terminando com um ponto e v√≠rgula.</p>
<a class="header" href="ch10-02-traits.html#implementando-um-trait-em-um-tipo" id="implementando-um-trait-em-um-tipo"><h3>Implementando um Trait em um Tipo</h3></a>
<p>Agora que deifnimos o trait <code>Resumir</code>, podemos implementa-lo nos tipos do nosso
agregador de m√≠dias que queremos que tenham esse comportamento. A Listagem
10-13 mostra uma implementa√ß√£o do trait <code>Resumir</code> no struct <code>ArtigoNot√≠cia</code> que
possui o t√≠tulo, o autor e a localiza√ß√£o para criar e retornar o valor de
<code>resumo</code>. Para o struct <code>Tweet</code>, n√≥s escolhemos definir <code>resumo</code> como o nome de
usu√°rio seguido por todo o texto do tweet, assumindo que o conte√∫do do tweet j√°
est√° limitado a 140 caracteres.</p>
<p><span class="filename">Nome do arquivo: lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub trait Resumir {
#     fn summary(&amp;self) -&gt; String;
# }
#
pub struct ArtigoDeNoticia {
    pub titulo: String,
    pub local: String,
    pub autor: String,
    pub conteudo: String,
}

impl Resumir for ArtigoDeNoticia {
    fn summary(&amp;self) -&gt; String {
        format!(&quot;{}, by {} ({})&quot;, self.titulo, self.autor, self.local)
    }
}

pub struct Tweet {
    pub nomeusuario: String,
    pub conteudo: String,
    pub resposta: bool,
    pub retweet: bool,
}

impl Resumir for Tweet {
    fn summary(&amp;self) -&gt; String {
        format!(&quot;{}: {}&quot;, self.nomeusuario, self.conteudo)
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 10-13: Implementando o trait <code>Resumir</code> nos tipos
<code>ArtigoDeNoticia</code> e <code>Tweet</code></span></p>
<p>Implementar um trait em um tipo √© similar a implementar m√©todos que n√£o est√£o
relacionados com um trait. A diferen√ßa est√° depois de <code>impl</code>, n√≥s colocamos o
nome do trait que queremos implementar, ent√£o dizemos <code>for</code> e o nome do tipo
que queremos implementar. Dentro do bloco <code>impl</code>, n√≥s colocamos as assinaturas
dos m√©todos que a defini√ß√£o do trait definiu, mas ao inv√©s de colocar um ponto
e v√≠rgula depois de cada assinatura, n√≥s colocamos chaves e preenchemos o corpo
do m√©todo com o comportamento espec√≠fico que queremos que os m√©todos dos traits
tenham para um tipo particular.</p>
<p>Uma vez que implementamos o trait, n√≥s podemos chamar os m√©todos nas inst√¢ncias
de <code>ArtigoDeNoticia</code> e <code>Tweet</code> da mesma maneira que n√≥s chamamos m√©todos que n√£o
s√£o parte de um trait:</p>
<pre><code class="language-rust ignore">let tweet = Tweet {
    nomeUsuario: String::from(&quot;horse_ebooks&quot;),
    conteudo: String::from(&quot;claro, como voc√™s provavelmente j√° sabem, 
    pessoas&quot;),
    resposta: false,
    retweet: false,
};

println!(&quot;1 novo tweet: {}&quot;, tweet.summary());
</code></pre>
<p>Isso ir√° imprimir <code>1 novo tweet: claro, como voc√™s provavelmente j√° sabem, pessoas</code></p>
<p>Note que porque n√≥s definimos o trait <code>Resumir</code> e os tipos <code>ArtigoDeNoticia</code> e
<code>Tweet</code> todos na mesma <code>lib.rs</code> na listagem 10-13, eles est√£o todos no mesmo
escopo. Se essa <code>lib.rs</code> √© para um crate n√≥s chamamos <code>agregador</code>, e se outra
pessoa quiser usar a funcionalidade do nosso crate e implementar o trait
<code>Resumir</code> na sua struct <code>PrevisaoTempo</code>, o c√≥digo deles precisaria importar o
trait <code>Resumir</code> no escopo deles primeiro antes deles poderem implement√°-lo,
como na Listagem 10-14:</p>
<p><span class="filename">Nome do arquivo: lib.rs</span></p>
<pre><code class="language-rust ignore">extern crate aggregator;

use aggregator::Resumir;

struct PrevisaoTempo {
    alta_temp: f64,
    baixa_temp: f64,
    chance_de_chuva: f64,
}

impl Resumir for PrevisaoTempo {
    fn resumo(&amp;self) -&gt; String {
        format!(&quot;A alta ser√° de {}, e a baixa de {}. A chance de precipita√ß√£o √©
        {}%.&quot;, self.alta_temp, self.baixa_temp, self.chance_de_chuva)
    }
}
</code></pre>
<p><span class="caption">Listagem 10-14: Trazendo o trait <code>Resumir</code> do nosso crate
<code>aggregator</code> para o escopo de outro crate</span></p>
<p>Esse c√≥digo tamb√©m assume que <code>Resumir</code> √© um trait p√∫blico, o que √© verdade
porque colocamos a palavra-chave <code>pub</code> antes de <code>trait</code> na Listagem 10-12.</p>
<p>Uma restri√ß√£o para se prestar aten√ß√£o na implementa√ß√£o de traits: n√≥s podemos
implementar um trait em um tipo desde que o trait ou o tipo forem locais para o
nosso crate. Em outras palavras, n√≥s n√£o estamos autorizados a implementar
traits externos em tipos externos. N√≥s n√£o podemos implementar o trait
<code>Display</code> em <code>Vec</code>, por exemplo, j√° que ambos <code>Display</code> e <code>Vec</code> s√£o definidos na
biblioteca padr√£o. N√≥s temos a permiss√£o de implementar traits da biblioteca
padr√£o como <code>Display</code> em um tipo personalizado como <code>Tweet</code> como parte da
funcionalidade do nosso crate <code>aggregator</code>, j√° que n√≥s j√° hav√≠amos definido
<code>Resumir</code> l√°. Essa restri√ß√£o √© parte do que √© chamado de a <em>regra do ·πçrf√£o</em>,
qual voc√™ pode procurar se estiver interessado nesse tipo de teoria. De forma
curta, √© chamada de a regra do √≥rf√£o porque o tipo pai n√£o est√° presente. Sem
essa regra, dois crates poderiam implementar o mesmo trait para o mesmo tipo,
e as duas implementa√ß√µes entrariam em conflito: o Rust n√£o saberia qual
implementa√ß√£o usar. Porque o Rust imp√µe a regra do √≥rf√£o, os c√≥digos de outras
pessoas n√£o podem quebrar seu c√≥digo e vice e versa.</p>
<a class="header" href="ch10-02-traits.html#implementa√ß√µes-padr√£o" id="implementa√ß√µes-padr√£o"><h3>Implementa√ß√µes Padr√£o</h3></a>
<p>As vezes √© √∫til ter um comportamento padr√£o pra alguns ou todos os m√©todos em
um trait, ao inv√©s de fazer toda implementa√ß√£o em todo tipo e definir um
comportamento personalizado. Quando implementamos o trait em um tipo
particular, n√≥s podemos escolher manter ou sobrescrever o comportamento padr√£o
de cada m√©todo.</p>
<p>A Listagem 10-15 mostra como poder√≠amos ter escolhido especificar uma string
padr√£o para o m√©todo <code>resumo</code> do trait <code>Resumir</code> ao inv√©s de escolher de apenas
definir a assinatura do m√©todo como fizemos na Listagem 10-12:</p>
<p><span class="filename">Nome do arquivo: lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Resumir {
    fn resumo(&amp;self) -&gt; String {
        String::from(&quot;(Leia mais...)&quot;)
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 10-15: Defini√ß√£o de um trait <code>Resumir</code> com a
implementa√ß√£o padr√£o do m√©todo <code>resumo</code></span></p>
<p>Se n√≥s quis√©ssemos usar a implementa√ß√£o padr√£o para resumir as inst√¢ncias de
<code>ArtigoDeNoticia</code> ao inv√©s de definir uma implementa√ß√£o personalizada como
fizemos na Listagem 10-13, n√≥s especificar√≠amos um bloco <code>impl</code> vazio:</p>
<pre><code class="language-rust ignore">impl Resumir for ArtigoDeNoticia {}
</code></pre>
<p>Mesmo que n√£o estejamos mais escolhendo definir o m√©todo <code>resumo</code> diretamente
em <code>ArtigoDeNoticia</code>, j√° que o m√©todo <code>resumo</code> tem uma implementa√ß√£o padr√£o e
n√≥s especificamos que <code>ArtigoDeNoticia</code> implementa o trait <code>Resumir</code>, n√≥s ainda
podemos chamar o m√©todo <code>resumo</code> em uma inst√¢ncia de <code>ArtigoDeNoticia</code>:</p>
<pre><code class="language-rust ignore">let artigo = ArtigoDeNoticia {
    titulo: String::from(&quot;Os Penguins ganham a copa do campeonato Stanley&quot;),
    lugar: String::from(&quot;Pittsburgh, PA, USA&quot;),
    autor: String::from(&quot;Iceburgh&quot;),
    conteudo: String::from(&quot;Os Penguins de Pittsburgh s√£o novamente o melhor
    time de hockey da NHL.&quot;),
};

println!(&quot;Novo artigo dispon√≠vel! {}&quot;, artigo.summary());
</code></pre>
<p>Esse c√≥digo imprime <code>Novo artigo dispon√≠vel! (Leia mais...)</code></p>
<p>Mudando o trait <code>Resumir</code> para ter uma implementa√ß√£o padr√£o para <code>resumo</code> n√£o
requer que n√≥s mudemos nada na implementa√ß√£o de <code>Resumir</code> em <code>Tweet</code> na
Listagem 10-13 ou em <code>PrevisaoTempo</code> na Listagem 10-14: a sintaxe para sobrepor
uma implementa√ß√£o padr√£o √© exatamente a mesma de uma sintaxe para implementar
um m√©todo de trait que n√£o tem uma implementa√ß√£o padr√£o.</p>
<p>Implementa√ß√µes padr√µes s√£o autorizadas a chamar outros m√©todos no mesmo trait,
mesmo se os outros m√©todos n√£o tiverem uma implementa√ß√£o padr√£o. Desse modo, um
trait pode prover muitas funcionalidades √∫teis e apenas requerir implementa√ß√µes
para especificar uma pequena parte dele. N√≥s poder√≠amos escolher que o trait
<code>Resumir</code> tamb√©m tivesse o m√©todo <code>resumo_autor</code> qual a implementa√ß√£o √©
necess√°ria, ent√£o um m√©todo <code>resumo</code> que tem a implementa√ß√£o padr√£o que chama
pelo m√©todo <code>resumo_autor</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Resumir {
    fn resumo_autor(&amp;self) -&gt; String;

    fn resumo(&amp;self) -&gt; String {
        format!(&quot;(Leia mais de {}...)&quot;, self.resumo_autor())
    }
}
#}</code></pre></pre>
<p>Para usar essa vers√£o de <code>Resumir</code>, n√≥s s√≥ precisamos definir <code>resumo_autor</code>
quando n√≥s implementamos o trait em um tipo:</p>
<pre><code class="language-rust ignore">impl Resumir for Tweet {
    fn autor_resumo(&amp;self) -&gt; String {
        format!(&quot;@{}&quot;, self.nomeusuario)
    }
}
</code></pre>
<p>Uma vez que definimos <code>resumo_autor</code>, n√≥s podemos chamar <code>resumo</code> em inst√¢ncias
do struct <code>Tweet</code>, e a implementa√ß√£o padr√£o de <code>resumo</code> chamar√° a defini√ß√£o de
<code>resumo_autor</code> que fornecemos.</p>
<pre><code class="language-rust ignore">let tweet = Tweet {
    nomeusuario: String::from(&quot;horse_ebooks&quot;),
    conteudo: String::from(&quot;claro, como voc√™s provavelmente j√° sabem, 
    pessoas&quot;),
    resposta: false,
    retweet: false,
};

println!(&quot;1 novo tweet: {}&quot;, tweet.resumo());
</code></pre>
<p>Isso ir√° imprimir <code>1 novo tweet: (Leia mais de @horse_ebooks...)</code>.</p>
<p>Note que n√£o √© poss√≠vel chamar a implementa√ß√£o padr√£o de uma implementa√ß√£o
primordial.</p>
<a class="header" href="ch10-02-traits.html#limites-de-traits" id="limites-de-traits"><h3>Limites de traits</h3></a>
<p>Agora que definimos traits e os implementamos em tipos, podemos usar traits com
par√¢metros de tipos gen√©ricos. Podemos restringir tipos gen√©ricos para que ao
inv√©s de serem qualquer tipo, o compilador tenha certeza que o tipo estar√°
limitado a aqueles tipos que implementam um trait em particular e por
consequ√™ncia tenham o comportamento que precisamos que os tipos tenham. Isso √©
chamado de especificar os <em>limites dos traits</em> em um tipo gen√©rico.</p>
<p>Por exemplo, na Listagem 10-13, n√≥s implementamos o trait <code>Resumir</code> nos tipos
<code>ArtigoDeNoticia</code> e <code>Tweet</code>. N√≥s podemos definir uma fun√ß√£o <code>notificar</code> que chama
o m√©todo <code>resumo</code> no seu par√¢metro <code>item</code>, que √© do tipo gen√©rico <code>T</code>. Para
ser poss√≠vel chamar <code>resumo</code> em <code>item</code> sem receber um erro, podemos usar os
limites de traits em <code>T</code> para especificar que <code>item</code> precisa ser de um tipo que
implementa o trait <code>Resumir</code>:</p>
<pre><code class="language-rust ignore">pub fn notificar&lt;T: Resumir&gt;(item: T) {
    println!(&quot;Not√≠cias de √∫ltima hora! {}&quot;, item.resumo());
}
</code></pre>
<p>Limites de traits v√£o juntos com a declara√ß√£o de um par√¢metro de tipo gen√©rico,
depois de uma v√≠rgula e entre colchetes angulares. Por causa do limite de trait
em  <code>T</code>, n√≥s podemos chamar <code>notificar</code> e passar qualquer inst√¢ncia de
<code>ArtigoDeNoticia</code> ou <code>Tweet</code>. O c√≥digo externo da Listagem 10-14 que est√°
usando nosso crate <code>aggregator</code> pode chamar nossa fun√ß√£o <code>notificar</code> e passar
uma inst√¢ncia de <code>PrevisaoTempo</code>, j√° que <code>Resumir</code> √© implementado para
<code>PrevisaoTempo</code> tamb√©m. O c√≥digo que chama <code>notificar</code> com qualquer outro tipo,
como uma <code>String</code> ou um <code>i32</code>, n√£o compilar√°, j√° que esses tipos n√£o
implementam <code>Resumir</code>.</p>
<p>N√≥s podemos especificar m√∫ltiplos limites de traits em um tipo gen√©rico usando
<code>+</code>. Se n√≥s precis√°ssemos ser capazes de usar mostrar formata√ß√£o no tipo <code>T</code> em
uma fun√ß√£o assim como no m√©todo <code>resumo</code>, n√≥s podemos usar os limites de trait
<code>T: Resumir + Mostrar</code>. Isso signifca que <code>T</code> pode ser qualquer tipo que
implemente ambos <code>Resumir</code> e <code>Mostrar</code>.</p>
<p>Para fun√ß√µes que t√™m m√∫ltiplos par√¢metros de tipos gen√©ricos, cada tipo
gen√©rico tem seu pr√≥prio limite de trait. Especificar muitas informa√ß√µes de
limites de trait dentro de chaves angulares entre o nome de uma fun√ß√£o e sua
lista de par√¢metros pode tornar o c√≥digo dif√≠cil de ler, ent√£o h√° uma sintaxe
alternativa para especificar limites de traits que nos permite mov√™-los para
uma cl√°usula depois da assinatura da fun√ß√£o. Ent√£o ao inv√©s de:</p>
<pre><code class="language-rust ignore">fn alguma_funcao&lt;T: Mostrar + Clone, U: Clone + Debug&gt;(t: T, u: U) -&gt; i32 {
</code></pre>
<p>N√≥s podemos escrever isso com uma cl√°usula de <code>where</code>:</p>
<pre><code class="language-rust ignore">fn alguma_funcao&lt;T, U&gt;(t: T, u: U) -&gt; i32
    where T: Display + Clone,
          U: Clone + Debug
{
</code></pre>
<p>Isso √© menos confuso e faz a assinatura da fun√ß√£o ficar mais parecida √† uma
fun√ß√£o sem ter v√°rios limites de trait, nela o nome da fun√ß√£o, a lista de
par√¢metros, e o tipo de retorno est√£o mais pr√≥ximos.</p>
<a class="header" href="ch10-02-traits.html#consertando-a-fun√ß√£o-maior-com-limites-de-traits" id="consertando-a-fun√ß√£o-maior-com-limites-de-traits"><h3>Consertando a Fun√ß√£o <code>maior</code> com Limites de Traits</h3></a>
<p>Ent√£o qualquer hora que voc√™ queira usar um comportamento definido por um trait
em um tipo gen√©rico, voc√™ precisa especificar aquele trait nos limites dos
par√¢metros dos tipos gen√©ricos. Agora podemos consertar a defini√ß√£o da fun√ß√£o
<code>maior</code> que usa um par√¢metro de tipo gen√©rico da Listagem 10-5! Quando deixamos
esse c√≥digo de lado, n√≥s recebemos esse erro:</p>
<pre><code class="language-text">error[E0369]: binary operation `&gt;` cannot be applied to type `T`
  |
5 |         if item &gt; maior {
  |            ^^^^
  |
note: an implementation of `std::cmp::PartialOrd` might be missing for `T`
</code></pre>
<p>No corpo de <code>maior</code> n√≥s quer√≠amos ser capazes de comparar dois valores de tipo
<code>T</code> usando o operador maior-que. Esse operador √© definido com o m√©todo padr√£o
na biblioteca padr√£o de trait <code>std::cmp::PartialOrd</code>. Ent√£o para que possamos
usar o operador maior-que, precisamos especificar <code>PartialOrd</code> nos limites do
trait  para <code>T</code> para que a fun√ß√£o <code>maior</code> funcione em partes de qualquer tipo
que possa ser comparada. N√£o precisamos trazer <code>PartialOrd</code> para o escopo
porque est√° no prel√∫dio.</p>
<pre><code class="language-rust ignore">fn maior&lt;T: PartialOrd&gt;(list: &amp;[T]) -&gt; T {
</code></pre>
<p>Se tentarmos compilar isso, receberemos diferentes erros:</p>
<pre><code class="language-text">error[E0508]: cannot move out of type `[T]`, a non-copy array
 --&gt; src/main.rs:4:23
  |
4 |     let mut maior = list[0];
  |         -----------   ^^^^^^^ cannot move out of here
  |         |
  |         hint: to prevent move, use `ref maior` or `ref mut maior`

error[E0507]: cannot move out of borrowed content
 --&gt; src/main.rs:6:9
  |
6 |     for &amp;item in list.iter() {
  |         ^----
  |         ||
  |         |hint: to prevent move, use `ref item` or `ref mut item`
  |         cannot move out of borrowed content
</code></pre>
<p>A chave para esse erro √© <code>cannot move out of type [T], a non-copy array</code>. Com
nossas vers√µes n√£o gen√©ricas da fun√ß√£o <code>maior</code>, n√≥s est√°vamos apenas tentando
encontrar o maior <code>i32</code> ou <code>char</code>. Como discutimos no Cap√≠tulo 4, tipos como o
<code>i32</code> e <code>char</code> que t√™m um tamanho conhecido podem ser armazenados na pilha,
ent√£o eles implementam o trait <code>Copia</code>. Quando mudamos a fun√ß√£o <code>maior</code> para
ser gen√©rica, agora √© poss√≠vel que o par√¢metro <code>list</code> poderia ter tipos nele
que n√£o implementam o trait <code>Copia</code>, o que significa que n√£o ser√≠amos capazes
de mover o valor para fora de <code>list[0]</code> para a vari√°vel <code>maior</code>.</p>
<p>Se quisermos ser capazes de chamar esse c√≥digo com tipos que s√£o <code>Copia</code>, n√≥s
podemos adicionar <code>Copia</code> para os limites de trait de <code>T</code>! A Listagem 10-16
mostra o c√≥digo completo de uma fun√ß√£o <code>maior</code> gen√©rica que compilar√° desde que
os tipos dos valores nessa parte que passamos para <code>maior</code> implementem ambos os
traits <code>PartialOrd</code> e <code>Copia</code>, como <code>i32</code> e <code>char</code>:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn maior&lt;T: PartialOrd + Copy&gt;(list: &amp;[T]) -&gt; T {
    let mut maior = list[0];

    for &amp;item in list.iter() {
        if item &gt; maior {
            maior = item;
        }
    }

    maior
}

fn main() {
    let lista_numero = vec![34, 50, 25, 100, 65];

    let result = maior(&amp;lista_numero);
    println!(&quot;O maior n√∫mero √© {}&quot;, result);

    let lista_char = vec!['y', 'm', 'a', 'q'];

    let result = maior(&amp;lista_char);
    println!(&quot;O maior char √© {}&quot;, result);
}
</code></pre></pre>
<p><span class="caption">Listagem 10-16: Uma defini√ß√£o funcional da fun√ß√£o <code>maior</code>
que funciona em qualquer tipo gen√©rico que implementa os traits <code>PartialOrd</code> e
<code>Copia</code></span></p>
<p>Se n√£o quisermos restringir nossa fun√ß√£o <code>maior</code> para apenas tipos que
implementam o trait <code>Copia</code>, podemos especificar que <code>T</code> tem o limite de trait
<code>Clone</code> ao inv√©s de <code>Copia</code> e clonar cada valor na parte quando quisermos que a
fun√ß√£o <code>maior</code> tenha dom√≠nio. Usando a fun√ß√£o <code>clone</code> significa que
potencialmente estamos fazendo mais aloca√ß√µes no heap, por√©m, e aloca√ß√µes no
heap podem ser vagarosas se estivermos trabalhando com grande quantidade de
dados. Outro jeito que podemos implementar <code>maior</code> √© para a fun√ß√£o retornar uma
refer√™ncia ao valor de <code>T</code> em uma parte. Se retornarmos o tipo de retorno para
ser <code>&amp;T</code> ao inv√©s de <code>T</code> e mudar o corpo da fun√ß√£o para retornar uma
refer√™ncia, n√£o precisar√≠amos usar os limites de traits <code>Clone</code> ou <code>Copia</code> e
n√≥s n√£o estar√≠amos fazendo nenhuma aloca√ß√£o de heap.
Tente implementar essas solu√ß√µes alternativas voc√™ mesmo!</p>
<a class="header" href="ch10-02-traits.html#usando-limites-de-trait-para-implementar-m√©todos-condicionalmente" id="usando-limites-de-trait-para-implementar-m√©todos-condicionalmente"><h3>Usando Limites de Trait para Implementar M√©todos Condicionalmente</h3></a>
<p>Usando um limite de trait com um bloco <code>impl</code> que usa par√¢metros de tipos
gen√©ricos podemos implementar m√©todos condicionalmente apenas para tipos que
implementam os traits espec√≠ficos. Por exemplo, o tipo <code>Par&lt;T&gt;</code> na listagem
10-17 sempre implementa o m√©todo <code>novo</code>, mas <code>Par&lt;T&gt;</code> implementa apenas o
<code>cmp_display</code> se seu tipo interno <code>T</code> implementa o trait <code>PartialOrd</code> que
permite a compara√ß√£o e do trait <code>Display</code> que permite a impress√£o:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fmt::Display;

struct Par&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Par&lt;T&gt; {
    fn novo(x: T, y: T) -&gt; Self {
        Self {
            x,
            y,
        }
    }
}

impl&lt;T: Display + PartialOrd&gt; Par&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!(&quot;O maior membro √© x = {}&quot;, self.x);
        } else {
            println!(&quot;O maior membro √© y = {}&quot;, self.y);
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 10-17: Implementa m√©todos condicionalmente em um
tipo gen√©rico dependendo dos limites de trait</span></p>
<p>Podemos tamb√©m condicionalmente implementar um trait para qualquer tipo que
implementa um trait. Implementa√ß√µes de trait de qualquer tipo que satisfazem os
limites de trait s√£o chamadas de <em>implementa√ß√µes cobertores</em>, e s√£o
extesivamente utilizadas na biblioteca padr√£o de Rust. Por exemplo, a
biblioteca padr√£o implementa o trait <code>Display</code>. Esse bloco <code>impl</code> se parece com
este c√≥digo:</p>
<pre><code class="language-rust ignore">impl&lt;T: Display&gt; ToString for T {
    // --snip--
}
</code></pre>
<p>Porque a biblioteca padr√£o tem essa implementa√ß√£o cobertor, podemos chamar
o m√©todo <code>to_string</code> definido pelo tipo <code>ToString</code> em qualquer tipo que
implemente o trait <code>Display</code>. Por exemplo, n√≥s podemos transformar inteiros em
seus correspondentes valores de <code>String</code> do seguinte modo, j√° que inteiros
implementam <code>Display</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = 3.to_string();
#}</code></pre></pre>
<p>Implementa√ß√µes cobertor aparecem na documenta√ß√£o para traits na se√ß√£o
&quot;Implementadores&quot;.</p>
<p>Traits e limites de traits nos deixam escrever c√≥digo que usam par√¢metros de
tipos gen√©ricos para reduzir a duplica√ß√£o, mas ainda sim especificam para o
compilador exatamente qual o comportamento que nosso c√≥digo precisa que o tipo
gen√©rico tenha. Porque demos a informa√ß√£o do limite de trait para o compilador,
ele pode checar que todos os tipos concretos usados no nosso c√≥digo
proporcionam o comportamento correto. Em linguagens dinamicamente tipadas, se
n√≥s tent√°ssemos chamar um m√©todo em um tipo que n√£o implementamos, n√≥s
receber√≠amos um erro em tempo de execu√ß√£o. O Rust move esses erros para o temp
de compila√ß√£o para que possamos ser for√ßados a resolver os problemas antes que
nosso c√≥digo seja capaz de rodar. Al√©m disso, n√≥s n√£o temos que escrever c√≥digo
que checa o comportamento em tempo de execu√ß√£o j√° que j√° checamos em tempo de
compila√ß√£o, o que melhora o desempenho comparado com outras linguagens sem ter
que abrir m√£o da flexibilidade de tipos gen√©ricos.</p>
<p>H√° outro tipo de tipos gen√©ricos que estamos usando sem nem ao menos perceber
chamados <em>lifetimes</em>. Em vez de nos ajudar a garantir que um tipo tenha o
comportamento que precisamos, lifetimes nos ajudam a garantir que as
refer√™ncias s√£o v√°lidas tanto quanto precisam ser. Vamos aprender como
lifetimes fazem isso.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch10-01-syntax.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch10-03-lifetime-syntax.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="ch10-01-syntax.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="ch10-03-lifetime-syntax.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if (getComputedStyle(document.querySelector(".fa")).fontFamily !== "FontAwesome") {
                var link = document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = '_FontAwesome/css/font-awesome.css';
                document.head.insertBefore(link, document.head.firstChild)
            }
        </script>

        

        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
