<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>ğŸ‡§ğŸ‡· Tipos GenÃ©ricos de Dados - </title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme;
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            document.querySelector('html').classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="ch01-00-introduction.html"><strong aria-hidden="true">1.</strong> ğŸ‡§ğŸ‡· IntroduÃ§Ã£o</a></li><li><ol class="section"><li><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> ğŸ‡§ğŸ‡· InstalaÃ§Ã£o</a></li><li><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> ğŸ‡§ğŸ‡· OlÃ¡, Mundo!</a></li></ol></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> ğŸ‡§ğŸ‡· Jogo de AdivinhaÃ§Ã£o</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> ğŸ‡§ğŸ‡· Conceitos Comuns de ProgramaÃ§Ã£o</a></li><li><ol class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> ğŸ‡§ğŸ‡· VariÃ¡veis e Mutabilidade</a></li><li><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> ğŸ‡§ğŸ‡· Tipos de dados</a></li><li><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> ğŸ‡§ğŸ‡· FunÃ§Ãµes</a></li><li><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> ğŸ‡§ğŸ‡· ComentÃ¡rios</a></li><li><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> ğŸ‡§ğŸ‡· Controle de fluxo</a></li></ol></li><li><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> ğŸ‡§ğŸ‡· Entendendo Ownership</a></li><li><ol class="section"><li><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> ğŸ‡§ğŸ‡· O Que Ã‰ Ownership?</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> ğŸ‡§ğŸ‡· ReferÃªncias e Borrowing</a></li><li><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> ğŸ‡§ğŸ‡· Slices</a></li></ol></li><li><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> ğŸ‡§ğŸ‡· Structs</a></li><li><ol class="section"><li><a href="ch05-01-method-syntax.html"><strong aria-hidden="true">5.1.</strong> Method Syntax</a></li></ol></li><li><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> ğŸ‡§ğŸ‡· Enums e Casamento de PadrÃµes</a></li><li><ol class="section"><li><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> ğŸ‡§ğŸ‡· Definindo uma Enum</a></li><li><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> ğŸ‡§ğŸ‡· Operador match</a></li><li><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> ğŸ‡§ğŸ‡· Controle de Fluxo Conciso com if let</a></li></ol></li><li><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> ğŸ‡§ğŸ‡· MÃ³dulos</a></li><li><ol class="section"><li><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> ğŸ‡§ğŸ‡· mod e o Sistema de Arquivos</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> ğŸ‡§ğŸ‡· Controlando a Visibilidade com pub</a></li><li><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> ğŸ‡§ğŸ‡· Importando nomes com use</a></li></ol></li><li><a href="ch08-00-fundamental-collections.html"><strong aria-hidden="true">8.</strong> Fundamental Collections</a></li><li><ol class="section"><li><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> ğŸ‡§ğŸ‡· Vetores</a></li><li><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> ğŸ‡§ğŸ‡· Strings</a></li><li><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> ğŸ‡§ğŸ‡· Hash Maps</a></li></ol></li><li><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> ğŸ‡§ğŸ‡· Tratamento de Erros</a></li><li><ol class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> ğŸ‡§ğŸ‡· Erros IrrecuperÃ¡veis com panic!</a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> ğŸ‡§ğŸ‡· Erros recuperÃ¡veis com Result</a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> ğŸ‡§ğŸ‡· Entrar em panic! ou NÃ£o Entrar em panic!</a></li></ol></li><li><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> ğŸ‡§ğŸ‡· Tipos GenÃ©ricos, Traits, e Tempos de vida (Lifetimes)</a></li><li><ol class="section"><li><a href="ch10-01-syntax.html" class="active"><strong aria-hidden="true">10.1.</strong> ğŸ‡§ğŸ‡· Tipos GenÃ©ricos de Dados</a></li><li><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> ğŸ‡§ğŸ‡· Traits: Definindo Comportamento Compartilhado</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> ğŸ‡§ğŸ‡· Validating References with Lifetimes</a></li></ol></li><li><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Writing tests</a></li><li><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Running tests</a></li><li><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project</a></li><li><ol class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Improving Error Handling and Modularity</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Testing the Library's Functionality</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing to stderr instead of stdout</a></li></ol></li><li><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features in Rust</a></li><li><ol class="section"><li><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures</a></li><li><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Iterators</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving our I/O Project</a></li><li><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performance</a></li></ol></li><li><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Release Profiles</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> ğŸ‡§ğŸ‡· Ponteiros Inteligentes (Smart Pointers)</a></li><li><ol class="section"><li><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> ğŸ‡§ğŸ‡· Box<T> Aponta para Dados no Heap e Tem Tamanho Conhecido</a></li><li><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> ğŸ‡§ğŸ‡· Tratando Ponteiros Inteligentes como ReferÃªncias Normais com a Trait Deref</a></li><li><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> ğŸ‡§ğŸ‡· A Trait Drop Roda CÃ³digo durante a Limpeza</a></li><li><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> ğŸ‡§ğŸ‡· Rc<T>, o Ponteiro Inteligente com Contagem de ReferÃªncias</a></li><li><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> ğŸ‡§ğŸ‡· RefCell<T> e a Pattern de Mutabilidade Interior</a></li><li><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> ğŸ‡§ğŸ‡· Ciclos de ReferÃªncias Podem Vazar MemÃ³ria</a></li></ol></li><li><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrency</a></li><li><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> ğŸ‡§ğŸ‡· Rust Ã© uma linguagem orientada a objetos?</a></li><li><ol class="section"><li><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> ğŸ‡§ğŸ‡· O que significa orientado a objetos?</a></li><li><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> ğŸ‡§ğŸ‡· Usando objetos trait que permitem valores de tipos diferentes</a></li><li><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> ğŸ‡§ğŸ‡· Implementando um padrÃ£o de projeto orientado a objetos</a></li></ol></li><li><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns</a></li><li><a href="ch19-00-more-lifetimes.html"><strong aria-hidden="true">19.</strong> More Lifetimes</a></li><li><a href="ch20-00-advanced-types.html"><strong aria-hidden="true">20.</strong> Advanced Type System Features</a></li><li><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> Keywords</a></li><li><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> Operators</a></li><li><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> Derivable Traits</a></li><li><a href="appendix-04-nightly-rust.html"><strong aria-hidden="true">21.4.</strong> Nightly Rust</a></li><li><a href="appendix-05-macros.html"><strong aria-hidden="true">21.5.</strong> Macros</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="submenu">
                                <li><button class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li><button class="theme" id="rust">Rust</button></li>
                                <li><button class="theme" id="coal">Coal</button></li>
                                <li><button class="theme" id="navy">Navy</button></li>
                                <li><button class="theme" id="ayu">Ayu</button></li>
                            </ul>
                        </div>

                        <h1 class="menu-title"></h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="ch10-01-syntax.html#tipos-genÃ©ricos-de-dados" id="tipos-genÃ©ricos-de-dados"><h2>Tipos GenÃ©ricos de Dados</h2></a>
<p>Usando tipos genÃ©ricos onde usualmente colocamos tipos, como em assinaturas de
funÃ§Ãµes ou estruturas, vamos criar definiÃ§Ãµes que podemos usar muitos tipos
diferentes de tipos concretos de dados. Vamos dar uma olhada em como definir
funÃ§Ãµes, structs, enums e mÃ©todos usando tipos genÃ©ricos, e ao final dessa
seÃ§Ã£o discutiremos a performance do cÃ³digo usando tipos genÃ©ricos.</p>
<a class="header" href="ch10-01-syntax.html#usando-tipos-genÃ©ricos-de-dados-em-definiÃ§Ãµes-de-funÃ§Ãµes" id="usando-tipos-genÃ©ricos-de-dados-em-definiÃ§Ãµes-de-funÃ§Ãµes"><h3>Usando Tipos GenÃ©ricos de Dados em DefiniÃ§Ãµes de FunÃ§Ãµes</h3></a>
<p>NÃ³s podemos definir funÃ§Ãµes que usam tipos genÃ©ricos na assinatura da funÃ§Ã£o
onde os tipos de dados dos parÃ¢metros e os retornos vÃ£o. Desse modo, o cÃ³digo
que escrevemos pode ser mais flexÃ­vel e pode fornecer mais funcionalidades para
os chamadores da nossa funÃ§Ã£o, e ainda diminuir duplicaÃ§Ã£o de cÃ³digo.</p>
<p>Continuando com nossa funÃ§Ã£o <code>maior</code>, a Listagem 10-4 mostra duas funÃ§Ãµes que
oferecem a mesma funcionalidade de encontrar o maior valor dado um corte. A
primeira funÃ§Ã£o Ã© a que extraÃ­mos na Listagem 10-3 que encontra o maior <code>Ã¬32</code>
em um corte. A segunda funÃ§Ã£o encontra o maior <code>char</code> em um corte:</p>
<p><span class="filename">Nome do Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn maior_i32(lista: &amp;[i32]) -&gt; i32 {
    let mut maior = list[0];

    for &amp;item in lista.iter() {
        if item &gt; maior {
            maior = item;
        }
    }

    maior
}

fn maior_char(lista: &amp;[char]) -&gt; char {
    let mut maior = lista[0];

    for &amp;item in lista.iter() {
        if item &gt; maior {
            maior = item;
        }
    }

    maior
}

fn main() {
    let lista_numero = vec![34, 50, 25, 100, 65];

    let resultado = maior_i32(&amp;lista_numero);
    println!(&quot;O maior nÃºmero {}&quot;, resultado);
#    assert_eq!(resultado, 100);

    let lista_char = vec!['y', 'm', 'a', 'q'];

    let resultado = maior_char(&amp;lista_char);
    println!(&quot;O maior char Ã© {}&quot;, resultado);
#    assert_eq!(resultado, 'y');
}
</code></pre></pre>
<p><span class="caption">Listing 10-4: Duas funÃ§Ãµes que diferem apenas em seus
nomes e nos tipos de suas assinaturas</span></p>
<p>Aqui as funÃ§Ãµes <code>maior_i32</code> e <code>maior_char</code> tem exatamente o mesmo corpo, entÃ£o
seria bom se pudÃ©ssemos transformar essas duas funÃ§Ãµes em uma e nos livrar da
duplicaÃ§Ã£o. Por sorte, nÃ³s podemos fazer isso introduzindo um parÃ¢metro de
tipo genÃ©rico!</p>
<p>Para parametrizar os tipos na assinatura de uma funÃ§Ã£o que vamos definir,
precisamos criar um nome para o tipo parÃ¢metro, assim como damos nomes para os
valores dos parÃ¢metros de uma funÃ§Ã£o. NÃ³s vamos escolher o nome <code>T</code>. Qualquer
identificador pode ser usado como um nome de tipo de parÃ¢metro, mas estamos
escolhendo <code>T</code> porque a convenÃ§Ã£o de nomes de tipos de Rust Ã© a CamelCase.
Nomes de parÃ¢metros de tipos genÃ©ricos tambÃ©m tendem a ser curtos por
convenÃ§Ã£o, e frequentemente usam apenas uma letra. A abreviatura de &quot;tipo&quot;, <code>T</code>
Ã© a escolha padrÃ£o feita por programadores Rust.</p>
<p>Quando usamos um parÃ¢metro no corpo de uma funÃ§Ã£o, nÃ³s temos que declarar o
parÃ¢metro na assinatura para que o compilador saiba o que aquele nome no corpo
significa. Similarmente, quando usamos um tipo de nome de parÃ¢metro em uma
assinatura de funÃ§Ã£o, temos que declarar o tipo de nome de parÃ¢metro antes de
usa-lo. DeclaraÃ§Ãµes de tipos de nomes vÃ£o em colchetes entre o nome da funÃ§Ã£o e
a lista de paramÃªtros.</p>
<p>A assinatura da funÃ§Ã£o da funÃ§Ã£o genÃ©rica <code>maior</code> que vamos definir se parecerÃ¡
com isto:</p>
<pre><code class="language-rust ignore">fn maior&lt;T&gt;(lista: &amp;[T]) -&gt; T {
</code></pre>
<p>NÃ³s lerÃ­amos isso como: a funÃ§Ã£o <code>maior</code> Ã© genÃ©rica sobre algum tipo <code>T</code>. Ela
tem um parÃ¢metro chamado <code>lista</code>, e o tipo de <code>lista</code> Ã© um corte dos valores
do tipo <code>T</code>. A funÃ§Ã£o <code>maior</code> retornarÃ¡ um valor do mesmo tipo <code>T</code>.</p>
<p>A listagem 10-5 mostra a definiÃ§Ã£o da funÃ§Ã£o unificada <code>maior</code> usando um tipo
genÃ©rico de dado na sua assinatura, e mostra quando nÃ³s poderemos chamar a
funÃ§Ã£o <code>maior</code> com ou um corte de valores de <code>i32</code> ou de valores <code>char</code>. Note
que esse cÃ³digo nÃ£o compilarÃ¡ ainda!</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn maior&lt;T&gt;(lista: &amp;[T]) -&gt; T {
    let mut maior = lista[0];

    for &amp;item in lista.iter() {
        if item &gt; maior {
            maior = item;
        }
    }

    maior
}

fn main() {
    let lista_numero = vec![34, 50, 25, 100, 65];

    let resultado = maior(&amp;lista_numero);
    println!(&quot;The maior number is {}&quot;, resultado);

    let lista_char = vec!['y', 'm', 'a', 'q'];

    let resultado = maior(&amp;char_lista);
    println!(&quot;O maior char e {}&quot;, resultado);
}
</code></pre>
<p><span class="caption">Listagem 10-5: Uma definiÃ§Ã£o para a funÃ§Ã£o <code>maior</code> que
usa um tipo genÃ©rico como parÃ¢metro mas nÃ£o compila ainda</span></p>
<p>Se nÃ³s tentarmos compilar o cÃ³digo agora, nÃ³s receberemos esse erro:</p>
<pre><code class="language-text">error[E0369]: binary operation `&gt;` cannot be applied to type `T`
  |
5 |         if item &gt; maior {
  |            ^^^^
  |
note: an implementation of `std::cmp::PartialOrd` might be missing for `T`
</code></pre>
<p>A nota menciona <code>std::cmp::PartialOrd</code>, que Ã© um <em>trait</em>. NÃ³s vamos falar sobre
trait na prÃ³xima sessÃ£o, mas de forma breve, o que esse erro estÃ¡ dizendo Ã© que
o corpo de <code>maior</code> nÃ£o funcionarÃ¡ para todos os possÃ­veis tipos que <code>T</code> poderia
ser; jÃ¡ que queremos comparar valores do tipo <code>T</code> no corpo, nÃ³s podemos apenas
usar tipos que sabem como ser ordenados. A biblioteca padrÃ£o definiu que o
trait <code>std::cmp::PartialOrd</code> que tipos podem implementar para habilitar
comparaÃ§Ãµes. Vamos voltar a traits e em como especificar que um tipo genÃ©rico
tenha um trait em particular na prÃ³xima sessÃ£o, mas vamos deixar isso de lado
por um momento e explorar outros lugares que podemos usar parÃ¢metros de tipos
genÃ©ricos primeiro.</p>
<a class="header" href="ch10-01-syntax.html#usando-tipos-de-dados-genÃ©ros-em-definiÃ§Ãµes-de-structs" id="usando-tipos-de-dados-genÃ©ros-em-definiÃ§Ãµes-de-structs"><h3>Usando Tipos de Dados GenÃ©ros em DefiniÃ§Ãµes de Structs</h3></a>
<p>NÃ³s podemos definir structs para usar um parÃ¢metro de tipo genÃ©rico em um ou
mais campos de um struct com a sintaxe <code>&lt;&gt;</code> tambÃ©m. A listagem 10-6 mostra a
definiÃ§Ã£o e faz uso do struct <code>Ponto</code> que contÃ©m as coordenadas <code>x</code> e <code>y</code> com
valores de qualquer tipo:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Ponto&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let inteiro = Ponto { x: 5, y: 10 };
    let float = Ponto { x: 1.0, y: 4.0 };
}
</code></pre></pre>
<p><span class="caption">Listagem 10-6: Uma struct <code>Ponto</code> contÃ©m os valores <code>x</code> e
<code>y</code> do tipo <code>T</code></span></p>
<p>A sintaxe Ã© similar a que se usa em definiÃ§Ãµes de funÃ§Ãµes usando tipos
genÃ©ricos. Primeiro, nÃ³s temos que declarar o nome do tipo de parÃ¢metro dentro
de colchetes angulares logo apÃ³s o nome da struct. EntÃ£o nÃ³s podemos usar tipos
genÃ©ricos na definiÃ§Ã£o da struct onde nÃ³s especificarÃ­amos tipos concretos de
dados.</p>
<p>Note que porque sÃ³ usamos um tipo genÃ©rico na definiÃ§Ã£o de <code>Ponto</code>, o que
estamos dizendo Ã© que o struct <code>Ponto</code> Ã© genÃ©rico sobre algum tipo <code>T</code>, e os
campos <code>x</code> e <code>y</code> sÃ£o <em>ambos</em> do mesmo tipo, qualquer que seja. Se nÃ³s tentarmos
criar uma instÃ¢ncia de um <code>Ponto</code> que possui valores de tipos diferentes, como
na Listagem 10-7, nosso cÃ³digo nÃ£o compilarÃ¡:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">struct Ponto&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let nao_funciona = Ponto { x: 5, y: 4.0 };
}
</code></pre>
<p><span class="caption">Listagem 10-7: Os campos <code>x</code> e <code>y</code> precisam ser do mesmo
tipo porque ambos tem o tipo genÃ©rico de dado <code>T</code></span></p>
<p>Se nÃ³s tentarmos compilar isso, receberemos o seguinte erro:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt;
  |
7 |     let nao_funciona = Point { x: 5, y: 4.0 };
  |                                         ^^^ expected integral variable, found
  floating-point variable
  |
  = note: expected type `{integer}`
  = note:    found type `{float}`
</code></pre>
<p>Quando atribuÃ­mos o valor de 5 para <code>x</code>, o compilador sabe que para essa
instÃ¢ncia de <code>Ponto</code> o tipo genÃ©rico <code>T</code> serÃ¡ um nÃºmero inteiro. EntÃ£o quando
especificamos 4.0 para <code>y</code>, o qual Ã© definido para ter o mesmo tipo de <code>x</code>, nÃ³s
temos um tipo de erro de incompatibilidade.</p>
<p>Se nÃ³s quisermos definir um struct de <code>Ponto</code> onde <code>x</code> e <code>y</code> tÃªm tipos
diferentes e quisermos fazer com que esses tipos sejam genÃ©ricos, nÃ³s podemos
usar parÃ¢metros mÃºltiplos de tipos genÃ©ricos. Na listagem 10-8, nÃ³s mudamos a
definiÃ§Ã£o do <code>Ponto</code> para os tipos genÃ©ricos <code>T</code> e <code>U</code>. O campo <code>x</code> Ã© do tipo
<code>T</code>, e o campo <code>y</code> do tipo <code>U</code>:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Ponto&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let ambos_inteiros = Ponto { x: 5, y: 10 };
    let ambos_floats = Ponto { x: 1.0, y: 4.0 };
    let inteiro_e_float = Ponto { x: 5, y: 4.0 };
}
</code></pre></pre>
<p><span class="caption">Listagem 10-8: Um <code>Ponto</code> genÃ©rico sobre dois tipos <code>x</code> e
<code>y</code> podem ser valores de tipos diferentes</span></p>
<p>Agora todos as instÃ¢ncias de <code>Ponto</code> sÃ£o permitidas! VocÃª pode usar quantos
parÃ¢metros de tipos genÃ©ricos em uma definiÃ§Ã£o quanto quiser, mas usar mais que
alguns comeÃ§a a tornar o cÃ³digo difÃ­cil de ler e entender. Se vocÃª chegar em um
ponto que precisa usar muitos tipos genÃ©ricos, Ã© provavelmente um sinal que seu
cÃ³digo poderia ser reestruturado e separado em partes menores.</p>
<a class="header" href="ch10-01-syntax.html#usando-tipos-de-dados-genÃ©ricos-em-definiÃ§Ãµes-de-enum" id="usando-tipos-de-dados-genÃ©ricos-em-definiÃ§Ãµes-de-enum"><h3>Usando Tipos de Dados GenÃ©ricos em DefiniÃ§Ãµes de Enum</h3></a>
<p>Similar a structs, enums podem ser definidos para conter tipos genÃ©ricos de
dados nas suas variantes. NÃ³s usamos o enum <code>Option&lt;T&gt;</code> concedido pela
biblioteca padrÃ£o no capÃ­tulo 6, e agora a definiÃ§Ã£o deve fazer mais sentido.
Vamos dar uma outra olhada:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Option&lt;T&gt; {
    Some(T),
    None,
}
#}</code></pre></pre>
<p>Em outras palavras, <code>Option&lt;T&gt;</code> Ã© um enum genÃ©rico do tipo <code>T</code>. Ele tÃªm duas
variantes: <code>Some</code>, que contÃ©m o valor do tipo <code>T</code>, e uma variante <code>None</code> que
nÃ£o contÃ©m nenhum valor. A biblioteca padrÃ£o tem que ter apenas essa deifiniÃ§Ã£o
para suportar a criaÃ§Ã£o de valores desse enum que pode conter qualquer tipo
concreto. A ideia de um &quot;um valor opcional&quot; Ã© um conceito mais abstrato que o
de um tipo especÃ­fico, e Rust nos deixa expressar esse conceito abstrato sem
muitas duplicaÃ§Ãµes.</p>
<p>Enum podem usar tipos mÃºltiplos genÃ©ricos tambÃ©m. A definiÃ§Ã£o do enum
<code>Resultado</code> que usamos no CapÃ­tulo 9 Ã© um exemplo:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Resultado&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
#}</code></pre></pre>
<p>O enum <code>Resultado</code> Ã© genÃ©rico sobre dois tipos, <code>T</code> e <code>E</code>. <code>Resultado</code> tem duas
variantes: <code>Ok</code>, que contÃ©m um valor do tipo <code>T</code>, e <code>Err</code>, que contÃ©m um valor
do tipo  <code>E</code>. Essa definiÃ§Ã£o faz com que seja conveniente usar o enum
<code>Resultado</code> em qualquer lugar que tenhamos uma operaÃ§Ã£o que possa ser bem
sucedida (e retornar um valor de algum tipo <code>T</code>) ou falhar (e retornar um erro
de algum tipo <code>E</code>). Lembre da Listagem 9-2 quando abrimos um arquivo: naquele
caso, <code>T</code> tinha o tipo <code>std::fs::File</code> quando o arquivo era aberto com sucesso
e <code>E</code> tinha o tipo <code>std::io::Error</code> quando havia problemas em abrir o arquivo.</p>
<p>Quando vocÃª reconhece situaÃ§Ãµes no seu cÃ³digo com structs mÃºltiplos ou
definiÃ§Ãµes de enum que diferem apenas nos tipos de valores que eles contÃ©m,
vocÃª pode remover a duplicata usando o mesmo processo usado na definiÃ§Ã£o de
funÃ§Ãµes para introduzir tipos genÃ©ricos.</p>
<a class="header" href="ch10-01-syntax.html#usando-tipos-genÃ©ricos-de-dados-em-definiÃ§Ãµes-de-mÃ©todos" id="usando-tipos-genÃ©ricos-de-dados-em-definiÃ§Ãµes-de-mÃ©todos"><h3>Usando Tipos GenÃ©ricos de Dados em DefiniÃ§Ãµes de MÃ©todos</h3></a>
<p>Como fizemos no CapÃ­tulo 5, nÃ³s podemos implementar mÃ©todos em estruturas e
enums que tÃªm tipos genÃ©ricos em suas definiÃ§Ãµes. A Listagem 10-9 mostra o
struct <code>Ponto&lt;T&gt;</code> que definimos na Listagem 10-6. NÃ³s, entÃ£o, definimos um
mÃ©todo chamado <code>x</code> no <code>Ponto&lt;T&gt;</code> que retorna a referÃªncia para o dado no campo
<code>x</code>:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Ponto&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Ponto&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Ponto { x: 5, y: 10 };

    println!(&quot;p.x = {}&quot;, p.x());
}
</code></pre></pre>
<p><span class="caption">Listagem 10-9: Implementando um mÃ©todo chamado <code>x</code> na
struct <code>Ponto&lt;T&gt;</code> que retornarÃ¡ uma referÃªncia para o campo <code>x</code>, que Ã© do tipo
<code>T</code>.</span></p>
<p>Note que temos que declarar <code>T</code> logo apÃ³s <code>impl</code> para usar <code>T</code> no tipo
<code>Ponto&lt;T&gt;</code>. Declarar <code>T</code> como um tipo genÃ©rico depois e <code>impl</code> Ã© como o Rust
sabe se o tipo dentro das chaves angulares em <code>Ponto</code> Ã© um tipo genÃ©rico ou um
tipo concreto. Por exemplo, nÃ³s poderÃ­amos escolher implementar mÃ©todos nas
instÃ¢ncias de <code>Ponto&lt;f32&gt;</code> ao invÃ©s nas de <code>Ponto</code> com qualquer tipo genÃ©rico.
A listagem 10-10 mostra que nÃ£o declaramos nada depois de <code>impl</code> nesse caso, jÃ¡
que estamos usanod um tipo concreto, <code>f32</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Ponto&lt;T&gt; {
#     x: T,
#     y: T,
# }
#
impl Ponto&lt;f32&gt; {
    fn distancia_da_origem(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 10-10: Construindo um bloco de <code>impl</code> que sÃ³ se
aplica a uma struct com o tipo especÃ­fico usado pelo parÃ¢metro de tipo genÃ©rico
<code>T</code></span></p>
<p>Esse cÃ³digo significa que o tipo <code>Ponto&lt;f32&gt;</code> terÃ¡ um mÃ©todo chamado
<code>distancia_da_origem</code>, e outras instÃ¢ncias do <code>Ponto&lt;T&gt;</code> onde <code>T</code> nÃ£o Ã© do tipo
<code>f32</code> nÃ£o terÃ¡ esse mÃ©todo definido. Esse mÃ©todo quÃ£o longe nosso ponto estÃ¡
das coordenadas (0.0, 0.0) e usa operaÃ§Ãµes matemÃ¡ticas que sÃ³ estÃ£o disponÃ­veis
para tipos de ponto-flutuantes.</p>
<p>ParÃ¢metros de tipos genÃ©ricos em uma definiÃ§Ã£o de struct nÃ£o sÃ£o sempre os
parÃ¢metros de tipos genÃ©ricos que vocÃª quer usar na assinatura de mÃ©todo
daquela struct. A Listagem 10-11 define um mÃ©todo <code>mistura</code> na estrutura
<code>Ponto&lt;T, U&gt;</code> da Listagem 10-8. O mÃ©todo recebe outro <code>Ponto</code> como parÃ¢metro,
que pode ter tipos diferentes de <code>self</code> <code>Ponto</code> dos quais usamos no <code>mistura</code>.
O mÃ©todo cria uma nova instÃ¢ncia de <code>Ponto</code> que possui o valor <code>x</code> de <code>self</code>
<code>Point</code> (que Ã© um tipo de <code>T</code>) e o valor de <code>y</code> passado de <code>Ponto</code> (que Ã© do
tipo <code>W</code>):</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Ponto&lt;T, U&gt; {
    x: T,
    y: U,
}

impl&lt;T, U&gt; Ponto&lt;T, U&gt; {
    fn mistura&lt;V, W&gt;(self, other: Ponto&lt;V, W&gt;) -&gt; Ponto&lt;T, W&gt; {
        Ponto {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Ponto { x: 5, y: 10.4 };
    let p2 = Ponto { x: &quot;Ola&quot;, y: 'c'};

    let p3 = p1.mistura(p2);

    println!(&quot;p3.x = {}, p3.y = {}&quot;, p3.x, p3.y);
}
</code></pre></pre>
<p><span class="caption">Listagem 10-11: MÃ©todos que usam diferentes tipos
genÃ©ricos das suas definiÃ§Ãµes de struct</span></p>
<p>No <code>main</code>, nÃ³s definimos um <code>Ponto</code> que tem um <code>i32</code> para o <code>x</code> (com o valor de
<code>5</code>) e um <code>f64</code> para <code>y</code> (com o valor de <code>10.4</code>). <code>p2</code> Ã© um <code>Ponto</code> que tem um
pedaÃ§o de string <code>x</code> (com o valor <code>&quot;Ola&quot;</code>) e um <code>char</code> para <code>y</code> (com o valor
<code>c</code>). Chamando <code>mistura</code> no <code>p1</code> com o argumento <code>p2</code> nos dÃ¡ <code>p3</code>, que terÃ¡ um
<code>i32</code> para <code>x</code>, jÃ¡ que <code>x</code> veio de <code>p1</code>. <code>p3</code> terÃ¡ um <code>char</code> para <code>y</code>, jÃ¡ que
<code>y</code> veio de <code>p2</code>. O <code>println!</code> irÃ¡ imprimir <code>p3.x = 5, p3.y = c</code>.</p>
<p>Note que os parÃ¢metro genÃ©ricos <code>T</code> e <code>U</code> sÃ£o declarados depois de <code>impl</code>, jÃ¡
que eles vÃ£o com a definiÃ§Ã£o do struct. Os parÃ¢metros genÃ©ricos <code>V</code> e <code>áº€</code> sÃ£o
declarados depois de <code>fn mistura</code>, jÃ¡ que elÃ©s sÃ³ sÃ£o relevantes para esse
mÃ©todo.</p>
<a class="header" href="ch10-01-syntax.html#desempenho-do-cÃ³digo-usando-genÃ©ricos" id="desempenho-do-cÃ³digo-usando-genÃ©ricos"><h3>Desempenho do CÃ³digo Usando GenÃ©ricos</h3></a>
<p>VocÃª pode estar lendo essa seÃ§Ã£o e imaginando se hÃ¡ um custo no tempo de
execuÃ§Ã£o para usar parÃ¢metros de tipos genÃ©ricos. Boas notÃ­cias: o modo como
Rust implementa tipos genÃ©ricos significa que seu cÃ³digo nÃ£o vai ser executado
mais devagar do que se vocÃª tivesse especificado tipos concretos ao invÃ©s de
tipos genÃ©ricos como parÃ¢metros!</p>
<p>Rust consegue fazer isso realizando <em>monomorfizaÃ§Ã£o</em> de cÃ³digo usando tipos
genÃ©ricos em tempo de compilaÃ§Ã£o. MonomorfizaÃ§Ã£o Ã© o processo de transformar
cÃ³digo genÃ©rico em cÃ³digo especÃ­fico substituindo os tipos genÃ©ricos pelos
tipos concretos que sÃ£o realmente utilizados.</p>
<p>O que o compilador faz Ã© o oposto dos passos que fizemos para criar uma funÃ§Ã£o
de tipo genÃ©rico na Listagem 10-5. O compilador olhar para todos os lugares que
o cÃ³digo genÃ©rico Ã© chamado e gera o cÃ³digo para os tipos concretos que o
cÃ³digo genÃ©rico Ã© chamado.</p>
<p>Vamos trabalhar sobre o exemplo que usa o padrÃ£o de enum <code>Option</code> da
biblioteca:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let inteiro = Some(5);
let float = Some(5.0);
#}</code></pre></pre>
<p>Quando o Rust compilar esse cÃ³digo, ele vai fazer a monomorfizaÃ§Ã£o. O
compilador lerÃ¡ os valores que foram passados para <code>Option</code> e ver que temos
dois tipos de <code>Option&lt;T&gt;</code>: um Ã© <code>i32</code>, e o outro <code>f64</code>. Assim sendo, ele
expandirÃ¡ a definiÃ§Ã£o genÃ©rica de <code>Option&lt;T&gt;</code> para <code>Option_i32</code> e <code>Option_64</code>,
substituindo a definiÃ§Ã£o genÃ©rica por definiÃ§Ãµes especÃ­ficas.</p>
<p>A versÃ£o monomorfizada do nosso cÃ³digo que o compilador gera Ã© a seguinte, com
os usos da <code>Option</code> genÃ©rica substituÃ­dos pelas definiÃ§Ãµes especÃ­ficas criadas
pelo compilador:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let inteiro = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
</code></pre></pre>
<p>NÃ³s podemos escrever cÃ³digos nÃ£o duplicados usando tipos genÃ©ricos, e Rust vai
compila-lo em cÃ³digo que especifica o tipo em cada instÃ¢ncia. Isso significa
que nÃ£o pagamos nenhum custo em tempo de processamento para usar tipos
genÃ©ricos; quando o cÃ³digo roda, ele executa do mesmo modo como executaria se
tivÃ©ssemos duplicado cada definiÃ§Ã£o particular a mÃ£o. O proccesso de
monomorfizaÃ§Ã£o Ã© o que faz os tipos genÃ©ricos de Rust serem extremamente
eficientes em tempo de processamento.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch10-00-generics.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch10-02-traits.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="ch10-00-generics.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="ch10-02-traits.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if (getComputedStyle(document.querySelector(".fa")).fontFamily !== "FontAwesome") {
                var link = document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = '_FontAwesome/css/font-awesome.css';
                document.head.insertBefore(link, document.head.firstChild)
            }
        </script>

        

        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
