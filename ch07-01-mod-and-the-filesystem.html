<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>🇧🇷 mod e o Sistema de Arquivos - </title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme;
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            document.querySelector('html').classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="ch01-00-introduction.html"><strong aria-hidden="true">1.</strong> 🇧🇷 Introdução</a></li><li><ol class="section"><li><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> 🇧🇷 Instalação</a></li><li><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> 🇧🇷 Olá, Mundo!</a></li></ol></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> 🇧🇷 Jogo de Adivinhação</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> 🇧🇷 Conceitos Comuns de Programação</a></li><li><ol class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> 🇧🇷 Variáveis e Mutabilidade</a></li><li><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> 🇧🇷 Tipos de dados</a></li><li><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> 🇧🇷 Funções</a></li><li><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> 🇧🇷 Comentários</a></li><li><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> 🇧🇷 Controle de fluxo</a></li></ol></li><li><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> 🇧🇷 Entendendo Ownership</a></li><li><ol class="section"><li><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> 🇧🇷 O Que É Ownership?</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> 🇧🇷 Referências e Borrowing</a></li><li><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> 🇧🇷 Slices</a></li></ol></li><li><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> 🇧🇷 Structs</a></li><li><ol class="section"><li><a href="ch05-01-method-syntax.html"><strong aria-hidden="true">5.1.</strong> Method Syntax</a></li></ol></li><li><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> 🇧🇷 Enums e Casamento de Padrões</a></li><li><ol class="section"><li><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> 🇧🇷 Definindo uma Enum</a></li><li><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> 🇧🇷 Operador match</a></li><li><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> 🇧🇷 Controle de Fluxo Conciso com if let</a></li></ol></li><li><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> 🇧🇷 Módulos</a></li><li><ol class="section"><li><a href="ch07-01-mod-and-the-filesystem.html" class="active"><strong aria-hidden="true">7.1.</strong> 🇧🇷 mod e o Sistema de Arquivos</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> 🇧🇷 Controlando a Visibilidade com pub</a></li><li><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> 🇧🇷 Importando nomes com use</a></li></ol></li><li><a href="ch08-00-fundamental-collections.html"><strong aria-hidden="true">8.</strong> Fundamental Collections</a></li><li><ol class="section"><li><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> 🇧🇷 Vetores</a></li><li><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> 🇧🇷 Strings</a></li><li><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> 🇧🇷 Hash Maps</a></li></ol></li><li><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> 🇧🇷 Tratamento de Erros</a></li><li><ol class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> 🇧🇷 Erros Irrecuperáveis com panic!</a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> 🇧🇷 Erros recuperáveis com Result</a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> 🇧🇷 Entrar em panic! ou Não Entrar em panic!</a></li></ol></li><li><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> 🇧🇷 Tipos Genéricos, Traits, e Tempos de vida (Lifetimes)</a></li><li><ol class="section"><li><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> 🇧🇷 Tipos Genéricos de Dados</a></li><li><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> 🇧🇷 Traits: Definindo Comportamento Compartilhado</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> 🇧🇷 Validating References with Lifetimes</a></li></ol></li><li><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Writing tests</a></li><li><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Running tests</a></li><li><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project</a></li><li><ol class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Improving Error Handling and Modularity</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Testing the Library's Functionality</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing to stderr instead of stdout</a></li></ol></li><li><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features in Rust</a></li><li><ol class="section"><li><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures</a></li><li><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Iterators</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving our I/O Project</a></li><li><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performance</a></li></ol></li><li><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Release Profiles</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> 🇧🇷 Ponteiros Inteligentes (Smart Pointers)</a></li><li><ol class="section"><li><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> 🇧🇷 Box<T> Aponta para Dados no Heap e Tem Tamanho Conhecido</a></li><li><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> 🇧🇷 Tratando Ponteiros Inteligentes como Referências Normais com a Trait Deref</a></li><li><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> 🇧🇷 A Trait Drop Roda Código durante a Limpeza</a></li><li><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> 🇧🇷 Rc<T>, o Ponteiro Inteligente com Contagem de Referências</a></li><li><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> 🇧🇷 RefCell<T> e a Pattern de Mutabilidade Interior</a></li><li><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> 🇧🇷 Ciclos de Referências Podem Vazar Memória</a></li></ol></li><li><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrency</a></li><li><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> 🇧🇷 Rust é uma linguagem orientada a objetos?</a></li><li><ol class="section"><li><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> 🇧🇷 O que significa orientado a objetos?</a></li><li><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> 🇧🇷 Usando objetos trait que permitem valores de tipos diferentes</a></li><li><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> 🇧🇷 Implementando um padrão de projeto orientado a objetos</a></li></ol></li><li><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns</a></li><li><a href="ch19-00-more-lifetimes.html"><strong aria-hidden="true">19.</strong> More Lifetimes</a></li><li><a href="ch20-00-advanced-types.html"><strong aria-hidden="true">20.</strong> Advanced Type System Features</a></li><li><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> Keywords</a></li><li><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> Operators</a></li><li><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> Derivable Traits</a></li><li><a href="appendix-04-nightly-rust.html"><strong aria-hidden="true">21.4.</strong> Nightly Rust</a></li><li><a href="appendix-05-macros.html"><strong aria-hidden="true">21.5.</strong> Macros</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="submenu">
                                <li><button class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li><button class="theme" id="rust">Rust</button></li>
                                <li><button class="theme" id="coal">Coal</button></li>
                                <li><button class="theme" id="navy">Navy</button></li>
                                <li><button class="theme" id="ayu">Ayu</button></li>
                            </ul>
                        </div>

                        <h1 class="menu-title"></h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="ch07-01-mod-and-the-filesystem.html#mod-e-o-sistema-de-arquivos" id="mod-e-o-sistema-de-arquivos"><h2><code>mod</code> e o Sistema de Arquivos</h2></a>
<p>Vamos iniciar o nosso exemplo de módulo fazendo um novo projeto com o Cargo, mas em vez de
criar um crate binário, faremos um crate de biblioteca: um projeto que
as outras pessoas podem puxar para os seus projetos como uma dependência. Por exemplo, o crate <code>rand</code>
discutido no Capítulo 2, é um crate de biblioteca que usamos como uma dependência no
projeto do jogo de adivinhação.</p>
<p>Criaremos um esqueleto de uma biblioteca que fornece algumas funcionalidades gerais
de rede; nos concentraremos na organização dos módulos e funções,
mas não nos preocuparemos com o código que está dentro das funções. Chamaremos
nossa biblioteca de <code>communicator</code>. Por padrão, o Cargo criará uma biblioteca, a menos que
outro tipo de projeto seja especificado: se omitimos a opção <code>--bin</code>, que temos
usado em todos os capítulos anteriores a este, nosso projeto será um
biblioteca:</p>
<pre><code class="language-text">$ cargo new communicator
$ cd communicator
</code></pre>
<p>Observe que Cargo gerou <em>src/lib.rs</em> em vez de <em>src/main.rs</em>. Dentro de
<em>src/lib.rs</em> encontraremos o seguinte:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
#}</code></pre></pre>
<p>Cargo cria um teste de exemplo para nos ajudar a começar nossa biblioteca, em vez de
o binário “Hello, world!” que recebemos quando usamos a opção <code>--bin</code>. Olharemos
a sintaxe <code>#[]</code> e <code>mod tests</code> no “Usando <code>super</code> para Acessar um
Módulo Pai” mais adiante neste capítulo, mas por agora, deixe este código
na parte inferior de <em>src/lib.rs</em>.</p>
<p>Como não temos um arquivo <em>src/main.rs</em>, não há nada para ser executado pelo Cargo
com o comando <code>cargo run</code>. Portanto, usaremos o comando  <code>cargo build</code>
para compilar o código da nossa biblioteca.</p>
<p>Examinaremos diferentes opções para organizar o código da sua biblioteca que serão
adequados em uma variedade de situações, dependendo da intenção do código.</p>
<a class="header" href="ch07-01-mod-and-the-filesystem.html#definições-do-módulo" id="definições-do-módulo"><h3>Definições do Módulo</h3></a>
<p>Para a nossa biblioteca de rede <code>communicator</code>, primeiro definiremos um módulo chamado
<code>network</code> que contém a definição de uma função chamada<code>connect</code>. Cada
definição de módulo em Rust começa com a palavra-chave <code>mod</code>. Adicione este código ao
início do arquivo <em>src/lib.rs</em>, acima do código de teste:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod network {
    fn connect() {
    }
}
#}</code></pre></pre>
<p>Após a palavra-chave <code>mod</code>, colocamos o nome do módulo, <code>network</code> e, em seguida, um
bloco de código entre chaves. Tudo dentro deste bloco está dentro do
namespace <code>network</code>. Neste caso, temos uma única função, <code>connect</code>. Se nós
quisermos chamar essa função do código fora do módulo <code>network</code>, nós
precisaremos especificar o módulo e usar a sintaxe do namespace <code>::</code>, assim:
<code>network::connect()</code> em vez de apenas <code>connect()</code>.</p>
<p>Também podemos ter múltiplos módulos, lado a lado, no mesmo arquivo <em>src/lib.rs</em>.
Por exemplo, para ter mais um módulo <code>client</code> que possui uma função chamada <code>connect</code>
, podemos adicioná-lo como mostrado na Listagem 7-1:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod network {
    fn connect() {
    }
}

mod client {
    fn connect() {
    }
}
#}</code></pre></pre>
<p><span class = "caption"> Listagem 7-1: O módulo <code>network</code> e o módulo <code>client</code>
definidos lado a lado em <em>src/lib.rs</em> </span></p>
<p>Agora, temos uma função <code>network::connect</code> e uma função <code>client::connect</code>.
Estas podem ter funcionalidades completamente diferentes, e os nomes das funções
não estão em conflito entre si porque estão em módulos diferentes.</p>
<p>Nesse caso, como estamos construindo uma biblioteca, o arquivo que serve como
ponto de entrada para construir nossa biblioteca é <em>src/lib.rs</em>. No entanto, em relação a
criação de módulos, não há nada de especial sobre <em>src/lib.rs</em>. Poderíamos também
criar módulos em <em>src/main.rs</em> para um crate binário da mesma forma que nós
criamos módulos em <em>src/lib.rs</em> para o crate de biblioteca. Na verdade, podemos colocar módulos
dentro de módulos, o que pode ser útil à medida que seus módulos crescem para manter juntas
funcionalidades relacionadas e separar funcionalidades não relacionadas. A
escolha de como você organiza seu código depende do que você pensa sobre a
relação entre as partes do seu código. Por exemplo, o código <code>client</code>
e a função <code>connect</code> podem ter mais sentido para os usuários de nossa biblioteca se
eles estivessem dentro do namespace <code>network</code>, como na Listagem 7-2:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod network {
    fn connect() {
    }

    mod client {
        fn connect() {
        }
    }
}
#}</code></pre></pre>
<p><span class = "caption"> Listagem 7-2: Movendo o módulo <code>client</code> para dentro do
módulo <code>network</code></span></p>
<p>No seu arquivo <em>src/lib.rs</em>, substitua as definições <code>mod network</code> e <code>mod client</code>
pelas da Listagem 7-2, que possuem o módulo <code>client</code> como um
módulo interno da <code>network</code>. Agora temos as funções <code>network::connect</code> e
<code>network::client::connect</code>: novamente, as duas funções denominadas <code>connect</code> não conflitam
uma com a outra porque elas estão em diferentes namespaces.</p>
<p>Desta forma, os módulos formam uma hierarquia. O conteúdo de <em>src/lib.rs</em> está no
nível superior mais alto, e os submódulos estão em níveis mais baixos. Aqui está
a nossa organização quando pensada de forma hierárquica na Listagem 7-1:</p>
<pre><code class="language-text">communicator
 ├── network
 └── client
</code></pre>
<p>E aqui está a hierarquia correspondente ao exemplo na Listagem 7-2:</p>
<pre><code class="language-text">communicator
 └── network
     └── client
</code></pre>
<p>Conforme a hierarquia mostrada na Listagem 7-2, <code>client</code> é um filho do módulo <code>network</code>
em vez de um irmão. Projetos mais complicados podem ter muitos módulos, é necessário
organizá-los logicamente para mantê-los sob controle. O que &quot;logicamente&quot; significa em
seu projeto fica a seu critério, e depende do que você e os usuários da sua biblioteca
pensam sobre o domínio do seu projeto. Use as técnicas mostradas
aqui para criar módulos lado a lado e módulos aninhados em qualquer estrutura que
você queira.</p>
<a class="header" href="ch07-01-mod-and-the-filesystem.html#movendo-módulos-para-outros-arquivos" id="movendo-módulos-para-outros-arquivos"><h3>Movendo Módulos para Outros Arquivos</h3></a>
<p>Os módulos formam uma estrutura hierárquica, bem parecida com outra estrutura computacional
que você conhece: sistemas de arquivos! Podemos usar o sistema de módulos do Rust juntamente com
vários arquivos para dividir projetos Rust de forma que nem tudo resida em
<em>src/lib.rs</em> ou <em>src/main.rs</em>. Para este exemplo, vamos começar com o código em
Listagem 7-3:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod client {
    fn connect() {
    }
}

mod network {
    fn connect() {
    }

    mod server {
        fn connect() {
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 7-3: Três módulos, <code>client</code>, <code>network</code>, e
<code>network::server</code>, todos definidos em <em>src/lib.rs</em></span></p>
<p>O arquivo <em>src/lib.rs</em> possui esta hierarquia de módulos:</p>
<pre><code class="language-text">communicator
 ├── client
 └── network
     └── server
</code></pre>
<p>Se esses módulos tivessem muitas funções, e elas estivessem se alongando muito,
seria difícil percorrer esse arquivo para encontrar o código com que queremos
trabalhar. Como as funções estão aninhadas dentro de um ou mais blocos <code>mod</code>,
as linhas de código dentro das funções começarão a se alongar também.
Estes seriam bons motivos para separar os módulos <code>client</code>, <code>network</code>, e <code>server</code>
de <em>src/lib.rs</em> e colocá-los em seus próprios arquivos.</p>
<p>Primeiro, substitua o código do módulo <code>client</code> por apenas a declaração do
módulo <code>client</code>, para que seu <em>src/lib.rs</em> se pareça com o código mostrado na Listagem 7-4:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">mod client;

mod network {
    fn connect() {
    }

    mod server {
        fn connect() {
        }
    }
}
</code></pre>
<p><span class="caption"> Listagem 7-4: Extraindo o conteúdo do módulo <code>client</code>, mas deixando a declaração em <em>src/lib.rs</em> </span></p>
<p>Ainda estamos <em>declarando</em> o módulo <code>client</code> aqui, mas ao substituir o bloco
por um ponto e vírgula, estamos dizendo ao Rust para que procure, em outro local, o código
definido no escopo do módulo <code>client</code>. Em outras palavras, a linha <code>mod client;</code> significa:</p>
<pre><code class="language-rust ignore">mod client {
    // conteúdo de client.rs
}
</code></pre>
<p>Agora precisamos criar o arquivo externo com o nome do módulo. Crie um
arquivo <em>client.rs</em> em <em>src/</em> e abra-o. Em seguida digite o seguinte,
que é a função <code>connect</code> do módulo <code>client</code> que foi
removida na etapa anterior:</p>
<p><span class="filename">Arquivo: src/client.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn connect() {
}
#}</code></pre></pre>
<p>Observe que não precisamos de uma declaração <code>mod</code> neste arquivo porque já fizemos
a declaração do módulo <code>client</code> com <code>mod</code> em <em>src/lib.rs</em>. Este arquivo apenas
fornece o <em>conteúdo</em> do módulo <code>client</code>. Se colocarmos um <code>mod client</code> aqui,
nós estaríamos dando ao módulo <code>client</code> seu próprio submódulo chamado <code>client</code>!</p>
<p>Rust só sabe olhar em <em>src/lib.rs</em> por padrão. Se quisermos adicionar mais
arquivos para o nosso projeto, precisamos dizer ao Rust em <em>src/lib.rs</em> para procurar em outros
arquivos; é por isso que <code>mod client</code> precisa ser definido em <em>src/lib.rs</em> e não pode
ser definido em <em>src/client.rs</em>.</p>
<p>Agora, o projeto deve compilar com sucesso, embora você obtenha alguns
warnings (avisos). Lembre-se de usar <code>cargo build</code>, em vez de <code>cargo run</code>, porque temos
um crate de biblioteca em vez de um crate binário:</p>
<pre><code class="language-text">$ cargo build
   Compiling communicator v0.1.0 (file:///projects/communicator)
warning: function is never used: `connect`
 --&gt; src/client.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
  |
  = note: #[warn(dead_code)] on by default

warning: function is never used: `connect`
 --&gt; src/lib.rs:4:5
  |
4 | /     fn connect() {
5 | |     }
  | |_____^

warning: function is never used: `connect`
 --&gt; src/lib.rs:8:9
  |
8 | /         fn connect() {
9 | |         }
  | |_________^
</code></pre>
<p>Esses <em>warnings</em> nos dizem que temos funções que nunca são usadas. Não se preocupe
com esses <em>warnings</em> por enquanto; vamos abordá-los mais adiante neste capítulo, na
seção “Controlando a visibilidade com <code>pub</code>”. A boa notícia é que eles são apenas
<em>warnings</em>; nosso projeto foi construído com sucesso!</p>
<p>Em seguida, vamos extrair o módulo <code>network</code> em seu próprio arquivo usando o mesmo
procedimento. Em <em>src/lib.rs</em>, exclua o corpo do módulo <code>network</code> e adicione um
ponto e vírgula à declaração, assim:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">mod client;

mod network;
</code></pre>
<p>Em seguida, crie um novo arquivo <em>src/network.rs</em> e digite o seguinte:</p>
<p><span class="filename">Arquivo: src/network.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn connect() {
}

mod server {
    fn connect() {
    }
}
#}</code></pre></pre>
<p>Observe que ainda temos uma declaração <code>mod</code> dentro deste arquivo de módulo; isto é
porque ainda queremos que <code>server</code> seja um submódulo de <code>network</code>.</p>
<p>Execute <code>cargo build</code> novamente. Sucesso! Temos mais um módulo para extrair: <code>server</code>.
Como ele é um submódulo - ou seja, um módulo dentro de outro - nossa tática atual de
extrair um módulo para um arquivo com o nome do módulo não funcionará. Iremos
tentar, de qualquer maneira, para que você possa ver o erro. Primeiro, altere o arquivo <em>src/network.rs</em> colocando
<code>mod server;</code> no lugar do conteúdo do módulo <code>server</code>:</p>
<p><span class="filename">Arquivo: src/network.rs</span></p>
<pre><code class="language-rust ignore">fn connect() {
}

mod server;
</code></pre>
<p>Em seguida, crie um arquivo <em>src/server.rs</em> e insira o conteúdo do módulo <code>server</code>
que extraímos:</p>
<p><span class="filename">Arquivo: src/server.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn connect() {
}
#}</code></pre></pre>
<p>Quando tentamos <code>cargo build</code>, obteremos o erro mostrado na Listagem 7-5:</p>
<pre><code class="language-text">$ cargo build
   Compiling communicator v0.1.0 (file:///projects/communicator)
error: cannot declare a new module at this location
 --&gt; src/network.rs:4:5
  |
4 | mod server;
  |     ^^^^^^
  |
note: maybe move this module `src/network.rs` to its own directory via `src/network/mod.rs`
 --&gt; src/network.rs:4:5
  |
4 | mod server;
  |     ^^^^^^
note: ... or maybe `use` the module `server` instead of possibly redeclaring it
 --&gt; src/network.rs:4:5
  |
4 | mod server;
  |     ^^^^^^
</code></pre>
<p><span class="caption">Listagem 7-5: Erro ao tentar extrair o submódulo <code>server</code>
em <em>src/server.rs</em> </span></p>
<p>O erro diz que não podemos declarar um novo módulo neste local (<code>cannot declare a new module at this location</code>)
e está apontando para a linha <code>mod server</code>; em <em>src/network.rs</em>. Então <em>src/network.rs</em> é
diferente de <em>src/lib.rs</em> de alguma forma: continue lendo para entender o porquê.</p>
<p>A nota no meio da Listagem 7-5 é realmente muito útil,
porque ela aponta para algo de que não falamos ainda:</p>
<pre><code class="language-text">note: maybe move this module `network` to its own directory via
`network/mod.rs`
</code></pre>
<p>(<strong>Tradução:</strong> talvez mover este módulo network para o seu próprio diretório via <code>network/mod.rs</code>)</p>
<p>Em vez de continuar a seguir o mesmo padrão de nomeação de arquivo usado
anteriormente, podemos fazer o que a nota sugere:</p>
<ol>
<li>Crie um novo <em>diretório</em> chamado <em>network</em>, o nome do módulo pai.</li>
<li>Mova o arquivo <em>src/network.rs</em> para o novo diretório <em>network</em> e
    renomeie para <em>src/network/mod.rs</em>.</li>
<li>Mova o arquivo de submódulo <em>src/server.rs</em> para o diretório <em>network</em>.</li>
</ol>
<p>Aqui estão os comandos para executar estas etapas:</p>
<pre><code class="language-text">$ mkdir src/network
$ mv src/network.rs src/network/mod.rs
$ mv src/server.rs src/network
</code></pre>
<p>Agora, quando tentamos executar <code>cargo build</code>, a compilação funcionará (embora ainda teremos
avisos). O layout dos nossos módulos ainda é exatamente o
mesmo de quando tínhamos todo o código em <em>src/lib.rs</em> na Listagem 7-3:</p>
<pre><code class="language-text">communicator
 ├── client
 └── network
     └── server
</code></pre>
<p>O layout dos arquivos correspondentes agora ficou assim:</p>
<pre><code class="language-text">├── src
│   ├── client.rs
│   ├── lib.rs
│   └── network
│       ├── mod.rs
│       └── server.rs
</code></pre>
<p>Quando queríamos extrair o módulo <code>network::server</code>, por que precisávamos
também mudar o arquivo <em>src/network.rs</em> para o arquivo <em>src/network/mod.rs</em> e colocar
o código de <code>network::server</code> no diretório <em>network</em> em
<em>src/network/server.rs</em> em vez de apenas extrair o
módulo <code>network::server</code> em <em>src/server.rs</em>? O motivo é que Rust não
será capaz de reconhecer que <code>server</code> deveria ser um submódulo de <code>network</code>
se o arquivo <em>server.rs</em> estiver no diretório <em>src</em>. Para esclarecer o comportamento de Rust
aqui, consideremos um exemplo diferente com a seguinte hierarquia de módulos,
onde todas as definições estão em <em>src/lib.rs</em>:</p>
<pre><code class="language-text">communicator
 ├── client
 └── network
     └── client
</code></pre>
<p>Neste exemplo, temos novamente três módulos : <code>client</code>,<code>network</code>, e
<code>network::client</code>. Seguindo os mesmos passos anteriores para extrair
módulos em arquivos, poderíamos criar <em>src/client.rs</em> para o módulo <code>client</code>.
Para o módulo <code>network</code>, poderíamos criar <em>src/network.rs</em>. Mas não seríamos
capazes de extrair o módulo <code>network::client</code> para um arquivo <em>src/client.rs</em>
porque ele já existe para o módulo <code>client</code> de nível superior! Se pudéssemos colocar
o código para <em>ambos</em> os módulos <code>client</code> e<code>network::client</code> no arquivo
<em>src/client.rs</em>, Rust não teria nenhuma maneira de saber se o código era
para <code>client</code> ou para <code>network::client</code>.</p>
<p>Portanto, para extrair um arquivo para o submódulo <code>network::client</code> do
módulo <code>network</code>, precisamos criar um diretório para o módulo <code>network</code>
em vez de um arquivo <em>src/network.rs</em>. O código que está no módulo <code>network</code>
entra no arquivo <em>src/network/mod.rs</em>, e o submódulo
<code>network::client</code> pode ter seu próprio arquivo <em>src/network/client.rs</em>. Agora o
o nível superior <em>src/client.rs</em> é inequivocamente o código que pertence ao
módulo <code>client</code>.</p>
<a class="header" href="ch07-01-mod-and-the-filesystem.html#regras-dos-módulos-e-seus-arquivos" id="regras-dos-módulos-e-seus-arquivos"><h3>Regras dos Módulos e Seus Arquivos</h3></a>
<p>Vamos resumir as regras dos módulos em relação aos arquivos:</p>
<ul>
<li>Se um módulo chamado <code>foo</code> não possui submódulos, você deve colocar as declarações
   para <code>foo</code> em um arquivo chamado <em>foo.rs</em>.</li>
<li>Se um módulo chamado <code>foo</code> possui submódulos, você deve colocar as declarações
   para <code>foo</code> em um arquivo chamado <em>foo/mod.rs</em>.</li>
</ul>
<p>Essas regras se aplicam de forma recursiva, então, se um módulo chamado <code>foo</code> tiver um submódulo chamado
<code>bar</code> e<code>bar</code> não possui submódulos, você deve ter os seguintes arquivos
no seu diretório <em>src</em>:</p>
<pre><code class="language-text">├── foo
│   ├── bar.rs (contém as declarações em `foo::bar`)
│   └── mod.rs (contém as declarações em `foo`, incluindo `mod bar`)
</code></pre>
<p>Os módulos devem ser declarados no arquivo do módulo pai usando a palavra-chave <code>mod</code>.</p>
<p>Em seguida, vamos falar sobre a palavra-chave <code>pub</code> e nos livrar dessas warnings!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch07-00-modules.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch07-02-controlling-visibility-with-pub.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="ch07-00-modules.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="ch07-02-controlling-visibility-with-pub.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if (getComputedStyle(document.querySelector(".fa")).fontFamily !== "FontAwesome") {
                var link = document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = '_FontAwesome/css/font-awesome.css';
                document.head.insertBefore(link, document.head.firstChild)
            }
        </script>

        

        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
