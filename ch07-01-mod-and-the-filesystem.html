<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>ğŸ‡§ğŸ‡· mod e o Sistema de Arquivos - </title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme;
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            document.querySelector('html').classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="ch01-00-introduction.html"><strong aria-hidden="true">1.</strong> ğŸ‡§ğŸ‡· IntroduÃ§Ã£o</a></li><li><ol class="section"><li><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> ğŸ‡§ğŸ‡· InstalaÃ§Ã£o</a></li><li><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> ğŸ‡§ğŸ‡· OlÃ¡, Mundo!</a></li></ol></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> ğŸ‡§ğŸ‡· Jogo de AdivinhaÃ§Ã£o</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> ğŸ‡§ğŸ‡· Conceitos Comuns de ProgramaÃ§Ã£o</a></li><li><ol class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> ğŸ‡§ğŸ‡· VariÃ¡veis e Mutabilidade</a></li><li><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> ğŸ‡§ğŸ‡· Tipos de dados</a></li><li><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> ğŸ‡§ğŸ‡· FunÃ§Ãµes</a></li><li><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> ğŸ‡§ğŸ‡· ComentÃ¡rios</a></li><li><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> ğŸ‡§ğŸ‡· Controle de fluxo</a></li></ol></li><li><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> ğŸ‡§ğŸ‡· Entendendo Ownership</a></li><li><ol class="section"><li><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> ğŸ‡§ğŸ‡· O Que Ã‰ Ownership?</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> ğŸ‡§ğŸ‡· ReferÃªncias e Borrowing</a></li><li><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> ğŸ‡§ğŸ‡· Slices</a></li></ol></li><li><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> ğŸ‡§ğŸ‡· Structs</a></li><li><ol class="section"><li><a href="ch05-01-method-syntax.html"><strong aria-hidden="true">5.1.</strong> Method Syntax</a></li></ol></li><li><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> ğŸ‡§ğŸ‡· Enums e Casamento de PadrÃµes</a></li><li><ol class="section"><li><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> ğŸ‡§ğŸ‡· Definindo uma Enum</a></li><li><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> ğŸ‡§ğŸ‡· Operador match</a></li><li><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> ğŸ‡§ğŸ‡· Controle de Fluxo Conciso com if let</a></li></ol></li><li><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> ğŸ‡§ğŸ‡· MÃ³dulos</a></li><li><ol class="section"><li><a href="ch07-01-mod-and-the-filesystem.html" class="active"><strong aria-hidden="true">7.1.</strong> ğŸ‡§ğŸ‡· mod e o Sistema de Arquivos</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> ğŸ‡§ğŸ‡· Controlando a Visibilidade com pub</a></li><li><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> ğŸ‡§ğŸ‡· Importando nomes com use</a></li></ol></li><li><a href="ch08-00-fundamental-collections.html"><strong aria-hidden="true">8.</strong> Fundamental Collections</a></li><li><ol class="section"><li><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> ğŸ‡§ğŸ‡· Vetores</a></li><li><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> ğŸ‡§ğŸ‡· Strings</a></li><li><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> ğŸ‡§ğŸ‡· Hash Maps</a></li></ol></li><li><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> ğŸ‡§ğŸ‡· Tratamento de Erros</a></li><li><ol class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> ğŸ‡§ğŸ‡· Erros IrrecuperÃ¡veis com panic!</a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> ğŸ‡§ğŸ‡· Erros recuperÃ¡veis com Result</a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> ğŸ‡§ğŸ‡· Entrar em panic! ou NÃ£o Entrar em panic!</a></li></ol></li><li><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> ğŸ‡§ğŸ‡· Tipos GenÃ©ricos, Traits, e Tempos de vida (Lifetimes)</a></li><li><ol class="section"><li><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> ğŸ‡§ğŸ‡· Tipos GenÃ©ricos de Dados</a></li><li><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> ğŸ‡§ğŸ‡· Traits: Definindo Comportamento Compartilhado</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> ğŸ‡§ğŸ‡· Validating References with Lifetimes</a></li></ol></li><li><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Writing tests</a></li><li><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Running tests</a></li><li><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project</a></li><li><ol class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Improving Error Handling and Modularity</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Testing the Library's Functionality</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing to stderr instead of stdout</a></li></ol></li><li><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features in Rust</a></li><li><ol class="section"><li><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures</a></li><li><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Iterators</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving our I/O Project</a></li><li><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performance</a></li></ol></li><li><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Release Profiles</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> ğŸ‡§ğŸ‡· Ponteiros Inteligentes (Smart Pointers)</a></li><li><ol class="section"><li><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> ğŸ‡§ğŸ‡· Box<T> Aponta para Dados no Heap e Tem Tamanho Conhecido</a></li><li><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> ğŸ‡§ğŸ‡· Tratando Ponteiros Inteligentes como ReferÃªncias Normais com a Trait Deref</a></li><li><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> ğŸ‡§ğŸ‡· A Trait Drop Roda CÃ³digo durante a Limpeza</a></li><li><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> ğŸ‡§ğŸ‡· Rc<T>, o Ponteiro Inteligente com Contagem de ReferÃªncias</a></li><li><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> ğŸ‡§ğŸ‡· RefCell<T> e a Pattern de Mutabilidade Interior</a></li><li><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> ğŸ‡§ğŸ‡· Ciclos de ReferÃªncias Podem Vazar MemÃ³ria</a></li></ol></li><li><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrency</a></li><li><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> ğŸ‡§ğŸ‡· Rust Ã© uma linguagem orientada a objetos?</a></li><li><ol class="section"><li><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> ğŸ‡§ğŸ‡· O que significa orientado a objetos?</a></li><li><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> ğŸ‡§ğŸ‡· Usando objetos trait que permitem valores de tipos diferentes</a></li><li><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> ğŸ‡§ğŸ‡· Implementando um padrÃ£o de projeto orientado a objetos</a></li></ol></li><li><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns</a></li><li><a href="ch19-00-more-lifetimes.html"><strong aria-hidden="true">19.</strong> More Lifetimes</a></li><li><a href="ch20-00-advanced-types.html"><strong aria-hidden="true">20.</strong> Advanced Type System Features</a></li><li><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> Keywords</a></li><li><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> Operators</a></li><li><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> Derivable Traits</a></li><li><a href="appendix-04-nightly-rust.html"><strong aria-hidden="true">21.4.</strong> Nightly Rust</a></li><li><a href="appendix-05-macros.html"><strong aria-hidden="true">21.5.</strong> Macros</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="submenu">
                                <li><button class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li><button class="theme" id="rust">Rust</button></li>
                                <li><button class="theme" id="coal">Coal</button></li>
                                <li><button class="theme" id="navy">Navy</button></li>
                                <li><button class="theme" id="ayu">Ayu</button></li>
                            </ul>
                        </div>

                        <h1 class="menu-title"></h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="ch07-01-mod-and-the-filesystem.html#mod-e-o-sistema-de-arquivos" id="mod-e-o-sistema-de-arquivos"><h2><code>mod</code> e o Sistema de Arquivos</h2></a>
<p>Vamos iniciar o nosso exemplo de mÃ³dulo fazendo um novo projeto com o Cargo, mas em vez de
criar um crate binÃ¡rio, faremos um crate de biblioteca: um projeto que
as outras pessoas podem puxar para os seus projetos como uma dependÃªncia. Por exemplo, o crate <code>rand</code>
discutido no CapÃ­tulo 2, Ã© um crate de biblioteca que usamos como uma dependÃªncia no
projeto do jogo de adivinhaÃ§Ã£o.</p>
<p>Criaremos um esqueleto de uma biblioteca que fornece algumas funcionalidades gerais
de rede; nos concentraremos na organizaÃ§Ã£o dos mÃ³dulos e funÃ§Ãµes,
mas nÃ£o nos preocuparemos com o cÃ³digo que estÃ¡ dentro das funÃ§Ãµes. Chamaremos
nossa biblioteca de <code>communicator</code>. Por padrÃ£o, o Cargo criarÃ¡ uma biblioteca, a menos que
outro tipo de projeto seja especificado: se omitimos a opÃ§Ã£o <code>--bin</code>, que temos
usado em todos os capÃ­tulos anteriores a este, nosso projeto serÃ¡ um
biblioteca:</p>
<pre><code class="language-text">$ cargo new communicator
$ cd communicator
</code></pre>
<p>Observe que Cargo gerou <em>src/lib.rs</em> em vez de <em>src/main.rs</em>. Dentro de
<em>src/lib.rs</em> encontraremos o seguinte:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
#}</code></pre></pre>
<p>Cargo cria um teste de exemplo para nos ajudar a comeÃ§ar nossa biblioteca, em vez de
o binÃ¡rio â€œHello, world!â€ que recebemos quando usamos a opÃ§Ã£o <code>--bin</code>. Olharemos
a sintaxe <code>#[]</code> e <code>mod tests</code> no â€œUsando <code>super</code> para Acessar um
MÃ³dulo Paiâ€ mais adiante neste capÃ­tulo, mas por agora, deixe este cÃ³digo
na parte inferior de <em>src/lib.rs</em>.</p>
<p>Como nÃ£o temos um arquivo <em>src/main.rs</em>, nÃ£o hÃ¡ nada para ser executado pelo Cargo
com o comando <code>cargo run</code>. Portanto, usaremos o comando  <code>cargo build</code>
para compilar o cÃ³digo da nossa biblioteca.</p>
<p>Examinaremos diferentes opÃ§Ãµes para organizar o cÃ³digo da sua biblioteca que serÃ£o
adequados em uma variedade de situaÃ§Ãµes, dependendo da intenÃ§Ã£o do cÃ³digo.</p>
<a class="header" href="ch07-01-mod-and-the-filesystem.html#definiÃ§Ãµes-do-mÃ³dulo" id="definiÃ§Ãµes-do-mÃ³dulo"><h3>DefiniÃ§Ãµes do MÃ³dulo</h3></a>
<p>Para a nossa biblioteca de rede <code>communicator</code>, primeiro definiremos um mÃ³dulo chamado
<code>network</code> que contÃ©m a definiÃ§Ã£o de uma funÃ§Ã£o chamada<code>connect</code>. Cada
definiÃ§Ã£o de mÃ³dulo em Rust comeÃ§a com a palavra-chave <code>mod</code>. Adicione este cÃ³digo ao
inÃ­cio do arquivo <em>src/lib.rs</em>, acima do cÃ³digo de teste:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod network {
    fn connect() {
    }
}
#}</code></pre></pre>
<p>ApÃ³s a palavra-chave <code>mod</code>, colocamos o nome do mÃ³dulo, <code>network</code> e, em seguida, um
bloco de cÃ³digo entre chaves. Tudo dentro deste bloco estÃ¡ dentro do
namespace <code>network</code>. Neste caso, temos uma Ãºnica funÃ§Ã£o, <code>connect</code>. Se nÃ³s
quisermos chamar essa funÃ§Ã£o do cÃ³digo fora do mÃ³dulo <code>network</code>, nÃ³s
precisaremos especificar o mÃ³dulo e usar a sintaxe do namespace <code>::</code>, assim:
<code>network::connect()</code> em vez de apenas <code>connect()</code>.</p>
<p>TambÃ©m podemos ter mÃºltiplos mÃ³dulos, lado a lado, no mesmo arquivo <em>src/lib.rs</em>.
Por exemplo, para ter mais um mÃ³dulo <code>client</code> que possui uma funÃ§Ã£o chamada <code>connect</code>
, podemos adicionÃ¡-lo como mostrado na Listagem 7-1:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod network {
    fn connect() {
    }
}

mod client {
    fn connect() {
    }
}
#}</code></pre></pre>
<p><span class = "caption"> Listagem 7-1: O mÃ³dulo <code>network</code> e o mÃ³dulo <code>client</code>
definidos lado a lado em <em>src/lib.rs</em> </span></p>
<p>Agora, temos uma funÃ§Ã£o <code>network::connect</code> e uma funÃ§Ã£o <code>client::connect</code>.
Estas podem ter funcionalidades completamente diferentes, e os nomes das funÃ§Ãµes
nÃ£o estÃ£o em conflito entre si porque estÃ£o em mÃ³dulos diferentes.</p>
<p>Nesse caso, como estamos construindo uma biblioteca, o arquivo que serve como
ponto de entrada para construir nossa biblioteca Ã© <em>src/lib.rs</em>. No entanto, em relaÃ§Ã£o a
criaÃ§Ã£o de mÃ³dulos, nÃ£o hÃ¡ nada de especial sobre <em>src/lib.rs</em>. PoderÃ­amos tambÃ©m
criar mÃ³dulos em <em>src/main.rs</em> para um crate binÃ¡rio da mesma forma que nÃ³s
criamos mÃ³dulos em <em>src/lib.rs</em> para o crate de biblioteca. Na verdade, podemos colocar mÃ³dulos
dentro de mÃ³dulos, o que pode ser Ãºtil Ã  medida que seus mÃ³dulos crescem para manter juntas
funcionalidades relacionadas e separar funcionalidades nÃ£o relacionadas. A
escolha de como vocÃª organiza seu cÃ³digo depende do que vocÃª pensa sobre a
relaÃ§Ã£o entre as partes do seu cÃ³digo. Por exemplo, o cÃ³digo <code>client</code>
e a funÃ§Ã£o <code>connect</code> podem ter mais sentido para os usuÃ¡rios de nossa biblioteca se
eles estivessem dentro do namespace <code>network</code>, como na Listagem 7-2:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod network {
    fn connect() {
    }

    mod client {
        fn connect() {
        }
    }
}
#}</code></pre></pre>
<p><span class = "caption"> Listagem 7-2: Movendo o mÃ³dulo <code>client</code> para dentro do
mÃ³dulo <code>network</code></span></p>
<p>No seu arquivo <em>src/lib.rs</em>, substitua as definiÃ§Ãµes <code>mod network</code> e <code>mod client</code>
pelas da Listagem 7-2, que possuem o mÃ³dulo <code>client</code> como um
mÃ³dulo interno da <code>network</code>. Agora temos as funÃ§Ãµes <code>network::connect</code> e
<code>network::client::connect</code>: novamente, as duas funÃ§Ãµes denominadas <code>connect</code> nÃ£o conflitam
uma com a outra porque elas estÃ£o em diferentes namespaces.</p>
<p>Desta forma, os mÃ³dulos formam uma hierarquia. O conteÃºdo de <em>src/lib.rs</em> estÃ¡ no
nÃ­vel superior mais alto, e os submÃ³dulos estÃ£o em nÃ­veis mais baixos. Aqui estÃ¡
a nossa organizaÃ§Ã£o quando pensada de forma hierÃ¡rquica na Listagem 7-1:</p>
<pre><code class="language-text">communicator
 â”œâ”€â”€ network
 â””â”€â”€ client
</code></pre>
<p>E aqui estÃ¡ a hierarquia correspondente ao exemplo na Listagem 7-2:</p>
<pre><code class="language-text">communicator
 â””â”€â”€ network
     â””â”€â”€ client
</code></pre>
<p>Conforme a hierarquia mostrada na Listagem 7-2, <code>client</code> Ã© um filho do mÃ³dulo <code>network</code>
em vez de um irmÃ£o. Projetos mais complicados podem ter muitos mÃ³dulos, Ã© necessÃ¡rio
organizÃ¡-los logicamente para mantÃª-los sob controle. O que &quot;logicamente&quot; significa em
seu projeto fica a seu critÃ©rio, e depende do que vocÃª e os usuÃ¡rios da sua biblioteca
pensam sobre o domÃ­nio do seu projeto. Use as tÃ©cnicas mostradas
aqui para criar mÃ³dulos lado a lado e mÃ³dulos aninhados em qualquer estrutura que
vocÃª queira.</p>
<a class="header" href="ch07-01-mod-and-the-filesystem.html#movendo-mÃ³dulos-para-outros-arquivos" id="movendo-mÃ³dulos-para-outros-arquivos"><h3>Movendo MÃ³dulos para Outros Arquivos</h3></a>
<p>Os mÃ³dulos formam uma estrutura hierÃ¡rquica, bem parecida com outra estrutura computacional
que vocÃª conhece: sistemas de arquivos! Podemos usar o sistema de mÃ³dulos do Rust juntamente com
vÃ¡rios arquivos para dividir projetos Rust de forma que nem tudo resida em
<em>src/lib.rs</em> ou <em>src/main.rs</em>. Para este exemplo, vamos comeÃ§ar com o cÃ³digo em
Listagem 7-3:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod client {
    fn connect() {
    }
}

mod network {
    fn connect() {
    }

    mod server {
        fn connect() {
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 7-3: TrÃªs mÃ³dulos, <code>client</code>, <code>network</code>, e
<code>network::server</code>, todos definidos em <em>src/lib.rs</em></span></p>
<p>O arquivo <em>src/lib.rs</em> possui esta hierarquia de mÃ³dulos:</p>
<pre><code class="language-text">communicator
 â”œâ”€â”€ client
 â””â”€â”€ network
     â””â”€â”€ server
</code></pre>
<p>Se esses mÃ³dulos tivessem muitas funÃ§Ãµes, e elas estivessem se alongando muito,
seria difÃ­cil percorrer esse arquivo para encontrar o cÃ³digo com que queremos
trabalhar. Como as funÃ§Ãµes estÃ£o aninhadas dentro de um ou mais blocos <code>mod</code>,
as linhas de cÃ³digo dentro das funÃ§Ãµes comeÃ§arÃ£o a se alongar tambÃ©m.
Estes seriam bons motivos para separar os mÃ³dulos <code>client</code>, <code>network</code>, e <code>server</code>
de <em>src/lib.rs</em> e colocÃ¡-los em seus prÃ³prios arquivos.</p>
<p>Primeiro, substitua o cÃ³digo do mÃ³dulo <code>client</code> por apenas a declaraÃ§Ã£o do
mÃ³dulo <code>client</code>, para que seu <em>src/lib.rs</em> se pareÃ§a com o cÃ³digo mostrado na Listagem 7-4:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">mod client;

mod network {
    fn connect() {
    }

    mod server {
        fn connect() {
        }
    }
}
</code></pre>
<p><span class="caption"> Listagem 7-4: Extraindo o conteÃºdo do mÃ³dulo <code>client</code>, mas deixando a declaraÃ§Ã£o em <em>src/lib.rs</em> </span></p>
<p>Ainda estamos <em>declarando</em> o mÃ³dulo <code>client</code> aqui, mas ao substituir o bloco
por um ponto e vÃ­rgula, estamos dizendo ao Rust para que procure, em outro local, o cÃ³digo
definido no escopo do mÃ³dulo <code>client</code>. Em outras palavras, a linha <code>mod client;</code> significa:</p>
<pre><code class="language-rust ignore">mod client {
    // conteÃºdo de client.rs
}
</code></pre>
<p>Agora precisamos criar o arquivo externo com o nome do mÃ³dulo. Crie um
arquivo <em>client.rs</em> em <em>src/</em> e abra-o. Em seguida digite o seguinte,
que Ã© a funÃ§Ã£o <code>connect</code> do mÃ³dulo <code>client</code> que foi
removida na etapa anterior:</p>
<p><span class="filename">Arquivo: src/client.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn connect() {
}
#}</code></pre></pre>
<p>Observe que nÃ£o precisamos de uma declaraÃ§Ã£o <code>mod</code> neste arquivo porque jÃ¡ fizemos
a declaraÃ§Ã£o do mÃ³dulo <code>client</code> com <code>mod</code> em <em>src/lib.rs</em>. Este arquivo apenas
fornece o <em>conteÃºdo</em> do mÃ³dulo <code>client</code>. Se colocarmos um <code>mod client</code> aqui,
nÃ³s estarÃ­amos dando ao mÃ³dulo <code>client</code> seu prÃ³prio submÃ³dulo chamado <code>client</code>!</p>
<p>Rust sÃ³ sabe olhar em <em>src/lib.rs</em> por padrÃ£o. Se quisermos adicionar mais
arquivos para o nosso projeto, precisamos dizer ao Rust em <em>src/lib.rs</em> para procurar em outros
arquivos; Ã© por isso que <code>mod client</code> precisa ser definido em <em>src/lib.rs</em> e nÃ£o pode
ser definido em <em>src/client.rs</em>.</p>
<p>Agora, o projeto deve compilar com sucesso, embora vocÃª obtenha alguns
warnings (avisos). Lembre-se de usar <code>cargo build</code>, em vez de <code>cargo run</code>, porque temos
um crate de biblioteca em vez de um crate binÃ¡rio:</p>
<pre><code class="language-text">$ cargo build
   Compiling communicator v0.1.0 (file:///projects/communicator)
warning: function is never used: `connect`
 --&gt; src/client.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
  |
  = note: #[warn(dead_code)] on by default

warning: function is never used: `connect`
 --&gt; src/lib.rs:4:5
  |
4 | /     fn connect() {
5 | |     }
  | |_____^

warning: function is never used: `connect`
 --&gt; src/lib.rs:8:9
  |
8 | /         fn connect() {
9 | |         }
  | |_________^
</code></pre>
<p>Esses <em>warnings</em> nos dizem que temos funÃ§Ãµes que nunca sÃ£o usadas. NÃ£o se preocupe
com esses <em>warnings</em> por enquanto; vamos abordÃ¡-los mais adiante neste capÃ­tulo, na
seÃ§Ã£o â€œControlando a visibilidade com <code>pub</code>â€. A boa notÃ­cia Ã© que eles sÃ£o apenas
<em>warnings</em>; nosso projeto foi construÃ­do com sucesso!</p>
<p>Em seguida, vamos extrair o mÃ³dulo <code>network</code> em seu prÃ³prio arquivo usando o mesmo
procedimento. Em <em>src/lib.rs</em>, exclua o corpo do mÃ³dulo <code>network</code> e adicione um
ponto e vÃ­rgula Ã  declaraÃ§Ã£o, assim:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">mod client;

mod network;
</code></pre>
<p>Em seguida, crie um novo arquivo <em>src/network.rs</em> e digite o seguinte:</p>
<p><span class="filename">Arquivo: src/network.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn connect() {
}

mod server {
    fn connect() {
    }
}
#}</code></pre></pre>
<p>Observe que ainda temos uma declaraÃ§Ã£o <code>mod</code> dentro deste arquivo de mÃ³dulo; isto Ã©
porque ainda queremos que <code>server</code> seja um submÃ³dulo de <code>network</code>.</p>
<p>Execute <code>cargo build</code> novamente. Sucesso! Temos mais um mÃ³dulo para extrair: <code>server</code>.
Como ele Ã© um submÃ³dulo - ou seja, um mÃ³dulo dentro de outro - nossa tÃ¡tica atual de
extrair um mÃ³dulo para um arquivo com o nome do mÃ³dulo nÃ£o funcionarÃ¡. Iremos
tentar, de qualquer maneira, para que vocÃª possa ver o erro. Primeiro, altere o arquivo <em>src/network.rs</em> colocando
<code>mod server;</code> no lugar do conteÃºdo do mÃ³dulo <code>server</code>:</p>
<p><span class="filename">Arquivo: src/network.rs</span></p>
<pre><code class="language-rust ignore">fn connect() {
}

mod server;
</code></pre>
<p>Em seguida, crie um arquivo <em>src/server.rs</em> e insira o conteÃºdo do mÃ³dulo <code>server</code>
que extraÃ­mos:</p>
<p><span class="filename">Arquivo: src/server.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn connect() {
}
#}</code></pre></pre>
<p>Quando tentamos <code>cargo build</code>, obteremos o erro mostrado na Listagem 7-5:</p>
<pre><code class="language-text">$ cargo build
   Compiling communicator v0.1.0 (file:///projects/communicator)
error: cannot declare a new module at this location
 --&gt; src/network.rs:4:5
  |
4 | mod server;
  |     ^^^^^^
  |
note: maybe move this module `src/network.rs` to its own directory via `src/network/mod.rs`
 --&gt; src/network.rs:4:5
  |
4 | mod server;
  |     ^^^^^^
note: ... or maybe `use` the module `server` instead of possibly redeclaring it
 --&gt; src/network.rs:4:5
  |
4 | mod server;
  |     ^^^^^^
</code></pre>
<p><span class="caption">Listagem 7-5: Erro ao tentar extrair o submÃ³dulo <code>server</code>
em <em>src/server.rs</em> </span></p>
<p>O erro diz que nÃ£o podemos declarar um novo mÃ³dulo neste local (<code>cannot declare a new module at this location</code>)
e estÃ¡ apontando para a linha <code>mod server</code>; em <em>src/network.rs</em>. EntÃ£o <em>src/network.rs</em> Ã©
diferente de <em>src/lib.rs</em> de alguma forma: continue lendo para entender o porquÃª.</p>
<p>A nota no meio da Listagem 7-5 Ã© realmente muito Ãºtil,
porque ela aponta para algo de que nÃ£o falamos ainda:</p>
<pre><code class="language-text">note: maybe move this module `network` to its own directory via
`network/mod.rs`
</code></pre>
<p>(<strong>TraduÃ§Ã£o:</strong> talvez mover este mÃ³dulo network para o seu prÃ³prio diretÃ³rio via <code>network/mod.rs</code>)</p>
<p>Em vez de continuar a seguir o mesmo padrÃ£o de nomeaÃ§Ã£o de arquivo usado
anteriormente, podemos fazer o que a nota sugere:</p>
<ol>
<li>Crie um novo <em>diretÃ³rio</em> chamado <em>network</em>, o nome do mÃ³dulo pai.</li>
<li>Mova o arquivo <em>src/network.rs</em> para o novo diretÃ³rio <em>network</em> e
Â Â Â  renomeie para <em>src/network/mod.rs</em>.</li>
<li>Mova o arquivo de submÃ³dulo <em>src/server.rs</em> para o diretÃ³rio <em>network</em>.</li>
</ol>
<p>Aqui estÃ£o os comandos para executar estas etapas:</p>
<pre><code class="language-text">$ mkdir src/network
$ mv src/network.rs src/network/mod.rs
$ mv src/server.rs src/network
</code></pre>
<p>Agora, quando tentamos executar <code>cargo build</code>, a compilaÃ§Ã£o funcionarÃ¡ (embora ainda teremos
avisos). O layout dos nossos mÃ³dulos ainda Ã© exatamente o
mesmo de quando tÃ­nhamos todo o cÃ³digo em <em>src/lib.rs</em> na Listagem 7-3:</p>
<pre><code class="language-text">communicator
 â”œâ”€â”€ client
 â””â”€â”€ network
     â””â”€â”€ server
</code></pre>
<p>O layout dos arquivos correspondentes agora ficou assim:</p>
<pre><code class="language-text">â”œâ”€â”€ src
â”‚   â”œâ”€â”€ client.rs
â”‚   â”œâ”€â”€ lib.rs
â”‚   â””â”€â”€ network
â”‚       â”œâ”€â”€ mod.rs
â”‚       â””â”€â”€ server.rs
</code></pre>
<p>Quando querÃ­amos extrair o mÃ³dulo <code>network::server</code>, por que precisÃ¡vamos
tambÃ©m mudar o arquivo <em>src/network.rs</em> para o arquivo <em>src/network/mod.rs</em> e colocar
o cÃ³digo de <code>network::server</code> no diretÃ³rio <em>network</em> em
<em>src/network/server.rs</em> em vez de apenas extrair o
mÃ³dulo <code>network::server</code> em <em>src/server.rs</em>? O motivo Ã© que Rust nÃ£o
serÃ¡ capaz de reconhecer que <code>server</code> deveria ser um submÃ³dulo de <code>network</code>
se o arquivo <em>server.rs</em> estiver no diretÃ³rio <em>src</em>. Para esclarecer o comportamento de Rust
aqui, consideremos um exemplo diferente com a seguinte hierarquia de mÃ³dulos,
onde todas as definiÃ§Ãµes estÃ£o em <em>src/lib.rs</em>:</p>
<pre><code class="language-text">communicator
 â”œâ”€â”€ client
 â””â”€â”€ network
     â””â”€â”€ client
</code></pre>
<p>Neste exemplo, temos novamente trÃªs mÃ³dulos : <code>client</code>,<code>network</code>, e
<code>network::client</code>. Seguindo os mesmos passos anteriores para extrair
mÃ³dulos em arquivos, poderÃ­amos criar <em>src/client.rs</em> para o mÃ³dulo <code>client</code>.
Para o mÃ³dulo <code>network</code>, poderÃ­amos criar <em>src/network.rs</em>. Mas nÃ£o serÃ­amos
capazes de extrair o mÃ³dulo <code>network::client</code> para um arquivo <em>src/client.rs</em>
porque ele jÃ¡ existe para o mÃ³dulo <code>client</code> de nÃ­vel superior! Se pudÃ©ssemos colocar
o cÃ³digo para <em>ambos</em> os mÃ³dulos <code>client</code> e<code>network::client</code> no arquivo
<em>src/client.rs</em>, Rust nÃ£o teria nenhuma maneira de saber se o cÃ³digo era
para <code>client</code> ou para <code>network::client</code>.</p>
<p>Portanto, para extrair um arquivo para o submÃ³dulo <code>network::client</code> do
mÃ³dulo <code>network</code>, precisamos criar um diretÃ³rio para o mÃ³dulo <code>network</code>
em vez de um arquivo <em>src/network.rs</em>. O cÃ³digo que estÃ¡ no mÃ³dulo <code>network</code>
entra no arquivo <em>src/network/mod.rs</em>, e o submÃ³dulo
<code>network::client</code> pode ter seu prÃ³prio arquivo <em>src/network/client.rs</em>. Agora o
o nÃ­vel superior <em>src/client.rs</em> Ã© inequivocamente o cÃ³digo que pertence ao
mÃ³dulo <code>client</code>.</p>
<a class="header" href="ch07-01-mod-and-the-filesystem.html#regras-dos-mÃ³dulos-e-seus-arquivos" id="regras-dos-mÃ³dulos-e-seus-arquivos"><h3>Regras dos MÃ³dulos e Seus Arquivos</h3></a>
<p>Vamos resumir as regras dos mÃ³dulos em relaÃ§Ã£o aos arquivos:</p>
<ul>
<li>Se um mÃ³dulo chamado <code>foo</code> nÃ£o possui submÃ³dulos, vocÃª deve colocar as declaraÃ§Ãµes
Â Â  para <code>foo</code> em um arquivo chamado <em>foo.rs</em>.</li>
<li>Se um mÃ³dulo chamado <code>foo</code> possui submÃ³dulos, vocÃª deve colocar as declaraÃ§Ãµes
Â Â  para <code>foo</code> em um arquivo chamado <em>foo/mod.rs</em>.</li>
</ul>
<p>Essas regras se aplicam de forma recursiva, entÃ£o, se um mÃ³dulo chamado <code>foo</code> tiver um submÃ³dulo chamado
<code>bar</code> e<code>bar</code> nÃ£o possui submÃ³dulos, vocÃª deve ter os seguintes arquivos
no seu diretÃ³rio <em>src</em>:</p>
<pre><code class="language-text">â”œâ”€â”€ foo
â”‚   â”œâ”€â”€ bar.rs (contÃ©m as declaraÃ§Ãµes em `foo::bar`)
â”‚   â””â”€â”€ mod.rs (contÃ©m as declaraÃ§Ãµes em `foo`, incluindo `mod bar`)
</code></pre>
<p>Os mÃ³dulos devem ser declarados no arquivo do mÃ³dulo pai usando a palavra-chave <code>mod</code>.</p>
<p>Em seguida, vamos falar sobre a palavra-chave <code>pub</code> e nos livrar dessas warnings!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch07-00-modules.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch07-02-controlling-visibility-with-pub.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="ch07-00-modules.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="ch07-02-controlling-visibility-with-pub.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if (getComputedStyle(document.querySelector(".fa")).fontFamily !== "FontAwesome") {
                var link = document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = '_FontAwesome/css/font-awesome.css';
                document.head.insertBefore(link, document.head.firstChild)
            }
        </script>

        

        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
