<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>ğŸ‡§ğŸ‡· Strings - </title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme;
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            document.querySelector('html').classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="ch01-00-introduction.html"><strong aria-hidden="true">1.</strong> ğŸ‡§ğŸ‡· IntroduÃ§Ã£o</a></li><li><ol class="section"><li><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> ğŸ‡§ğŸ‡· InstalaÃ§Ã£o</a></li><li><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> ğŸ‡§ğŸ‡· OlÃ¡, Mundo!</a></li></ol></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> ğŸ‡§ğŸ‡· Jogo de AdivinhaÃ§Ã£o</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> ğŸ‡§ğŸ‡· Conceitos Comuns de ProgramaÃ§Ã£o</a></li><li><ol class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> ğŸ‡§ğŸ‡· VariÃ¡veis e Mutabilidade</a></li><li><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> ğŸ‡§ğŸ‡· Tipos de dados</a></li><li><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> ğŸ‡§ğŸ‡· FunÃ§Ãµes</a></li><li><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> ğŸ‡§ğŸ‡· ComentÃ¡rios</a></li><li><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> ğŸ‡§ğŸ‡· Controle de fluxo</a></li></ol></li><li><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> ğŸ‡§ğŸ‡· Entendendo Ownership</a></li><li><ol class="section"><li><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> ğŸ‡§ğŸ‡· O Que Ã‰ Ownership?</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> ğŸ‡§ğŸ‡· ReferÃªncias e Borrowing</a></li><li><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> ğŸ‡§ğŸ‡· Slices</a></li></ol></li><li><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> ğŸ‡§ğŸ‡· Structs</a></li><li><ol class="section"><li><a href="ch05-01-method-syntax.html"><strong aria-hidden="true">5.1.</strong> Method Syntax</a></li></ol></li><li><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> ğŸ‡§ğŸ‡· Enums e Casamento de PadrÃµes</a></li><li><ol class="section"><li><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> ğŸ‡§ğŸ‡· Definindo uma Enum</a></li><li><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> ğŸ‡§ğŸ‡· Operador match</a></li><li><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> ğŸ‡§ğŸ‡· Controle de Fluxo Conciso com if let</a></li></ol></li><li><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> ğŸ‡§ğŸ‡· MÃ³dulos</a></li><li><ol class="section"><li><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> ğŸ‡§ğŸ‡· mod e o Sistema de Arquivos</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> ğŸ‡§ğŸ‡· Controlando a Visibilidade com pub</a></li><li><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> ğŸ‡§ğŸ‡· Importando nomes com use</a></li></ol></li><li><a href="ch08-00-fundamental-collections.html"><strong aria-hidden="true">8.</strong> Fundamental Collections</a></li><li><ol class="section"><li><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> ğŸ‡§ğŸ‡· Vetores</a></li><li><a href="ch08-02-strings.html" class="active"><strong aria-hidden="true">8.2.</strong> ğŸ‡§ğŸ‡· Strings</a></li><li><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> ğŸ‡§ğŸ‡· Hash Maps</a></li></ol></li><li><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> ğŸ‡§ğŸ‡· Tratamento de Erros</a></li><li><ol class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> ğŸ‡§ğŸ‡· Erros IrrecuperÃ¡veis com panic!</a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> ğŸ‡§ğŸ‡· Erros recuperÃ¡veis com Result</a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> ğŸ‡§ğŸ‡· Entrar em panic! ou NÃ£o Entrar em panic!</a></li></ol></li><li><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> ğŸ‡§ğŸ‡· Tipos GenÃ©ricos, Traits, e Tempos de vida (Lifetimes)</a></li><li><ol class="section"><li><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> ğŸ‡§ğŸ‡· Tipos GenÃ©ricos de Dados</a></li><li><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> ğŸ‡§ğŸ‡· Traits: Definindo Comportamento Compartilhado</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> ğŸ‡§ğŸ‡· Validating References with Lifetimes</a></li></ol></li><li><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Writing tests</a></li><li><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Running tests</a></li><li><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project</a></li><li><ol class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Improving Error Handling and Modularity</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Testing the Library's Functionality</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing to stderr instead of stdout</a></li></ol></li><li><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features in Rust</a></li><li><ol class="section"><li><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures</a></li><li><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Iterators</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving our I/O Project</a></li><li><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performance</a></li></ol></li><li><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Release Profiles</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> ğŸ‡§ğŸ‡· Ponteiros Inteligentes (Smart Pointers)</a></li><li><ol class="section"><li><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> ğŸ‡§ğŸ‡· Box<T> Aponta para Dados no Heap e Tem Tamanho Conhecido</a></li><li><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> ğŸ‡§ğŸ‡· Tratando Ponteiros Inteligentes como ReferÃªncias Normais com a Trait Deref</a></li><li><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> ğŸ‡§ğŸ‡· A Trait Drop Roda CÃ³digo durante a Limpeza</a></li><li><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> ğŸ‡§ğŸ‡· Rc<T>, o Ponteiro Inteligente com Contagem de ReferÃªncias</a></li><li><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> ğŸ‡§ğŸ‡· RefCell<T> e a Pattern de Mutabilidade Interior</a></li><li><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> ğŸ‡§ğŸ‡· Ciclos de ReferÃªncias Podem Vazar MemÃ³ria</a></li></ol></li><li><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrency</a></li><li><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> ğŸ‡§ğŸ‡· Rust Ã© uma linguagem orientada a objetos?</a></li><li><ol class="section"><li><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> ğŸ‡§ğŸ‡· O que significa orientado a objetos?</a></li><li><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> ğŸ‡§ğŸ‡· Usando objetos trait que permitem valores de tipos diferentes</a></li><li><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> ğŸ‡§ğŸ‡· Implementando um padrÃ£o de projeto orientado a objetos</a></li></ol></li><li><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns</a></li><li><a href="ch19-00-more-lifetimes.html"><strong aria-hidden="true">19.</strong> More Lifetimes</a></li><li><a href="ch20-00-advanced-types.html"><strong aria-hidden="true">20.</strong> Advanced Type System Features</a></li><li><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> Keywords</a></li><li><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> Operators</a></li><li><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> Derivable Traits</a></li><li><a href="appendix-04-nightly-rust.html"><strong aria-hidden="true">21.4.</strong> Nightly Rust</a></li><li><a href="appendix-05-macros.html"><strong aria-hidden="true">21.5.</strong> Macros</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="submenu">
                                <li><button class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li><button class="theme" id="rust">Rust</button></li>
                                <li><button class="theme" id="coal">Coal</button></li>
                                <li><button class="theme" id="navy">Navy</button></li>
                                <li><button class="theme" id="ayu">Ayu</button></li>
                            </ul>
                        </div>

                        <h1 class="menu-title"></h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="ch08-02-strings.html#strings" id="strings"><h2>Strings</h2></a>
<p>NÃ³s jÃ¡ conversamos sobre as strings no capÃ­tulo 4, mas vamos dar uma olhada mais
em profundidade agora. As strings sÃ£o uma Ã¡rea que os novos RustÃ¡ceos geralmente tem maior
dificuldade. Isto Ã© devido a uma combinaÃ§Ã£o de trÃªs coisas: a propensÃ£o de Rust de
certificar-se de expor possÃ­veis erros, as strings sÃ£o estruturas de dados mais complicadas
que muitos programadores lhes dÃ£o crÃ©dito, e UTF-8. Essas coisas
combina de tal forma que parecem difÃ­cil quando se vem de outras linguagens.</p>
<p>A razÃ£o pela qual as strings estÃ£o no capÃ­tulo de coleÃ§Ãµes Ã© que as strings sÃ£o
implementadas como uma coleÃ§Ã£o de bytes mais alguns mÃ©todos para fornecer informaÃ§Ãµes Ãºteis e
funcionalidade quando esses bytes sÃ£o interpretados como texto. Nesta seÃ§Ã£o, iremos
falar sobre as operaÃ§Ãµes em <code>String</code> que todo tipo de coleÃ§Ã£o tem, como
criar, atualizar e ler. TambÃ©m discutiremos as formas em que <code>String</code>
Ã© diferente das outras coleÃ§Ãµes, a saber, como a indexaÃ§Ã£o em um <code>String</code> Ã©
complicada pelas diferenÃ§as entre como as pessoas e os computadores interpretam
dados <code>String</code>.</p>
<a class="header" href="ch08-02-strings.html#o-que-Ã©-string" id="o-que-Ã©-string"><h3>O que Ã© String?</h3></a>
<p>Antes de podermos explorar esses aspectos, precisamos falar sobre o que exatamente
significa o termo <em>string</em>. Rust realmente sÃ³ tem um tipo de string no nÃºcleo
da prÃ³pria linguagem: <code>str</code>, a fatia de string, que geralmente Ã© vista na forma emprestada
, <code>&amp;str</code>. NÃ³s falamos sobre <em>fatias de strings</em> no CapÃ­tulo 4: estas sÃ£o uma
referÃªncia a alguns dados de string codificados em UTF-8 armazenados em outro lugar. Literais de strings,
por exemplo, sÃ£o armazenados na saÃ­da binÃ¡ria do programa e, portanto, sÃ£o
fatias de string.</p>
<p>O tipo chamado <code>String</code> Ã© fornecido na biblioteca padrÃ£o do Rust, em vez de
codificado no nÃºleo da linguagem, e Ã© um extensÃ­vel, mutÃ¡vel, <code>owned</code>, tipo string
codificado UTF-8. Quando RustÃ¡ceos falam sobre â€œstringsâ€ em Rust, geralmente significa
tanto os tipos <code>String</code> quanto os tipos de string<code>&amp;str</code>, normalmente ambos.
Esta seÃ§Ã£o, Ã© em grande parte sobre <code>String</code>, mas ambos esses tipos sÃ£o usados em grande parte
na biblioteca padrÃ£o da Rust. Tanto o <code>String</code> como as fatias de string sÃ£o codificadas em UTF-8.</p>
<p>A biblioteca padrÃ£o do Rust tambÃ©m inclui uma sÃ©rie de outros tipos de string, como
<code>OsString</code>,<code>OsStr</code>, <code>CString</code> e<code>CStr</code>. Bibliotecas crates podem fornecer
mais opÃ§Ãµes para armazenar dados de string. Semelhante ao nome <code>*String</code>/<code>*Str</code>,
elas geralmente fornecem uma variante owned e borrowed, assim como <code>String</code>/<code>&amp;str</code>.
Esses tipos de string podem armazenar diferentes codificaÃ§Ãµes ou ser representados na memÃ³ria de
maneira diferente, por exemplo. NÃ³s nÃ£o estaremos falando sobre esse outro tipo de string
neste capÃ­tulo; veja a documentaÃ§Ã£o da API para obter mais informaÃ§Ãµes sobre como usÃ¡-los
e quando cada um Ã© apropriado.</p>
<a class="header" href="ch08-02-strings.html#criando-uma-nova-string" id="criando-uma-nova-string"><h3>Criando uma Nova String</h3></a>
<p>Muitas das mesmas operaÃ§Ãµes disponÃ­veis com <code>Vec</code> tambÃ©m estÃ£o disponÃ­veis em <code>String</code>,
comeÃ§ando com a funÃ§Ã£o <code>new</code> para criar uma string, assim:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::new();
#}</code></pre></pre>
<p>Isso cria uma nova string vazia chamada <code>s</code> na qual podemos carregar dados.</p>
<p>Muitas vezes, teremos alguns dados iniciais que gostarÃ­amos de jÃ¡ colocar na string.
Para isso, usamos o mÃ©todo <code>to_string</code>, que estÃ¡ disponÃ­vel em qualquer tipo
que implementa a trait <code>Display</code>, como as strings literais:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let data = &quot;initial contents&quot;;

let s = data.to_string();

// o mÃ©todo tambÃ©m funciona em literais diretamente
let s = &quot;initial contents&quot;.to_string();
#}</code></pre></pre>
<p>Isso cria uma string contendo <code>initial contents</code>.</p>
<p>TambÃ©m podemos usar a funÃ§Ã£o <code>String :: from</code> para criar uma<code>String</code> de uma string
literal. Isso equivale a usar <code>to_string</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;initial contents&quot;);
#}</code></pre></pre>
<p>Como as strings sÃ£o usadas para tantas coisas, existem vÃ¡rias APIs genÃ©ricas diferentes
que podem ser usadas para strings, entÃ£o hÃ¡ muitas opÃ§Ãµes. Algumas delas
podem parecer redundantes, mas todas tÃªm seu lugar! Nesse caso, <code>String :: from</code>
e <code>.to_string</code> acabam fazendo exatamente o mesmo, entÃ£o a que vocÃª escolher Ã© uma
questÃ£o de estilo.</p>
<p>Lembre-se de que as string sÃ£o codificadas em UTF-8, para que possamos incluir qualquer dados apropriadamente codificados
neles:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let hello = &quot;Ø§Ù„Ø³Ù„Ø§Ù… Ø¹Ù„ÙŠÙƒÙ…&quot;;
let hello = &quot;DobrÃ½ den&quot;;
let hello = &quot;Hello&quot;;
let hello = &quot;×©Ö¸××œ×•Ö¹×&quot;;
let hello = &quot;à¤¨à¤®à¤¸à¥à¤¤à¥‡&quot;;
let hello = &quot;ã“ã‚“ã«ã¡ã¯&quot;;
let hello = &quot;ì•ˆë…•í•˜ì„¸ìš”&quot;;
let hello = &quot;ä½ å¥½&quot;;
let hello = &quot;OlÃ¡&quot;;
let hello = &quot;Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ&quot;;
let hello = &quot;Hola&quot;;
#}</code></pre></pre>
<a class="header" href="ch08-02-strings.html#atualizando-uma-string" id="atualizando-uma-string"><h3>Atualizando uma String</h3></a>
<p>Uma <code>String</code> pode crescer em tamanho e seu conteÃºdo pode mudar assim como o conteÃºdo
de um <code>Vec</code>, empurrando mais dados para ela. AlÃ©m disso, <code>String</code> tem
operaÃ§Ãµes de concatenaÃ§Ã£o implementadas com o operador <code>+</code> por conveniÃªncia.</p>
<a class="header" href="ch08-02-strings.html#anexando-a-uma-string-com-push" id="anexando-a-uma-string-com-push"><h4>Anexando a uma String com Push</h4></a>
<p>Podemos criar uma <code>String</code> usando o mÃ©todo <code>push_str</code> para adicionar uma  seqÃ¼Ãªncia de caracteres:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::from(&quot;foo&quot;);
s.push_str(&quot;bar&quot;);
#}</code></pre></pre>
<p><code>s</code> conterÃ¡ â€œfoobarâ€œ apÃ³s essas duas linhas. O mÃ©todo <code>push_str</code> leva um
fatia de string porque nÃ£o necessariamente queremos ownership do
parÃ¢metro. Por exemplo, seria lamentÃ¡vel se nÃ£o pudÃ©ssemos usar <code>s2</code>
depois de atualizar o seu conteÃºdo a <code>s1</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s1 = String::from(&quot;foo&quot;);
let s2 = String::from(&quot;bar&quot;);
s1.push_str(&amp;s2);
#}</code></pre></pre>
<p>O mÃ©todo <code>push</code> Ã© definido para ter um Ãºnico caractere como parÃ¢metro e adicionar
Ã  <code>String</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::from(&quot;lo&quot;);
s.push('l');
#}</code></pre></pre>
<p>ApÃ³s isso, <code>s</code> irÃ¡ conter â€œlolâ€.</p>
<a class="header" href="ch08-02-strings.html#concatenaÃ§Ã£o-com-o-operador--ou-a-macro-format" id="concatenaÃ§Ã£o-com-o-operador--ou-a-macro-format"><h4>ConcatenaÃ§Ã£o com o Operador + ou a macro <code>format!</code></h4></a>
<p>Muitas vezes, queremos combinar duas strings existentes. Uma maneira Ã© usar
o operador <code>+</code> dessa forma:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;Hello, &quot;);
let s2 = String::from(&quot;world!&quot;);
let s3 = s1 + &amp;s2; // Note que s1 foi movido aqui e nÃ£o pode ser mais usado
#}</code></pre></pre>
<p>ApÃ³s este cÃ³digo, a String <code>s3</code> conterÃ¡ <code>Hello, world!</code>. O motivo que
<code>s1</code> nÃ£o Ã© mais vÃ¡lido apÃ³s a adiÃ§Ã£o e o motivo que usamos uma
referÃªncia a <code>s2</code> tem a ver com a assinatura do mÃ©todo que Ã© chamado
quando usamos o operador <code>+</code>. O operador <code>+</code> usa o mÃ©todo <code>add</code>, cuja
assinatura parece algo assim:</p>
<pre><code class="language-rust ignore">fn add(self, s: &amp;str) -&gt; String {
</code></pre>
<p>Esta nÃ£o Ã© a assinatura exata que estÃ¡ na biblioteca padrÃ£o; lÃ¡ o <code>add</code> Ã©
definido usando genÃ©ricos. Aqui, estamos olhando a assinatura do <code>add</code> com
tipos de concreto substituÃ­dos pelos genÃ©ricos, o que acontece quando nÃ³s
chamamos esse mÃ©todo com valores <code>String</code>. Vamos discutir genÃ©ricos no
CapÃ­tulo 10. Esta assinatura nos dÃ¡ as pistas que precisamos para entender o complicado
operador <code>+</code>.</p>
<p>Antes de tudo, <code>s2</code> tem um <code>&amp;</code>, o que significa que estamos adicionando uma <em>referÃªncia</em> da
segunda string para a primeira string. Isso Ã© devido ao parÃ¢metro <code>s</code> na
funÃ§Ã£o <code>add</code>: sÃ³ podemos adicionar um <code>&amp;str</code> Ã  <code>String</code>, nÃ£o podemos adicionar dois
valores <code>String</code> juntos. Mas espere - o tipo de <code>&amp;s2</code> Ã© <code>&amp;String</code>, nÃ£o
<code>&amp;str</code>, conforme especificado no segundo parÃ¢metro para<code>add</code>. Por que nosso exemplo
compila? Podemos usar <code>&amp;s2</code> na chamada para <code>add</code> porque um <code>&amp;String</code>
o argumento pode ser <em>coerced</em> em um <code>&amp;str</code> - quando a funÃ§Ã£o<code>add</code> Ã© chamada,
Rust usa algo chamado de <em>deref coercion</em>, o que vocÃª poderia pensar aqui como
virando <code>&amp;s2</code> para<code>&amp;s2[..]</code> para uso na funÃ§Ã£o <code>add</code>. Vamos discutir deref
coercion  em maior profundidade no CapÃ­tulo 15. Como o <code>add</code> nÃ£o se apropria
o parÃ¢metro <code>s2</code> ainda serÃ¡ uma <code>String</code> vÃ¡lida apÃ³s essa operaÃ§Ã£o.</p>
<p>Em segundo lugar, podemos ver na assinatura que <code>add</code> toma posse de<code>self</code>,
porque <code>self</code> <em>nÃ£o</em> tem <code>&amp;</code>. Isso significa <code>s1</code> no exemplo acima
serÃ¡ transferido para a chamada <code>add</code> e nÃ£o serÃ¡ mais vÃ¡lido depois disso. Por enquanto
<code>let s3 = s1 + &amp;s2;</code> parece que irÃ¡ copiar ambas as strings e criar uma nova,
esta declaraÃ§Ã£o realmente adere a <code>s1</code>, acrescenta uma cÃ³pia do conteÃºdo
de <code>s2</code>, entÃ£o retorna ownership do resultado. Em outras palavras, parece
estar fazendo muitas cÃ³pias, mas nÃ£o Ã©: a implementaÃ§Ã£o Ã© mais eficiente
do que copiar.</p>
<p>Se precisarmos concatenar vÃ¡rias strings, o comportamento de <code>+</code> fica complicado:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;tic&quot;);
let s2 = String::from(&quot;tac&quot;);
let s3 = String::from(&quot;toe&quot;);

let s = s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;s3;
#}</code></pre></pre>
<p><code>s</code> serÃ¡ â€œtic-tac-toeâ€ neste momento. Com todos os <code>+</code> e <code>&quot;</code>,
fica difÃ­cil ver o que estÃ¡ acontecendo. Para strings mais complicadas
, podemos usar o macro <code>format!</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;tic&quot;);
let s2 = String::from(&quot;tac&quot;);
let s3 = String::from(&quot;toe&quot;);

let s = format!(&quot;{}-{}-{}&quot;, s1, s2, s3);
#}</code></pre></pre>
<p>Este cÃ³digo tambÃ©m definirÃ¡ <code>s</code> para â€œtic-tac-toeâ€. A macro <code>format!</code> funciona
do mesmo modo que <code>println!</code>, mas em vez de imprimir a saÃ­da para a tela, ela
retorna uma <code>String</code> com o conteÃºdo. Esta versÃ£o Ã© muito mais fÃ¡cil de ler, e
tambÃ©m nÃ£o incide ownership em nenhum dos seus parÃ¢metros.</p>
<a class="header" href="ch08-02-strings.html#indexaÃ§Ã£o-em-strings" id="indexaÃ§Ã£o-em-strings"><h3>IndexaÃ§Ã£o em Strings</h3></a>
<p>Em muitas outras linguagens, acessar caracteres individuais em uma string por
referenciando por Ã­ndice Ã© uma operaÃ§Ã£o vÃ¡lida e comum. Em Rust, no entanto, se
nÃ³s tentamos acessar partes de uma <code>String</code> usando sintaxe de indexaÃ§Ã£o, vamos ter um erro.
Ou seja, este cÃ³digo:</p>
<pre><code class="language-rust ignore">let s1 = String::from(&quot;hello&quot;);
let h = s1[0];
</code></pre>
<p>resultarÃ¡ neste erro:</p>
<pre><code class="language-text">error: the trait bound `std::string::String: std::ops::Index&lt;_&gt;` is not
satisfied [--explain E0277]
  |&gt;
  |&gt;     let h = s1[0];
  |&gt;             ^^^^^
note: the type `std::string::String` cannot be indexed by `_`
</code></pre>
<p>O erro e a nota contam a histÃ³ria: as strings em Rust nÃ£o suportam a indexaÃ§Ã£o. Assim
a prÃ³xima pergunta Ã©, por que nÃ£o? Para responder a isso, temos que conversar um
pouco sobre como o Rust armazena strings na memÃ³ria.</p>
<a class="header" href="ch08-02-strings.html#representaÃ§Ã£o-interna" id="representaÃ§Ã£o-interna"><h4>RepresentaÃ§Ã£o Interna</h4></a>
<p>Uma <code>String</code> Ã© um invÃ³lucro sobre um <code>Vec &lt;u8&gt;</code>. Vejamos alguns dos nossos
exemplos UTF-8, codificadas corretamente, de strings vistas anteriormente. Primeiro, este:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let len = String::from(&quot;Hola&quot;).len();
#}</code></pre></pre>
<p>Neste caso, <code>len</code> terÃ¡ valor de quatro, o que significa que o<code>Vec</code> armazena a string
â€Holaâ€ tem quatro bytes de comprimento: cada uma dessas letras leva um byte quando codificado em
UTF-8. E o que acontece para esse exemplo?</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let len = String::from(&quot;Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ&quot;).len();
#}</code></pre></pre>
<p>Uma pessoa que pergunte pelo comprimento da string pode dizer que ela deva ter 12.No entanto, a resposta de Rust
Ã© 24. Este Ã© o nÃºmero de bytes que Ã© necessÃ¡rio para codificar â€œĞ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµâ€œ em
UTF-8, uma vez que cada valor escalar Unicode leva dois bytes de armazenamento. Assim sendo,
um Ã­ndice nos bytes da string nem sempre se correlaciona com um  valor escalar Unicode vÃ¡lido.</p>
<p>Para demonstrar, considere este cÃ³digo invÃ¡lido do Rust:</p>
<pre><code class="language-rust ignore">let hello = &quot;Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ&quot;;
let answer = &amp;hello[0];
</code></pre>
<p>Qual deve ser o valor da <code>answer</code>? Seria <code>Ğ—</code>, a primeira letra? Quando
codificado em UTF-8, o primeiro byte de <code>Ğ—</code> Ã© <code>208</code>, e o segundo Ã© <code>151</code>, entÃ£o
a <code>answer</code> deve, na verdade, ser <code>208</code>, mas <code>208</code> nÃ£o Ã© um caractere vÃ¡lido em
si. Retornar <code>208</code> provavelmente nÃ£o Ã© o que uma pessoa gostaria se eles pedissem
a primeira letra desta string, mas esse Ã© o Ãºnico dado que Rust tem no byte
de Ã­ndice 0. O retorno do valor do byte provavelmente nÃ£o Ã© o que as pessoas querem, mesmo com
caracteres contendo acentuaÃ§Ã£o: <code>&amp;&quot;hello&quot;[0]</code> retornaria <code>104</code>, nÃ£o<code>h</code>. Para evitar o
retornando um valor inesperado e causando erros que podem nÃ£o ser descobertos
imediatamente, Rust escolhe nÃ£o compilar este cÃ³digo e previne
mal-entendidos anteriormente.</p>
<a class="header" href="ch08-02-strings.html#bytes-e-valores-escalares-e-clusters-de-grafemas-nossa" id="bytes-e-valores-escalares-e-clusters-de-grafemas-nossa"><h4>Bytes e Valores Escalares e Clusters de Grafemas! Nossa!</h4></a>
<p>Isso leva a outro ponto sobre UTF-8: existem realmente trÃªs maneiras relevantes
de olhar para as strings, da perspectiva do Rust: como bytes, valores escalares e
clusters de grafemas (a coisa mais prÃ³xima do que as pessoas chamariam <em>letras</em>).</p>
<p>Se olharmos para a palavra Hindi â€œà¤¨à¤®à¤¸à¥à¤¤à¥‡â€ escrita na escrita Devanagari, Ã©
em Ãºltima instÃ¢ncia, armazenada como um <code>Vec</code> de valores <code>u8</code> que se parece com isto:</p>
<pre><code class="language-text">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
</code></pre>
<p>Isso Ã© 18 bytes, e Ã© como os computadores de fato armazenam esses dados. Se olharmos para
eles como valores escalares Unicode, que sÃ£o o tipo <code>char</code> de Rust, aqueles
bytes se parecem com isto:</p>
<pre><code class="language-text">['à¤¨', 'à¤®', 'à¤¸', 'à¥', 'à¤¤', 'à¥‡']
</code></pre>
<p>Existem seis valores <code>char</code> aqui, mas o quarto e o sexto nÃ£o sÃ£o letras,
Eles sÃ£o diacrÃ­ticos que nÃ£o fazem sentido por conta prÃ³pria. Finalmente, se olharmos para
eles como clusters de grafemas, terÃ­amos o que uma pessoa chamaria as quatro letras
que compÃµem esta palavra:</p>
<pre><code class="language-text">[&quot;à¤¨&quot;, &quot;à¤®&quot;, &quot;à¤¸à¥&quot;, &quot;à¤¤à¥‡&quot;]
</code></pre>
<p>Rust fornece diferentes maneiras de interpretar os dados de uma string bruta que os computadores
armazenem para que cada programa possa escolher a interpretaÃ§Ã£o que necessite, nÃ£o importa
em que idioma humano os dados estÃ£o.</p>
<p>Uma razÃ£o final do Rust nÃ£o permitir que vocÃª indexe uma <code>String</code> para obter um
caracter Ã© que as operaÃ§Ãµes de indexaÃ§Ã£o sempre esperam um tempo constante
(O(1)). NÃ£o Ã© possÃ­vel garantir que o desempenho com uma <code>String</code>,
entretanto, jÃ¡ que o Rust teria que percorrer todo o conteÃºdo desde o inÃ­cio
atÃ© o Ã­ndice para determinar quantos caracteres vÃ¡lidos havia.</p>
<a class="header" href="ch08-02-strings.html#fatiando-strings" id="fatiando-strings"><h3>Fatiando Strings</h3></a>
<p>Porque nÃ£o estÃ¡ claro qual seria o tipo de retorno da indexaÃ§Ã£o de string, e
muitas vezes Ã© uma mÃ¡ idÃ©ia indexar uma string, Rust dissuade-o de fazÃª-lo
pedindo que vocÃª seja mais especÃ­fico se vocÃª realmente precisar disso. Do jeito que vocÃª pode ser
mais especÃ­fico que a indexaÃ§Ã£o usando <code>[]</code> com um Ãºnico nÃºmero Ã© usando <code>[]</code> com
um intervalo para criar uma fatia de string contendo bytes especÃ­ficos:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let hello = &quot;Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ&quot;;

let s = &amp;hello[0..4];
#}</code></pre></pre>
<p>Aqui, <code>s</code> serÃ¡ um <code>&amp;str</code> que contÃ©m os primeiros quatro bytes da string.
Mais cedo, mencionamos que cada um desses personagens era de dois bytes, de modo que
significa que <code>s</code> serÃ¡ â€œĞ—Ğ´â€.</p>
<p>O que aconteceria se fizÃ©ssemos <code>&amp;hello[0..1]</code>? A resposta: entrarÃ¡ em pÃ¢nico
em tempo de execuÃ§Ã£o, da mesma maneira que acessar um Ã­ndice invÃ¡lido em um vetor:</p>
<pre><code class="language-text">thread 'main' panicked at 'index 0 and/or 1 in `Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ` do not lie on
character boundary', ../src/libcore/str/mod.rs:1694
</code></pre>
<p>VocÃª deve usar isso com cautela, pois isso pode fazer com que seu programa falhe.</p>
<a class="header" href="ch08-02-strings.html#mÃ©todos-para-interagir-sobre-strings" id="mÃ©todos-para-interagir-sobre-strings"><h3>MÃ©todos para Interagir Sobre Strings</h3></a>
<p>Felizmente, existem outras maneiras de acessar elementos em um String.</p>
<p>Se precisarmos realizar operaÃ§Ãµes em valores escalares Unicode individuais, a melhor
maneira de fazer isso Ã© usar o mÃ©todo <code>chars</code>. Chamando <code>chars</code> em â€œà¤¨à¤®à¤¸à¥à¤¤à¥‡â€
Ã© separado e retorna seis valores do tipo <code>char</code>, e vocÃª pode interar
no resultado para acessar cada elemento:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
for c in &quot;à¤¨à¤®à¤¸à¥à¤¤à¥‡&quot;.chars() {
    println!(&quot;{}&quot;, c);
}
#}</code></pre></pre>
<p>Este cÃ³digo irÃ¡ imprimir:</p>
<pre><code class="language-text">à¤¨
à¤®
à¤¸
à¥
à¤¤
à¥‡
</code></pre>
<p>O mÃ©todo <code>bytes</code> retorna cada byte bruto, que pode ser apropriado para o seu
domÃ­nio:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
for b in &quot;à¤¨à¤®à¤¸à¥à¤¤à¥‡&quot;.bytes() {
    println!(&quot;{}&quot;, b);
}
#}</code></pre></pre>
<p>Este cÃ³digo imprimirÃ¡ os 18 bytes que compÃµem esse <code>String</code>, comeÃ§ando por:</p>
<pre><code class="language-text">224
164
168
224
// ... etc
</code></pre>
<p>Mas lembre-se de que os valores escalares Unicode vÃ¡lidos podem ser constituÃ­dos por
mais de um byte.</p>
<p>Obter clusters de grafemas de strings Ã© complexo, entÃ£o esta funcionalidade nÃ£o Ã©
fornecida pela biblioteca padrÃ£o. Existem crates disponÃ­veis em crates.io se
Esta Ã© a funcionalidade que vocÃª precisa.</p>
<a class="header" href="ch08-02-strings.html#as-strings-nÃ£o-sÃ£o-tÃ£o-simples" id="as-strings-nÃ£o-sÃ£o-tÃ£o-simples"><h3>As Strings NÃ£o sÃ£o tÃ£o Simples</h3></a>
<p>Para resumir, as strings sÃ£o complicadas. Diferentes linguagens de programaÃ§Ã£o fazem
escolhas diferentes sobre como apresentar essa complexidade ao programador. Rust
optou por fazer o tratamento correto dos dados <code>String</code> o comportamento padrÃ£o
para todos os programas Rust, o que significa que os programadores devem pensar mais
no gerenciamento de dados UTF-8 antecipadamente. Este tradeoff expÃµe mais da complexidade
de strings do que outras linguagens de programaÃ§Ã£o, mas isso irÃ¡ impedi-lo de
ter que lidar com erros envolvendo caracteres nÃ£o-ASCII mais tarde em seu
ciclo de desenvolvimento.</p>
<p>Vamos mudar para algo um pouco menos complexo: hash maps!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch08-01-vectors.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch08-03-hash-maps.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="ch08-01-vectors.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="ch08-03-hash-maps.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if (getComputedStyle(document.querySelector(".fa")).fontFamily !== "FontAwesome") {
                var link = document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = '_FontAwesome/css/font-awesome.css';
                document.head.insertBefore(link, document.head.firstChild)
            }
        </script>

        

        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
