<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>ğŸ‡§ğŸ‡· RefCell&lt;T&gt; e a Pattern de Mutabilidade Interior - </title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme;
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            document.querySelector('html').classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="ch01-00-introduction.html"><strong aria-hidden="true">1.</strong> ğŸ‡§ğŸ‡· IntroduÃ§Ã£o</a></li><li><ol class="section"><li><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> ğŸ‡§ğŸ‡· InstalaÃ§Ã£o</a></li><li><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> ğŸ‡§ğŸ‡· OlÃ¡, Mundo!</a></li></ol></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> ğŸ‡§ğŸ‡· Jogo de AdivinhaÃ§Ã£o</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> ğŸ‡§ğŸ‡· Conceitos Comuns de ProgramaÃ§Ã£o</a></li><li><ol class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> ğŸ‡§ğŸ‡· VariÃ¡veis e Mutabilidade</a></li><li><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> ğŸ‡§ğŸ‡· Tipos de dados</a></li><li><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> ğŸ‡§ğŸ‡· FunÃ§Ãµes</a></li><li><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> ğŸ‡§ğŸ‡· ComentÃ¡rios</a></li><li><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> ğŸ‡§ğŸ‡· Controle de fluxo</a></li></ol></li><li><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> ğŸ‡§ğŸ‡· Entendendo Ownership</a></li><li><ol class="section"><li><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> ğŸ‡§ğŸ‡· O Que Ã‰ Ownership?</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> ğŸ‡§ğŸ‡· ReferÃªncias e Borrowing</a></li><li><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> ğŸ‡§ğŸ‡· Slices</a></li></ol></li><li><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> ğŸ‡§ğŸ‡· Structs</a></li><li><ol class="section"><li><a href="ch05-01-method-syntax.html"><strong aria-hidden="true">5.1.</strong> Method Syntax</a></li></ol></li><li><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> ğŸ‡§ğŸ‡· Enums e Casamento de PadrÃµes</a></li><li><ol class="section"><li><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> ğŸ‡§ğŸ‡· Definindo uma Enum</a></li><li><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> ğŸ‡§ğŸ‡· Operador match</a></li><li><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> ğŸ‡§ğŸ‡· Controle de Fluxo Conciso com if let</a></li></ol></li><li><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> ğŸ‡§ğŸ‡· MÃ³dulos</a></li><li><ol class="section"><li><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> ğŸ‡§ğŸ‡· mod e o Sistema de Arquivos</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> ğŸ‡§ğŸ‡· Controlando a Visibilidade com pub</a></li><li><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> ğŸ‡§ğŸ‡· Importando nomes com use</a></li></ol></li><li><a href="ch08-00-fundamental-collections.html"><strong aria-hidden="true">8.</strong> Fundamental Collections</a></li><li><ol class="section"><li><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> ğŸ‡§ğŸ‡· Vetores</a></li><li><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> ğŸ‡§ğŸ‡· Strings</a></li><li><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> ğŸ‡§ğŸ‡· Hash Maps</a></li></ol></li><li><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> ğŸ‡§ğŸ‡· Tratamento de Erros</a></li><li><ol class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> ğŸ‡§ğŸ‡· Erros IrrecuperÃ¡veis com panic!</a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> ğŸ‡§ğŸ‡· Erros recuperÃ¡veis com Result</a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> ğŸ‡§ğŸ‡· Entrar em panic! ou NÃ£o Entrar em panic!</a></li></ol></li><li><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> ğŸ‡§ğŸ‡· Tipos GenÃ©ricos, Traits, e Tempos de vida (Lifetimes)</a></li><li><ol class="section"><li><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> ğŸ‡§ğŸ‡· Tipos GenÃ©ricos de Dados</a></li><li><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> ğŸ‡§ğŸ‡· Traits: Definindo Comportamento Compartilhado</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> ğŸ‡§ğŸ‡· Validating References with Lifetimes</a></li></ol></li><li><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Writing tests</a></li><li><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Running tests</a></li><li><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project</a></li><li><ol class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Improving Error Handling and Modularity</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Testing the Library's Functionality</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing to stderr instead of stdout</a></li></ol></li><li><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features in Rust</a></li><li><ol class="section"><li><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures</a></li><li><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Iterators</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving our I/O Project</a></li><li><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performance</a></li></ol></li><li><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Release Profiles</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> ğŸ‡§ğŸ‡· Ponteiros Inteligentes (Smart Pointers)</a></li><li><ol class="section"><li><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> ğŸ‡§ğŸ‡· Box<T> Aponta para Dados no Heap e Tem Tamanho Conhecido</a></li><li><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> ğŸ‡§ğŸ‡· Tratando Ponteiros Inteligentes como ReferÃªncias Normais com a Trait Deref</a></li><li><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> ğŸ‡§ğŸ‡· A Trait Drop Roda CÃ³digo durante a Limpeza</a></li><li><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> ğŸ‡§ğŸ‡· Rc<T>, o Ponteiro Inteligente com Contagem de ReferÃªncias</a></li><li><a href="ch15-05-interior-mutability.html" class="active"><strong aria-hidden="true">15.5.</strong> ğŸ‡§ğŸ‡· RefCell<T> e a Pattern de Mutabilidade Interior</a></li><li><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> ğŸ‡§ğŸ‡· Ciclos de ReferÃªncias Podem Vazar MemÃ³ria</a></li></ol></li><li><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrency</a></li><li><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> ğŸ‡§ğŸ‡· Rust Ã© uma linguagem orientada a objetos?</a></li><li><ol class="section"><li><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> ğŸ‡§ğŸ‡· O que significa orientado a objetos?</a></li><li><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> ğŸ‡§ğŸ‡· Usando objetos trait que permitem valores de tipos diferentes</a></li><li><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> ğŸ‡§ğŸ‡· Implementando um padrÃ£o de projeto orientado a objetos</a></li></ol></li><li><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns</a></li><li><a href="ch19-00-more-lifetimes.html"><strong aria-hidden="true">19.</strong> More Lifetimes</a></li><li><a href="ch20-00-advanced-types.html"><strong aria-hidden="true">20.</strong> Advanced Type System Features</a></li><li><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> Keywords</a></li><li><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> Operators</a></li><li><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> Derivable Traits</a></li><li><a href="appendix-04-nightly-rust.html"><strong aria-hidden="true">21.4.</strong> Nightly Rust</a></li><li><a href="appendix-05-macros.html"><strong aria-hidden="true">21.5.</strong> Macros</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="submenu">
                                <li><button class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li><button class="theme" id="rust">Rust</button></li>
                                <li><button class="theme" id="coal">Coal</button></li>
                                <li><button class="theme" id="navy">Navy</button></li>
                                <li><button class="theme" id="ayu">Ayu</button></li>
                            </ul>
                        </div>

                        <h1 class="menu-title"></h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="ch15-05-interior-mutability.html#refcellt-e-a-pattern-de-mutabilidade-interior" id="refcellt-e-a-pattern-de-mutabilidade-interior"><h2><code>RefCell&lt;T&gt;</code> e a Pattern de Mutabilidade Interior</h2></a>
<p><em>Mutabilidade interior</em> (<em>interior mutability</em>) Ã© uma design pattern em Rust que
lhe permite modificar um dado mesmo quando hÃ¡ referÃªncias imutÃ¡veis a ele:
normalmente, esta aÃ§Ã£o Ã© proibida pelas regras de emprÃ©stimo. Para fazer isso, a
pattern usa cÃ³digo <code>unsafe</code> (<em>inseguro</em>) dentro de uma estrutura de dados para
dobrar as regras normais do Rust que governam mutaÃ§Ã£o e emprÃ©stimo. NÃ³s ainda
nÃ£o cobrimos cÃ³digo unsafe; faremos isso no CapÃ­tulo 19. Podemos usar tipos que
usam a pattern de mutabilidade interior quando podemos garantir que as regras de
emprÃ©stimo serÃ£o seguidas em tempo de execuÃ§Ã£o, ainda que o compilador nÃ£o o
possa garantir. O cÃ³digo <code>unsafe</code> envolvido Ã© entÃ£o embrulhado em uma API safe,
e o tipo exterior permanece imutÃ¡vel.</p>
<p>Para explorar este conceito, vamos ver o tipo <code>RefCell&lt;T&gt;</code> que segue a pattern
de mutabilidade interior.</p>
<a class="header" href="ch15-05-interior-mutability.html#aplicando-regras-de-emprÃ©stimo-em-tempo-de-execuÃ§Ã£o-com-o-refcellt" id="aplicando-regras-de-emprÃ©stimo-em-tempo-de-execuÃ§Ã£o-com-o-refcellt"><h3>Aplicando Regras de EmprÃ©stimo em Tempo de ExecuÃ§Ã£o com o <code>RefCell&lt;T&gt;</code></h3></a>
<p>Diferente do <code>Rc&lt;T&gt;</code>, o tipo <code>RefCell&lt;T&gt;</code> representa posse Ãºnica sobre o dado
que ele contÃ©m. EntÃ£o o que torna o <code>RefCell&lt;T&gt;</code> diferente de um tipo como o
<code>Box&lt;T&gt;</code>? Lembre-se das regras de emprÃ©stimo que vocÃª aprendeu no CapÃ­tulo 4:</p>
<ul>
<li>Em qualquer momento, vocÃª pode ter <em>um dos</em> mas nÃ£o ambos os seguintes: uma
Ãºnica referÃªncia mutÃ¡vel <em>ou</em> qualquer nÃºmero de referÃªncias imutÃ¡veis;</li>
<li>ReferÃªncias devem sempre ser vÃ¡lidas.</li>
</ul>
<p>Com referÃªncias e com o <code>Box&lt;T&gt;</code>, as invariantes das regras de emprÃ©stimo sÃ£o
aplicadas em tempo de compilaÃ§Ã£o. Com o <code>RefCell&lt;T&gt;</code>, essas invariantes sÃ£o
aplicadas <em>em tempo de execuÃ§Ã£o</em>. Com referÃªncias, se vocÃª quebra essas regras,
vocÃª recebe um erro de compilaÃ§Ã£o. Com o <code>RefCell&lt;T&gt;</code>, se vocÃª quebrar essas
regras, seu programa irÃ¡ sofrer um <code>panic!</code> e terminar.</p>
<p>As vantagens de checar as regras de emprÃ©stimo em tempo de compilaÃ§Ã£o sÃ£o que
erros sÃ£o pegos mais cedo no processo de desenvolvimento, e nÃ£o hÃ¡ nenhum custo
de desempenho de execuÃ§Ã£o porque toda a anÃ¡lise Ã© completada de antemÃ£o. Por
esses motivos, checar as regras de emprÃ©stimo em tempo de compilaÃ§Ã£o Ã© a melhor
opÃ§Ã£o na maioria dos casos, e por isso este Ã© o padrÃ£o do Rust.</p>
<p>A vantagem de checar as regras de emprÃ©stimo em tempo de execuÃ§Ã£o,
alternativamente, Ã© que certos cenÃ¡rios <em>memory-safe</em> (<em>seguros em termos de
memÃ³ria</em>) sÃ£o entÃ£o permitidos, ao passo que seriam proibidos pelas checagens em
tempo de compilaÃ§Ã£o. A anÃ¡lise estÃ¡tica, como a do compilador Rust, Ã©
inerentemente conservadora. Algumas propriedades do programa sÃ£o impossÃ­veis de
detectar analisando o cÃ³digo: o exemplo mais famoso Ã© o Problema da Parada, que
estÃ¡ alÃ©m do escopo deste livro mas Ã© um tÃ³pico interessante para pesquisa.</p>
<p>Como algumas anÃ¡lises sÃ£o impossÃ­veis, se o compilador Rust nÃ£o consegue se
assegurar que o cÃ³digo obedece Ã s regras de posse, ele pode rejeitar um programa
correto; neste sentido, ele Ã© conservador. Se o Rust aceitasse um programa
incorreto, os usuÃ¡rios nÃ£o poderiam confiar nas garantias que ele faz. Se, por
outro lado, o Rust rejeita um programa correto, o programador terÃ¡ alguma
inconveniÃªncia, mas nada catastrÃ³fico pode acontecer. O tipo <code>RefCell&lt;T&gt;</code> Ã© Ãºtil
quando vocÃª tem certeza que seu cÃ³digo segue as regras de emprÃ©stimo, mas o
compilador Ã© incapaz de entender e garantir isso.</p>
<p>Assim como o <code>Rc&lt;T&gt;</code>, o <code>RefCell&lt;T&gt;</code> Ã© apenas para uso em cenÃ¡rios de thread
Ãºnica e lhe darÃ£o um erro de compilaÃ§Ã£o se vocÃª tentar usÃ¡-lo em um contexto de
mÃºltiplas threads. Falaremos sobre como obter a funcionalidade de um
<code>RefCell&lt;T&gt;</code> em um programa multithread no CapÃ­tulo 16.</p>
<p>Aqui estÃ¡ uma recapitulaÃ§Ã£o das razÃµes para escolher o <code>Box&lt;T&gt;</code>, o <code>Rc&lt;T&gt;</code> ou o
<code>RefCell&lt;T&gt;</code>:</p>
<ul>
<li>O <code>Rc&lt;T&gt;</code> permite mÃºltiplos possuidores do mesmo dado; <code>Box&lt;T&gt;</code> e <code>RefCell&lt;T&gt;</code>
tÃªm possuidores Ãºnicos.</li>
<li>O <code>Box&lt;T&gt;</code> permite emprÃ©stimos imutÃ¡veis ou mutÃ¡veis checados em tempo de
compilaÃ§Ã£o; o <code>Rc&lt;T&gt;</code> permite apenas emprÃ©stimos imutÃ¡veis em tempo de
compilaÃ§Ã£o; o <code>RefCell&lt;T&gt;</code> permite emprÃ©stimos imutÃ¡veis ou mutÃ¡veis checados
em tempo de execuÃ§Ã£o.</li>
<li>Como o <code>RefCell&lt;T&gt;</code> permite emprÃ©stimos mutÃ¡veis checados em tempo de
execuÃ§Ã£o, nÃ³s podemos modificar o valor dentro de um <code>RefCell&lt;T&gt;</code> mesmo quando
o <code>RefCell&lt;T&gt;</code> Ã© imutÃ¡vel.</li>
</ul>
<p>Modificar o valor dentro de um valor imutÃ¡vel Ã© a pattern de <em>mutabilidade
interior</em>. Vamos dar uma olhada em uma situaÃ§Ã£o em que a mutabilidade interior Ã©
Ãºtil e examinar como ela Ã© possÃ­vel.</p>
<a class="header" href="ch15-05-interior-mutability.html#mutabilidade-interior-um-emprÃ©stimo-mutÃ¡vel-de-um-valor-imutÃ¡vel" id="mutabilidade-interior-um-emprÃ©stimo-mutÃ¡vel-de-um-valor-imutÃ¡vel"><h3>Mutabilidade Interior: Um EmprÃ©stimo MutÃ¡vel de um Valor ImutÃ¡vel</h3></a>
<p>Uma consequÃªncia das regras de emprÃ©stimo Ã© que quando temos um valor imutÃ¡vel,
nÃ³s nÃ£o podemos pegÃ¡-lo emprestado mutavelmente. Por exemplo, este cÃ³digo nÃ£o
compila:</p>
<pre><code class="language-rust ignore">fn main() {
    let x = 5;
    let y = &amp;mut x;
}
</code></pre>
<p>Quando tentamos compilar este cÃ³digo, recebemos o seguinte erro:</p>
<pre><code class="language-text">erro[E0596]: nÃ£o posso pegar emprestado a variÃ¡vel local imutÃ¡vel `x` como
mutÃ¡vel
 --&gt; src/main.rs:3:18
  |
2 |     let x = 5;
  |         - considere mudar isto para `mut x`
3 |     let y = &amp;mut x;
  |                  ^ nÃ£o posso pegar emprestado mutavelmente
</code></pre>
<p>Contudo, hÃ¡ situaÃ§Ãµes em que seria Ãºtil para um valor modificar a si mesmo em
seus mÃ©todos, mas continuar parecendo imutÃ¡vel para cÃ³digo externo. CÃ³digo fora
dos mÃ©todos do valor nÃ£o teriam como modificÃ¡-lo. Usar o <code>RefCell&lt;T&gt;</code> Ã© um jeito
de obter a habilidade de ter mutabilidade interior. Mas o <code>RefCell&lt;T&gt;</code> nÃ£o dÃ¡ a
volta nas regras de emprÃ©stimo por completo: o borrow checker no compilador
permite esta mutabilidade interior, e as regras de emprÃ©stimo sÃ£o em vez disso
checadas em tempo de execuÃ§Ã£o. Se violarmos as regras, receberemos um <code>panic!</code>
em vez de um erro de compilaÃ§Ã£o.</p>
<p>Vamos trabalhar com um exemplo prÃ¡tico onde podemos usar o <code>RefCell&lt;T&gt;</code> para
modificar um valor imutÃ¡vel e ver por que isto Ã© Ãºtil.</p>
<a class="header" href="ch15-05-interior-mutability.html#um-caso-de-uso-para-a-mutabilidade-interior-objetos-simulados" id="um-caso-de-uso-para-a-mutabilidade-interior-objetos-simulados"><h4>Um Caso de Uso para a Mutabilidade Interior: Objetos Simulados</h4></a>
<p>Um <em>dublÃª de teste</em> (<em>test double</em>) Ã© um conceito geral de programaÃ§Ã£o para um
tipo usado no lugar de outro durante os testes. <em>Objetos simulados</em> (<em>mock
objects</em>) sÃ£o tipos especÃ­ficos de dublÃªs de teste que registram o que acontece
durante o teste para que possamos confirmar que as aÃ§Ãµes corretas aconteceram.</p>
<p>Rust nÃ£o tem objetos da mesma forma que outras linguagens, e nÃ£o tem
funcionalidade de objetos simulados embutida na biblioteca padrÃ£o como algumas
outras linguagens. Contudo, certamente podemos criar uma struct que serve os
mesmos propÃ³sitos que um objeto simulado.</p>
<p>Eis o cenÃ¡rio que vamos testar: vamos criar uma biblioteca que acompanha um
valor contra um valor mÃ¡ximo e envia mensagens com base em quÃ£o prÃ³ximo do valor
mÃ¡ximo o valor atual estÃ¡. Esta biblioteca pode ser usada para acompanhar a cota
de um usuÃ¡rio para o nÃºmero de chamadas de API que ele tem direito a fazer, por
exemplo.</p>
<p>Nossa biblioteca irÃ¡ prover somente a funcionalidade de acompanhar quÃ£o perto do
mÃ¡ximo um valor estÃ¡ e o que as mensagens deveriam ser em quais momentos. As
aplicaÃ§Ãµes que usarem nossa biblioteca terÃ£o a responsabilidade de prover o
mecanismo para enviar as mensagens: a aplicaÃ§Ã£o pode pÃ´r a mensagem na prÃ³pria
aplicaÃ§Ã£o, enviar um email, uma mensagem de texto, ou alguma outra coisa. A
biblioteca nÃ£o precisa saber deste detalhe. Tudo que ela precisa Ã© de algo que
implemente uma trait que iremos prover chamada <code>Mensageiro</code>. A
Listagem 15-20 mostra o cÃ³digo da biblioteca:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Mensageiro {
    fn enviar(&amp;self, msg: &amp;str);
}

pub struct AvisaLimite&lt;'a, T: 'a + Mensageiro&gt; {
    mensageiro: &amp;'a T,
    valor: usize,
    max: usize,
}

impl&lt;'a, T&gt; AvisaLimite&lt;'a, T&gt;
    where T: Mensageiro {
    pub fn new(mensageiro: &amp;T, max: usize) -&gt; AvisaLimite&lt;T&gt; {
        AvisaLimite {
            mensageiro,
            valor: 0,
            max,
        }
    }

    pub fn set_valor(&amp;mut self, valor: usize) {
        self.valor = valor;

        let porcentagem_do_max = self.valor as f64 / self.max as f64;

        if porcentagem_do_max &gt;= 0.75 &amp;&amp; porcentagem_do_max &lt; 0.9 {
            self.mensageiro.enviar(&quot;Aviso: VocÃª usou mais de 75% da sua cota!&quot;);
        } else if porcentagem_do_max &gt;= 0.9 &amp;&amp; porcentagem_do_max &lt; 1.0 {
            self.mensageiro.enviar(&quot;Aviso urgente: VocÃª usou mais de 90% da sua cota!&quot;);
        } else if porcentagem_do_max &gt;= 1.0 {
            self.mensageiro.enviar(&quot;Erro: VocÃª excedeu sua cota!&quot;);
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 15-20: Uma biblioteca para acompanhar quÃ£o perto
do mÃ¡ximo um valor estÃ¡ e avisar quando o valor estÃ¡ em certos nÃ­veis</span></p>
<p>Uma parte importante deste cÃ³digo Ã© que a trait <code>Mensageiro</code> tem um mÃ©todo
chamado <code>enviar</code> que recebe uma referÃªncia imutÃ¡vel a <code>self</code> e o texto da
mensagem. Esta Ã© a interface que nosso objeto simulado precisa ter. A outra
parte importante Ã© que queremos testar o comportamento do mÃ©todo <code>set_valor</code> no
<code>AvisaLimite</code>. Podemos mudar o que passamos para o parÃ¢metro <code>valor</code>, mas o
<code>set_valor</code> nÃ£o retorna nada sobre o qual possamos fazer asserÃ§Ãµes. Queremos
poder dizer que se criarmos um <code>AvisaLimite</code> com algo que implemente a trait
<code>Mensageiro</code> e um valor especÃ­fico de <code>max</code>, quando passarmos diferentes nÃºmeros
para o <code>valor</code>, o mensageiro receberÃ¡ o comando para enviar as mensagens
apropriadas.</p>
<p>Precisamos de um objeto simulado que, em vez de enviar um email ou mensagem de
texto quando chamarmos <code>enviar</code>, irÃ¡ apenas registrar as mensagens que recebeu
para enviar. Podemos criar uma nova instÃ¢ncia do objeto simulado, criar um
<code>AvisaLimite</code> que use o objeto simulado, chamar o mÃ©todo <code>set_valor</code> no
<code>AvisaLimite</code>, e entÃ£o verificar se o objeto simulado tem as mensagens que
esperamos. A Listagem 15-21 mostra uma tentativa de implementar um objeto
simulado para fazer exatamente isto, mas que o borrow checker nÃ£o permite:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    use super::*;

    struct MensageiroSimulado {
        mensagens_enviadas: Vec&lt;String&gt;,
    }

    impl MensageiroSimulado {
        fn new() -&gt; MensageiroSimulado {
            MensageiroSimulado { mensagens_enviadas: vec![] }
        }
    }

    impl Mensageiro for MensageiroSimulado {
        fn enviar(&amp;self, mensagem: &amp;str) {
            self.mensagens_enviadas.push(String::from(mensagem));
        }
    }

    #[test]
    fn envia_uma_mensagem_de_aviso_de_acima_de_75_porcento() {
        let mensageiro_simulado = MensageiroSimulado::new();
        let mut avisa_limite = AvisaLimite::new(&amp;mensageiro_simulado, 100);

        avisa_limite.set_valor(80);

        assert_eq!(mensageiro_simulado.mensagens_enviadas.len(), 1);
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 15-21: Uma tentativa de implementar um
<code>MensageiroSimulado</code> que nÃ£o Ã© permitida pelo borrow checker</span></p>
<p>Este cÃ³digo de teste define uma struct <code>MensageiroSimulado</code> que tem um campo
<code>mensagens_enviadas</code> com um <code>Vec</code> de valores <code>String</code> para registrar as
mensagens que ele recebe para enviar. TambÃ©m definimos uma funÃ§Ã£o associada
<code>new</code> para facilitar a criaÃ§Ã£o de novos valores <code>MensageiroSimulado</code> que comeÃ§am
com uma lista vazia de mensagens. EntÃ£o implementamos a trait <code>Mensageiro</code> para
o <code>MensageiroSimulado</code> para que possamos passar um <code>MensageiroSimulado</code> a um
<code>AvisaLimite</code>. Na definiÃ§Ã£o do mÃ©todo <code>enviar</code>, nÃ³s pegamos a mensagem passada
como parÃ¢metro e a armazenamos na lista <code>mensagens_enviadas</code> do
<code>MensageiroSimulado</code>.</p>
<p>No teste, estamos testando o que acontece quando o <code>AvisaLimite</code> recebe o
comando para setar o <code>valor</code> para algo que Ã© mais do que 75 porcento do valor
<code>max</code>. Primeiro, criamos um novo <code>MensageiroSimulado</code>, que irÃ¡ comeÃ§ar com uma
lista vazia de mensagens. EntÃ£o criamos um novo <code>AvisaLimite</code> e lhe damos uma
referÃªncia ao novo <code>MensageiroSimulado</code> e um valor <code>max</code> de 100. NÃ³s chamamos o
mÃ©todo <code>set_valor</code> no <code>AvisaLimite</code> com um valor de 80, que Ã© mais do que 75
porcento de 100. EntÃ£o conferimos se a lista de mensagens que o
<code>MensageiroSimulado</code> estÃ¡ registrando agora tem uma mensagem nela.</p>
<p>Entretanto, hÃ¡ um problema neste teste, conforme abaixo:</p>
<pre><code class="language-text">erro[E0596]: nÃ£o posso pegar emprestado o campo imutÃ¡vel
             `self.mensagens_enviadas` como mutÃ¡vel
  --&gt; src/lib.rs:52:13
   |
51 |         fn send(&amp;self, message: &amp;str) {
   |                 ----- use `&amp;mut self` aqui para tornÃ¡-lo mutÃ¡vel
52 |             self.sent_messages.push(String::from(message));
   |             ^^^^^^^^^^^^^^^^^^ nÃ£o posso pegar emprestado mutavelmente um
                                    campo imutÃ¡vel
</code></pre>
<p>NÃ£o podemos modificar o <code>MensageiroSimulado</code> para registrar as mensagens porque
o mÃ©todo <code>enviar</code> recebe uma referÃªncia imutÃ¡vel a <code>self</code>. TambÃ©m nÃ£o podemos
seguir a sugestÃ£o do texto de erro e usar <code>&amp;mut self</code> em vez disso porque a
assinatura de <code>enviar</code> nÃ£o corresponderia Ã  assinatura na definiÃ§Ã£o da trait
<code>Mensageiro</code> (fique Ã  vontade para tentar e ver qual mensagem de erro vocÃª
recebe).</p>
<p>Esta Ã© uma situaÃ§Ã£o em que a mutabilidade interior pode ajudar! Vamos armazenas
as <code>mensagens_enviadas</code> dentro de um <code>RefCell&lt;T&gt;</code>, e entÃ£o o mÃ©todo <code>enviar</code>
poderÃ¡ modificar <code>mensagens_enviadas</code> para armazenar as mensagens que jÃ¡ vimos.
A Listagem 15-22 mostra como fica isto:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MensageiroSimulado {
        mensagens_enviadas: RefCell&lt;Vec&lt;String&gt;&gt;,
    }

    impl MensageiroSimulado {
        fn new() -&gt; MensageiroSimulado {
            MensageiroSimulado { mensagens_enviadas: RefCell::new(vec![]) }
        }
    }

    impl Mensageiro for MensageiroSimulado {
        fn enviar(&amp;self, mensagem: &amp;str) {
            self.mensagens_enviadas.borrow_mut().push(String::from(mensagem));
        }
    }

    #[test]
    fn envia_uma_mensagem_de_aviso_de_acima_de_75_porcento() {
        // --snip--
#         let mensageiro_simulado = MensageiroSimulado::new();
#         let mut avisa_limite = AvisaLimite::new(&amp;mensageiro_simulado, 100);
#         avisa_limite.set_valor(75);

        assert_eq!(mensageiro_simulado.mensagens_enviadas.borrow().len(), 1);
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 15-22: Usando <code>RefCell&lt;T&gt;</code> para modificar um
valor interno enquanto o valor externo Ã© considerado imutÃ¡vel</span></p>
<p>O campo <code>mensagens_enviadas</code> agora Ã© do tipo <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> em vez de
<code>Vec&lt;String&gt;</code>. Na funÃ§Ã£o <code>new</code>, nÃ³s criamos uma nova instÃ¢ncia de
<code>RefCell&lt;Vec&lt;String&gt;&gt;</code> em torno do vetor vazio.</p>
<p>Para a implementaÃ§Ã£o do mÃ©todo <code>enviar</code>, o primeiro parÃ¢metro ainda Ã© um
emprÃ©stimo imutÃ¡vel de <code>self</code>, que corresponde Ã  definiÃ§Ã£o da trait. NÃ³s
chamamos <code>borrow_mut</code> no <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> em <code>self.mensagens_enviadas</code>
para obter uma referÃªncia mutÃ¡vel ao valor dentro do <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>, que
Ã© o vetor. EntÃ£o podemos chamar <code>push</code> na referÃªncia mutÃ¡vel ao vetor para
registrar as mensagens enviadas durante o teste.</p>
<p>A Ãºltima mudanÃ§a que temos que fazer Ã© na asserÃ§Ã£o: para ver quantos itens estÃ£o
no vetor interno, chamamos <code>borrow</code> no <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> para obter uma
referÃªncia imutÃ¡vel ao vetor.</p>
<p>Agora que vocÃª viu como usar o <code>RefCell&lt;T&gt;</code>, vamos nos aprofundar em como ele
funciona!</p>
<a class="header" href="ch15-05-interior-mutability.html#o-refcellt-registra-emprÃ©stimos-em-tempo-de-execuÃ§Ã£o" id="o-refcellt-registra-emprÃ©stimos-em-tempo-de-execuÃ§Ã£o"><h4>O <code>RefCell&lt;T&gt;</code> Registra EmprÃ©stimos em Tempo de ExecuÃ§Ã£o</h4></a>
<p>Quando estamos criando referÃªncias imutÃ¡veis e mutÃ¡veis, usamos as sintaxes <code>&amp;</code>
e <code>&amp;mut</code>, respectivamente. Com o <code>RefCell&lt;T&gt;</code>, usamos os mÃ©todos <code>borrow</code> e
<code>borrow_mut</code>, que sÃ£o parte da API safe que pertence ao <code>RefCell&lt;T&gt;</code>. O mÃ©todo
<code>borrow</code> retorna o ponteiro inteligente <code>Ref&lt;T&gt;</code>, e o <code>borrow_mut</code> retorna o
ponteiro inteligente <code>RefMut&lt;T&gt;</code>. Ambos os tipos implementam <code>Deref</code>, entÃ£o
podemos tratÃ¡-los como referÃªncias normais.</p>
<p>O tipo <code>RefCell&lt;T&gt;</code> mantÃ©m registro de quantos ponteiros inteligentes <code>Ref&lt;T&gt;</code> e
<code>RefMut&lt;T&gt;</code> estÃ£o atualmente ativos. Cada vez que chamamos <code>borrow</code>, o
<code>RefCell&lt;T&gt;</code> aumenta seu contador de quantos emprÃ©stimos imutÃ¡veis estÃ£o ativos.
Quando um valor <code>Ref&lt;T&gt;</code> sai de escopo, o contador de emprÃ©stimos imutÃ¡veis
diminui em um. Assim como as regras de emprÃ©stimo em tempo de compilaÃ§Ã£o, o
<code>RefCell&lt;T&gt;</code> nos permite ter vÃ¡rios emprÃ©stimos imutÃ¡veis ou um emprÃ©stimo
mutÃ¡vel em um dado momento.</p>
<p>Se tentarmos violar estas regras, em vez de receber um erro do compilador como
irÃ­amos com referÃªncias, a implementaÃ§Ã£o de <code>RefCell&lt;T&gt;</code> chamarÃ¡ <code>panic!</code> em
tempo de execuÃ§Ã£o. A Listagem 15-23 mostra uma modificaÃ§Ã£o da implementaÃ§Ã£o do
<code>enviar</code> da Listagem 15-22. Estamos deliberadamente tentando criar dois
emprÃ©stimos mutÃ¡veis ativos para o mesmo escopo para ilustrar que o <code>RefCell&lt;T&gt;</code>
nos impede de fazer isto em tempo de execuÃ§Ã£o:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Mensageiro for MensageiroSimulado {
    fn enviar(&amp;self, mensagem: &amp;str) {
        let mut emprestimo_um = self.mensagens_enviadas.borrow_mut();
        let mut emprestimo_dois = self.mensagens_enviadas.borrow_mut();

        emprestimo_um.push(String::from(mensagem));
        emprestimo_dois.push(String::from(mensagem));
    }
}
</code></pre>
<p><span class="caption">Listagem 15-23: Criando duas referÃªncias mutÃ¡veis no mesmo
escopo para ver que o <code>RefCell&lt;T&gt;</code> irÃ¡ &quot;entrar em pÃ¢nico&quot; (i.e., executar
<code>panic!</code>)</span></p>
<p>NÃ³s criamos uma variÃ¡vel <code>emprestimo_um</code> para o ponteiro inteligente <code>RefMut&lt;T&gt;</code>
retornado por <code>borrow_mut</code>. EntÃ£o criamos outro emprÃ©stimo mutÃ¡vel da mesma
forma na variÃ¡vel <code>emprestimo_dois</code>. Isto resulta em duas referÃªncias mutÃ¡veis
no mesmo escopo, o que nÃ£o Ã© permitido. Quando rodarmos os testes para nossa
biblioteca, o cÃ³digo na Listagem 15-23 irÃ¡ compilar sem nenhum erro, mas o teste
irÃ¡ falhar:</p>
<pre><code class="language-text">---- tests::envia_uma_mensagem_de_aviso_de_acima_de_75_porcento stdout ----
    thread 'tests::envia_uma_mensagem_de_aviso_de_acima_de_75_porcento' entrou
    em pÃ¢nico em
    'jÃ¡ emprestado: BorrowMutError', src/libcore/result.rs:906:4
nota: Rode com `RUST_BACKTRACE=1` para um backtrace.
</code></pre>
<p>Note como o cÃ³digo entrou em pÃ¢nico com a mensagem <code>jÃ¡ emprestado: BorrowMutError</code>. Ã‰ assim que o <code>RefCell&lt;T&gt;</code> lida com violaÃ§Ãµes das regras de
emprÃ©stimo em tempo de execuÃ§Ã£o.</p>
<p>Pegar erros de emprÃ©stimo em tempo de execuÃ§Ã£o em vez de em tempo de compilaÃ§Ã£o
significa encontrar defeitos no nosso cÃ³digo mais tarde no processo de
desenvolvimento, e possivelmente nem mesmo atÃ© que nosso cÃ³digo jÃ¡ tenha sido
implantado em produÃ§Ã£o. AlÃ©m disso, nosso cÃ³digo irÃ¡ incorrer em uma pequena
penalidade de desempenho de execuÃ§Ã£o como resultado de manter registro dos
emprÃ©stimos em tempo de execuÃ§Ã£o em vez de compilaÃ§Ã£o. Ainda assim, usar o
<code>RefCell&lt;T&gt;</code> nos torna possÃ­vel escrever um objeto simulado que pode se
modificar para registrar as mensagens que ele jÃ¡ viu enquanto o usamos em um
contexto onde apenas valores imutÃ¡veis sÃ£o permitidos. Podemos usar o
<code>RefCell&lt;T&gt;</code>, apesar de seus trade-offs, para obter mais funcionalidade do que
referÃªncias regulares nos dÃ£o.</p>
<a class="header" href="ch15-05-interior-mutability.html#conseguindo-mÃºltiplos-possuidores-de-dados-mutÃ¡veis-pela-combinaÃ§Ã£o-de-rct-e-refcellt" id="conseguindo-mÃºltiplos-possuidores-de-dados-mutÃ¡veis-pela-combinaÃ§Ã£o-de-rct-e-refcellt"><h3>Conseguindo MÃºltiplos Possuidores de Dados MutÃ¡veis pela CombinaÃ§Ã£o de <code>Rc&lt;T&gt;</code> e <code>RefCell&lt;T&gt;</code></h3></a>
<p>Um jeito comum de usar o <code>RefCell&lt;T&gt;</code> Ã© em combinaÃ§Ã£o com o <code>Rc&lt;T&gt;</code>. Lembre-se
de que o <code>Rc&lt;T&gt;</code> nos permite ter mÃºltiplos possuidores de algum dado, mas ele sÃ³
nos permite acesso imutÃ¡vel a esse dado. Se temos um <code>Rc&lt;T&gt;</code> que contÃ©m um
<code>RefCell&lt;T&gt;</code>, podemos ter um valor que pode ter mÃºltiplos possuidores <em>e</em> que
podemos modificar!</p>
<p>Por exemplo, lembre-se da cons list na Listagem 15-18 onde usamos o <code>Rc&lt;T&gt;</code> para
nos permitir que mÃºltiplas listas compartilhassem posse de outra lista. Como o
<code>Rc&lt;T&gt;</code> guarda apenas valores imutÃ¡veis, nÃ³s nÃ£o podemos modificar nenhum dos
valores na lista uma vez que os criamos. Vamos adicionar o <code>RefCell&lt;T&gt;</code> para
ganhar a habilidade de mudar os valores nas listas. A Listagem 15-24 mostra que,
usando um <code>RefCell&lt;T&gt;</code> na definiÃ§Ã£o do <code>Cons</code>, podemos modificar o valor
armazenado em todas as listas:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}

use List::{Cons, Nil};
use std::rc::Rc;
use std::cell::RefCell;

fn main() {
    let valor = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&amp;valor), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(6)), Rc::clone(&amp;a));
    let c = Cons(Rc::new(RefCell::new(10)), Rc::clone(&amp;a));

    *valor.borrow_mut() += 10;

    println!(&quot;a depois = {:?}&quot;, a);
    println!(&quot;b depois = {:?}&quot;, b);
    println!(&quot;c depois = {:?}&quot;, c);
}
</code></pre></pre>
<p><span class="caption">Listagem 15-24: Usando <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> para criar uma
<code>List</code> que podemos modificar</span></p>
<p>NÃ³s criamos um valor que Ã© uma instÃ¢ncia de <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> e o armazenamos
em uma variÃ¡vel chamada <code>valor</code> para que possamos acessÃ¡-lo diretamente mais
tarde. EntÃ£o criamos uma <code>List</code> em <code>a</code> com uma variante <code>Cons</code> que guarda
<code>valor</code>.</p>
<p>NÃ³s embrulhamos a lista <code>a</code> em um <code>Rc&lt;T&gt;</code> para que, quando criarmos as listas
<code>b</code> e <code>c</code>, elas possam ambas se referir a <code>a</code>, que Ã© o que fizemos na Listagem
15-18.</p>
<p>Depois de criarmos as listas em <code>a</code>, <code>b</code> e <code>c</code>, adicionamos 10 ao valor em
<code>valor</code>. Fazemos isto chamando <code>borrow_mut</code> em <code>valor</code>, o que usa a
funcionalidade de desreferÃªncia automÃ¡tica que discutimos no CapÃ­tulo 5 (veja a
seÃ§Ã£o &quot;Onde estÃ¡ o operador <code>-&gt;</code>?&quot;) para desreferenciar o <code>Rc&lt;T&gt;</code> ao valor
interno <code>RefCell&lt;T&gt;</code>. O mÃ©todo <code>borrow_mut</code> retorna um ponteiro inteligente
<code>RefMut&lt;T&gt;</code> no qual usamos o operador de desreferÃªncia e modificamos o valor
interno.</p>
<p>Quando imprimimos <code>a</code>, <code>b</code> e <code>c</code>, podemos ver que todos eles tÃªm o valor
modificado de 15 em vez de 5:</p>
<pre><code class="language-text">a depois = Cons(RefCell { value: 15 }, Nil)
b depois = Cons(RefCell { value: 6 }, Cons(RefCell { value: 15 }, Nil))
c depois = Cons(RefCell { value: 10 }, Cons(RefCell { value: 15 }, Nil))
</code></pre>
<p>Esta tÃ©cnica Ã© bem bacana! Usando um <code>RefCell&lt;T&gt;</code>, temos uma <code>List</code>
exteriormente imutÃ¡vel. Mas podemos usar os mÃ©todos no <code>RefCell&lt;T&gt;</code> que dÃ£o
acesso a sua mutabilidade interior para que possamos modificar nossos dados
quando precisarmos. As checagens em tempo de execuÃ§Ã£o das regras de emprÃ©stimo
nos protegem de corridas de dados, e Ã s vezes vale a pena trocar um pouco de
velocidade por esta flexibilidade nas nossas estruturas de dados.</p>
<p>A biblioteca padrÃ£o tem outros tipos que proveem mutabilidade interior, como o
<code>Cell&lt;T&gt;</code>, que Ã© parecido, exceto que em vez de dar referÃªncias ao valor
interno, o valor Ã© copiado para dentro e para fora do <code>Cell&lt;T&gt;</code>. Tem tambÃ©m o
<code>Mutex&lt;T&gt;</code>, que oferece mutabilidade interior que Ã© segura de usar entre
threads; vamos discutir seu uso no CapÃ­tulo 16. Confira a documentaÃ§Ã£o da
biblioteca padrÃ£o para mais detalhes sobre as diferenÃ§as entre estes tipos.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch15-04-rc.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch15-06-reference-cycles.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="ch15-04-rc.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="ch15-06-reference-cycles.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if (getComputedStyle(document.querySelector(".fa")).fontFamily !== "FontAwesome") {
                var link = document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = '_FontAwesome/css/font-awesome.css';
                document.head.insertBefore(link, document.head.firstChild)
            }
        </script>

        

        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
