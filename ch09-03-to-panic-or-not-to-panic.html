<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>ğŸ‡§ğŸ‡· Entrar em panic! ou NÃ£o Entrar em panic! - </title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme;
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            document.querySelector('html').classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="ch01-00-introduction.html"><strong aria-hidden="true">1.</strong> ğŸ‡§ğŸ‡· IntroduÃ§Ã£o</a></li><li><ol class="section"><li><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> ğŸ‡§ğŸ‡· InstalaÃ§Ã£o</a></li><li><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> ğŸ‡§ğŸ‡· OlÃ¡, Mundo!</a></li></ol></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> ğŸ‡§ğŸ‡· Jogo de AdivinhaÃ§Ã£o</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> ğŸ‡§ğŸ‡· Conceitos Comuns de ProgramaÃ§Ã£o</a></li><li><ol class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> ğŸ‡§ğŸ‡· VariÃ¡veis e Mutabilidade</a></li><li><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> ğŸ‡§ğŸ‡· Tipos de dados</a></li><li><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> ğŸ‡§ğŸ‡· FunÃ§Ãµes</a></li><li><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> ğŸ‡§ğŸ‡· ComentÃ¡rios</a></li><li><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> ğŸ‡§ğŸ‡· Controle de fluxo</a></li></ol></li><li><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> ğŸ‡§ğŸ‡· Entendendo Ownership</a></li><li><ol class="section"><li><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> ğŸ‡§ğŸ‡· O Que Ã‰ Ownership?</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> ğŸ‡§ğŸ‡· ReferÃªncias e Borrowing</a></li><li><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> ğŸ‡§ğŸ‡· Slices</a></li></ol></li><li><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> ğŸ‡§ğŸ‡· Structs</a></li><li><ol class="section"><li><a href="ch05-01-method-syntax.html"><strong aria-hidden="true">5.1.</strong> Method Syntax</a></li></ol></li><li><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> ğŸ‡§ğŸ‡· Enums e Casamento de PadrÃµes</a></li><li><ol class="section"><li><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> ğŸ‡§ğŸ‡· Definindo uma Enum</a></li><li><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> ğŸ‡§ğŸ‡· Operador match</a></li><li><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> ğŸ‡§ğŸ‡· Controle de Fluxo Conciso com if let</a></li></ol></li><li><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> ğŸ‡§ğŸ‡· MÃ³dulos</a></li><li><ol class="section"><li><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> ğŸ‡§ğŸ‡· mod e o Sistema de Arquivos</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> ğŸ‡§ğŸ‡· Controlando a Visibilidade com pub</a></li><li><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> ğŸ‡§ğŸ‡· Importando nomes com use</a></li></ol></li><li><a href="ch08-00-fundamental-collections.html"><strong aria-hidden="true">8.</strong> Fundamental Collections</a></li><li><ol class="section"><li><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> ğŸ‡§ğŸ‡· Vetores</a></li><li><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> ğŸ‡§ğŸ‡· Strings</a></li><li><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> ğŸ‡§ğŸ‡· Hash Maps</a></li></ol></li><li><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> ğŸ‡§ğŸ‡· Tratamento de Erros</a></li><li><ol class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> ğŸ‡§ğŸ‡· Erros IrrecuperÃ¡veis com panic!</a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> ğŸ‡§ğŸ‡· Erros recuperÃ¡veis com Result</a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html" class="active"><strong aria-hidden="true">9.3.</strong> ğŸ‡§ğŸ‡· Entrar em panic! ou NÃ£o Entrar em panic!</a></li></ol></li><li><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> ğŸ‡§ğŸ‡· Tipos GenÃ©ricos, Traits, e Tempos de vida (Lifetimes)</a></li><li><ol class="section"><li><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> ğŸ‡§ğŸ‡· Tipos GenÃ©ricos de Dados</a></li><li><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> ğŸ‡§ğŸ‡· Traits: Definindo Comportamento Compartilhado</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> ğŸ‡§ğŸ‡· Validating References with Lifetimes</a></li></ol></li><li><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Writing tests</a></li><li><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Running tests</a></li><li><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project</a></li><li><ol class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Improving Error Handling and Modularity</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Testing the Library's Functionality</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing to stderr instead of stdout</a></li></ol></li><li><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features in Rust</a></li><li><ol class="section"><li><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures</a></li><li><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Iterators</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving our I/O Project</a></li><li><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performance</a></li></ol></li><li><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Release Profiles</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> ğŸ‡§ğŸ‡· Ponteiros Inteligentes (Smart Pointers)</a></li><li><ol class="section"><li><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> ğŸ‡§ğŸ‡· Box<T> Aponta para Dados no Heap e Tem Tamanho Conhecido</a></li><li><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> ğŸ‡§ğŸ‡· Tratando Ponteiros Inteligentes como ReferÃªncias Normais com a Trait Deref</a></li><li><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> ğŸ‡§ğŸ‡· A Trait Drop Roda CÃ³digo durante a Limpeza</a></li><li><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> ğŸ‡§ğŸ‡· Rc<T>, o Ponteiro Inteligente com Contagem de ReferÃªncias</a></li><li><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> ğŸ‡§ğŸ‡· RefCell<T> e a Pattern de Mutabilidade Interior</a></li><li><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> ğŸ‡§ğŸ‡· Ciclos de ReferÃªncias Podem Vazar MemÃ³ria</a></li></ol></li><li><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrency</a></li><li><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> ğŸ‡§ğŸ‡· Rust Ã© uma linguagem orientada a objetos?</a></li><li><ol class="section"><li><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> ğŸ‡§ğŸ‡· O que significa orientado a objetos?</a></li><li><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> ğŸ‡§ğŸ‡· Usando objetos trait que permitem valores de tipos diferentes</a></li><li><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> ğŸ‡§ğŸ‡· Implementando um padrÃ£o de projeto orientado a objetos</a></li></ol></li><li><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns</a></li><li><a href="ch19-00-more-lifetimes.html"><strong aria-hidden="true">19.</strong> More Lifetimes</a></li><li><a href="ch20-00-advanced-types.html"><strong aria-hidden="true">20.</strong> Advanced Type System Features</a></li><li><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> Keywords</a></li><li><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> Operators</a></li><li><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> Derivable Traits</a></li><li><a href="appendix-04-nightly-rust.html"><strong aria-hidden="true">21.4.</strong> Nightly Rust</a></li><li><a href="appendix-05-macros.html"><strong aria-hidden="true">21.5.</strong> Macros</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="submenu">
                                <li><button class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li><button class="theme" id="rust">Rust</button></li>
                                <li><button class="theme" id="coal">Coal</button></li>
                                <li><button class="theme" id="navy">Navy</button></li>
                                <li><button class="theme" id="ayu">Ayu</button></li>
                            </ul>
                        </div>

                        <h1 class="menu-title"></h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="ch09-03-to-panic-or-not-to-panic.html#entrar-em-panic-ou-nÃ£o-entrar-em-panic" id="entrar-em-panic-ou-nÃ£o-entrar-em-panic"><h2>Entrar em <code>panic!</code> ou NÃ£o Entrar em <code>panic!</code></h2></a>
<p>EntÃ£o como vocÃª decide quando entrar em <code>panic!</code> e quando vocÃª deveria retornar
um <code>Result</code>? Quando o cÃ³digo entra em pÃ¢nico, nÃ£o hÃ¡ maneira de se recuperar. VocÃª
poderia chamar <code>panic!</code> para qualquer situaÃ§Ã£o de erro, tendo uma maneira de se recuperar
ou nÃ£o, mas entÃ£o vocÃª estaria decidindo no lugar do cÃ³digo que chama seu cÃ³digo
que a situaÃ§Ã£o Ã© irrecuperÃ¡vel. Quando vocÃª decide retornar um valor de <code>Result</code>,
vocÃª lhe dÃ¡ opÃ§Ãµes em vez de tomar a decisÃ£o por ele. O cÃ³digo
que chama seu cÃ³digo pode tentar se recuperar de uma maneira que Ã© apropriada para
a situaÃ§Ã£o, ou ele pode decidir que um valor de <code>Err</code> nesse caso Ã© irrecuperÃ¡vel,
chamando <code>panic!</code> e transformando seu erro recuperÃ¡vel em um irrecuperÃ¡vel.
Portanto, retornar <code>Result</code> Ã© uma boa escolha padrÃ£o quando vocÃª estÃ¡ definindo
uma funÃ§Ã£o que pode falhar.</p>
<p>Em algumas situaÃ§Ãµes Ã© mais apropriado escrever cÃ³digo que entra em pÃ¢nico em vez
de retornar um <code>Result</code>, mas eles sÃ£o menos comuns. Vamos explorar porque Ã© apropriado
entrar em pÃ¢nico em alguns exemplos, protÃ³tipos de cÃ³digo e testes; depois situaÃ§Ãµes
em que vocÃª como humano pode saber que um mÃ©todo nÃ£o vai falhar, mas que o compilador nÃ£o
tem como saber; e concluir com algumas diretrizes sobre como decidir entrar ou
nÃ£o em pÃ¢nico em cÃ³digo de biblioteca.</p>
<a class="header" href="ch09-03-to-panic-or-not-to-panic.html#exemplos-protÃ³tipos-e-testes-sÃ£o-todos-lugares-em-que-Ã‰-perfeitamente-ok-entrar-em-pÃ¢nico" id="exemplos-protÃ³tipos-e-testes-sÃ£o-todos-lugares-em-que-Ã‰-perfeitamente-ok-entrar-em-pÃ¢nico"><h3>Exemplos, ProtÃ³tipos, e Testes SÃ£o Todos Lugares em que Ã‰ Perfeitamente Ok Entrar em PÃ¢nico</h3></a>
<p>Quando vocÃª estÃ¡ escrevendo um exemplo para ilustrar algum conceito, ter cÃ³digo
de tratamento de erro robusto junto do exemplo pode tornÃ¡-lo menos claro. Em exemplos,
Ã© compreensÃ­vel que uma chamada a um mÃ©todo como <code>unwrap</code> que poderia chamar <code>panic!</code>
apenas substitua a maneira como vocÃª trataria erros na sua aplicaÃ§Ã£o,
que pode ser diferente baseado no que o resto do seu cÃ³digo estÃ¡ fazendo.</p>
<p>De forma semelhante, os mÃ©todos <code>unwrap</code> e <code>expect</code> sÃ£o bem Ãºteis ao fazer
protÃ³tipos, antes de vocÃª estar pronto para decidir como tratar erros. Eles deixam
marcadores claros no seu cÃ³digo para quando vocÃª estiver pronto para tornar
seu programa mais robusto.</p>
<p>Se uma chamada de mÃ©todo falha em um teste, queremos que o teste inteiro falhe,
mesmo se esse mÃ©todo nÃ£o Ã© a funcionalidade sendo testada. Como <code>panic!</code> Ã© o modo
que um teste Ã© marcado como falha, chamar <code>unwrap</code> ou <code>expect</code> Ã© exatamente o que
deveria acontecer.</p>
<a class="header" href="ch09-03-to-panic-or-not-to-panic.html#casos-em-que-vocÃª-tem-mais-informaÃ§Ã£o-que-o-compilador" id="casos-em-que-vocÃª-tem-mais-informaÃ§Ã£o-que-o-compilador"><h3>Casos em que VocÃª Tem Mais InformaÃ§Ã£o Que o Compilador</h3></a>
<p>Seria tambÃ©m apropriado chamar <code>unwrap</code> quando vocÃª tem outra lÃ³gica que
assegura que o <code>Result</code> vai ter um valor <code>Ok</code>, mas essa lÃ³gica nÃ£o Ã© algo
que o compilador entenda. VocÃª ainda vai ter um valor de <code>Result</code> que precisa
lidar: seja qual for a operaÃ§Ã£o que vocÃª estÃ¡ chamando, ela ainda tem uma possibilidade
de falhar em geral, mesmo que seja logicamente impossÃ­vel que isso ocorra nessa
situaÃ§Ã£o particular. Se vocÃª consegue assegurar ao inspecionar manualmente o cÃ³digo que
vocÃª nunca tera uma variante <code>Err</code>, Ã© perfeitamente aceitÃ¡vel chamar <code>unwrap</code>.
Aqui temos um exemplo:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::net::IpAddr;

let home = &quot;127.0.0.1&quot;.parse::&lt;IpAddr&gt;().unwrap();
#}</code></pre></pre>
<p>NÃ³s estamos criando uma instÃ¢ncia <code>IpAddr</code> ao analisar uma string <em>hardcoded</em>. NÃ³s
podemos ver que <code>127.0.0.1</code> Ã© um endereÃ§o de IP vÃ¡lido, entÃ£o Ã© aceitÃ¡vel usar
<code>unwrap</code> aqui. No entanto, ter uma string vÃ¡lida <em>hardcoded</em> nÃ£o muda o tipo retornado
pelo mÃ©todo <code>parse</code>: ainda teremos um valor de <code>Result</code>, e o compilador ainda
vai nos fazer tratar o <code>Result</code> como se a variante <code>Err</code> fosse uma
possibilidade, porque o compilador nÃ£o Ã© inteligente o bastante para ver que essa string
Ã© sempre um endereÃ§o IP vÃ¡lido. Se a string de endereÃ§o IP viesse de um usuÃ¡rio ao invÃ©s
de ser <em>hardcoded</em> no programa, e portanto, de fato tivesse uma possibilidade de falha, nÃ³s
definitivamente irÃ­amos querer tratar o <code>Result</code> de uma forma mais robusta.</p>
<a class="header" href="ch09-03-to-panic-or-not-to-panic.html#diretrizes-para-tratamento-de-erro" id="diretrizes-para-tratamento-de-erro"><h3>Diretrizes para Tratamento de Erro</h3></a>
<p>Ã‰ aconselhÃ¡vel fazer que seu cÃ³digo entre em <code>panic!</code> quando Ã© possÃ­vel que
ele entre em um mau estado. Nesse contexto, mau estado Ã© quando
alguma hipÃ³tese, garantia, contrato ou invariante foi quebrada, tal como
valores invÃ¡lidos, valores contraditÃ³rios, ou valores faltando que sÃ£o passados
a seu cÃ³digo - alÃ©m de um ou mais dos seguintes:</p>
<ul>
<li>O mau estado nÃ£o Ã© algo que Ã© <em>esperado</em> que aconteÃ§a ocasionalmente.</li>
<li>Seu cÃ³digo apÃ³s certo ponto precisa confiar que ele nÃ£o estÃ¡ nesse mau estado.</li>
<li>NÃ£o hÃ¡ uma forma boa de codificar essa informaÃ§Ã£o nos tipos que vocÃª usa.</li>
</ul>
<p>Se alguÃ©m chama seu cÃ³digo e passa valores que nÃ£o fazem sentido, a melhor escolha
talvez seja entrar em <code>panic!</code> e alertar a pessoa usando sua biblioteca do bug no
cÃ³digo dela para que ela possa consertÃ¡-la durante o desenvolvimento. Similarmente,
<code>panic!</code> Ã© em geral apropriado se vocÃª estÃ¡ chamando cÃ³digo externo que estÃ¡ fora
do seu controle e ele retorna um estado invÃ¡lido que vocÃª nÃ£o tem como consertar.</p>
<p>Quando se chega a um mau estado, mas isso Ã© esperado que aconteÃ§a nÃ£o importa
quÃ£o bem vocÃª escreva seu cÃ³digo, ainda Ã© mais apropriado retornar um <code>Result</code>
a fazer uma chamada a <code>panic!</code>. Um exemplo disso Ã© um <em>parser</em> recebendo dados
malformados ou uma requisiÃ§Ã£o HTTP retornando um status que indique que vocÃª atingiu
um limite de taxa. Nesses casos, vocÃª deveria indicar que falha Ã© uma possibilidade
esperada ao retornar um <code>Result</code> para propagar esses estados ruins para cima,
de forma que o cÃ³digo que chamou seu cÃ³digo pode decidir como tratar o problema.
Entrar em <code>panic!</code> nÃ£o seria a melhor maneira de lidar com esses casos.</p>
<p>Quando seu cÃ³digo realiza operaÃ§Ãµes em valores, ele deveria verificar que os valores
sÃ£o vÃ¡lidos primeiro, e entrar em <code>panic!</code> caso nÃ£o sejam. Isso Ã©
em boa parte por razÃµes de seguranÃ§a: tentar operar em dados invÃ¡lidos pode expor seu
cÃ³digo a vulnerabilidades. Essa Ã© a principal razÃ£o para a biblioteca padrÃ£o entrar em
<code>panic!</code> se vocÃª tentar um acesso de memÃ³ria fora dos limites: tentar acessar memÃ³ria
que nÃ£o pertence Ã  estrutura de dados atual Ã© um problema de seguranÃ§a comum. FunÃ§Ãµes
frequentemente tem <em>contratos</em>: seu comportamento somente Ã© garantido se os inputs cumprem
requerimentos especÃ­ficos. Entrar em pÃ¢nico quando o contrato Ã© violado faz sentido
porque uma violaÃ§Ã£o de contrato sempre indica um bug da parte do chamador, e nÃ£o Ã© o tipo
de erro que vocÃª quer que seja tratado explicitamente. De fato,
nÃ£o hÃ¡ nenhuma maneira razoÃ¡vel para o cÃ³digo chamador se recuperar: os <em>programadores</em>
que precisam consertar o cÃ³digo. Contratos para uma funÃ§Ã£o, especialmente quando uma
violaÃ§Ã£o leva a pÃ¢nico, devem ser explicados na documentaÃ§Ã£o da API da funÃ§Ã£o.</p>
<p>No entanto, ter vÃ¡rias checagens de erro em todas suas funÃ§Ãµes pode ser verboso
e irritante. Felizmente, vocÃª pode usar o sistema de tipos do Rust (e portanto a
checagem que o compilador faz) para fazer vÃ¡rias dessas checagens para vocÃª. Se
sua funÃ§Ã£o tem um tipo particular como parÃ¢metro, vocÃª pode continuar com a lÃ³gica
do seu cÃ³digo sabendo que o compilador jÃ¡ assegurou que vocÃª tem um valor vÃ¡lido.
Por exemplo, se vocÃª tem um tipo em vez de uma <code>Option</code>, seu programa espera
ter <em>algo</em> ao invÃ©s de <em>nada</em>. Seu cÃ³digo nÃ£o precisa tratar dois casos para
as variantes <code>Some</code> e <code>None</code>: ele vai somente ter um caso para definitivamente ter
um valor. Um cÃ³digo que tente passar nada para sua funÃ§Ã£o nÃ£o vai nem compilar,
entÃ£o sua funÃ§Ã£o nÃ£o precisa checar esse caso em tempo de execuÃ§Ã£o. Outro exemplo Ã© usar
um tipo de inteiro sem sinal como <code>u32</code>, que assegura que o parÃ¢metro nunca Ã©
negativo.</p>
<a class="header" href="ch09-03-to-panic-or-not-to-panic.html#criando-tipos-customizados-para-validaÃ§Ã£o" id="criando-tipos-customizados-para-validaÃ§Ã£o"><h3>Criando Tipos Customizados para ValidaÃ§Ã£o</h3></a>
<p>Vamos dar um passo alÃ©m na ideia de usar o sistema de tipos de Rust para assegurar que temos
um valor vÃ¡lido e ver como criar um tipo customizado para validaÃ§Ã£o.
Lembre do jogo de adivinhaÃ§Ã£o no CapÃ­tulo 2 onde nosso cÃ³digo pedia ao usuÃ¡rio
para adivinhar um nÃºmero entre 1 e 100. NÃ³s nunca validamos que o chute do usuÃ¡rio
fosse entre esses nÃºmeros antes de comparÃ¡-lo com o nÃºmero secreto; nÃ³s somente
validamos que o chute era positivo. Nesse caso, as consequÃªncias nÃ£o foram tÃ£o
drÃ¡sticas: nosso output de &quot;Muito alto&quot; ou &quot;Muito baixo&quot; ainda estariam corretos. Seria
uma melhoria Ãºtil guiar o usuÃ¡rio para chutes vÃ¡lidos, e ter um comportamento distinto
quando um usuÃ¡rio chuta um nÃºmero fora do limite e quando um usuÃ¡rio digita letras, por exemplo.</p>
<p>Uma maneira de fazer isso seria interpretar o chute como um <code>i32</code> em vez de
somente um <code>u32</code> para permitir nÃºmeros potenciamente negativos, e entÃ£o adicionar
uma checagem se o nÃºmero estÃ¡ dentro dos limites, conforme a seguir:</p>
<pre><code class="language-rust ignore">loop {
    // snip

    let palpite: i32 = match palpite.trim().parse() {
        Ok(num) =&gt; num,
        Err(_) =&gt; continue,
    };

    if palpite &lt; 1 || palpite &gt; 100 {
        println!(&quot;O nÃºmero secreto vai estar entre 1 e 100.&quot;);
        continue;
    }

    match palpite.cmp(&amp;numero_secreto) {
    // snip
}
</code></pre>
<p>A expressÃ£o <code>if</code> checa se nosso valor estÃ¡ fora dos limites, informa o usuÃ¡rio
sobre o problema, e chama <code>continue</code> para comeÃ§ar a prÃ³xima iteraÃ§Ã£o do loop
e pedir por outro chute. Depois da expressÃ£o <code>if</code> podemos proceder com as
comparaÃ§Ãµes entre <code>palpite</code> e o nÃºmero secreto sabendo que <code>palpite</code> estÃ¡
entre 1 e 100.</p>
<p>No entanto, essa nÃ£o Ã© a soluÃ§Ã£o ideal: se fosse absolutamente crÃ­tico que o
programa somente operasse em valores entre 1 e 100, e ele tivesse vÃ¡rias funÃ§Ãµes
com esse requisito, seria tedioso (e potencialmente impactante na performance)
ter uma checagem dessa em cada funÃ§Ã£o.</p>
<p>Em vez disso, podemos fazer um novo tipo e colocar as validaÃ§Ãµes em uma funÃ§Ã£o
para criar uma instÃ¢ncia do tipo em vez de repetir as validaÃ§Ãµes em todo lugar.
Dessa maneira, Ã© seguro para funÃ§Ãµes usarem o novo tipo nas suas assinaturas e
confidentemente usar os valores que recebem. A Listagem 9-9  mostra uma maneira de
definir um tipo <code>Palpite</code> que vai somente criar uma instÃ¢ncia de <code>Palpite</code> se a funÃ§Ã£o
<code>new</code> receber um valor entre 1 e 100:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Palpite {
    valor: u32,
}

impl Palpite {
    pub fn new(valor: u32) -&gt; Palpite {
        if valor &lt; 1 || valor &gt; 100 {
            panic!(&quot;Valor de chute deve ser entre 1 e 100, recebi {}.&quot;, valor);
        }

        Palpite {
            valor
        }
    }

    pub fn valor(&amp;self) -&gt; u32 {
        self.valor
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 9-9: Um tipo <code>Palpite</code> que somente funciona com valores
entre 1 e 100.</span></p>
<p>Primeiro, definimos uma struct chamada <code>Palpite</code> que tem um campo chamado <code>valor</code>
que guarda um <code>u32</code>. Isso Ã© onde o nÃºmero vai ser guardado.</p>
<p>EntÃ£o nÃ³s implementamos uma funÃ§Ã£o associada chamada <code>new</code> em <code>Palpite</code> que cria
instÃ¢ncias de valores <code>Palpite</code>. A funÃ§Ã£o <code>new</code> Ã© definida a ter um parÃ¢metro
chamado <code>valor</code> de tipo <code>u32</code> e retornar um <code>Palpite</code>. O cÃ³digo no corpo da funÃ§Ã£o
<code>new</code> testa para ter certeza que <code>valor</code> estÃ¡ entre 1 e 100. Se <code>valor</code> nÃ£o passa
nesse teste, fazemos uma chamada a <code>panic!</code>, que vai alertar ao programador que
estÃ¡ escrevendo o cÃ³digo chamando a funÃ§Ã£o que ele tem um bug que precisa ser
corrigido, porque criar um <code>Palpite</code> com um <code>valor</code> fora desses limites violaria
o contrato em que <code>Palpite::new</code> se baseia. As condiÃ§Ãµes em que <code>Palpite::new</code> pode
entrar em pÃ¢nico devem ser discutidas na sua documentaÃ§Ã£o da API voltada ao pÃºblico;
no CapÃ­tulo 14 nÃ³s cobriremos convenÃ§Ãµes de documentaÃ§Ã£o indicando a possibilidade de um <code>panic!</code>
na documentaÃ§Ã£o de API. Se <code>valor</code> de fato passa no
teste, criamos um novo <code>Palpite</code> com o campo <code>valor</code> preenchido com o parÃ¢metro
<code>valor</code> e retornamos o <code>Palpite</code>.</p>
<p>Em seguida, implementamos um mÃ©todo chamado <code>valor</code> que pega <code>self</code> emprestado, nÃ£o
tem nenhum outro parÃ¢metro, e retorna um <code>u32</code>. Esse Ã© o tipo de mÃ©todo Ã s vezes
chamado de <em>getter</em>, pois seu propÃ³sito Ã© pegar um dado de um dos campos e o retornar.
Esse mÃ©todo pÃºblico Ã© necessÃ¡rio porque o campo <code>valor</code> da struct <code>Palpite</code> Ã© privado.
Ã‰ importante que o campo <code>valor</code> seja privado para que cÃ³digo usando a struct <code>Palpite</code>
nÃ£o tenha permissÃ£o de definir o valor de <code>valor</code> diretamente: cÃ³digo de fora do mÃ³dulo
<em>deve</em> usar a funÃ§Ã£o <code>Palpite::new</code> para criar uma instÃ¢ncia de <code>Palpite</code>, o que certifica
que nÃ£o hÃ¡ maneira de um <code>Palpite</code> ter um <code>valor</code> que nÃ£o foi checado pelas condiÃ§Ãµes
definidas na funÃ§Ã£o <code>Palpite::new</code>.</p>
<p>Uma funÃ§Ã£o que tem um parÃ¢metro ou retorna somente nÃºmeros entre 1 e 100 pode
entÃ£o declarar na sua assinatura que ela recebe ou retorna um <code>Palpite</code> em vez
de um <code>u32</code> e nÃ£o precisaria fazer nenhuma checagem adicional no seu corpo.</p>
<a class="header" href="ch09-03-to-panic-or-not-to-panic.html#resumo" id="resumo"><h2>Resumo</h2></a>
<p>As ferramentas de tratamento de erros de Rust sÃ£o feitas para te ajudar a escrever
cÃ³digo mais robusto. A macro <code>panic!</code> sinaliza que seu programa estÃ¡ num estado que
nÃ£o consegue lidar e deixa vocÃª parar o processo ao invÃ©s de tentar prosseguir com
valores invÃ¡lidos ou incorretos. O enum <code>Result</code> usa o sistema de tipos de Rust para
indicar que operaÃ§Ãµes podem falhar de uma maneira que seu cÃ³digo pode se recuperar.
VocÃª pode usar <code>Result</code> para dizer ao cÃ³digo que chama seu cÃ³digo que ele precisa
tratar potenciais sucessos ou falhas tambÃ©m. Usar <code>panic!</code> e <code>Result</code> nas situaÃ§Ãµes
apropriadas farÃ¡ seu cÃ³digo mais confiÃ¡vel em face aos problemas inevitÃ¡veis.</p>
<p>Agora que vocÃª viu as maneiras Ãºteis em que a biblioteca padrÃ£o usa genÃ©ricos com
os enums <code>Option</code> e <code>Result</code>, nÃ³s falaremos como genÃ©ricos funcionam e como vocÃª
pode usÃ¡-los em seu cÃ³digo no prÃ³ximo capÃ­tulo.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch09-02-recoverable-errors-with-result.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch10-00-generics.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="ch09-02-recoverable-errors-with-result.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="ch10-00-generics.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if (getComputedStyle(document.querySelector(".fa")).fontFamily !== "FontAwesome") {
                var link = document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = '_FontAwesome/css/font-awesome.css';
                document.head.insertBefore(link, document.head.firstChild)
            }
        </script>

        

        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
