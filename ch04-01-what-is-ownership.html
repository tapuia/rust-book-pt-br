<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>üáßüá∑ O Que √â Ownership? - </title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme;
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            document.querySelector('html').classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="ch01-00-introduction.html"><strong aria-hidden="true">1.</strong> üáßüá∑ Introdu√ß√£o</a></li><li><ol class="section"><li><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> üáßüá∑ Instala√ß√£o</a></li><li><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> üáßüá∑ Ol√°, Mundo!</a></li></ol></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> üáßüá∑ Jogo de Adivinha√ß√£o</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> üáßüá∑ Conceitos Comuns de Programa√ß√£o</a></li><li><ol class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> üáßüá∑ Vari√°veis e Mutabilidade</a></li><li><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> üáßüá∑ Tipos de dados</a></li><li><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> üáßüá∑ Fun√ß√µes</a></li><li><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> üáßüá∑ Coment√°rios</a></li><li><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> üáßüá∑ Controle de fluxo</a></li></ol></li><li><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> üáßüá∑ Entendendo Ownership</a></li><li><ol class="section"><li><a href="ch04-01-what-is-ownership.html" class="active"><strong aria-hidden="true">4.1.</strong> üáßüá∑ O Que √â Ownership?</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> üáßüá∑ Refer√™ncias e Borrowing</a></li><li><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> üáßüá∑ Slices</a></li></ol></li><li><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> üáßüá∑ Structs</a></li><li><ol class="section"><li><a href="ch05-01-method-syntax.html"><strong aria-hidden="true">5.1.</strong> Method Syntax</a></li></ol></li><li><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> üáßüá∑ Enums e Casamento de Padr√µes</a></li><li><ol class="section"><li><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> üáßüá∑ Definindo uma Enum</a></li><li><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> üáßüá∑ Operador match</a></li><li><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> üáßüá∑ Controle de Fluxo Conciso com if let</a></li></ol></li><li><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> üáßüá∑ M√≥dulos</a></li><li><ol class="section"><li><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> üáßüá∑ mod e o Sistema de Arquivos</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> üáßüá∑ Controlando a Visibilidade com pub</a></li><li><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> üáßüá∑ Importando nomes com use</a></li></ol></li><li><a href="ch08-00-fundamental-collections.html"><strong aria-hidden="true">8.</strong> Fundamental Collections</a></li><li><ol class="section"><li><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> üáßüá∑ Vetores</a></li><li><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> üáßüá∑ Strings</a></li><li><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> üáßüá∑ Hash Maps</a></li></ol></li><li><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> üáßüá∑ Tratamento de Erros</a></li><li><ol class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> üáßüá∑ Erros Irrecuper√°veis com panic!</a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> üáßüá∑ Erros recuper√°veis com Result</a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> üáßüá∑ Entrar em panic! ou N√£o Entrar em panic!</a></li></ol></li><li><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> üáßüá∑ Tipos Gen√©ricos, Traits, e Tempos de vida (Lifetimes)</a></li><li><ol class="section"><li><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> üáßüá∑ Tipos Gen√©ricos de Dados</a></li><li><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> üáßüá∑ Traits: Definindo Comportamento Compartilhado</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> üáßüá∑ Validating References with Lifetimes</a></li></ol></li><li><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Writing tests</a></li><li><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Running tests</a></li><li><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project</a></li><li><ol class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Improving Error Handling and Modularity</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Testing the Library's Functionality</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing to stderr instead of stdout</a></li></ol></li><li><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features in Rust</a></li><li><ol class="section"><li><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures</a></li><li><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Iterators</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving our I/O Project</a></li><li><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performance</a></li></ol></li><li><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Release Profiles</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> üáßüá∑ Ponteiros Inteligentes (Smart Pointers)</a></li><li><ol class="section"><li><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> üáßüá∑ Box<T> Aponta para Dados no Heap e Tem Tamanho Conhecido</a></li><li><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> üáßüá∑ Tratando Ponteiros Inteligentes como Refer√™ncias Normais com a Trait Deref</a></li><li><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> üáßüá∑ A Trait Drop Roda C√≥digo durante a Limpeza</a></li><li><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> üáßüá∑ Rc<T>, o Ponteiro Inteligente com Contagem de Refer√™ncias</a></li><li><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> üáßüá∑ RefCell<T> e a Pattern de Mutabilidade Interior</a></li><li><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> üáßüá∑ Ciclos de Refer√™ncias Podem Vazar Mem√≥ria</a></li></ol></li><li><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrency</a></li><li><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> üáßüá∑ Rust √© uma linguagem orientada a objetos?</a></li><li><ol class="section"><li><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> üáßüá∑ O que significa orientado a objetos?</a></li><li><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> üáßüá∑ Usando objetos trait que permitem valores de tipos diferentes</a></li><li><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> üáßüá∑ Implementando um padr√£o de projeto orientado a objetos</a></li></ol></li><li><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns</a></li><li><a href="ch19-00-more-lifetimes.html"><strong aria-hidden="true">19.</strong> More Lifetimes</a></li><li><a href="ch20-00-advanced-types.html"><strong aria-hidden="true">20.</strong> Advanced Type System Features</a></li><li><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> Keywords</a></li><li><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> Operators</a></li><li><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> Derivable Traits</a></li><li><a href="appendix-04-nightly-rust.html"><strong aria-hidden="true">21.4.</strong> Nightly Rust</a></li><li><a href="appendix-05-macros.html"><strong aria-hidden="true">21.5.</strong> Macros</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="submenu">
                                <li><button class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li><button class="theme" id="rust">Rust</button></li>
                                <li><button class="theme" id="coal">Coal</button></li>
                                <li><button class="theme" id="navy">Navy</button></li>
                                <li><button class="theme" id="ayu">Ayu</button></li>
                            </ul>
                        </div>

                        <h1 class="menu-title"></h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="ch04-01-what-is-ownership.html#o-que-√â-ownership" id="o-que-√â-ownership"><h2>O Que √â Ownership?</h2></a>
<p>A caracter√≠stica central do Rust √© <em>ownership</em>. Embora seja bem direta de
explicar, ela tem implica√ß√µes profundas em todo o resto da linguagem.</p>
<p>Todos os programas t√™m que decidir de que forma v√£o usar a mem√≥ria do computador
durante a execu√ß√£o. Algumas linguagens possuem <em>garbage collection</em> (coleta de
lixo), que constantemente busca segmentos de mem√≥ria que j√° n√£o s√£o mais
utilizados enquanto o programa executa; em outras linguagens, o programador deve
alocar e liberar mem√≥ria de forma expl√≠cita. Rust usa uma terceira abordagem: a
mem√≥ria √© gerenciada atrav√©s de um sistema de posse, que tem um conjunto de
regras verificadas em tempo de compila√ß√£o. Nenhuma caracter√≠stica relacionada ao
ownership implica qulaquer custo em tempo de execu√ß√£o.</p>
<p>Como ownership √© um conceito novo para muitos programadores, leva um pouco de
tempo para se acostumar. A boa not√≠cia √© que quanto mais experiente voc√™ se
torna em Rust e nas regras do sistema de posse, mais voc√™ ser√° capaz de
escrever, naturalmente, c√≥digo seguro e eficiente. Fique a√≠!</p>
<p>Quando voc√™ entender ownership, voc√™ ter√° uma funda√ß√£o s√≥lida para entender as
caracter√≠sticas que fazem o Rust ser √∫nico. Neste cap√≠tulo, voc√™ vai aprender
ownership trabalhando em alguns exemplos com foco em uma estrutura de dados
muito comum: <em>strings</em>.</p>
<!-- PROD: START BOX -->
<blockquote>
<a class="header" href="ch04-01-what-is-ownership.html#a-pilha-e-a-heap" id="a-pilha-e-a-heap"><h3>A Pilha e a <em>Heap</em></h3></a>
<p>Em muitas linguagens de programa√ß√£o, n√£o temos que pensar muito sobre a pilha
e sobre a <em>heap</em>. Mas em uma linguagem de programa√ß√£o de sistemas, como Rust,
o fato de um valor estar na pilha ou na heap tem impacto na forma como a
linguagem se comporta e no porqu√™ de termos que tomar certas decis√µes. Vamos
descrever partes do ownership em rela√ß√£o √† pilha e √† heap mais para a frente
neste cap√≠tulo, ent√£o aqui vai uma explica√ß√£o preparat√≥ria.</p>
<p>Tanto a pilha como a heap s√£o partes da mem√≥ria que est√£o dispon√≠veis ao seu
c√≥digo para uso em tempo de execu√ß√£o, mas elas s√£o estruturadas de formas
diferentes. A pilha armazena valores na ordem em que eles chegam, e os remove
na ordem inversa. Isto √© chamado de <em>last in, first out</em> (√∫ltimo a chegar,
primeiro a sair). Imagine uma pilha de pratos: quando voc√™ coloca mais pratos,
voc√™ os p√µe em cima da pilha, e quando voc√™ precisa de um prato, voc√™ pega o
que est√° no topo. Adicionar ou remover pratos do meio ou do fundo n√£o funciona
t√£o bem! Dizemos fazer um <em>push</em> na pilha quando nos refererimos a inserir
dados, e fazer um <em>pop</em> da pilha quando nos referimos a remover dados.</p>
<p>A pilha √© r√°pida por conta da forma como ela acessa os dados: ela nunca tem
que procurar um lugar para colocar novos dados, ou um lugar de onde obter
dados, este lugar √© sempre o topo da pilha. Outra propriedade que faz a pilha
ser r√°pida √© que todos os dados contidos nela devem ocupar um tamanho fixo e
conhecido.</p>
<p>Para dados com um tamanho desconhecido em tempo de compila√ß√£o, ou com um
tamanho que pode mudar, podemos usar a heap em vez da pilha. A heap √© menos
organizada: quando colocamos dados na heap, n√≥s pedimos um certo espa√ßo de
mem√≥ria. O sistema operacional encontra um espa√ßo vazio em algum lugar na heap
que seja grande o suficiente, marca este espa√ßo como em uso, e nos retorna um
<em>ponteiro</em>, que √© o endere√ßo deste local. Este processo √© chamado de
<em>alocar na heap</em>, e √†s vezes se abrevia esta frase como apenas &quot;aloca√ß√£o&quot;.
Colocar valores na pilha n√£o √© considerado uma aloca√ß√£o. Como o ponteiro tem
um tamanho fixo e conhecido, podemos armazen√°-lo na pilha, mas quando queremos
os dados, de fato, temos que seguir o ponteiro.</p>
<p>Imagine que voc√™ est√° sentado em um restaurante. Quando voc√™ entra, voc√™ diz
o n√∫mero de pessoas que est√£o com voc√™, o atendente encontra uma mesa vazia
que acomode todos e os leva para l√°. Se algu√©m do seu grupo chegar mais tarde,
poder√° perguntar onde voc√™s est√£o para encontr√°-los.</p>
<p>Acessar dados na heap √© mais lento do que acessar dados na pilha, porque voc√™
precisa seguir um ponteiro para chegar l√°. Processadores de hoje em dia s√£o
mais r√°pidos se n√£o precisarem pular tanto de um lugar para outro na mem√≥ria.
Continuando com a analogia, considere um gar√ßom no restaurante anotando os
pedidos de v√°rias mesas. √â mais eficiente anotar todos os pedidos de uma √∫nica
mesa antes de passar para a mesa seguinte. Anotar um pedido da mesa A, depois
um da mesa B, depois outro da mesa A, e outro da mesa B novamente seria um
processo bem mais lento. Da mesma forma, um processador pode cumprir melhor
sua tarefa se trabalhar em dados que est√£o pr√≥ximos uns dos outros (assim como
est√£o na pilha) em vez de dados afastados entre si (como podem estar na heap).
Alocar um espa√ßo grande na heap tamb√©m pode levar tempo.</p>
<p>Quando nosso c√≥digo chama uma fun√ß√£o, os valores passados para ela (incluindo
poss√≠veis ponteiros para dados na heap) e as vari√°veis locais da fun√ß√£o s√£o
colocados na pilha. Quando a fun√ß√£o termina, esses valores s√£o removidos dela.</p>
<p>Rastrear quais partes do c√≥digo est√£o usando quais dados na heap, minimizar a
quantidade de dados duplicados na heap e limpar segmentos inutilizados da heap
para que n√£o fiquemos sem espa√ßo s√£o todos problemas tratados pelo ownership.
Uma vez que voc√™ entende ownership, voc√™ n√£o vai mais precisar pensar tanto
sobre a pilha e a heap, mas saber que ownership existe para gerenciar os dados
na heap pode ajudar a explicar como e por que ele funciona.</p>
</blockquote>
<!-- PROD: END BOX -->
<a class="header" href="ch04-01-what-is-ownership.html#regras-de-ownership" id="regras-de-ownership"><h3>Regras de Ownership</h3></a>
<p>Primeiro, vamos dar uma olhada nas regras de ownership. Mantenha em mente essas
regras quando trabalharmos com os exemplos em seguida:</p>
<blockquote>
<ol>
<li>Cada valor em Rust possui uma vari√°vel que √© dita seu <em>owner</em> (sua dona).</li>
<li>Pode apenas haver um owner por vez.</li>
<li>Quando o owner sai fora de escopo, o valor ser√° destru√≠do.</li>
</ol>
</blockquote>
<a class="header" href="ch04-01-what-is-ownership.html#escopo-de-vari√°veis" id="escopo-de-vari√°veis"><h3>Escopo de Vari√°veis</h3></a>
<p>J√° analisamos um exemplo de programa em Rust no Cap√≠tulo 2. Agora que j√°
passamos da sintaxe b√°sica, n√£o vamos incluir o c√≥digo <code>fn main() {</code> nos
pr√≥ximos exemplos, ent√£o se voc√™ estiver acompanhando, ter√° que coloc√°-los
manualmente dentro de uma fun√ß√£o <code>main</code>. Como resultado, nossos exemplos ser√£o
um pouco mais concisos, mantendo o foco nos detalhes que realmente interessam.</p>
<p>Como um primeiro exemplo de ownership, vamos olhar para o <em>escopo</em> de algumas
vari√°veis. Um escopo √© a √°rea dentro de um programa para a qual um item √©
v√°lido. Digamos que n√≥s temos uma vari√°vel como esta:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = &quot;ol√°&quot;;
#}</code></pre></pre>
<p>A vari√°vel <code>s</code> se refere a uma string literal cujo valor √© fixo no c√≥digo. A
vari√°vel √© v√°lida do ponto em que √© declarada at√© o fim do atual <em>escopo</em>. A
Listagem 4-1 tem coment√°rios indicando onde a vari√°vel <code>s</code> √© v√°lida:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{                      // s n√£o √© v√°lida aqui, ainda n√£o est√° declarada
    let s = &quot;texto&quot;;   // s √© v√°lida deste ponto em diante

    // faz alguma coisa com s
}                      // agora este escopo terminou, e s n√£o √© mais v√°lida
#}</code></pre></pre>
<p><span class="caption">Listagem 4-1: Uma vari√°vel e o escopo em que ela √©
v√°lida.</span></p>
<p>Em outras palavras, existem dois pontos no tempo que s√£o importantes aqui:</p>
<ol>
<li>Quando <code>s</code> <em>entra no escopo</em>, ela √© v√°lida.</li>
<li>Permanece dessa maneira at√© que ela <em>saia de escopo</em>.</li>
</ol>
<p>Neste ponto, a rela√ß√£o entre escopos e quando vari√°veis s√£o v√°lidas √© similar a
outras linguagens de programa√ß√£o. Agora vamos construir sobre este entendimento,
apresentando o tipo <code>String</code>.</p>
<a class="header" href="ch04-01-what-is-ownership.html#o-tipo-string" id="o-tipo-string"><h3>O Tipo <code>String</code></h3></a>
<p>Para ilustrar as regras de ownership, precisamos de um tipo de dados que seja
mais complexo do que aqueles abordados no Cap√≠tulo 3. Os tipos abordados na
se√ß√£o &quot;Tipos de Dados&quot; s√£o todos armazenados na pilha, e retirados dela quando
seu escopo termina, mas queremos ver dados que s√£o armazenados na heap e
explorar como o Rust faz para saber quando limpar esses dados.</p>
<p>Vamos usar <code>String</code> como exemplo aqui, e concentrar nas partes de <code>String</code> que
est√£o relacionadas ao ownership. Esses aspectos tamb√©m se aplicam aos outros
tipos complexos de dados fornecidos pela biblioteca padr√£o e os que voc√™ mesmo
cria. Vamos discutir <code>String</code> mais a fundo no Cap√≠tulo 8.</p>
<p>J√° vimos strings literais, em que um valor de string √© fixado pelo c√≥digo do
nosso programa. Strings literais s√£o convenientes, mas nem sempre s√£o adequadas
para situa√ß√µes em que queremos usar texto. Um motivo √© que elas s√£o imut√°veis.
Outro √© que nem todos os valores de string s√£o conhecidos enquanto escrevemos
nosso c√≥digo: por exemplo, o que fazer se queremos obter uma entrada do usu√°rio
e armazen√°-la? Para essas situa√ß√µes, Rust tem um segundo tipo de strings,
<code>String</code>. Este tipo √© alocado na heap, e como tal, √© capaz de armazenar uma
quantidade de texto que √© desconhecida em tempo de compila√ß√£o. Voc√™ pode criar
uma <code>String</code> de uma string literal usando a fun√ß√£o <code>from</code>, da seguinte forma:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;texto&quot;);
#}</code></pre></pre>
<p>O <code>::</code> √© um operador que nos permite indicar que o <em>namespace</em> desta fun√ß√£o
<code>from</code>, em particular, √© o tipo <code>String</code>, de forma que n√£o precisamos usar um
nome espec√≠fico como <code>string_from</code>. Vamos discutir esta sintaxe na se√ß√£o
&quot;Sintaxe do M√©todo&quot; do Cap√≠tulo 5, e quando falarmos sobre <em>namespaces</em> com
m√≥dulos no Cap√≠tulo 7.</p>
<p>Este tipo de string <em>pode</em> ser alterada:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::from(&quot;ol√°&quot;);

s.push_str(&quot;, mundo!&quot;); // push_str() adiciona um literal √† String

println!(&quot;{}&quot;, s); // Isso vai exibir `ol√°, mundo!`
#}</code></pre></pre>
<p>Mas ent√£o, qual √© a diferen√ßa aqui? Por que <code>String</code> pode ser alterada enquanto
literais n√£o podem? A diferen√ßa est√° em como esses dois tipos lidam com mem√≥ria.</p>
<a class="header" href="ch04-01-what-is-ownership.html#mem√≥ria-e-aloca√ß√£o" id="mem√≥ria-e-aloca√ß√£o"><h3>Mem√≥ria e Aloca√ß√£o</h3></a>
<p>No caso de uma string literal, sabemos o seu conte√∫do em tempo de compila√ß√£o,
ent√£o o texto √© injetado diretamente para dentro do execut√°vel final, o que
faz strings literais serem r√°pidas e eficientes. Mas essas propriedades prov√™m
apenas da sua imutabilidade. Infelizmente, n√£o podemos colocar um segmento de
mem√≥ria dentro do bin√°rio para cada texto cujo tamanho √© desconhecido em tempo
de compila√ß√£o, e cujo tamanho pode mudar ao longo da execu√ß√£o do programa.</p>
<p>Com o tipo <code>String</code>, para poder acomodar um trecho mut√°vel e expans√≠vel de
texto, precisamos alocar uma quantidade de mem√≥ria na heap, que √© desconhecida
em tempo de compila√ß√£o, para manter o seu conte√∫do. Isto significa que:</p>
<ol>
<li>A mem√≥ria deve ser solicitada ao sistema operacional em tempo de execu√ß√£o.</li>
<li>Precisamos de uma forma de retornar esta mem√≥ria ao sistema operacional
quando tivermos finalizado nossa <code>String</code>.</li>
</ol>
<p>A primeira parte √© feita por n√≥s: quando chamamos <code>String::from</code>, sua
implementa√ß√£o solicita a mem√≥ria de que precisa. Isso √© meio que universal em
linguagens de programa√ß√£o.</p>
<p>No entanto, a segunda parte √© diferente. Em linguagnes com um <em>garbage collector
(GC)</em>, o GC rastreia e limpa a mem√≥ria que n√£o est√° mais sendo usada, e n√≥s,
como programadores, n√£o precisamos pensar sobre isso. Sem um GC, √©
resposabilidade do programador identificar quando a mem√≥ria n√£o est√° mais sendo
usada e chamar, explicitamente, um c√≥digo que a retorne, assim como fizemos para
solicit√°-la. Fazer isso corretamente tem sido, historicamente, um problema
dif√≠cil de programa√ß√£o. Se esquecermos, vamos desperdi√ßar mem√≥ria. Se fizermos
cedo demais, teremos uma vari√°vel inv√°lida. Se fizermos duas vezes, tamb√©m ser√°
um bug. Precisamos casar exatamente um <code>allocate</code> (alocar) com exatamente um
<code>free</code> (liberar).</p>
<p>Rust segue um caminho diferente: a mem√≥ria √© automaticamente retornada assim que
a vari√°vel que a possui sai de escopo. Aqui est√° uma vers√£o do nosso exemplo de
escopo da Listagem 4-1 usando uma <code>String</code> em vez de uma string literal:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    let s = String::from(&quot;texto&quot;); // s √© v√°lida deste ponto em diante

    // faz alguma coisa com s
}                                  // agora este escopo terminou, e s n√£o √©
                                   // mais v√°lida
#}</code></pre></pre>
<p>Existe um ponto natural em que podemos retornar ao sistema operacional a mem√≥ria
da qual precisa nossa <code>String</code>: quando <code>s</code> sai de escopo. Quando uma vari√°vel
sai de escopo, o Rust chama para n√≥s uma fun√ß√£o especial. Essa fun√ß√£o √© chamada
<code>drop</code>, e √© a√≠ que o autor de <code>String</code> pode colocar o c√≥digo que retorna
a mem√≥ria. Rust chama <code>drop</code> automaticamente ao fechar chaves (<code>}</code>).</p>
<blockquote>
<p>Nota: Em C++, esta forma de desalocar recursos no fim do tempo de vida √∫til de
um item √†s vezes √© chamado de <em>Resource Acquisition Is Initialization</em> (RAII,
do ingl√™s, Aquisi√ß√£o de Recurso √â Inicializa√ß√£o). A fun√ß√£o <code>drop</code> em Rust vai
lhe ser bastante familar se voc√™ j√° tiver usado padr√µes RAII.</p>
</blockquote>
<p>Este padr√£o tem um profundo impacto na forma de escrever c√≥digo em Rust. Pode
parecer simples agora, mas o comportamento do c√≥digo pode ser inesperado em
situa√ß√µes mais complicadas, quando queremos que m√∫ltiplas vari√°veis usem os
dados que alocamos na heap. Vamos explorar algumas dessas situa√ß√µes agora.</p>
<a class="header" href="ch04-01-what-is-ownership.html#formas-de-intera√ß√£o-entre-vari√°veis-e-dados-move" id="formas-de-intera√ß√£o-entre-vari√°veis-e-dados-move"><h4>Formas de Intera√ß√£o Entre Vari√°veis e Dados: <em>Move</em></h4></a>
<p>M√∫ltiplas vari√°veis podem interagir com os mesmos dados de diferentes formas em
Rust. Vamos ver um exemplo usando um n√∫mero inteiro na Listagem 4-2:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
let y = x;
#}</code></pre></pre>
<p><span class="caption">Listagem 4-2: Atribuindo o valor inteiro da vari√°vel <code>x</code>
para <code>y</code>.</span></p>
<p>Provavelmente podemos advinhar o que isto faz com base nas nossas experi√™ncias
com outras linguagens: &quot;Associe o valor <code>5</code> a <code>x</code>; depois fa√ßa uma c√≥pia do
valor em <code>x</code> e a associe a <code>y</code>.&quot; Agora temos duas vari√°veis, <code>x</code> e <code>y</code>, e ambas
s√£o iguais a <code>5</code>. √â isto mesmo que acontece, porque n√∫meros inteiros s√£o valores
simples que possuem um tamanho fixo e conhecido, e esses dois valores <code>5</code> s√£o
colocados na pilha.</p>
<p>Agora vamos ver a vers√£o usando <code>String</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;texto&quot;);
let s2 = s1;
#}</code></pre></pre>
<p>Isso parece bem similar ao c√≥digo anterior, ent√£o poder√≠amos assumir que
funcionaria da mesma forma, isto √©, a segunda linha faria uma c√≥pia do valor em
<code>s1</code> e a associaria a <code>s2</code>. Mas n√£o √© exatamente isso que acontece.</p>
<p>Para explicar isso mais detalhadamente, vamos ver como a <code>String</code> funciona por
baixo dos panos na Figura 4-1. Uma <code>String</code> √© feita de tr√™s partes, mostradas
√† esquerda: um ponteiro para a mem√≥ria que guarda o conte√∫do da string, um
tamanho, e uma capacidade. Este grupo de dados √© armazenado na pilha. No lado
direito est√° a mem√≥ria na heap que guarda o conte√∫do.</p>
<p><img alt="String na mem√≥ria" src="img/trpl04-01.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Figura 4-1: Representa√ß√£o na mem√≥ria de uma <code>String</code>
contendo o valor <code>&quot;texto&quot;</code> associado a <code>s1</code>.</span></p>
<p>O tamanho representa quanta mem√≥ria, em bytes, o conte√∫do da <code>String</code> est√°
usando atualmente. A capacidade √© a quantidade total de mem√≥ria, em bytes, que
a <code>String</code> recebeu do sistema operacional. A diferen√ßa entre tamanho e
capacidade √© importante, mas n√£o neste contexto, ent√£o n√£o h√° problema em
ignorar a capacidade por enquanto.</p>
<p>Quando atribu√≠mos <code>s1</code> a <code>s2</code>, os dados da <code>String</code> s√£o copiados, o que
significa que estamos copiando o ponteiro, o tamanho e a capacidade que est√£o na
pilha. N√£o estamos copiando os dados que est√£o na heap, aos quais o ponteiro se
refere. Em outras palavras, a representa√ß√£o dos dados na mem√≥ria ocorre como
na Figura 4-2.</p>
<p><img alt="s1 e s2 apontando para o mesmo valor" src="img/trpl04-02.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Figura 4-2: Representa√ß√£o na mem√≥ria da vari√°vel <code>s2</code>, que
tem uma c√≥pia do ponteiro, tamanho e capacidade de <code>s1</code>.</span></p>
<p>A representa√ß√£o <em>n√£o</em> ocorre como na Figura 4-3, que √© como ficaria a mem√≥ria se
o Rust tamb√©m copiasse os dados da heap. Se o Rust fizesse isso, a opera√ß√£o
<code>s2 = s1</code> seria potencialmente bastante custosa em termos de desempenho em tempo
de execu√ß√£o caso os dados na heap fossem grandes.</p>
<p><img alt="s1 e s2 em dois lugares" src="img/trpl04-03.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Figura 4-3: Outra possibilidade do que <code>s2 = s1</code> poderia
fazer se o Rust tamb√©m copiasse os dados da heap.</span></p>
<p>Anteriormente, dissemos que, quando uma vari√°vel sai de escopo, o Rust
automaticamente chama a fun√ß√£o <code>drop</code> e limpa a mem√≥ria da heap para esta
vari√°vel. Mas a Figura 4-2 mostra que os dois ponteiros est√£o apontando para o
mesmo lugar. Isso √© um problema: quando <code>s2</code> e <code>s1</code> saem de escopo, os dois v√£o
tentar liberar a mesma mem√≥ria. Isso √© conhecido como erro de <em>double free</em>
(libera√ß√£o dupla), e √© um dos bugs de seguran√ßa de mem√≥ria que mencionamos
anteriormente. Liberar mem√≥ria duas vezes pode levar √† corrup√ß√£o da mem√≥ria,
o que pode, por sua vez, trazer potenciais vulnerabilidades de seguran√ßa.</p>
<p>Para garantir a seguran√ßa de mem√≥ria, h√° um outro detalhe sobre o que acontece
nesta situa√ß√£o em Rust. Em vez de tentar copiar a mem√≥ria alocada, o Rust
considera que <code>s1</code> deixa de ser v√°lida, e portanto, o Rust n√£o precisa liberar
nenhuma mem√≥ria quando <code>s1</code> sai de escopo. Veja s√≥ o que acontece quando voc√™
tenta usar <code>s1</code> depois que <code>s2</code> √© criada, n√£o vai funcionar:</p>
<pre><code class="language-rust ignore">let s1 = String::from(&quot;texto&quot;);
let s2 = s1;

println!(&quot;{}&quot;, s1);
</code></pre>
<p>Voc√™ vai ter um erro como este, porque o Rust lhe impede de usar a refer√™ncia
que foi invalidada:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `s1`
 --&gt; src/main.rs:5:20
  |
3 |     let s2 = s1;
  |         -- value moved here
4 |
5 |     println!(&quot;{}&quot;, s1);
  |                    ^^ value used here after move
  |
  = note: move occurs because `s1` has type `std::string::String`, which does
  not implement the `Copy` trait
</code></pre>
<p>Se voc√™ j√° ouviu os termos &quot;c√≥pia rasa&quot; e &quot;c√≥pia profunda&quot; (<em>shallow copy</em> e
<em>deep copy</em>) enquanto trabalhava com outras linguagens, o conceito de copiar o
ponteiro, tamanho e capacidade sem copiar os dados provavelmente parece uma
c√≥pia rasa. Mas como o Rust tamb√©m invalida a primeira vari√°vel, em vez de
chamar isto de c√≥pia rasa, isto √© conhecido como um <em>move</em>. Aqui poder√≠amos
dizer que <code>s1</code> foi <em>movida</em> para <code>s2</code>. Ent√£o, o que realmente acontece √©
mostrado na Figura 4-4.</p>
<p><img alt="s1 movida para s2" src="img/trpl04-04.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Figura 4-4: Representa√ß√£o na mem√≥ria depois de <code>s1</code> ter
sido invalidada.</span></p>
<p>Isso resolve o nosso problema! Tendo apenas <code>s2</code> v√°lida, quando ela sair de
escopo, somente ela vai liberar a mem√≥ria, e pronto.</p>
<p>Ademais, isto implica uma decis√£o de projeto: Rust nunca vai criar <em>deep copies</em>
dos seus dados. Logo, para qualquer c√≥pia <em>autom√°tica</em> que aconte√ßa, pode-se
assumir que ela n√£o ser√° custosa em termos de desempenho em tempo de execu√ß√£o.</p>
<a class="header" href="ch04-01-what-is-ownership.html#formas-de-intera√ß√£o-entre-vari√°veis-e-dados-clone" id="formas-de-intera√ß√£o-entre-vari√°veis-e-dados-clone"><h4>Formas de Intera√ß√£o Entre Vari√°veis e Dados: Clone</h4></a>
<p>Se n√≥s <em>queremos</em> fazer uma c√≥pia profunda dos dados da <code>String</code> que est√£o na
heap, e n√£o apenas os dados que est√£o na pilha, podemos usar um m√©todo comum
chamado <code>clone</code>. Vamos discutir sintaxe de m√©todos no Cap√≠tulo 5, mas como os
m√©todos constituem uma caracter√≠stica comum em v√°rias linguagens de programa√ß√£o,
voc√™ provavelmente j√° os viu antes.</p>
<p>Aqui est√° um exemplo de uso do m√©todo <code>clone</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;texto&quot;);
let s2 = s1.clone();

println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);
#}</code></pre></pre>
<p>Isto funciona bem, e √© assim que voc√™ pode, explicitamente, produzir o
comportamento mostrado na Figura 4-3, onde os dados da heap <em>s√£o</em> copiados.</p>
<p>Quando voc√™ ver uma chamada para <code>clone</code>, voc√™ sabe que algum c√≥digo arbitr√°rio
est√° sendo executado, e que este c√≥digo talvez seja custoso. √â um indicador
visual de que algo diferente est√° acontecendo.</p>
<a class="header" href="ch04-01-what-is-ownership.html#dados-somente-da-pilha-copy" id="dados-somente-da-pilha-copy"><h4>Dados Somente da Pilha: Copy</h4></a>
<p>H√° um outro detalhezinho de que ainda n√£o falamos. Este c√≥digo usando n√∫meros
inteiros, parte do qual foi mostrado anteriormente na Listagem 4-2, funciona e √©
v√°lido:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
let y = x;

println!(&quot;x = {}, y = {}&quot;, x, y);
#}</code></pre></pre>
<p>Mas este c√≥digo parece contradizer o que acabamos de aprender: n√£o temos uma
chamada ao m√©todo <code>clone</code>, mas <code>x</code> ainda √© v√°lido e n√£o foi movido para <code>y</code>.</p>
<p>O motivo √© que tipos como n√∫meros inteiros t√™m um tamanho conhecido em tempo de
compila√ß√£o e s√£o armazenados inteiramente na pilha, e por isso, c√≥pias desses
valores s√£o r√°pidas de se fazer. Isso significa que n√£o h√° raz√£o para impedir
<code>x</code> de ser v√°lido ap√≥s criarmos a vari√°vel <code>y</code>. Em outras palavras, n√£o h√°
diferen√ßa entre c√≥pia rasa e profunda aqui, ent√£o chamar o m√©todo <code>clone</code> n√£o
faria nada diferente de uma c√≥pia rasa, por isso podemos deix√°-lo de lado.</p>
<p>O Rust tem uma anota√ß√£o especial chamada de <em>trait</em> <code>Copy</code>, que podemos colocar
em tipos como n√∫meros inteiros, que s√£o armazenados na pilha (falaremos mais
sobre traits no Cap√≠tulo 10). Se um tipo possui o trait <code>Copy</code>, uma vari√°vel
anterior vai continuar sendo utiliz√°vel depois de uma atribui√ß√£o. O Rust n√£o vai
nos deixar anotar um tipo com o trait <code>Copy</code> se este tipo, ou qualquer uma de
suas partes, tiver implementado o trait <code>Drop</code>. Se o tipo precisa que algo
especial aconte√ßa quando o valor sair de escopo e h√° uma anota√ß√£o <code>Copy</code> neste
tipo, vamos ter um erro de compila√ß√£o. Para aprender sobre como inserir a
anota√ß√£o <code>Copy</code> ao seu tipo, veja o Ap√™ndice C em Traits Deriv√°veis.</p>
<p>Ent√£o quais tipos s√£o <code>Copy</code>? Voc√™ pode verificar a documenta√ß√£o de um
determinado tipo para se certificar, mas como regra geral, qualquer grupo de
valores simples escalares podem ser <code>Copy</code>, e nada que precise de aloca√ß√£o ou
que seja uma forma de recurso √© <code>Copy</code>. Aqui est√£o alguns tipos que s√£o <code>Copy</code>:</p>
<ul>
<li>Todos os tipos inteiros, como <code>u32</code>.</li>
<li>O tipo booleano, <code>bool</code>, com valores <code>true</code> e <code>false</code>.</li>
<li>O tipo caractere, <code>char</code>.</li>
<li>Todos os tipos de ponto flutuante, como <code>f64</code>.</li>
<li>Tuplas, mas apenas aquelas que cont√©m tipos que tamb√©m s√£o <code>Copy</code>.
<code>(i32, i32)</code> √© <code>Copy</code>, mas <code>(i32, String)</code> n√£o.</li>
</ul>
<a class="header" href="ch04-01-what-is-ownership.html#ownership-e-fun√ß√µes" id="ownership-e-fun√ß√µes"><h3>Ownership e Fun√ß√µes</h3></a>
<p>A sem√¢ntica para passar um valor a uma fun√ß√£o √© similar √† de atribuir um valor
a uma vari√°vel. Passar uma vari√°vel a uma fun√ß√£o ir√° mover ou copiar, assim como
acontece em uma atribui√ß√£o. A Listagem 4-3 tem um exemplo com algumas anota√ß√µes
mostrando onde as vari√°veis entram e saem de escopo:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s = String::from(&quot;texto&quot;);  // s entra em escopo.

    toma_posse(s);                  // move o valor de s para dentro da fun√ß√£o...
                                    // ... e ele n√£o √© mais v√°lido aqui.

    let x = 5;                      // x entra em escopo.

    faz_uma_copia(x);               // x seria movido para dentro da fun√ß√£o,
                                    // mas i32 √© Copy, ent√£o est√° tudo bem em
                                    // usar x daqui para a frente.

} // Aqui, x sai de escopo, e depois s. Mas como o valor de s foi movido, nada
  // de especial acontece.

fn toma_posse(uma_string: String) { // uma_string entra em escopo.
    println!(&quot;{}&quot;, uma_string);
} // Aqui, uma_string sai de escopo, e o m√©todo `drop` √© chamado. A mem√≥ria que
  // guarda seus dados √© liberada.

fn faz_uma_copia(um_inteiro: i32) { // um_inteiro entra em escopo.
    println!(&quot;{}&quot;, um_inteiro);
} // Aqui, um_inteiro sai de escopo. Nada de especial acontece.
</code></pre></pre>
<p><span class="caption">Listagem 4-3: Fun√ß√µes com anota√ß√µes de ownership e
escopo</span></p>
<p>Se tent√°ssemos usar <code>s</code> ap√≥s a chamada para <code>toma_posse</code>, o Rust iria lan√ßar um
erro de compila√ß√£o. Essas verifica√ß√µes est√°ticas nos protegem de certo enganos.
Tente adicionar um c√≥digo √† fun√ß√£o <code>main</code> que usa <code>s</code> e <code>x</code> para ver onde voc√™
pode us√°-los e onde as regras de ownership lhe impedem de faz√™-lo.</p>
<a class="header" href="ch04-01-what-is-ownership.html#retorno-de-valores-e-escopo" id="retorno-de-valores-e-escopo"><h3>Retorno de Valores e Escopo</h3></a>
<p>Retornar valores tamb√©m pode transferir a posse de um valor. Aqui est√° um
exemplo com anota√ß√µes similares √†quelas da Listagem 4-3:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = entrega_valor();           // entrega_valor move o valor retornado
                                        // para s1.

    let s2 = String::from(&quot;texto&quot;);     // s2 entra em escopo.

    let s3 = pega_e_entrega_valor(s2);  // s2 √© movido para dentro da fun√ß√£o
                                        // pega_e_entrega_valor, que tamb√©m
                                        // move o valor retornado para s3.
} // Aqui, s3 sai de escopo e √© destru√≠da. s2 sai de escopo, mas j√° foi movida,
  // ent√£o nada demais acontece. s1 sai de escopo e √© destru√≠da.

fn entrega_valor() -&gt; String {               // entrega_valor move o valor
                                             // retornado para dentro da fun√ß√£o
                                             // que a chamou.

    let uma_string = String::from(&quot;ol√°&quot;);    // uma_string entra em escopo.

    uma_string                               // uma_string √© retornada e movida
                                             // para a fun√ß√£o que chamou
                                             // entrega_valor.
}

// pega_e_entrega_valor vai pegar uma String e retorn√°-la.
fn pega_e_entrega_valor(uma_string: String) -&gt; String { // uma_string entra em
                                                        // escopo.

    uma_string  // uma_string √© retornada e movida para a fun√ß√£o que chamou
                // pega_e_entrega_valor.
}
</code></pre></pre>
<p>A posse de uma vari√°vel segue o mesmo padr√£o toda vez: atribuir um valor a outra
vari√°vel ir√° mov√™-lo. Quando uma vari√°vel que inclui dados na heap sai de
escopo, o valor ser√° destru√≠do pelo m√©todo <code>drop</code>, a n√£o ser que os dados tenham
sido movidos para outra vari√°vel.</p>
<p>Obter e retornar a posse de um valor em cada fun√ß√£o √© um pouco tedioso. O que
fazer se queremos deixar uma fun√ß√£o usar um valor sem tomar posse dele? √â meio
irritante saber que qualquer coisa que passemos a uma fun√ß√£o tamb√©m precisa ser
passado de volta se quisermos us√°-lo novamente, al√©m de algum poss√≠vel resultado
proveniente do corpo da fun√ß√£o que tamb√©m queremos retornar.</p>
<p>√â poss√≠vel retornar m√∫ltiplos valores usando uma tupla, da seguinte forma:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;texto&quot;);

    let (s2, tamanho) = calcula_tamanho(s1);

    println!(&quot;O tamanho de '{}' √© {}.&quot;, s2, tamanho);
}

fn calcula_tamanho(s: String) -&gt; (String, usize) {
    let tamanho = s.len(); // len() retorna o tamanho de uma String.

    (s, tamanho)
}
</code></pre></pre>
<p>Mas isto √© muita cerim√¥nia e trabalho para um conceito que deveria ser comum.
Para nossa sorte, Rust tem uma ferramenta para este conceito, e ela √© chamada de
<em>refer√™ncias</em>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch04-00-understanding-ownership.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch04-02-references-and-borrowing.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="ch04-00-understanding-ownership.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="ch04-02-references-and-borrowing.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if (getComputedStyle(document.querySelector(".fa")).fontFamily !== "FontAwesome") {
                var link = document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = '_FontAwesome/css/font-awesome.css';
                document.head.insertBefore(link, document.head.firstChild)
            }
        </script>

        

        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
