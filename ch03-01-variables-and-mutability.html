<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>ğŸ‡§ğŸ‡· VariÃ¡veis e Mutabilidade - </title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme;
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            document.querySelector('html').classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="ch01-00-introduction.html"><strong aria-hidden="true">1.</strong> ğŸ‡§ğŸ‡· IntroduÃ§Ã£o</a></li><li><ol class="section"><li><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> ğŸ‡§ğŸ‡· InstalaÃ§Ã£o</a></li><li><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> ğŸ‡§ğŸ‡· OlÃ¡, Mundo!</a></li></ol></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> ğŸ‡§ğŸ‡· Jogo de AdivinhaÃ§Ã£o</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> ğŸ‡§ğŸ‡· Conceitos Comuns de ProgramaÃ§Ã£o</a></li><li><ol class="section"><li><a href="ch03-01-variables-and-mutability.html" class="active"><strong aria-hidden="true">3.1.</strong> ğŸ‡§ğŸ‡· VariÃ¡veis e Mutabilidade</a></li><li><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> ğŸ‡§ğŸ‡· Tipos de dados</a></li><li><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> ğŸ‡§ğŸ‡· FunÃ§Ãµes</a></li><li><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> ğŸ‡§ğŸ‡· ComentÃ¡rios</a></li><li><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> ğŸ‡§ğŸ‡· Controle de fluxo</a></li></ol></li><li><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> ğŸ‡§ğŸ‡· Entendendo Ownership</a></li><li><ol class="section"><li><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> ğŸ‡§ğŸ‡· O Que Ã‰ Ownership?</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> ğŸ‡§ğŸ‡· ReferÃªncias e Borrowing</a></li><li><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> ğŸ‡§ğŸ‡· Slices</a></li></ol></li><li><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> ğŸ‡§ğŸ‡· Structs</a></li><li><ol class="section"><li><a href="ch05-01-method-syntax.html"><strong aria-hidden="true">5.1.</strong> Method Syntax</a></li></ol></li><li><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> ğŸ‡§ğŸ‡· Enums e Casamento de PadrÃµes</a></li><li><ol class="section"><li><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> ğŸ‡§ğŸ‡· Definindo uma Enum</a></li><li><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> ğŸ‡§ğŸ‡· Operador match</a></li><li><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> ğŸ‡§ğŸ‡· Controle de Fluxo Conciso com if let</a></li></ol></li><li><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> ğŸ‡§ğŸ‡· MÃ³dulos</a></li><li><ol class="section"><li><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> ğŸ‡§ğŸ‡· mod e o Sistema de Arquivos</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> ğŸ‡§ğŸ‡· Controlando a Visibilidade com pub</a></li><li><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> ğŸ‡§ğŸ‡· Importando nomes com use</a></li></ol></li><li><a href="ch08-00-fundamental-collections.html"><strong aria-hidden="true">8.</strong> Fundamental Collections</a></li><li><ol class="section"><li><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> ğŸ‡§ğŸ‡· Vetores</a></li><li><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> ğŸ‡§ğŸ‡· Strings</a></li><li><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> ğŸ‡§ğŸ‡· Hash Maps</a></li></ol></li><li><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> ğŸ‡§ğŸ‡· Tratamento de Erros</a></li><li><ol class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> ğŸ‡§ğŸ‡· Erros IrrecuperÃ¡veis com panic!</a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> ğŸ‡§ğŸ‡· Erros recuperÃ¡veis com Result</a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> ğŸ‡§ğŸ‡· Entrar em panic! ou NÃ£o Entrar em panic!</a></li></ol></li><li><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> ğŸ‡§ğŸ‡· Tipos GenÃ©ricos, Traits, e Tempos de vida (Lifetimes)</a></li><li><ol class="section"><li><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> ğŸ‡§ğŸ‡· Tipos GenÃ©ricos de Dados</a></li><li><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> ğŸ‡§ğŸ‡· Traits: Definindo Comportamento Compartilhado</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> ğŸ‡§ğŸ‡· Validating References with Lifetimes</a></li></ol></li><li><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Writing tests</a></li><li><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Running tests</a></li><li><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project</a></li><li><ol class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Improving Error Handling and Modularity</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Testing the Library's Functionality</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing to stderr instead of stdout</a></li></ol></li><li><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features in Rust</a></li><li><ol class="section"><li><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures</a></li><li><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Iterators</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving our I/O Project</a></li><li><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performance</a></li></ol></li><li><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Release Profiles</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> ğŸ‡§ğŸ‡· Ponteiros Inteligentes (Smart Pointers)</a></li><li><ol class="section"><li><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> ğŸ‡§ğŸ‡· Box<T> Aponta para Dados no Heap e Tem Tamanho Conhecido</a></li><li><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> ğŸ‡§ğŸ‡· Tratando Ponteiros Inteligentes como ReferÃªncias Normais com a Trait Deref</a></li><li><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> ğŸ‡§ğŸ‡· A Trait Drop Roda CÃ³digo durante a Limpeza</a></li><li><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> ğŸ‡§ğŸ‡· Rc<T>, o Ponteiro Inteligente com Contagem de ReferÃªncias</a></li><li><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> ğŸ‡§ğŸ‡· RefCell<T> e a Pattern de Mutabilidade Interior</a></li><li><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> ğŸ‡§ğŸ‡· Ciclos de ReferÃªncias Podem Vazar MemÃ³ria</a></li></ol></li><li><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrency</a></li><li><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> ğŸ‡§ğŸ‡· Rust Ã© uma linguagem orientada a objetos?</a></li><li><ol class="section"><li><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> ğŸ‡§ğŸ‡· O que significa orientado a objetos?</a></li><li><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> ğŸ‡§ğŸ‡· Usando objetos trait que permitem valores de tipos diferentes</a></li><li><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> ğŸ‡§ğŸ‡· Implementando um padrÃ£o de projeto orientado a objetos</a></li></ol></li><li><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns</a></li><li><a href="ch19-00-more-lifetimes.html"><strong aria-hidden="true">19.</strong> More Lifetimes</a></li><li><a href="ch20-00-advanced-types.html"><strong aria-hidden="true">20.</strong> Advanced Type System Features</a></li><li><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> Keywords</a></li><li><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> Operators</a></li><li><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> Derivable Traits</a></li><li><a href="appendix-04-nightly-rust.html"><strong aria-hidden="true">21.4.</strong> Nightly Rust</a></li><li><a href="appendix-05-macros.html"><strong aria-hidden="true">21.5.</strong> Macros</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="submenu">
                                <li><button class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li><button class="theme" id="rust">Rust</button></li>
                                <li><button class="theme" id="coal">Coal</button></li>
                                <li><button class="theme" id="navy">Navy</button></li>
                                <li><button class="theme" id="ayu">Ayu</button></li>
                            </ul>
                        </div>

                        <h1 class="menu-title"></h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="ch03-01-variables-and-mutability.html#variÃ¡veis-e-mutabilidade" id="variÃ¡veis-e-mutabilidade"><h1>VariÃ¡veis e Mutabilidade</h1></a>
<p>Como mencionado no CapÃ­tulo 2, por padrÃ£o, as variÃ¡veis sÃ£o imutÃ¡veis. Essa Ã© uma das
maneiras que o Rust lhe dÃ¡ para escrever o seu cÃ³digo de
modo seguro e a fÃ¡cil concorrÃªncia que Rust oferece. No entanto, vocÃª ainda tem
a opÃ§Ã£o de tornar a sua variÃ¡vel mutÃ¡vel. Vamos explorar como e por que Rust
incentiva vocÃª a usar variÃ¡veis imutÃ¡veis e por que Ã s vezes pode
nÃ£o optar por utilizÃ¡-las.</p>
<p>Quando uma variÃ¡vel Ã© imutÃ¡vel, logo que um valor Ã© associado a uma variÃ¡vel, vocÃª nÃ£o pode mudar este valor.
Para ilustrar isso, vamos criar um projeto chamado <em>variaveis</em>
no seu diretÃ³rio <em>projetos</em> usando <code>cargo new --bin variables</code>.</p>
<p>EntÃ£o dentro do novo diretÃ³rio chamado <em>variaveis</em>, abra <em>src/main.rs</em> e substitua o
cÃ³digo com o cÃ³digo abaixo, que nÃ£o irÃ¡ compilar:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let x = 5;
    println!(&quot;O valor de x Ã©: {}&quot;, x);
    x = 6;
    println!(&quot;O valor de x Ã©: {}&quot;, x);
}
</code></pre>
<p>Salve e execute o programa usando <code>cargo run</code>. VocÃª deve receber uma mensagem de erro,
conforme mostrado nesta saÃ­da:</p>
<pre><code class="language-text">error[E0384]: cannot assign twice to immutable variable `x`
 --&gt; src/main.rs:4:5
  |
2 |     let x = 5;
  |         - first assignment to `x`
3 |     println!(&quot;O valor de x Ã©: {}&quot;, x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable
</code></pre>
<p>Esse exemplo mostra como o compilador ajuda vocÃª a encontrar erros no seus programas.
Mesmo que erros de compilaÃ§Ã£o sejam frustrantes, eles apenas significam que seu programa
nÃ£o estÃ¡ fazendo de modo seguro o que vocÃª espera fazer; eles <em>nÃ£o</em> siginificam que vocÃª
nÃ£o Ã© um bom programador! Programadores experientes tambÃ©m recebem erros de compilaÃ§Ã£o.</p>
<p>A mensagem indica que a causa do erro Ã© que vocÃª
<code>nÃ£o pode atribuir mais de uma vez Ã  variÃ¡vel imutÃ¡vel x</code>, porque vocÃª tentou atribuir um segundo valor Ã  variÃ¡vel <code>x</code>.</p>
<p>Ã‰ importante que nos recebamos erros em tempo de compilaÃ§Ã£o quando tentamos
alterar um valor que anteriormente foi indicado como imutÃ¡vel, porque
esta situaÃ§Ã£o pode ocasionar erros. Se uma parte do seu cÃ³digo funciona assumindo
que o valor nunca serÃ¡ alterado e outra parte do seu cÃ³digo muda este valor, Ã©
possÃ­vel que a primeira parte do cÃ³digo nÃ£o faÃ§a o que foi projetada para fazer.
A causa desse tipo de falha pode ser difÃ­cil de rastrear,
especialmente quando o segundo trecho de cÃ³digo muda o valor apenas <em>algumas vezes</em>.</p>
<p>Em Rust, o compilador garante que quando vocÃª afirma que um valor nÃ£o pode mudar,
ele nÃ£o mude. Isso significa que quando vocÃª estÃ¡ lendo e ecrevendo cÃ³digo,
vocÃª nÃ£o tenha de acompanhar como e onde um valor pode mudar. E assim seu cÃ³digo
fica mais fÃ¡cil de entender.</p>
<p>Mas mutabilidade pode ser muito Ãºtil. VariÃ¡veis sÃ£o imutÃ¡veis por padrÃ£o; como
vocÃª fez no CapÃ­tulo 2, vocÃª pode tornÃ¡-las mutÃ¡veis adicionando <code>mut</code> na frente do
nome da variÃ¡vel. AlÃ©m de permitir que este valor mude, <code>mut</code> transmite
a intenÃ§Ã£o aos futuros leitores do cÃ³digo, indicando que naquela
parte do cÃ³digo estarÃ£o mudando o valor da variÃ¡vel.</p>
<p>Por exemplo, vamos mudar <em>src/main.rs</em> para o seguinte:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut x = 5;
    println!(&quot;O valor de x Ã©: {}&quot;, x);
    x = 6;
    println!(&quot;O valor de x Ã©: {}&quot;, x);
}
</code></pre></pre>
<p>Quando executamos o programa, recebemos isso:</p>
<pre><code class="language-text">$ cargo run
   Compiling variaveis v0.1.0 (file:///projects/variaveis)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30 secs
     Running `target/debug/variaveis`
O valor de x Ã©: 5
O valor de x Ã©: 6
</code></pre>
<p>Estamos autorizados a mudar o valor <code>5</code> contido  em <code>x</code> para <code>6</code>
quando <code>mut</code> Ã© usado. Em alguns casos, vocÃª precisarÃ¡ criar uma variÃ¡vel mutÃ¡vel porque ela
serÃ¡ mais conveniente para escrever do que se fosse imutÃ¡vel.</p>
<p>Tem vÃ¡rios compromissos a serem considerados alÃ©m de prevenÃ§Ã£o de
falhas. Por exemplo, nos casos em que vocÃª usa estruturas de dados grandes,
a alteraÃ§Ã£o em uma instÃ¢ncia pode ser mais rÃ¡pida do que copiar e retornar a nova instÃ¢ncia
alocada. Com estruturas de dados menores, criar novas instÃ¢ncias e escrever
em um estilo de programaÃ§Ã£o funcional pode ser mais fÃ¡cil de entender, portanto,
um desempenho menor pode ser uma penalidade que vale a pena para obter mais clareza.</p>
<a class="header" href="ch03-01-variables-and-mutability.html#diferenÃ§as-entre-variÃ¡veis-e-constantes" id="diferenÃ§as-entre-variÃ¡veis-e-constantes"><h3>DiferenÃ§as entre variÃ¡veis e constantes</h3></a>
<p>Ser incapaz de mudar o valor de uma variÃ¡vel, pode ter feito vocÃª lembrar de
outro conceito de programaÃ§Ã£o, que a maioria das outras linguagens possui, chamado: <em>constantes</em>. Como
variÃ¡veis imutÃ¡veis, constantes sÃ£o valores que estÃ£o vinculados ao nome e nÃ£o
podem serem alterados, mas hÃ¡ algumas diferenÃ§as entre constantes e
variÃ¡veis.</p>
<p>Primeiro, vocÃª nÃ£o pode usar <code>mut</code> com constantes. Constante nÃ£o sÃ£o apenas
imutÃ¡veis por padrÃ£o, constante sÃ£o sempre imutÃ¡veis.</p>
<p>VocÃª declara constante usando a palavra-chave <code>const</code> em vez de <code>let</code>,
e o tipo do valor <em>necessita</em> ser especÃ­ficado. Falaremos sobre tipos de dados
na prÃ³xima seÃ§Ã£o, &quot;Data Type&quot;, entÃ£o
nÃ£o se preocupe com os detalhes por agora. Apenas saiba que vocÃª precisa especificar o tipo.</p>
<p>Constantes podem ser declaradas em qualquer escopo, incluindo o escopo global, o que os tornam
Ãºteis para valores que vÃ¡rias partes do cÃ³digo precisa conhecer.</p>
<p>A Ãºltima diferenÃ§a Ã© que as constantes podem ser definidas apenas para uma expressÃ£o constante,
ou seja, nÃ£o pode ser o resultado de uma chamada de funÃ§Ã£o ou qualquer outro valor que sÃ³ poderia ser
calculado em tempo de execuÃ§Ã£o.</p>
<p>Aqui estÃ¡ um exemplo de uma declaraÃ§Ã£o constante, em que o nome da constante Ã©
<code>PONTOS_MAXIMOS</code> e o valor definido Ã© 100,000 (por
convenÃ§Ã£o, contantes em Rust sÃ£o nomeadas usando maiÃºsculas e sublinhado entre as palavras):</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
const PONTOS_MAXIMOS: u32 = 100_000;
#}</code></pre></pre>
<p>Constante sÃ£o vÃ¡lidas durante todo o tempo de execuÃ§Ã£o de um programa, dentro do escopo em que
foram declaradas, tornando-as uma Ã³tima escolha para valores no domÃ­nio da aplicaÃ§Ã£o,
que vÃ¡rias partes do programa necessitam conhecer, como por exemplo,
o nÃºmero mÃ¡ximo de pontos um jogador pode ter ou a
velocidade da luz.</p>
<p>A nomeaÃ§Ã£o de valores codificados permanentemente usados em todo o programa como constantes Ã© Ãºtil
para transmitir o significado desse valor para futuros mantenedores do cÃ³digo. TambÃ©m
ajuda ter apenas um lugar em seu cÃ³digo que vocÃª precisaria mudar se o
valor codificado precisasse ser atualizado no futuro.</p>
<a class="header" href="ch03-01-variables-and-mutability.html#shadowing" id="shadowing"><h3>Shadowing</h3></a>
<p>Como vocÃª viu na seÃ§Ã£o â€œComparando o Adivinha ao NÃºmero Secretoâ€ no CapÃ­tulo
2, vocÃª pode declarar uma nova variÃ¡vel com o mesmo nome de uma variÃ¡vel anterior,
e a nova variÃ¡vel sombreia a variÃ¡vel anterior. Rustaceans dizem que a
primeira variÃ¡vel Ã© <em>sombreada</em> pela segunda, o que significa que o segundo
valor da variÃ¡vel Ã© o que aparece quando a variÃ¡vel Ã© usada. Podemos sombrear uma
variÃ¡vel usando o mesmo nome da variÃ¡vel e repetindo o uso da palavra-chave <code>let</code>
da seguinte forma:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 5;

    let x = x + 1;

    let x = x * 2;

    println!(&quot;O valor de x Ã©: {}&quot;, x);
}
</code></pre></pre>
<p>Esse programa primeiro vincula <code>x</code> ao valor <code>5</code>. Em seguida <code>x</code> Ã© sombreado por
<code>let x =</code>, pegando o valor original e adicionando <code>1</code>, entÃ£o o valor de
<code>x</code> Ã© <code>6</code>. O terceiro <code>let</code> tambÃ©m sombrea <code>x</code>, multiplicando o
valor anterior por <code>2</code> para entÃ£o <code>x</code> ficar com o valor final de <code>12</code>. Quando nÃ³s executamos esse programa, Ã©
produzida a seguinte saÃ­da:</p>
<pre><code class="language-text">$ cargo run
   Compiling variaveis v0.1.0 (file:///projects/variaveis)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/variaveis`
O valor de x Ã©: 12
</code></pre>
<p>Shadowing Ã© diferente do que dizer que uma variÃ¡vel Ã© <code>mut</code>, porque teremos um
erro em tempo de compilaÃ§Ã£o se, acidentalmente, tentarmos reatribuir essa variÃ¡vel sem
utilizar <code>let</code>. Usando <code>let</code>, nÃ³s podemos realizar algumas transformaÃ§Ãµes,
mas sem ter uma variÃ¡vel imutÃ¡vel apÃ³s estas transformaÃ§Ãµes terem
sido concluÃ­das.</p>
<p>Uma outra diferenÃ§a entre <code>mut</code> e shadowing Ã© que,
como estamos efetivamente criando uma nova vÃ¡rivel, quando usamos novamente a palavra-chave <code>let</code>, nÃ³s
podemos mudar o tipo do valor, mas reutilizando o mesmo nome. Por exemplo, digamos que nosso programa
solicite ao usuÃ¡rio que mostre quantos espaÃ§os deseja entre um texto, inserindo
caracteres de espaÃ§o, mas queremos armazenar essa entrada como um nÃºmero:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let espacos = &quot;   &quot;;
let espacos = espacos.len();
#}</code></pre></pre>
<p>Essa construÃ§Ã£o Ã© permitida, porque a primeira variÃ¡vel <code>espacos</code> Ã© do tipo string
e a segunda variÃ¡vel, que Ã© uma nova variÃ¡vel que tem o
mesmo nome que a primeira, Ã© do tipo numÃ©rico. Shadowing nos poupa de
ter de criar nomes diferentes, como <code>str_espacos</code> e
<code>num_espacos</code>; em vez disso, podemos simplesmente reutilizar o nome <code>espacos</code>. No entanto, se
tentassemos usar <code>mut</code> para isso, como mostramos aqui, teremos um erro em tempo de compilaÃ§Ã£o:</p>
<pre><code class="language-rust ignore">let mut espacos = &quot;   &quot;;
espacos = espacos.len();
</code></pre>
<p>O erro diz que nÃ£o podemos alterar o tipo de variÃ¡vel:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:3:14
  |
3 |     espacos = espacos.len();
  |              ^^^^^^^^^^^^ expected &amp;str, found usize
  |
  = note: expected type `&amp;str`
             found type `usize`
</code></pre>
<p>Agora que exploramos como as variÃ¡veis funcionam, vamos ver mais tipos de dados.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch03-00-common-programming-concepts.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch03-02-data-types.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="ch03-00-common-programming-concepts.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="ch03-02-data-types.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if (getComputedStyle(document.querySelector(".fa")).fontFamily !== "FontAwesome") {
                var link = document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = '_FontAwesome/css/font-awesome.css';
                document.head.insertBefore(link, document.head.firstChild)
            }
        </script>

        

        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
